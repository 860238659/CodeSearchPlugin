{"repo":"doxygen4cj","file":"token.cj","path":"doxygen4cj/src/cjdoc/token.cj","code_tokens":"public func toString ( ) : String {  return tokenNames [ this . kind ] + : + text NL }","func_name":"toString","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func forword ( ) {  lookahead [ p ] = nextInputChar ( ) NL p = ( p + 1 ) % k NL }","func_name":"forword","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func lookChar ( i : Int64 ) : Char {  return lookahead [ ( p + i ) % k ] NL }","func_name":"lookChar","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func nextInputChar ( ) : Char {  index += 1 NL if ( index > = input . size ) {  return eof NL } else {  return input [ index ] NL } NL }","func_name":"nextInputChar","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"public func printToken ( ) {   var b = nextToken ( ) NL while ( b . kind != Token . EOF ) {  print ( ${b.text}\\t ) NL b = nextToken ( ) NL } NL }","func_name":"printToken","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func nextToken ( ) : Token {  skipWhiteSpace ( ) NL  var c = lookChar ( 0 ) NL if ( c == eof ) {  return Token ( Token . EOF ) NL } NL if ( c == \\n ) {  forword ( ) NL return Token ( Token . LINEFEED ) NL } NL if ( isIdentifier ( c ) ) {  return identifier ( ) NL } else if ( c == / ) {   var next = lookChar ( 1 ) NL if ( next == / ) {  return lineComment ( ) NL } else if ( next == * ) {  return blockComment ( ) NL } NL forword ( ) NL return Token ( Token . DEFAULT , / ) NL } else if ( c == \\\" ) {  return stringText ( ) NL } else if ( c == + || c == - ) {   var c1 = lookChar ( 1 ) NL if ( isDigit ( c1 ) ) {  return digit ( ) NL } NL } else if ( isDigit ( c ) ) {  return digit ( ) NL } NL forword ( ) NL return Token ( Token . DEFAULT , String ( [ c ] ) ) NL }","func_name":"nextToken","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func digit ( ) : Token {   let sb = StringBuilder ( ) NL  var c = lookChar ( 0 ) NL do {  sb . append ( c ) NL forword ( ) NL c = lookChar ( 0 ) NL } while ( c == x || c == X || isDigit ( c ) || c == . ) NL return Token ( Token . NUMBER , sb . toString ( ) ) NL }","func_name":"digit","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func skipWhiteSpace ( ) {   var c = lookChar ( 0 ) NL while ( c ==   || c == \\t ) {  forword ( ) NL c = lookChar ( 0 ) NL } NL }","func_name":"skipWhiteSpace","docstring":"// 跳过空格    "}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func isDigit ( ch : Char ) : Bool {  return ch > = 0 && ch <= 9 NL }","func_name":"isDigit","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func isIdentifier ( ch : Char ) : Bool {  return ( ch > = a && ch <= z ) || ( ch > = A && ch <= Z ) || ( ch == _ ) NL }","func_name":"isIdentifier","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func stringText ( ) : Token {   var list = StringBuilder ( ) NL  var a = lookChar ( 0 ) NL  var b = lookChar ( 1 ) NL  var c = lookChar ( 2 ) NL if ( a == \\\" && b == \\\" && c == \\\" ) {  forword ( ) NL forword ( ) NL forword ( ) NL  var d = lookChar ( 0 ) NL  var e = lookChar ( 1 ) NL  var f = lookChar ( 2 ) NL while ( ! ( d == \\\" && e == \\\" && f == \\\" ) ) {  list . append ( d ) NL forword ( ) NL d = lookChar ( 0 ) NL e = lookChar ( 1 ) NL f = lookChar ( 2 ) NL } NL forword ( ) NL forword ( ) NL forword ( ) NL } else {  forword ( ) NL  var next = lookChar ( 0 ) NL while ( next != \\\" ) {  list . append ( next ) NL forword ( ) NL next = lookChar ( 0 ) NL } NL forword ( ) NL } NL return Token ( Token . STRING , list . toString ( ) ) NL }","func_name":"stringText","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func blockComment ( ) : Token {   var commentList = StringBuilder ( ) NL forword ( ) NL forword ( ) NL  var c = lookChar ( 0 ) NL  var d = lookChar ( 1 ) NL while ( ! ( c == * && d == / ) ) {  commentList . append ( c ) NL c = lookChar ( 0 ) NL d = lookChar ( 1 ) NL forword ( ) NL } NL forword ( ) NL forword ( ) NL  var commentStr = commentList . toString ( ) NL return Token ( Token . COMMENT , commentStr ) NL }","func_name":"blockComment","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func lineComment ( ) : Token {   var commentList = StringBuilder ( ) NL forword ( ) NL forword ( ) NL  var c = lookChar ( 0 ) NL while ( c != \\n ) {  commentList . append ( c ) NL c = lookChar ( 0 ) NL forword ( ) NL } NL  var commentStr = commentList . toString ( ) NL return Token ( Token . COMMENT , commentStr ) NL }","func_name":"lineComment","docstring":""}
{"repo":"doxygen4cj","file":"lex.cj","path":"doxygen4cj/src/cjdoc/lex.cj","code_tokens":"func identifier ( ) : Token {   var idList = StringBuilder ( ) NL  var c = lookChar ( 0 ) NL do {  idList . append ( c ) NL forword ( ) NL c = lookChar ( 0 ) NL } while ( isIdentifier ( c ) || isDigit ( c ) ) NL return Token ( Token . ID , idList . toString ( ) ) NL }","func_name":"identifier","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"func forword ( ) {   var t = lex . nextToken ( ) NL lookahead [ p ] = t NL p = ( p + 1 ) % k NL }","func_name":"forword","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"func lookAt ( i : Int64 ) : Token {  return lookahead [ ( p + i ) % k ] NL }","func_name":"lookAt","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func parsePkgName ( ) : String {   var token = lookAt ( 0 ) NL if ( token . kind == Token . ID && token . text == package ) {  token = promote ( ) NL  let sb = StringBuilder ( ) NL while ( token . kind == Token . ID || ( token . kind == Token . DEFAULT && token . text == . ) ) {  if ( token . kind == Token . LINEFEED ) {  forword ( ) NL break NL } NL if ( token . text == ; ) {  break NL } NL if ( token . kind == Token . ID ) {  sb . append ( token . text ) NL } NL token = promote ( ) NL } NL return sb . toString ( ) NL } NL return  NL }","func_name":"parsePkgName","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func parseComment ( ) : String {   var token = lookAt ( 0 ) NL  var comment =  NL while ( token . kind == Token . COMMENT ) {  comment = comment + token . text NL token = promote ( ) NL } NL return comment NL }","func_name":"parseComment","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func parserClassMember ( clazz : Clazz ) : Unit {   var token = lookAt ( 0 ) NL  var comment =  NL  var left = 1 NL if ( token . text == { ) {  token = promote ( ) NL } NL while ( true ) {  if ( token . kind == Token . COMMENT ) {  comment = parseComment ( ) NL } else if ( token . kind == Token . ID ) {  token = lookAt ( 0 ) NL  var accessSpecifier = aquireaccessSpecifier ( ) NL  var isStatic = aquireStatic ( ) NL  var isOpen = aquireOpen ( ) NL token = lookAt ( 0 ) NL if ( token . text == var ) {   var v = parseVar ( accessSpecifier , isStatic ) NL v . doc = comment NL if ( v . accessSpecifier == 0 || v . accessSpecifier == 1 ) {  clazz . vairable . append ( v ) NL } NL } else if ( token . text == let ) {   var v = parseLet ( accessSpecifier , isStatic ) NL v . doc = comment NL if ( v . accessSpecifier == 0 || v . accessSpecifier == 1 ) {  clazz . constant . append ( v ) NL } NL } else if ( token . text == class ) {   var v = parseClass ( accessSpecifier , isOpen ) NL } else if ( token . text == struct ) {  } else if ( token . text == enum ) {  } else if ( token . text == interface ) {  } else if ( token . text == func || token . text == init ) {   var v = parseFunc ( accessSpecifier , isStatic ) NL v . doc = comment NL if ( v . accessSpecifier == 0 ) {  clazz . functions . append ( v ) NL } NL } NL comment =  NL } else {  token = promote ( ) NL if ( token . text == } ) {  forword ( ) NL break NL } NL } NL token = lookAt ( 0 ) NL } NL }","func_name":"parserClassMember","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func parseClass ( accessSpecifier : Int64 , isOpen : Bool ) : Clazz {   var v = Clazz ( ) NL v . accessSpecifier = accessSpecifier NL v . isOpen = isOpen NL  var token = promote ( ) NL v . name = token . text NL token = promote ( ) NL if ( token . text == { ) {  parserClassMember ( v ) NL } NL return v NL }","func_name":"parseClass","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func parseParam ( ) : ArrayList < Parameter > {   var v = ArrayList < Parameter > ( ) NL  var token = promote ( ) NL while ( true ) {  if ( token . text == ) ) {  forword ( ) NL break NL } NL  let para = Parameter ( ) NL para . name = token . text NL token = promote ( ) NL if ( token . text == : ) {  token = promote ( ) NL if ( token . text == ! ) {  forword ( ) NL para . isNamed = true NL token = lookAt ( 0 ) NL } NL } NL para . kind += token . text NL token = promote ( ) NL if ( token . text == < ) {   var left = 1 NL while ( left != 0 ) {  para . kind += token . text NL token = promote ( ) NL if ( token . text == < ) {  left += 1 NL } else if ( token . text == > ) {  left -= 1 NL } NL } NL para . kind += token . text NL token = promote ( ) NL } NL if ( token . text == = ) {  token = promote ( ) NL para . defaultValue = token . text NL if ( token . text == [ ) {   var left = 1 NL while ( left != 0 ) {  token = promote ( ) NL para . defaultValue += token . text NL if ( token . text == [ ) {  left += 1 NL } else if ( token . text == ] ) {  left -= 1 NL } NL } NL } NL token = promote ( ) NL if ( token . text == ( ) {   var left = 1 NL while ( left != 0 ) {  para . defaultValue += token . text NL token = promote ( ) NL if ( token . text == ( ) {  left += 1 NL } else if ( token . text == ) ) {  left -= 1 NL para . defaultValue += token . text NL token = promote ( ) NL } NL } NL } NL } NL v . append ( para ) NL if ( token . text == , ) {  token = promote ( ) NL } NL } NL return v NL }","func_name":"parseParam","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func parseFunc ( accessSpecifier : Int64 , isStatic : Bool ) : Function {   var v = Function ( ) NL v . accessSpecifier = accessSpecifier NL v . isStatic = isStatic NL  var token = lookAt ( 0 ) NL if ( token . kind == Token . ID && ( token . text == func || token . text == init ) ) {  if ( token . text == init ) {  v . name = token . text NL } else {  token = promote ( ) NL v . name = token . text NL } NL forword ( ) NL v . params = parseParam ( ) NL token = lookAt ( 0 ) NL if ( token . kind == Token . DEFAULT ) {  if ( token . text == : ) {  token = promote ( ) NL } NL while ( token . text != { ) {  v . retKind += token . text NL token = promote ( ) NL } NL  var left = 1 NL while ( true ) {  token = promote ( ) NL if ( token . text == { ) {  left += 1 NL } else if ( token . text == } ) {  left -= 1 NL } NL if ( left == 0 ) {  break NL } NL } NL forword ( ) NL } NL } NL return v NL }","func_name":"parseFunc","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func promote ( ) : Token {  forword ( ) NL lookAt ( 0 ) NL }","func_name":"promote","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func parseLet ( accessSpecifier : Int64 , isStatic : Bool ) : Constant {   var v = Constant ( ) NL v . accessSpecifier = accessSpecifier NL v . isStatic = isStatic NL  var token = lookAt ( 0 ) NL if ( token . kind == Token . ID && token . text == let ) {  token = promote ( ) NL v . name = token . text NL token = promote ( ) NL if ( token . text == : ) {  token = promote ( ) NL while ( token . text != = ) {  v . kind += token . text NL token = promote ( ) NL } NL } NL if ( token . text == = ) {  token = promote ( ) NL v . hasValue = true NL } NL if ( token . kind == Token . ID ) {  v . value += token . text NL token = promote ( ) NL } NL if ( token . kind == Token . NUMBER ) {  v . value += token . text NL token = promote ( ) NL } NL if ( token . text == [ ) {   var left = 1 NL while ( left != 0 ) {  v . value += token . text NL token = promote ( ) NL if ( token . text == [ ) {  left += 1 NL } else if ( token . text == ] ) {  left -= 1 NL } NL } NL v . value += token . text NL token = promote ( ) NL } NL if ( token . text == ( ) {   var left = 1 NL while ( left != 0 ) {  v . value += token . text NL forword ( ) NL token = lookAt ( 0 ) NL if ( token . text == ( ) {  left += 1 NL } else if ( token . text == ) ) {  left -= 1 NL } NL } NL v . value += token . text NL token = promote ( ) NL } NL } NL return v NL }","func_name":"parseLet","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func parseVar ( accessSpecifier : Int64 , isStatic : Bool ) : Vairable {   var v = Vairable ( ) NL v . accessSpecifier = accessSpecifier NL v . isStatic = isStatic NL  var token = lookAt ( 0 ) NL if ( token . kind == Token . ID && token . text == var ) {  token = promote ( ) NL v . name = token . text NL token = promote ( ) NL if ( token . text == : ) {  token = promote ( ) NL v . kind += token . text NL token = promote ( ) NL if ( token . text == < ) {   var left = 1 NL while ( left != 0 ) {  v . kind += token . text NL token = promote ( ) NL if ( token . text == < ) {  left += 1 NL } else if ( token . text == > ) {  left -= 1 NL } NL } NL v . kind += token . text NL token = promote ( ) NL } NL } NL if ( token . text == = ) {  token = promote ( ) NL v . hasValue = true NL } NL if ( token . kind == Token . ID ) {  v . value += token . text NL token = promote ( ) NL } NL if ( token . kind == Token . NUMBER ) {  v . value += token . text NL token = promote ( ) NL } NL if ( token . text == [ ) {   var left = 1 NL while ( left != 0 ) {  v . value += token . text NL token = promote ( ) NL if ( token . text == [ ) {  left += 1 NL } else if ( token . text == ] ) {  left -= 1 NL } NL } NL v . value += token . text NL token = promote ( ) NL } NL if ( token . text == < ) {   var left = 1 NL while ( left != 0 ) {  v . value += token . text NL token = promote ( ) NL if ( token . text == < ) {  left += 1 NL } else if ( token . text == > ) {  left -= 1 NL } NL } NL v . value += token . text NL token = promote ( ) NL } NL if ( token . text == ( ) {   var left = 1 NL while ( left != 0 ) {  v . value += token . text NL token = promote ( ) NL if ( token . text == ( ) {  left += 1 NL } else if ( token . text == ) ) {  left -= 1 NL } NL } NL v . value += token . text NL token = promote ( ) NL } NL } NL return v NL }","func_name":"parseVar","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func aquireaccessSpecifier ( ) : Int64 {   var accessSpecifier = 3 NL  var token = lookAt ( 0 ) NL if ( token . text == public ) {  accessSpecifier = 0 NL forword ( ) NL } else if ( token . text == protected ) {  accessSpecifier = 1 NL forword ( ) NL } else if ( token . text == private ) {  accessSpecifier = 2 NL forword ( ) NL } NL return accessSpecifier NL }","func_name":"aquireaccessSpecifier","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func aquireStatic ( ) : Bool {   var token = lookAt ( 0 ) NL  var isStatic = false NL if ( token . text == static ) {  forword ( ) NL isStatic = true NL } NL return isStatic NL }","func_name":"aquireStatic","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func aquireOpen ( ) : Bool {   var token = lookAt ( 0 ) NL  var isOpen = false NL if ( token . text == open ) {  forword ( ) NL isOpen = true NL } NL return isOpen NL }","func_name":"aquireOpen","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func skipImport ( ) : Unit {   var token = lookAt ( 0 ) NL if ( token . text == from || token . text == import ) {  while ( token . kind != Token . LINEFEED ) {  forword ( ) NL token = lookAt ( 0 ) NL } NL forword ( ) NL } NL }","func_name":"skipImport","docstring":""}
{"repo":"doxygen4cj","file":"parser.cj","path":"doxygen4cj/src/cjdoc/parser.cj","code_tokens":"public func parsePackage ( ) : Pkg {   let pkg = Pkg ( ) NL pkg . doc = parseComment ( ) NL pkg . name = parsePkgName ( ) NL  var token = lookAt ( 0 ) NL  var comment =  NL while ( true ) {  if ( token . kind == Token . EOF ) {  break NL } NL if ( token . kind == Token . COMMENT ) {  comment = parseComment ( ) NL } else if ( token . text == from || token . text == import ) {  skipImport ( ) NL } else if ( token . kind == Token . ID ) {  token = lookAt ( 0 ) NL  var accessSpecifier = aquireaccessSpecifier ( ) NL  var isStatic = aquireStatic ( ) NL  var isOpen = aquireOpen ( ) NL token = lookAt ( 0 ) NL if ( token . text == var ) {   var v = parseVar ( accessSpecifier , isStatic ) NL v . doc = comment NL if ( v . accessSpecifier == 0 ) {  pkg . vairable . append ( v ) NL } NL } else if ( token . text == let ) {   var v = parseLet ( accessSpecifier , isStatic ) NL v . doc = comment NL if ( v . accessSpecifier == 0 ) {  pkg . constant . append ( v ) NL } NL } else if ( token . text == class ) {   var v = parseClass ( accessSpecifier , isOpen ) NL if ( v . accessSpecifier == 0 ) {  pkg . classes . append ( v ) NL } NL } else if ( token . text == struct ) {  } else if ( token . text == enum ) {  } else if ( token . text == interface ) {  } else if ( token . text == func ) {   var v = parseFunc ( accessSpecifier , isStatic ) NL v . doc = comment NL if ( v . accessSpecifier == 0 ) {  pkg . functions . append ( v ) NL } NL } NL comment =  NL } else {  forword ( ) NL } NL token = lookAt ( 0 ) NL } NL return pkg NL }","func_name":"parsePackage","docstring":""}
{"repo":"doxygen4cj","file":"def.cj","path":"doxygen4cj/src/cjdoc/def.cj","code_tokens":"public func addPkg ( pkg : Pkg ) {   var flag = false NL for ( p in this . pkgs ) {  if ( p . name == pkg . name ) {  flag = true NL p . merge ( pkg ) NL } NL } NL if ( ! flag ) {  this . pkgs . append ( pkg ) NL } NL }","func_name":"addPkg","docstring":""}
{"repo":"doxygen4cj","file":"def.cj","path":"doxygen4cj/src/cjdoc/def.cj","code_tokens":"public func merge ( pkg : Pkg ) {  this . constant . appendAll ( pkg . constant ) NL this . vairable . appendAll ( pkg . vairable ) NL this . functions . appendAll ( pkg . functions ) NL this . classes . appendAll ( pkg . classes ) NL this . structs . appendAll ( pkg . structs ) NL this . enums . appendAll ( pkg . enums ) NL }","func_name":"merge","docstring":""}
{"repo":"doxygen4cj","file":"def.cj","path":"doxygen4cj/src/cjdoc/def.cj","code_tokens":"public func toString ( ) : String {   let sb = StringBuilder ( ) NL if ( accessSpecifier == 0 ) {  sb . append ( public  ) NL } else if ( accessSpecifier == 1 ) {  sb . append ( protected  ) NL } NL if ( isStatic ) {  sb . append ( static  ) NL } NL sb . append ( var  ) NL sb . append ( name +   ) NL if ( kind !=  ) {  sb . append ( :  ) NL sb . append ( kind ) NL sb . append (   ) NL } NL if ( hasValue ) {  sb . append ( =  ) NL sb . append ( value ) NL if ( value ==  ) {  sb . append ( \\\"\\\" ) NL } NL sb . append (   ) NL } NL return sb . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"doxygen4cj","file":"def.cj","path":"doxygen4cj/src/cjdoc/def.cj","code_tokens":"public func toString ( ) : String {   let sb = StringBuilder ( ) NL if ( accessSpecifier == 0 ) {  sb . append ( public  ) NL } else if ( accessSpecifier == 1 ) {  sb . append ( protected  ) NL } NL if ( isStatic ) {  sb . append ( static  ) NL } NL sb . append ( var  ) NL sb . append ( name +   ) NL if ( kind !=  ) {  sb . append ( :  ) NL sb . append ( kind ) NL sb . append (   ) NL } NL if ( hasValue ) {  sb . append ( =  ) NL sb . append ( value ) NL if ( value ==  ) {  sb . append ( \\\"\\\" ) NL } NL sb . append (   ) NL } NL return sb . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"doxygen4cj","file":"def.cj","path":"doxygen4cj/src/cjdoc/def.cj","code_tokens":"public func toSignString ( ) {   let sb = StringBuilder ( ) NL if ( accessSpecifier == 0 ) {  sb . append ( public  ) NL } else if ( accessSpecifier == 1 ) {  sb . append ( protected  ) NL } NL if ( isStatic ) {  sb . append ( static  ) NL } NL if ( isMut ) {  sb . append ( mut  ) NL } NL sb . append ( func  ) NL sb . append ( name +   ) NL if ( params . size > 0 ) {  sb . append ( ( ) NL for ( i in 0 .. params . size ) {   let p = params [ i ] NL if ( i > 0 ) {  sb . append ( ,  ) NL } NL sb . append ( p . toString ( ) ) NL } NL sb . append ( ) ) NL } NL if ( retKind !=  ) {  sb . append ( :  ) NL sb . append ( retKind ) NL } NL return sb . toString ( ) NL }","func_name":"toSignString","docstring":""}
{"repo":"doxygen4cj","file":"def.cj","path":"doxygen4cj/src/cjdoc/def.cj","code_tokens":"public func toString ( ) : String {   let sb = StringBuilder ( ) NL sb . append ( name ) NL if ( isNamed ) {  sb . append ( ! ) NL } NL sb . append ( :  ) NL sb . append ( kind ) NL if ( isNamed ) {  sb . append (  =  ) NL sb . append ( defaultValue ) NL } NL return sb . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"doxygen4cj","file":"ast.cj","path":"doxygen4cj/src/cjdoc/ast.cj","code_tokens":"func addChild ( ast : AST ) {  this . child . append ( ast ) NL }","func_name":"addChild","docstring":""}
{"repo":"doxygen4cj","file":"generatehtml.cj","path":"doxygen4cj/src/cjdoc/generatehtml.cj","code_tokens":"func generatehtml ( code : Code ) {  }","func_name":"generatehtml","docstring":""}
{"repo":"doxygen4cj","file":"generatehtml.cj","path":"doxygen4cj/src/cjdoc/generatehtml.cj","code_tokens":"public func generatePkg ( pkg : Pkg ) {   let fileName = pkg . name + .xml NL html = html . replace ( $packageName , pkg . name ) NL  var index =  NL  var detail =  NL html = html . replace ( $indexContent , indexContent ) NL html = html . replace ( $detailContent , detailContent ) NL try (  let f = File ( fileName , AccessMode . Write , OpenMode . OpenOrCreate ) ) {  f . write ( html . toUtf8Array ( ) ) NL } NL }","func_name":"generatePkg","docstring":""}
