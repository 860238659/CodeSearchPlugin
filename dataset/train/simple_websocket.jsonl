{"repo":"simple_websocket","file":"web_socket_server.cj","path":"simple_websocket/src/server/web_socket_server.cj","code_tokens":"public func launch ( ) {  socket = SocketServer ( SocketNet . TCP , host , port ) NL socket . getOrThrow ( ) NL this . accept ( ) NL }","func_name":"launch","docstring":"/**\n    * 用于启动服务端websocket\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"web_socket_server.cj","path":"simple_websocket/src/server/web_socket_server.cj","code_tokens":"private func accept ( ) {  if ( no_blocking ) {  spawn { while ( exit ) {   let client = socket . getOrThrow ( ) . accept ( ) NL spawn {  let ws_client = Client ( client ) . ugrade ( ) NL match ( ws_client ) { case Some ( c ) =>  let fn = this . handle_func . getOrThrow ( ) NL fn ( c ) NL case _ => println ( get ws_server none ) NL } NL return NL } NL } NL } NL return NL } else {  while ( exit ) {   let client = socket . getOrThrow ( ) . accept ( ) NL spawn {  let ws_client = Client ( client ) . ugrade ( ) NL match ( ws_client ) { case Some ( c ) =>  let fn = this . handle_func . getOrThrow ( ) NL fn ( c ) NL case _ => println ( get ws_server none ) NL } NL return NL } NL } NL return NL } NL return NL }","func_name":"accept","docstring":"/**\n    * 用于启动服务端websocket之后的阻塞等待客户端连接\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"web_socket_server.cj","path":"simple_websocket/src/server/web_socket_server.cj","code_tokens":"public func handleFunc ( fn : ( WsConn ) -> Unit ) {  this . handle_func = fn NL }","func_name":"handleFunc","docstring":"/**\n    * 用于操作的函数\n    *\n    * @param fn of Function, 执行的方法参数是WsConn返回值是Unit\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"web_socket_server.cj","path":"simple_websocket/src/server/web_socket_server.cj","code_tokens":"public func setHost ( host : String ) {  this . host = host NL }","func_name":"setHost","docstring":"/**\n    * 用于设置host\n    *\n    * @param host of String, 用于设置host\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"web_socket_server.cj","path":"simple_websocket/src/server/web_socket_server.cj","code_tokens":"public func setPort ( port : UInt16 ) {  this . port = port NL }","func_name":"setPort","docstring":"/**\n    * 用于设置port\n    *\n    * @param port of UInt16, 用于设置port\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"web_socket_server.cj","path":"simple_websocket/src/server/web_socket_server.cj","code_tokens":"public func setNoBlocking ( no_blocking : Bool ) {  this . no_blocking = no_blocking NL }","func_name":"setNoBlocking","docstring":"/**\n    * 用于设置是否阻塞\n    *\n    * @param no_blocking of Bool, 用于设置是否阻塞\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"upgrader.cj","path":"simple_websocket/src/server/upgrader.cj","code_tokens":"func upgrade ( r : Request ) : Bool {   let badHandshake = websocket: the client is not using the websocket protocol:  NL if ( ! checkHeader ( r . header ( ) , Connection , upgrade ) ) {  return respError ( HttpStatusCode . STATUS_BAD_REQUEST , ${badHandshake}'upgrade' token not found in 'Connection' header ) NL } NL if ( ! checkHeader ( r . header ( ) , Upgrade , websocket ) ) {  return respError ( HttpStatusCode . STATUS_BAD_REQUEST , ${badHandshake}'websocket' token not found in 'Upgrade' header ) NL } NL if ( r . methods ( ) != GET ) {  return respError ( HttpStatusCode . STATUS_METHOD_NOT_ALLOWED , ${badHandshake}equest method is not GET ) NL } NL  let challengeKey = r . getHeader ( Sec-WebSocket-Key ) . getOrDefault ( { =>  NL } ) . trimAscii ( ) NL if ( ! validSecWebsocketKey ( challengeKey ) ) {  return respError ( HttpStatusCode . STATUS_BAD_REQUEST , websocket: not a websocket handshake: 'Sec-WebSocket-Key' header must be Base64 encoded value of 16-byte in length ) NL } NL  let key = getRespKey ( challengeKey ) NL resp . handleSuccess ( key ) NL }","func_name":"upgrade","docstring":"/**\n    * 服务端对客户端发送过来的握手信息校验的方法\n    *\n    * @param r of Requset\n    *\n    * @return Type of Bool\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"upgrader.cj","path":"simple_websocket/src/server/upgrader.cj","code_tokens":"private func getRespKey ( challengeKey : String ) : String {   let tmp = challengeKey + keyGuid NL  let result = SHA1 . digest ( tmp ) NL toBase64String ( result ) NL }","func_name":"getRespKey","docstring":"/**\n    * 对客户端发送过来的key进行规则加密的方法\n    *\n    * @param challengeKey of String\n    *\n    * @return Type of String\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"upgrader.cj","path":"simple_websocket/src/server/upgrader.cj","code_tokens":"private func validSecWebsocketKey ( key : String ) : Bool {  if ( key ==  ) {  return false NL } NL match ( fromBase64String ( key ) ) { case Some ( keyStr ) => keyStr . size == 16 NL case _ => false NL } NL }","func_name":"validSecWebsocketKey","docstring":"/**\n    * 校验客户端发送过来的key是否符合要求的方法\n    *\n    * @param key of String\n    *\n    * @return Type of Bool\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"upgrader.cj","path":"simple_websocket/src/server/upgrader.cj","code_tokens":"private func respError ( code : Int64 , msg : String ) : Bool {  this . resp . setHeader ( Content-Type: , text/html; charset=utf-8 ) NL this . resp . setHeader ( Sec-Websocket-Version , 13 ) NL this . resp . writeStatusCode ( code ) NL this . resp . writeBodyAndClose ( msg ) NL return false NL }","func_name":"respError","docstring":"/**\n    * 校验出错返回错误信息的方法\n    *\n    * @param code of Int64\n    * @param msg of String\n    *\n    * @return Type of Bool\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"upgrader.cj","path":"simple_websocket/src/server/upgrader.cj","code_tokens":"private func checkHeader ( r : HashMap < String , String > , key : String , val : String ) : Bool {   let connection = r . get ( key ) . getOrDefault ( { =>  NL } ) NL if ( connection ==  || connection . trimAscii ( ) . toAsciiLower ( ) != val ) {  return false NL } NL return true NL }","func_name":"checkHeader","docstring":"/**\n    * 检查对于的请求头的值是否和自己预料的一样\n    *\n    * @param r of HashMap<String, String>\n    * @param key of String\n    * @param val of String\n    *\n    * @return Type of Bool\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"upgrader.cj","path":"simple_websocket/src/server/upgrader.cj","code_tokens":"func ugrade ( w : Response , r : Request , readBufSize ! : IntNative , writeBufSize ! : IntNative ) : Bool {   var u = Upgrader ( readBufSize : readBufSize , writeBufSize : writeBufSize , resp : w ) NL u . upgrade ( r ) NL }","func_name":"ugrade","docstring":"/**\n* 判断客户端握手信息是否正确的方法\n*\n* @param w of Response\n* @param r of Requset\n* @param readBufSize of IntNative\n* @param writeBufSize of IntNative\n*\n* @return Type of Bool\n* @since 0.32.5\n*/"}
{"repo":"simple_websocket","file":"request.cj","path":"simple_websocket/src/server/request.cj","code_tokens":"private func parseFirstLine ( line : String ) {   let m = line . split (   ) NL this . method = m . get ( 0 ) . getOrDefault ( { => GET NL } ) NL this . url = m . get ( 1 ) . getOrDefault ( { => / NL } ) NL this . http_version = m . get ( 2 ) . getOrDefault ( { => HTTP/1.1 NL } ) NL }","func_name":"parseFirstLine","docstring":"/**\n    * 解析客户端发过来的第一行握手信息\n    *\n    * @param line of String\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"request.cj","path":"simple_websocket/src/server/request.cj","code_tokens":"private func parseHeaders ( line : String ) {  if ( ! line . contains ( : ) ) {  this . flag = false NL } NL  var m = line . split ( : ) NL  let s =  NL this . headers . put ( m . get ( 0 ) . getOrDefault ( { =>  NL } ) . trimAscii ( ) , m . get ( 1 ) . getOrDefault ( { =>  NL } ) . trimAscii ( ) ) NL }","func_name":"parseHeaders","docstring":"/**\n    * 解析客户端发过来的第一行后面的握手信息\n    *\n    * @param line of String\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"request.cj","path":"simple_websocket/src/server/request.cj","code_tokens":"func methods ( ) : String {  this . method NL }","func_name":"methods","docstring":"/**\n    * 获取Method\n    *\n    * @return Type of String\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"request.cj","path":"simple_websocket/src/server/request.cj","code_tokens":"func getUrl ( ) : String {  this . url NL }","func_name":"getUrl","docstring":"/**\n    * 获取Url\n    *\n    * @return Type of String\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"request.cj","path":"simple_websocket/src/server/request.cj","code_tokens":"func httpVersion ( ) : String {  this . http_version NL }","func_name":"httpVersion","docstring":"/**\n    * 获取http_version\n    *\n    * @return Type of String\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"request.cj","path":"simple_websocket/src/server/request.cj","code_tokens":"func getHeader ( key : String ) : Option < String > {  this . headers . get ( key ) NL }","func_name":"getHeader","docstring":"/**\n    * 获取对应key的value\n    *\n    * @param key of String\n    *\n    * @return Type of Option<String>\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"request.cj","path":"simple_websocket/src/server/request.cj","code_tokens":"func header ( ) : HashMap < String , String > {  this . headers NL }","func_name":"header","docstring":"/**\n    * 获取headers\n    *\n    * @return Type of HashMap<String, String>\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func getMethod ( ) : String {  return mMethod NL }","func_name":"getMethod","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func getUrl ( ) : String {  return mUrl NL }","func_name":"getUrl","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func getHttpVersion ( ) : String {  return mHttpVersion NL }","func_name":"getHttpVersion","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func getHeader ( ) : HashMap < String , String > {  return mHeaders NL }","func_name":"getHeader","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func readMsg ( ) : ( MsgType , Option < Array < UInt8 > > ) {  return readOne ( client , byteArray ) NL }","func_name":"readMsg","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"func readOne ( socket : Socket , byteArray : ByteArrayStream ) : ( MsgType , Option < Array < UInt8 > > ) {   let headerBuf : Array < UInt8 > = Array < UInt8 > ( 2 , item : 0 ) NL  let length126 : Array < UInt8 > = Array < UInt8 > ( 2 , item : 0 ) NL  let length127 : Array < UInt8 > = Array < UInt8 > ( 8 , item : 0 ) NL  let maskBuf : Array < UInt8 > = Array < UInt8 > ( 4 , item : 0 ) NL if ( byteArray . length == 0 ) {  byteArray . clear ( ) NL } NL if ( byteArray . length < 2 ) {  readAllToFrameServer ( 2 , byteArray , socket ) NL } NL  let num0 : Int64 = byteArray . read ( headerBuf ) NL  let fh : FrameHeaderServer = readFrameHeaderServer ( headerBuf ) NL this . opCode = fh . opCode NL  var length : Int64 = makeSureLengthServer ( fh , byteArray , socket , length126 , length127 ) NL if ( byteArray . length < 4 ) {  readAllToFrameServer ( 4 , byteArray , socket ) NL } NL  let num3 : Int64 = byteArray . read ( maskBuf ) NL  let msgData = Array < UInt8 > ( length , item : 0 ) NL if ( length > 0 ) {   let payload : Array < UInt8 > = Array < UInt8 > ( length , item : 0 ) NL if ( byteArray . length < length ) {  readAllToFrameServer ( length , byteArray , socket ) NL } NL  let numData : Int64 = byteArray . read ( payload ) NL for ( i in 0 .. length ) {  msgData [ i ] = payload [ i ] ^ maskBuf [ i % 4 ] NL } NL } NL doOperateByOpCodeServer ( ) NL frameDataServer . appendAll ( msgData [ .. ] ) NL if ( fh . isFin == 1 ) {   var tmp = frameDataServer . toArray ( ) NL this . frameDataServer . clear ( ) NL return ( mt , tmp ) NL } else {  readOne ( client , byteArray ) NL } NL }","func_name":"readOne","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"private func makeSureLengthServer ( fh : FrameHeaderServer , byteArray : ByteArrayStream , socket : Socket , length126 : Array < UInt8 > , length127 : Array < UInt8 > ) : Int64 {   var length : Int64 = 0 NL if ( fh . len <= 125 ) {   let changdu = UInt64 ( fh . len ) NL length = Int64 ( changdu ) NL } else if ( fh . len == 126 ) {  if ( byteArray . length < 2 ) {  readAllToFrameServer ( 2 , byteArray , socket ) NL } NL  let num1 : Int64 = byteArray . read ( length126 ) NL  var u16 : UInt16 = 0 NL u16 = UInt16 ( length126 [ 0 ] ) << 8 | UInt16 ( length126 [ 1 ] ) NL  let changdu = UInt64 ( u16 ) NL length = Int64 ( changdu ) NL } else if ( fh . len == 127 ) {  if ( byteArray . length < 8 ) {  readAllToFrameServer ( 8 , byteArray , socket ) NL } NL  let num2 : Int64 = byteArray . read ( length127 ) NL  let changdu = UInt64 ( length127 [ 0 ] ) << 56 | UInt64 ( length127 [ 1 ] ) << 48 | UInt64 ( length127 [ 2 ] ) << 40 | UInt64 ( length127 [ 3 ] ) << 32 | UInt64 ( length127 [ 4 ] ) << 24 | UInt64 ( length127 [ 5 ] ) << 16 | UInt64 ( length127 [ 6 ] ) << 8 | UInt64 ( length127 [ 7 ] ) NL length = Int64 ( changdu ) NL } NL return length NL }","func_name":"makeSureLengthServer","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"private func doOperateByOpCodeServer ( ) {  if ( opCode == TextMessage ) {  mt = TextMessageType NL } else if ( opCode == BinaryMessage ) {  mt = BinaryMessageType NL } else if ( opCode == PingMessage ) {  sendPong ( ) NL } else if ( opCode == CloseMessage ) {  close ( ) NL } NL }","func_name":"doOperateByOpCodeServer","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"func readAllToFrameServer ( len : Int64 , byteArray : ByteArrayStream , socket : Socket ) : Unit {   let buf : Array < UInt8 > = Array < UInt8 > ( 1024 , item : 0 ) NL while ( true ) {  if ( ! socket . isClosed ( ) ) {   let num : Int64 = socket . read ( buf ) NL if ( num <= 0 ) {  break NL } NL byteArray . write ( buf [ 0 .. num ] ) NL if ( byteArray . length > = len ) {  break NL } NL } NL } NL }","func_name":"readAllToFrameServer","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"func readFrameHeaderServer ( bufs : Array < UInt8 > ) : FrameHeaderServer {  return FrameHeaderServer ( isFin : ( ( bufs [ 0 ] & 0x80 ) >> 7 ) , opCode : ( bufs [ 0 ] & 0x0f ) , mask : ( ( bufs [ 1 ] & 0x80 ) >> 7 ) , len : ( bufs [ 1 ] & 0x7f ) , buf : bufs ) NL }","func_name":"readFrameHeaderServer","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func sendMsg ( arrayToWrite : Array < UInt8 > ) {   let result = encodeDataFrameServer ( arrayToWrite , TextMessage , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendMsg","docstring":"/**\n    * 服务端写消息发送到客户端的方法\n    *\n    * @param arrayToWrite of Array<UInt8>,\n    *\n    * @return Type of Int64\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func sendFragmentMsg ( arrayToWriteList : ArrayList < Array < UInt8 > > ) {  if ( arrayToWriteList . size <= 0 ) {  print ( arrayList length error ) NL return NL } NL  var result = Array < UInt8 > ( ) NL if ( arrayToWriteList . size == 1 ) {  result = encodeDataFrameServer ( arrayToWriteList [ 0 ] , TextMessage , 1 ) NL try {  client . write ( result ) NL return NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL } else {  try {  for ( i in 0 .. arrayToWriteList . size ) {  if ( i == 0 ) {  result = encodeDataFrameServer ( arrayToWriteList [ i ] , TextMessage , 0 ) NL } else if ( i == arrayToWriteList . size - 1 ) {  result = encodeDataFrameServer ( arrayToWriteList [ i ] , 0 , 1 ) NL } else {  result = encodeDataFrameServer ( arrayToWriteList [ i ] , 0 , 0 ) NL } NL client . write ( result ) NL } NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL return NL } NL }","func_name":"sendFragmentMsg","docstring":"/**\n    * 服务端写文本分片消息发送到客户端的方法\n    *\n    * @param arrayToWriteList of ArrayList<Array<UInt8>>,\n    *\n    * @return Type of Int64\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func sendPing ( ) {   let str = ping NL  let result = encodeDataFrameServer ( str . toUtf8Array ( ) , 9 , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendPing","docstring":"/**\n    * 服务端发送ping消息的方法\n    *\n    * @return Type of Int64\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"private func sendPong ( ) {   let str = pong NL  let result = encodeDataFrameServer ( str . toUtf8Array ( ) , 10 , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendPong","docstring":"/**\n    * 服务端发送pong消息的方法\n    *\n    * @return Type of Int64\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func sendClose ( ) {   let str = close NL  let result = encodeDataFrameServer ( str . toUtf8Array ( ) , 8 , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendClose","docstring":"/**\n        * 服务端发送结束连接消息的方法\n        *\n        * @return Type of Int64\n        * @since 0.32.5\n        */"}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func sendBinary ( arrayToWrite : Array < UInt8 > ) {   let result = encodeDataFrameServer ( arrayToWrite , BinaryMessage , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendBinary","docstring":"/**\n    * 服务端写二进制消息发送到客户端的方法\n    *\n    * @param arrayToWrite of Array<UInt8>,\n    *\n    * @return Type of Int64\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func sendFragmentBinary ( arrayToWriteList : ArrayList < Array < UInt8 > > ) {  if ( arrayToWriteList . size <= 0 ) {  print ( arrayList length error ) NL return NL } NL  var result = Array < UInt8 > ( ) NL if ( arrayToWriteList . size == 1 ) {  result = encodeDataFrameServer ( arrayToWriteList [ 0 ] , BinaryMessage , 1 ) NL try {  client . write ( result ) NL return NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL } else {  try {  for ( i in 0 .. arrayToWriteList . size ) {  if ( i == 0 ) {  result = encodeDataFrameServer ( arrayToWriteList [ i ] , BinaryMessage , 0 ) NL } else if ( i == arrayToWriteList . size - 1 ) {  result = encodeDataFrameServer ( arrayToWriteList [ i ] , 0 , 1 ) NL } else {  result = encodeDataFrameServer ( arrayToWriteList [ i ] , 0 , 0 ) NL } NL client . write ( result ) NL } NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL return NL } NL }","func_name":"sendFragmentBinary","docstring":"/**\n    * 服务端写二进制分片消息发送到客户端的方法\n    *\n    * @param arrayToWriteList of ArrayList<Array<UInt8>>,\n    *\n    * @return Type of Int64\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"private func encodeDataFrameServer ( src : Array < UInt8 > , messType : UInt8 , isFin : UInt8 ) : Array < UInt8 > {   var frame = ArrayList < UInt8 > ( ) NL  var finAndOpCode : UInt8 = 0 NL if ( isFin == 0 ) {  finAndOpCode = 0 << 7 | messType NL } else {  finAndOpCode = 1 << 7 | messType NL } NL frame . append ( finAndOpCode ) NL  var payLoadSize = src . size NL if ( payLoadSize <= 125 ) {  frame . append ( UInt8 ( payLoadSize ) ) NL } else if ( payLoadSize <= 65535 ) {  frame . append ( 126 ) NL frame . appendAll ( [ UInt8 ( UInt16 ( payLoadSize ) >> 8 ) , UInt8 ( UInt16 ( payLoadSize ) << 8 >> 8 ) ] ) NL } else {  frame . append ( 127 ) NL for ( i in 0 .. 8 ) {  frame . append ( UInt8 ( payLoadSize << i * 8 >> 56 ) ) NL } NL } NL frame . appendAll ( src ) NL return frame . toArray ( ) NL }","func_name":"encodeDataFrameServer","docstring":"/**\n    * 服务端写消息到客户端时候的加密方法\n    *\n    * @param src of Array<UInt8>\n    * @param messType of Int64\n    *\n    * @return Type of Array<UInt8>\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func isClosed ( ) : Bool {  return client . isClosed ( ) NL }","func_name":"isClosed","docstring":""}
{"repo":"simple_websocket","file":"ws_conn.cj","path":"simple_websocket/src/server/ws_conn.cj","code_tokens":"public func close ( ) {  bufferFrame . clear ( ) NL bufferFin . clear ( ) NL client . close ( ) NL }","func_name":"close","docstring":"/**\n    * 服务端关闭消息的方法\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"response.cj","path":"simple_websocket/src/server/response.cj","code_tokens":"func setHeader ( key : String , val : String ) {  this . headers . put ( key , val ) NL }","func_name":"setHeader","docstring":"/**\n    * 设置header\n    *\n    * @param key of String header的键\n    * @param val of String header的值\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"response.cj","path":"simple_websocket/src/server/response.cj","code_tokens":"func writeStatusCode ( code : Int64 ) {  this . status_code = code . toString ( ) NL }","func_name":"writeStatusCode","docstring":"/**\n    * 写入返回给客户端的code\n    *\n    * @param code of Int64\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"response.cj","path":"simple_websocket/src/server/response.cj","code_tokens":"func writeBodyAndClose ( msg : String ) {   var header_str = String ( ) NL for ( ( k , v ) in headers ) {  header_str += k + :  + v + \\r\\n NL } NL  var array : Array < String > = [ HTTP/1.1 ,   , status_code , \\r\\n + header_str + \\r\\n + msg ] NL  let tmp = String . join ( array ) NL  let data = tmp . toUtf8Array ( ) NL client . write ( data ) NL client . close ( ) NL }","func_name":"writeBodyAndClose","docstring":"/**\n    * 握手失败之后，返回的错误信息\n    *\n    * @param msg of String\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"response.cj","path":"simple_websocket/src/server/response.cj","code_tokens":"func handleSuccess ( key : String ) : Bool {  try {   var resp = HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept:  + key + \\r\\n\\r\\n NL client . write ( resp . toUtf8Array ( ) ) NL return true NL } catch ( e : Exception ) {  return false NL } NL }","func_name":"handleSuccess","docstring":"/**\n    * 握手成功之后，返回的状态信息\n    *\n    * @param key of String\n    *\n    * @return Type of Bool\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"client.cj","path":"simple_websocket/src/server/client.cj","code_tokens":"func ugrade ( ) : Option < WsConn > {   let readSize = 1024 NL  var buf : Array < UInt8 > = Array < UInt8 > ( 1024 , item : 0 ) NL  var data : ArrayList < UInt8 > = ArrayList < UInt8 > ( ) NL while ( true ) {   let n : Int64 = conn . read ( buf ) NL if ( n > 0 ) {  data . appendAll ( buf [ .. n ] ) NL if ( n > 0 && n < readSize ) {  break NL } else if ( n == readSize ) {  buf = Array < UInt8 > ( readSize , item : 0 ) NL } NL } else {  break NL } NL } NL if ( data . size == 0 ) {  throw IllegalArgumentException ( 参数异常 ) NL } NL  let r = Request ( data . toArray ( ) , conn . remoteAddress ) NL  let method = r . methods ( ) NL  let url = r . getUrl ( ) NL  let http_version = r . httpVersion ( ) NL  let headers = r . header ( ) NL  let resp = Response ( conn ) NL  let result = ugrade ( resp , r , readBufSize : 0 , writeBufSize : 0 ) NL return match ( result ) { case true => WsConn ( conn , method , url , http_version , headers ) NL case _ => None NL } NL }","func_name":"ugrade","docstring":"/**\n    * 执行握手流程成功返回wsConn对象\n    *\n    * @return Type of Option<WsConn>\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"status_code.cj","path":"simple_websocket/src/server/status_code.cj","code_tokens":"public func getValue ( ) : Int64 {  match ( this ) { case TextMessageType => 1 NL case BinaryMessageType => 2 NL } NL }","func_name":"getValue","docstring":""}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"public func readMsg ( ) : ( MsgType , Option < Array < UInt8 > > ) {  return readOne ( client , byteArray ) NL }","func_name":"readMsg","docstring":""}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"func readOne ( socket : Socket , byteArray : ByteArrayStream ) : ( MsgType , Option < Array < UInt8 > > ) {   let headerBuf : Array < UInt8 > = Array < UInt8 > ( 2 , item : 0 ) NL  let length126 : Array < UInt8 > = Array < UInt8 > ( 2 , item : 0 ) NL  let length127 : Array < UInt8 > = Array < UInt8 > ( 8 , item : 0 ) NL if ( byteArray . length == 0 ) {  byteArray . clear ( ) NL } NL if ( byteArray . length < 2 ) {  readAllToFrameClient ( 2 , byteArray , socket ) NL } NL  let num0 : Int64 = byteArray . read ( headerBuf ) NL  let fh : FrameHeaderClient = readFrameHeaderClient ( headerBuf ) NL this . opCode = fh . opCode NL  var length : Int64 = makeSureLengthClient ( fh , byteArray , socket , length126 , length127 ) NL  let payload : Array < UInt8 > = Array < UInt8 > ( length , item : 0 ) NL if ( length > 0 ) {  if ( byteArray . length < length ) {  readAllToFrameClient ( length , byteArray , socket ) NL } NL  let numData : Int64 = byteArray . read ( payload ) NL } NL doOperateByOpCodeClient ( ) NL frameDataClient . appendAll ( payload [ .. ] ) NL if ( fh . isFin == 1 ) {   var tmp = frameDataClient . toArray ( ) NL this . frameDataClient . clear ( ) NL return ( mt , tmp ) NL } else {  readOne ( client , byteArray ) NL } NL }","func_name":"readOne","docstring":""}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"private func makeSureLengthClient ( fh : FrameHeaderClient , byteArray : ByteArrayStream , socket : Socket , length126 : Array < UInt8 > , length127 : Array < UInt8 > ) : Int64 {   var length : Int64 = 0 NL if ( fh . len <= 125 ) {   let changdu = UInt64 ( fh . len ) NL length = Int64 ( changdu ) NL } else if ( fh . len == 126 ) {  if ( byteArray . length < 2 ) {  readAllToFrameClient ( 2 , byteArray , socket ) NL } NL  let num1 : Int64 = byteArray . read ( length126 ) NL  var u16 : UInt16 = 0 NL u16 = UInt16 ( length126 [ 0 ] ) << 8 | UInt16 ( length126 [ 1 ] ) NL  let changdu = UInt64 ( u16 ) NL length = Int64 ( changdu ) NL } else if ( fh . len == 127 ) {  if ( byteArray . length < 8 ) {  readAllToFrameClient ( 8 , byteArray , socket ) NL } NL  let num2 : Int64 = byteArray . read ( length127 ) NL  let changdu = UInt64 ( length127 [ 0 ] ) << 56 | UInt64 ( length127 [ 1 ] ) << 48 | UInt64 ( length127 [ 2 ] ) << 40 | UInt64 ( length127 [ 3 ] ) << 32 | UInt64 ( length127 [ 4 ] ) << 24 | UInt64 ( length127 [ 5 ] ) << 16 | UInt64 ( length127 [ 6 ] ) << 8 | UInt64 ( length127 [ 7 ] ) NL length = Int64 ( changdu ) NL } NL return length NL }","func_name":"makeSureLengthClient","docstring":""}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"private func doOperateByOpCodeClient ( ) {  if ( opCode == TextMessage ) {  mt = TextMessageType NL } else if ( opCode == BinaryMessage ) {  mt = BinaryMessageType NL } else if ( opCode == PingMessage ) {  sendPong ( ) NL } else if ( opCode == CloseMessage ) {  close ( ) NL } NL }","func_name":"doOperateByOpCodeClient","docstring":""}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"func readAllToFrameClient ( len : Int64 , byteArray : ByteArrayStream , socket : Socket ) : Unit {   let buf : Array < UInt8 > = Array < UInt8 > ( 1024 , item : 0 ) NL while ( true ) {  if ( ! socket . isClosed ( ) ) {   let num : Int64 = socket . read ( buf ) NL if ( num <= 0 ) {  break NL } NL byteArray . write ( buf [ 0 .. num ] ) NL if ( byteArray . length > = len ) {  break NL } NL } NL } NL }","func_name":"readAllToFrameClient","docstring":""}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"func readFrameHeaderClient ( bufs : Array < UInt8 > ) : FrameHeaderClient {  return FrameHeaderClient ( isFin : ( ( bufs [ 0 ] & 0x80 ) >> 7 ) , opCode : ( bufs [ 0 ] & 0x0f ) , mask : ( ( bufs [ 1 ] & 0x80 ) >> 7 ) , len : ( bufs [ 1 ] & 0x7f ) , buf : bufs ) NL }","func_name":"readFrameHeaderClient","docstring":""}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"public func sendMsg ( arrayToWrite : Array < UInt8 > ) {   let result = encodeDataFrameClient ( arrayToWrite , TextMessage , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendMsg","docstring":"/**\r\n    * 客户端写消息发送到服务端的方法\r\n    *\r\n    * @param arrayToWrite of Array<UInt8>,\r\n    *\r\n    * @return Type of Int64\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"public func sendFragmentMsg ( arrayToWriteList : ArrayList < Array < UInt8 > > ) {  if ( arrayToWriteList . size <= 0 ) {  print ( arrayList length error ) NL return NL } NL  var result = Array < UInt8 > ( ) NL if ( arrayToWriteList . size == 1 ) {  result = encodeDataFrameClient ( arrayToWriteList [ 0 ] , TextMessage , 1 ) NL try {  client . write ( result ) NL return NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL } else {  try {  for ( i in 0 .. arrayToWriteList . size ) {  if ( i == 0 ) {  result = encodeDataFrameClient ( arrayToWriteList [ i ] , TextMessage , 0 ) NL } else if ( i == arrayToWriteList . size - 1 ) {  result = encodeDataFrameClient ( arrayToWriteList [ i ] , 0 , 1 ) NL } else {  result = encodeDataFrameClient ( arrayToWriteList [ i ] , 0 , 0 ) NL } NL client . write ( result ) NL } NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL return NL } NL }","func_name":"sendFragmentMsg","docstring":"/**\r\n    * 客户端写文本分片消息发送到服务端的方法\r\n    *\r\n    * @param arrayToWriteList of ArrayList<Array<UInt8>>,\r\n    *\r\n    * @return Type of Int64\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"public func sendPing ( ) {   let str = ping NL  let result = encodeDataFrameClient ( str . toUtf8Array ( ) , 9 , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendPing","docstring":"/**\r\n    * 客户端发送ping消息的方法\r\n    *\r\n    * @return Type of Int64\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"private func sendPong ( ) {   let str = pong NL  let result = encodeDataFrameClient ( str . toUtf8Array ( ) , 10 , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendPong","docstring":"/**\r\n    * 客户端发送pong消息的方法\r\n    *\r\n    * @return Type of Int64\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"public func sendClose ( ) {   let str = close NL  let result = encodeDataFrameClient ( str . toUtf8Array ( ) , 8 , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendClose","docstring":"/**\r\n    * 客户端发送结束连接消息的方法\r\n    *\r\n    * @return Type of Int64\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"public func sendBinary ( arrayToWrite : Array < UInt8 > ) {   let result = encodeDataFrameClient ( arrayToWrite , BinaryMessage , 1 ) NL try {  client . write ( result ) NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL }","func_name":"sendBinary","docstring":"/**\r\n    * 客户端写二进制消息发送到服务端的方法\r\n    *\r\n    * @param arrayToWrite of Array<UInt8>,\r\n    *\r\n    * @return Type of Int64\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"public func sendFragmentBinary ( arrayToWriteList : ArrayList < Array < UInt8 > > ) {  if ( arrayToWriteList . size <= 0 ) {  print ( arrayList length error ) NL return NL } NL  var result = Array < UInt8 > ( ) NL if ( arrayToWriteList . size == 1 ) {  result = encodeDataFrameClient ( arrayToWriteList [ 0 ] , BinaryMessage , 1 ) NL try {  client . write ( result ) NL return NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL } else {  try {  for ( i in 0 .. arrayToWriteList . size ) {  if ( i == 0 ) {  result = encodeDataFrameClient ( arrayToWriteList [ i ] , BinaryMessage , 0 ) NL } else if ( i == arrayToWriteList . size - 1 ) {  result = encodeDataFrameClient ( arrayToWriteList [ i ] , 0 , 1 ) NL } else {  result = encodeDataFrameClient ( arrayToWriteList [ i ] , 0 , 0 ) NL } NL client . write ( result ) NL } NL } catch ( e : Exception ) {  print ( e . toString ( ) ) NL } NL return NL } NL }","func_name":"sendFragmentBinary","docstring":"/**\r\n    * 客户端写二进制分片消息发送到服务端的方法\r\n    *\r\n    * @param arrayToWriteList of ArrayList<Array<UInt8>>,\r\n    *\r\n    * @return Type of Int64\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"private func encodeDataFrameClient ( src : Array < UInt8 > , messType : UInt8 , isFin : UInt8 ) : Array < UInt8 > {   var frame = ArrayList < UInt8 > ( ) NL  var finAndOpCode : UInt8 = 0 NL if ( isFin == 0 ) {  finAndOpCode = 0 << 7 | messType NL } else {  finAndOpCode = 1 << 7 | messType NL } NL frame . append ( finAndOpCode ) NL  var payLoadSize = src . size NL if ( payLoadSize <= 125 ) {  frame . append ( UInt8 ( payLoadSize | 0x80 ) ) NL } else if ( payLoadSize <= 65535 ) {  frame . append ( 126 | 0x80 ) NL frame . appendAll ( [ UInt8 ( UInt16 ( payLoadSize ) >> 8 ) , UInt8 ( UInt16 ( payLoadSize ) << 8 >> 8 ) ] ) NL } else {  frame . append ( 127 | 0x80 ) NL for ( i in 0 .. 8 ) {  frame . append ( UInt8 ( payLoadSize << i * 8 >> 56 ) ) NL } NL } NL  var maskKey = Array < UInt8 > ( 4 , item : 0 ) NL for ( i in 0 .. 4 ) {   let randomMaskKey = m . nextUInt8 ( ) NL maskKey [ i ] = randomMaskKey NL frame . append ( randomMaskKey ) NL } NL for ( i in 0 .. payLoadSize ) {   let value = src [ Int64 ( i ) ] ^ maskKey [ Int64 ( i ) % 4 ] NL frame . append ( value ) NL } NL return frame . toArray ( ) NL }","func_name":"encodeDataFrameClient","docstring":"/**\r\n    * 客户端写消息到服务端时候的加密方法\r\n    *\r\n    * @param src of Array<UInt8>\r\n    * @param messType of Int64\r\n    *\r\n    * @return Type of Array<UInt8>\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"public func isClosed ( ) : Bool {  return client . isClosed ( ) NL }","func_name":"isClosed","docstring":""}
{"repo":"simple_websocket","file":"ws_conn_client.cj","path":"simple_websocket/src/client/ws_conn_client.cj","code_tokens":"public func close ( ) {  bufferFrame . clear ( ) NL bufferFin . clear ( ) NL client . close ( ) NL }","func_name":"close","docstring":"/**\r\n    * 客户端关闭连接的方法\r\n    *\r\n    * @return Type of UInt8\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"web_socket_client.cj","path":"simple_websocket/src/client/web_socket_client.cj","code_tokens":"public func connect ( ) : Option < WsConnClient > {  socket = Socket ( SocketNet . TCP , host , port ) NL socket . getOrThrow ( ) . connect ( Duration . second ( timeOutTime ) ) NL sleep ( sleepTime ) NL  let ws_client = SharkHand ( socket , rawUrl , headers , sharkHandsParams ) . sharkHand ( ) NL match ( ws_client ) { case Some ( c ) => return c NL case _ => println ( get ws_client none ) NL return Option < WsConnClient > . None NL } NL }","func_name":"connect","docstring":"/**\r\n        * 客户度连接的方法\r\n        *\r\n        * @since 0.32.5\r\n        */"}
{"repo":"simple_websocket","file":"shark_hand.cj","path":"simple_websocket/src/client/shark_hand.cj","code_tokens":"func sharkHand ( ) : Option < WsConnClient > {   let sr = SharkRequest ( conn , rawUrl , headers , sharkHandsParams ) NL sr . sendSharkHandRequest ( ) NL mRandomStr = sr . randomStr NL  let resSharkData = SharkResponse ( conn ) . listenHandShark ( ) NL  let checkRes = checkhandshark ( resSharkData ) NL return match ( checkRes ) { case true => WsConnClient ( conn ) NL case _ => None NL } NL }","func_name":"sharkHand","docstring":"/**\r\n    * 客户端执行握手步骤的方法，成功后返回WsConnClient对象\r\n    *\r\n    * @return Type of Option<WsConnClient>\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"shark_hand.cj","path":"simple_websocket/src/client/shark_hand.cj","code_tokens":"private func checkhandshark ( metadata : Array < UInt8 > ) : Bool {   var meta_str : String =  NL unsafe {  meta_str = String . fromUtf8Unchecked ( metadata ) NL } NL  let arrayStr : Array < String > = meta_str . split (   ) NL if ( arrayStr . size > 2 ) {   let status_code : String = arrayStr [ 1 ] NL if ( 101 . equals ( status_code ) ) {   let arrayStr : Array < String > = meta_str . split ( \\r\\n ) NL  var checkSuccess : Bool = false NL for ( str in arrayStr ) {  if ( str . startsWith ( Sec-WebSocket-Accept:  ) ) {   let key = str . replace ( Sec-WebSocket-Accept:  ,  ) NL  let arrayStr = mRandomStr . toUtf8Array ( ) NL  var webSocketKeyTemp = toBase64String ( arrayStr ) NL  let tmp = webSocketKeyTemp + keyGuid NL  let result = SHA1 . digest ( tmp ) NL  let genKey = toBase64String ( result ) NL if ( key . equals ( genKey ) ) {  checkSuccess = true NL break NL } else {  checkSuccess = false NL break NL } NL } NL } NL if ( checkSuccess ) {  return true NL } else {  return false NL } NL } else {   let arrayMess : Array < String > = meta_str . split ( \\r\\n ) NL  let sz = arrayMess . size NL if ( sz > 0 ) {  println ( arrayMess [ sz - 1 ] ) NL } NL return false NL } NL } else {  return false NL } NL }","func_name":"checkhandshark","docstring":"/**\r\n        * 客户端检查服务端返回的握手信息的方法\r\n        *\r\n        * @param metadata of Array<UInt8>\r\n        *\r\n        * @return Type of Bool\r\n        * @since 0.32.5\r\n        */"}
{"repo":"simple_websocket","file":"shark_request.cj","path":"simple_websocket/src/client/shark_request.cj","code_tokens":"func sendSharkHandRequest ( ) {   let handshakeString = getHandShakeString ( ) NL  let data = handshakeString . toUtf8Array ( ) NL socket . write ( data ) NL }","func_name":"sendSharkHandRequest","docstring":"/**\r\n    * 客户端发送握手信息\r\n    *\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"shark_request.cj","path":"simple_websocket/src/client/shark_request.cj","code_tokens":"private func getHttpMethodString ( sb : StringBuilder ) {  if ( sharkHandsParams . contains ( HttpMethod ) ) {   let httpMethod : String = sharkHandsParams . get ( HttpMethod ) . getOrThrow ( ) NL sb . append ( httpMethod ) . append (   ) NL } else {  sb . append ( GET  ) NL } NL }","func_name":"getHttpMethodString","docstring":"/**\r\n    * 获取HttpMethod字符串\r\n    *\r\n    * @param sb of StringBuilder\r\n    *\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"shark_request.cj","path":"simple_websocket/src/client/shark_request.cj","code_tokens":"private func getUpgradeTypeString ( sb : StringBuilder ) {  if ( sharkHandsParams . contains ( UpgradeType ) ) {   let upgradeType : String = sharkHandsParams . get ( UpgradeType ) . getOrThrow ( ) NL sb . append ( Upgrade:  ) . append ( upgradeType ) NL } else {  sb . append ( Upgrade: websocket ) NL } NL }","func_name":"getUpgradeTypeString","docstring":"/**\r\n    * 获取UpgradeType字符串\r\n    *\r\n    * @param sb of StringBuilder\r\n    *\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"shark_request.cj","path":"simple_websocket/src/client/shark_request.cj","code_tokens":"private func getConnectionTypeString ( sb : StringBuilder ) {  if ( sharkHandsParams . contains ( ConnectionType ) ) {   let connectionType : String = sharkHandsParams . get ( ConnectionType ) . getOrThrow ( ) NL sb . append ( Connection:  ) . append ( connectionType ) NL } else {  sb . append ( Connection: Upgrade ) NL } NL }","func_name":"getConnectionTypeString","docstring":"/**\r\n    * 获取ConnectionType字符串\r\n    *\r\n    * @param sb of StringBuilder\r\n    *\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"shark_request.cj","path":"simple_websocket/src/client/shark_request.cj","code_tokens":"private func getWebsocketKeyString ( sb : StringBuilder , webSocketKey : String ) {  if ( sharkHandsParams . contains ( WebsocketKey ) ) {   let websocketKeyOut : String = sharkHandsParams . get ( WebsocketKey ) . getOrThrow ( ) NL sb . append ( websocketKeyOut ) NL } else {  sb . append ( webSocketKey ) NL } NL }","func_name":"getWebsocketKeyString","docstring":"/**\r\n    * 获取WebsocketKey字符串\r\n    *\r\n    * @param sb of StringBuilder\r\n    *\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"shark_request.cj","path":"simple_websocket/src/client/shark_request.cj","code_tokens":"private func getWebsocketVersionString ( sb : StringBuilder ) {  if ( sharkHandsParams . contains ( WebsocketVersion ) ) {   let websocketVersion : String = sharkHandsParams . get ( WebsocketVersion ) . getOrThrow ( ) NL sb . append ( Sec-WebSocket-Version:  ) . append ( websocketVersion ) NL } else {  sb . append ( Sec-WebSocket-Version: 13 ) NL } NL }","func_name":"getWebsocketVersionString","docstring":"/**\r\n    * 获取WebsocketVersion字符串\r\n    *\r\n    * @param sb of StringBuilder\r\n    *\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"shark_request.cj","path":"simple_websocket/src/client/shark_request.cj","code_tokens":"private func getHandShakeString ( ) : String {   var sb = StringBuilder ( ) NL getHttpMethodString ( sb ) NL  var part =  NL  let part1 = uri . rawPath NL  let part2 = uri . rawQuery NL if ( ! part1 . isEmpty ( ) ) {  part = part1 NL } else {  part = / NL } NL if ( ! part2 . isEmpty ( ) ) {  part = part + ? + part2 NL } NL sb . append ( part ) . append (  HTTP/1.1 ) . append ( \\r\\n ) . append ( Host:  ) NL if ( port . isEmpty ( ) ) {  sb . append ( host ) NL } else {  sb . append ( host + : + port ) NL } NL sb . append ( \\r\\n ) NL getUpgradeTypeString ( sb ) NL sb . append ( \\r\\n ) NL getConnectionTypeString ( sb ) NL sb . append ( \\r\\n ) NL randomStr = generateId ( ) NL  let arrayStr = randomStr . toUtf8Array ( ) NL  var webSocketKey = toBase64String ( arrayStr ) NL  var origin =  NL if ( port . isEmpty ( ) ) {  origin = scheme + :// + host NL } else {  origin = scheme + :// + host + : + port NL } NL sb . append ( Sec-WebSocket-Key:  ) NL getWebsocketKeyString ( sb , webSocketKey ) NL sb . append ( \\r\\n ) . append ( Origin:  ) . append ( origin ) . append ( \\r\\n ) NL for ( ( k , v ) in headers ) {  sb . append ( k ) . append ( :  ) . append ( v ) . append ( \\r\\n ) NL } NL getWebsocketVersionString ( sb ) NL sb . append ( \\r\\n ) NL sb . append ( \\r\\n ) NL return sb . toString ( ) NL }","func_name":"getHandShakeString","docstring":"/**\r\n    * 客户端生成握手信息字符串\r\n    *\r\n    * @return Type of String\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"shark_request.cj","path":"simple_websocket/src/client/shark_request.cj","code_tokens":"private func generateId ( ) : String {   var array : Array < String > = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u , v , w , x , y , z , A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P , Q , R , S , T , U , V , W , X , Y , Z ] NL  var strbuilder = StringBuilder ( ) NL  let size = array . size NL  let sizeDouble = Float64 ( size ) NL  var m : Random = Random ( ) NL for ( i in 0 .. 16 ) {   let doubleValue = m . nextFloat64 ( ) NL  let value = doubleValue * sizeDouble NL  let IntValue = Int64 ( value ) NL  let chooseStr = array [ IntValue ] NL strbuilder . append ( chooseStr ) NL } NL return strbuilder . toString ( ) NL }","func_name":"generateId","docstring":"/**\r\n    * 客户端随机生成的websocket key\r\n    *\r\n    * @return Type of String\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"shark_response.cj","path":"simple_websocket/src/client/shark_response.cj","code_tokens":"func listenHandShark ( ) : Array < UInt8 > {  while ( true ) {   let n : Int64 = socket . read ( buf ) NL if ( n > 0 ) {  data . appendAll ( buf [ .. n ] ) NL if ( n > 0 && n < readSize ) {  break NL } else if ( n == readSize ) {  buf = Array < UInt8 > ( readSize , item : 0 ) NL } NL } else {  break NL } NL } NL if ( data . size == 0 ) {  throw IllegalArgumentException ( 参数异常 ) NL } NL return data . toArray ( ) NL }","func_name":"listenHandShark","docstring":"/**\r\n    * 客户端监听服务端返回握手信息的方法\r\n    *\r\n    * @return Type of Array<UInt8>\r\n    * @since 0.32.5\r\n    */"}
{"repo":"simple_websocket","file":"status_code.cj","path":"simple_websocket/src/client/status_code.cj","code_tokens":"public func getValue ( ) : Int64 {  match ( this ) { case TextMessageType => 1 NL case BinaryMessageType => 2 NL } NL }","func_name":"getValue","docstring":""}
{"repo":"simple_websocket","file":"sha1.cj","path":"simple_websocket/src/utils/sha1.cj","code_tokens":"static public func digest ( src : String ) : Array < UInt8 > {   var sha1 = SHA1 ( ) NL  let buf = src . toUtf8Array ( ) NL sha1 . sha1Update ( buf , buf . size ) NL sha1 . sha1Final ( ) NL return sha1 . hash NL }","func_name":"digest","docstring":"/**\n    * 计算字符串的sha1值\n    *\n    * @param src of String\n    *\n    * @return Type of Array<UInt8>\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"sha1.cj","path":"simple_websocket/src/utils/sha1.cj","code_tokens":"private func rotleft ( a : UInt32 , b : UInt32 ) : UInt32 {  ( ( a << b ) | ( a >> ( 32 - b ) ) ) NL }","func_name":"rotleft","docstring":"/**\n    * rotleft方法\n    *\n    * @param a of UInt32\n    * @param b of UInt32\n    *\n    * @return Type of UInt32\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"sha1.cj","path":"simple_websocket/src/utils/sha1.cj","code_tokens":"private func sha1Update ( other : Array < UInt8 > , len : Int64 ) {  for ( i in 0 .. len ) {  this . data [ this . datalen ] = other [ i ] NL this . datalen = this . datalen + 1 NL if ( this . datalen == 64 ) {  sha1Transform ( ) NL this . bitlen = this . bitlen + 512 NL this . datalen = 0 NL } NL } NL }","func_name":"sha1Update","docstring":"/**\n    * sha1Update方法\n    *\n    * @param other of Array<UInt8>\n    * @param len of Int64\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"sha1.cj","path":"simple_websocket/src/utils/sha1.cj","code_tokens":"@ overflowWrapping   private func sha1Final ( ) {   var i : Int64 = this . datalen NL if ( this . datalen < 56 ) {  this . data [ i ] = UInt8 ( 0b1000_0000 ) NL i = i + 1 NL while ( i < 56 ) {  this . data [ i ] = 0x00 NL i = i + 1 NL } NL } else {  this . data [ i ] = UInt8 ( 0b1000_0000 ) NL i = i + 1 NL while ( i < 64 ) {  this . data [ i ] = UInt8 ( 0x00 ) NL i = i + 1 NL } NL sha1Transform ( ) NL for ( j in 0 .. 56 ) {  this . data [ j ] = 0 NL } NL } NL this . bitlen = this . bitlen + ( this . datalen * 8 ) NL this . data [ 63 ] = UInt8 ( this . bitlen ) NL this . data [ 62 ] = UInt8 ( this . bitlen >> 8 ) NL this . data [ 61 ] = UInt8 ( this . bitlen >> 16 ) NL this . data [ 60 ] = UInt8 ( this . bitlen >> 24 ) NL this . data [ 59 ] = UInt8 ( this . bitlen >> 32 ) NL this . data [ 58 ] = UInt8 ( this . bitlen >> 40 ) NL this . data [ 57 ] = UInt8 ( this . bitlen >> 48 ) NL this . data [ 56 ] = UInt8 ( this . bitlen >> 56 ) NL sha1Transform ( ) NL for ( j in 0 .. 4 ) {  hash [ j ] = UInt8 ( ( this . state [ 0 ] >> ( 24 - j * 8 ) ) & 0x000000ff ) NL hash [ j + 4 ] = UInt8 ( ( this . state [ 1 ] >> ( 24 - j * 8 ) ) & 0x000000ff ) NL hash [ j + 8 ] = UInt8 ( ( this . state [ 2 ] >> ( 24 - j * 8 ) ) & 0x000000ff ) NL hash [ j + 12 ] = UInt8 ( ( this . state [ 3 ] >> ( 24 - j * 8 ) ) & 0x000000ff ) NL hash [ j + 16 ] = UInt8 ( ( this . state [ 4 ] >> ( 24 - j * 8 ) ) & 0x000000ff ) NL } NL }","func_name":"sha1Final","docstring":"/**\n    * sha1Final方法\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"sha1.cj","path":"simple_websocket/src/utils/sha1.cj","code_tokens":"@ overflowWrapping   private func sha1Transform ( ) {   var j : Int64 = 0 NL  var m : Array < UInt32 > = Array < UInt32 > ( 80 , { i => 0 NL } ) NL for ( i in 0 .. 16 ) {  m [ i ] = ( UInt32 ( this . data [ j ] ) << 24 ) + ( UInt32 ( this . data [ j + 1 ] ) << 16 ) + ( UInt32 ( this . data [ j + 2 ] ) << 8 ) + UInt32 ( this . data [ j + 3 ] ) NL j = j + 4 NL } NL for ( i in 16 .. 80 ) {  m [ i ] = ( m [ i - 3 ] ^ m [ i - 8 ] ^ m [ i - 14 ] ^ m [ i - 16 ] ) NL m [ i ] = ( m [ i ] << 1 ) | ( m [ i ] >> 31 ) NL } NL  var a : UInt32 = this . state [ 0 ] NL  var b : UInt32 = this . state [ 1 ] NL  var c : UInt32 = this . state [ 2 ] NL  var d : UInt32 = this . state [ 3 ] NL  var e : UInt32 = this . state [ 4 ] NL  var t : UInt32 = 0 NL  let res : ( UInt32 , UInt32 , UInt32 , UInt32 , UInt32 , UInt32 , Array < UInt32 > ) = getFieldChouQu ( t , a , b , c , d , e , m ) NL t = res [ 0 ] NL a = res [ 1 ] NL b = res [ 2 ] NL c = res [ 3 ] NL d = res [ 4 ] NL e = res [ 5 ] NL m = res [ 6 ] NL this . state [ 0 ] = this . state [ 0 ] + a NL this . state [ 1 ] = this . state [ 1 ] + b NL this . state [ 2 ] = this . state [ 2 ] + c NL this . state [ 3 ] = this . state [ 3 ] + d NL this . state [ 4 ] = this . state [ 4 ] + e NL }","func_name":"sha1Transform","docstring":"/**\n    * sha1Transform方法\n    *\n    * @since 0.32.5\n    */"}
{"repo":"simple_websocket","file":"sha1.cj","path":"simple_websocket/src/utils/sha1.cj","code_tokens":"@ overflowWrapping   private func getFieldChouQu ( paramt : UInt32 , parama : UInt32 , paramb : UInt32 , paramc : UInt32 , paramd : UInt32 , parame : UInt32 , paramm : Array < UInt32 > ) : ( UInt32 , UInt32 , UInt32 , UInt32 , UInt32 , UInt32 , Array < UInt32 > ) {   var t = paramt NL  var a = parama NL  var b = paramb NL  var c = paramc NL  var d = paramd NL  var e = parame NL  var m = paramm NL for ( i in 0 .. 20 ) {  t = UInt32 ( ( rotleft ( a , 5 ) ) + ( ( b & c ) ^ ( ( ! b ) & d ) ) + ( e ) + ( this . k [ 0 ] ) + ( m [ i ] ) ) NL e = d NL d = c NL c = rotleft ( b , 30 ) NL b = a NL a = t NL } NL for ( i in 20 .. 40 ) {  t = UInt32 ( ( rotleft ( a , 5 ) ) + ( b ^ c ^ d ) + ( e ) + ( this . k [ 1 ] ) + ( m [ i ] ) ) NL e = d NL d = c NL c = rotleft ( b , 30 ) NL b = a NL a = t NL } NL for ( i in 40 .. 60 ) {  t = UInt32 ( ( rotleft ( a , 5 ) ) + ( ( b & c ) ^ ( b & d ) ^ ( c & d ) ) + ( e ) + ( this . k [ 2 ] ) + ( m [ i ] ) ) NL e = d NL d = c NL c = rotleft ( b , 30 ) NL b = a NL a = t NL } NL for ( i in 60 .. 80 ) {  t = UInt32 ( ( rotleft ( a , 5 ) ) + ( b ^ c ^ d ) + ( e ) + ( this . k [ 3 ] ) + ( m [ i ] ) ) NL e = d NL d = c NL c = rotleft ( b , 30 ) NL b = a NL a = t NL } NL return ( t , a , b , c , d , e , m ) NL }","func_name":"getFieldChouQu","docstring":"/**\n    * getFieldChouQu方法\n    *\n    * @param paramt of UInt32\n    * @param parama of UInt32\n    * @param paramb of UInt32\n    * @param paramc of UInt32\n    * @param paramd of UInt32\n    * @param parame of UInt32\n    * @param paramm of Array<UInt32>\n    *\n    *\n    * @return Type of (UInt32,UInt32,UInt32,UInt32,UInt32,UInt32,Array<UInt32>)\n    *\n    * @since 0.32.5\n    */"}
