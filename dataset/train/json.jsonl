{"repo":"json","file":"jsom.cj","path":"json/src/jsom/jsom.cj","code_tokens":"func skip ( ) {  while ( true ) {  match ( tokens [ offset ] . kind ) { case NL => offset ++ NL case COMMENT => offset ++ NL case _ => break NL } NL } NL }","func_name":"skip","docstring":"/* skip newline and comment */"}
{"repo":"json","file":"jsom.cj","path":"json/src/jsom/jsom.cj","code_tokens":"func next ( ) {  skip ( ) NL offset ++ NL tokens [ offset - 1 ] NL }","func_name":"next","docstring":"/* read next token */"}
{"repo":"json","file":"jsom.cj","path":"json/src/jsom/jsom.cj","code_tokens":"func next ( kind : TokenKind ) {  skip ( ) NL if ( tokens [ offset ] . kind == kind ) {  offset ++ NL return true NL } NL false NL }","func_name":"next","docstring":"/* read next token */"}
{"repo":"json","file":"jsom.cj","path":"json/src/jsom/jsom.cj","code_tokens":"func readExp ( ) : Tokens {   var lc = 1 NL  var tok : Token NL  var ret = Tokens ( ) NL while ( true ) {  tok = tokens [ offset ] NL offset ++ NL match ( tok . kind ) { case LPAREN => lc ++ NL case RPAREN => lc -- NL if ( lc == 0 ) {  break NL } NL case _ => ( ) NL } NL ret += tok NL } NL ret NL }","func_name":"readExp","docstring":"/* ()内的表达式 */"}
{"repo":"json","file":"jsom.cj","path":"json/src/jsom/jsom.cj","code_tokens":"func readKey ( ) : Tokens {   let tok = next ( ) NL if ( tok . kind == LPAREN ) {   let exp = readExp ( ) NL if ( next ( ) . kind != COLON ) {  throw Exception ( Symbol `:` is required. ) NL } NL return quote ( $exp ) NL } NL if ( next ( ) . kind != COLON ) {  throw Exception ( Symbol `:` is required. ) NL } NL match ( tok . kind ) { case IDENTIFIER => quote ( $ ( tok . value ) ) NL case _ => quote ( $tok ) NL } NL }","func_name":"readKey","docstring":"/* key: 1、标识符(标识符默认为obj的key), 3、String/ToString类型的字面量/()内的表达式 */"}
{"repo":"json","file":"jsom.cj","path":"json/src/jsom/jsom.cj","code_tokens":"func readObj ( ) : Tokens {  if ( next ( RCURL ) ) {  return quote ( JsonObject ( ) ) NL } NL  var toks = quote ( JsonObjectBuilder ( ) ) NL while ( true ) {  toks += quote ( . put ( $ ( readKey ( ) ) , $ ( readJson ( ) ) ) ) NL match ( next ( ) . kind ) { case COMMA => continue NL case RCURL => break NL case c => throw Exception ( Invaild `${c}` in JSON object. ) NL } NL } NL toks + quote ( . build ( ) ) NL }","func_name":"readObj","docstring":"/* obj: \\{ [\\} | $key: $val (, $key: $val)*] */"}
{"repo":"json","file":"jsom.cj","path":"json/src/jsom/jsom.cj","code_tokens":"func readArr ( ) : Tokens {  if ( next ( RSQUARE ) ) {  return quote ( JsonArray ( ) ) NL } NL  var toks = quote ( JsonArrayBuilder ( ) ) NL while ( true ) {  toks += quote ( . append ( $ ( readJson ( ) ) ) ) NL match ( next ( ) . kind ) { case COMMA => continue NL case RSQUARE => break NL case c => throw Exception ( Invaild `${c}` in JSON array. ) NL } NL } NL toks + quote ( . build ( ) ) NL }","func_name":"readArr","docstring":"/* arr: \\[ [ \\] | $val (, $val)*] */"}
{"repo":"json","file":"jsom.cj","path":"json/src/jsom/jsom.cj","code_tokens":"public func readJson ( ) : Tokens {   let tok = next ( ) NL match ( tok . kind ) { case LCURL => readObj ( ) NL case LSQUARE => readArr ( ) NL case LPAREN => quote ( $ ( readExp ( ) ) ) NL case INTEGER_LITERAL => quote ( Float64 ( $tok ) ) NL case SUB =>  let num = tokens [ offset ] NL offset ++ NL match ( num . kind ) { case FLOAT_LITERAL => quote ( - $num ) NL case _ => quote ( - Float64 ( $num ) ) NL } NL case _ => quote ( $tok ) NL } NL }","func_name":"readJson","docstring":"/* val: 1、Json/ToString类型的, 标识符/字面量/()包围的原生表达式, 2、$obj 3、$arr */"}
{"repo":"json","file":"jsonBuilder.cj","path":"json/src/json/jsonBuilder.cj","code_tokens":"public func put ( key : ToString , val : Json ) {  obj [ key . toString ( ) ] = val NL this NL }","func_name":"put","docstring":""}
{"repo":"json","file":"jsonBuilder.cj","path":"json/src/json/jsonBuilder.cj","code_tokens":"public func put ( key : ToString , val : ToJson ) {  obj [ key . toString ( ) ] = val . toJson ( ) NL this NL }","func_name":"put","docstring":""}
{"repo":"json","file":"jsonBuilder.cj","path":"json/src/json/jsonBuilder.cj","code_tokens":"public func build ( ) {  obj NL }","func_name":"build","docstring":""}
{"repo":"json","file":"jsonBuilder.cj","path":"json/src/json/jsonBuilder.cj","code_tokens":"public func append ( val : Json ) {  arr . append ( val ) NL this NL }","func_name":"append","docstring":""}
{"repo":"json","file":"jsonBuilder.cj","path":"json/src/json/jsonBuilder.cj","code_tokens":"public func append ( val : ToJson ) {  arr . append ( val . toJson ( ) ) NL this NL }","func_name":"append","docstring":""}
{"repo":"json","file":"jsonBuilder.cj","path":"json/src/json/jsonBuilder.cj","code_tokens":"public func build ( ) {  arr NL }","func_name":"build","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"func toJson ( ) : Json","func_name":"toJson","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"func stringify ( os : JsonSerializer ) : Unit","func_name":"stringify","docstring":"/* stringify */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"func stringify ( ) {  StringBuilder ( ) . append ( this ) . toString ( ) NL }","func_name":"stringify","docstring":"/* stringify */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"func asNull ( ) {  ( this as JsonNull ) . getOrThrow ( ) NL }","func_name":"asNull","docstring":"/* `asXXX()` assert JSON is `XXX` and return `XXX` */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"func asNumber ( ) {  ( this as JsonNumber ) . getOrThrow ( ) NL }","func_name":"asNumber","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"func asBoolean ( ) {  ( this as JsonBoolean ) . getOrThrow ( ) NL }","func_name":"asBoolean","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"func asObject ( ) {  ( this as JsonObject ) . getOrThrow ( ) NL }","func_name":"asObject","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"func asArray ( ) {  ( this as JsonArray ) . getOrThrow ( ) NL }","func_name":"asArray","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"func asString ( ) {  ( this as JsonString ) . getOrThrow ( ) NL }","func_name":"asString","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"static func null ( ) {  JsonNull ( ) NL }","func_name":"null","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func toString ( ) {  null NL }","func_name":"toString","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func stringify ( ) {  null NL }","func_name":"stringify","docstring":"/* stringify */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func stringify ( os : JsonSerializer ) : Unit {  os . append ( null ) NL }","func_name":"stringify","docstring":"/* stringify */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func stringify ( os : JsonSerializer ) : Unit {  os . append ( \\\" ) NL escape ( os ) . append ( \\\" ) NL }","func_name":"stringify","docstring":"/* stringify */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func stringify ( os : JsonSerializer ) : Unit {   var sep = false NL os . append ( { ) NL for ( ( k , v ) in this ) {  if ( sep ) {  os . append ( ,  ) NL } else {  sep = true NL } NL os . append ( \\\" ) NL k . escape ( os ) . append ( \\\":  ) NL v . stringify ( os ) NL } NL os . append ( } ) NL }","func_name":"stringify","docstring":"/* stringify */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getNull ( k : K ) {  this [ k ] . asNull ( ) NL }","func_name":"getNull","docstring":"/* extend `getXXX()` for JsonObject */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getNumber ( k : K ) {  this [ k ] . asNumber ( ) NL }","func_name":"getNumber","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getBoolean ( k : K ) {  this [ k ] . asBoolean ( ) NL }","func_name":"getBoolean","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getObject ( k : K ) {  this [ k ] . asObject ( ) NL }","func_name":"getObject","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getArray ( k : K ) {  this [ k ] . asArray ( ) NL }","func_name":"getArray","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getString ( k : K ) {  this [ k ] . asString ( ) NL }","func_name":"getString","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func stringify ( os : JsonSerializer ) : Unit {   var sep = false NL os . append ( [ ) NL for ( v in this ) {  if ( sep ) {  os . append ( ,  ) NL } else {  sep = true NL } NL v . stringify ( os ) NL } NL os . append ( ] ) NL }","func_name":"stringify","docstring":"/* stringify */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getNull ( i : Int64 ) {  this [ i ] . asNull ( ) NL }","func_name":"getNull","docstring":"/* extend `getXXX()` for JsonObject */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getNumber ( i : Int64 ) {  this [ i ] . asNumber ( ) NL }","func_name":"getNumber","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getBoolean ( i : Int64 ) {  this [ i ] . asBoolean ( ) NL }","func_name":"getBoolean","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getObject ( i : Int64 ) {  this [ i ] . asObject ( ) NL }","func_name":"getObject","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getArray ( i : Int64 ) {  this [ i ] . asArray ( ) NL }","func_name":"getArray","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func getString ( i : Int64 ) {  this [ i ] . asString ( ) NL }","func_name":"getString","docstring":""}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func stringify ( os : JsonSerializer ) : Unit {  os . append ( if ( this ) {  true NL } else {  false NL } ) NL }","func_name":"stringify","docstring":"/* stringify */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"foreign func dtoa ( number : JsonNumber ) : CString","func_name":"dtoa","docstring":"/* c ffi, double to string */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func stringify ( os : JsonSerializer ) : Unit {  if ( this . isNaN ( ) || this . isInf ( ) ) {  os . append ( null ) NL } NL unsafe {   let str = dtoa ( this ) NL if ( str . isNull ( ) ) {  throw Exception ( ) NL } NL os . append ( str . toString ( ) ) NL str . free ( ) NL } NL }","func_name":"stringify","docstring":"/* stringify */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func parse ( str : String , lazy ! : Bool = false ) {   let src = JsonStringReader ( str ) NL  let ret = src . readJson ( ) NL if ( ! lazy && next_ ( src ) != \\0 ) {  throw Exception ( Bad JSON format string. ) NL } NL ret NL }","func_name":"parse","docstring":"/*\n * parse JSON from string, whitespace will be skipped.\n * throws Exception if parse failed or `lazy` is false (default) and any non-whitespace left.\n */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func load ( path : String , lazy ! : Bool = false ) {  parse ( String . fromUtf8 ( File . readFrom ( path ) ) , lazy : lazy ) NL }","func_name":"load","docstring":"/*\n * `parse` JSON from text file,\n * throws Exception if file read failed or `parse` failed.\n */"}
{"repo":"json","file":"json.cj","path":"json/src/json/json.cj","code_tokens":"public func dump ( path : String , val : Json , openOption ! : OpenOption = CreateOrTruncate ( false ) ) {  File . writeTo ( path , val . stringify ( ) . toUtf8Array ( ) , openOption : openOption ) NL }","func_name":"dump","docstring":"/*\n * dump JSON strigify to file with `CreateOrTruncate` open option.\n * throws Exception if dump failed.\n */"}
{"repo":"json","file":"jsonSerializer.cj","path":"json/src/json/jsonSerializer.cj","code_tokens":"func append ( s : String ) : Any","func_name":"append","docstring":""}
{"repo":"json","file":"jsonSerializer.cj","path":"json/src/json/jsonSerializer.cj","code_tokens":"func append ( c : Char ) : Any","func_name":"append","docstring":""}
{"repo":"json","file":"jsonSerializer.cj","path":"json/src/json/jsonSerializer.cj","code_tokens":"public func append ( o : Json ) {  o . stringify ( this ) NL this NL }","func_name":"append","docstring":""}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func read ( ) : Char","func_name":"read","docstring":"/**\n     * @return '\\0' if reader is empty.\n     * @return the stored character if it exists, and then removes it.\n     * @return the character at current position, and move to the next.\n     */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func store ( c : Char ) : Unit","func_name":"store","docstring":"/**\n     * store a read char.\n     * scanning unbounded `number` will read one more character, used to store it.\n     */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func readJson ( ) : Json {  json_ ( this ) NL }","func_name":"readJson","docstring":"/* read a Json from the reader */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func readObject ( ) {  readJson ( ) . asObject ( ) NL }","func_name":"readObject","docstring":"/* read a Json object from the reader */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func readArray ( ) {  readJson ( ) . asArray ( ) NL }","func_name":"readArray","docstring":"/* read a Json array from the reader */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func readString ( ) {  readJson ( ) . asString ( ) NL }","func_name":"readString","docstring":"/* read a Json string from the reader */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func readNumber ( ) {  readJson ( ) . asNumber ( ) NL }","func_name":"readNumber","docstring":"/* read a Json number from the reader */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func readBoolean ( ) {  readJson ( ) . asBoolean ( ) NL }","func_name":"readBoolean","docstring":"/* read a Json boolean from the reader */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func readNull ( ) {  readJson ( ) . asNull ( ) NL }","func_name":"readNull","docstring":"/* read a Json null from the reader */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"public func read ( ) {  if ( let Some ( chr ) = stored ) {  stored = None NL return chr NL } NL iter . next ( ) ?? \\0 NL }","func_name":"read","docstring":"/**\n     * @return '\\0' if reader is empty.\n     * @return the stored character if it exists, and then removes it.\n     * @return the character at current position, and move to the next.\n     */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"public func store ( chr : Char ) {  stored = chr NL }","func_name":"store","docstring":"/**\n     * store a read char.\n     * scanning unbounded `number` will read one more character, used to store it.\n     */"}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func string_ < T > ( rd : T ) : JsonString where T <: JsonReader {   let sb = StringBuilder ( ) NL while ( true ) {  match ( rd . read ( ) ) { case \\\" => break NL case \\\\ => match ( rd . read ( ) ) { case \\\" => sb . append ( \\\" ) NL case \\\\ => sb . append ( \\\\ ) NL case b => sb . append ( \\b ) NL case f => sb . append ( \\f ) NL case t => sb . append ( \\t ) NL case n => sb . append ( \\n ) NL case r => sb . append ( \\r ) NL case chr => throw Exception ( Unsupported escape pair `\\\\${chr}`. ) NL } NL case \\0 => throw Exception ( ) NL case chr => sb . append ( chr ) NL } NL } NL sb . toString ( ) NL }","func_name":"string_","docstring":""}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func object_ < T > ( rd : T ) : JsonObject where T <: JsonReader {   let ret = JsonObject ( ) NL match ( next_ ( rd ) ) { case } => return ret NL case \\\" => ( ) NL case _ => throw Exception ( ) NL } NL while ( true ) {  ret [ string_ ( rd ) ] = if ( next_ ( rd ) == : ) {  json_ ( rd ) NL } else {  throw Exception ( ) NL } NL match ( next_ ( rd ) ) { case , => if ( next_ ( rd ) != \\\" ) {  throw Exception ( ) NL } NL case } => break NL case c => throw Exception ( Invaild `${c}` in JSON object. ) NL } NL } NL ret NL }","func_name":"object_","docstring":""}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func array_ < T > ( rd : T ) : JsonArray where T <: JsonReader {   let ret = JsonArray ( ) NL  var chr = next_ ( rd ) NL if ( chr == ] ) {  return ret NL } NL rd . store ( chr ) NL while ( true ) {  ret . append ( json_ ( rd ) ) NL match ( next_ ( rd ) ) { case , => continue NL case ] => break NL case c => throw Exception ( Invaild `${c}` in JSON object. ) NL } NL } NL ret NL }","func_name":"array_","docstring":""}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func number_ < T > ( rd : T ) : JsonNumber where T <: JsonReader {   let sb = StringBuilder ( ) . append ( rd . read ( ) ) NL  var chr : Char NL while ( true ) {  chr = rd . read ( ) NL match ( chr ) { case 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | . | + | - | e | E => sb . append ( chr ) NL case _ => rd . store ( chr ) NL break NL } NL } NL sb . toString ( ) . parseToNumber ( ) NL }","func_name":"number_","docstring":""}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func json_ < T > ( rd : T ) : Json where T <: JsonReader {  match ( next_ ( rd ) ) { case \\\" => string_ ( rd ) NL case { => object_ ( rd ) NL case [ => array_ ( rd ) NL case n =>  let read = rd . read NL if ( read ( ) == u && read ( ) == l && read ( ) == l ) {  null NL } else {  throw Exception ( ) NL } NL case t =>  let read = rd . read NL if ( read ( ) == r && read ( ) == u && read ( ) == e ) {  true NL } else {  throw Exception ( ) NL } NL case f =>  let read = rd . read NL if ( read ( ) == a && read ( ) == l && read ( ) == s && read ( ) == e ) {  false NL } else {  throw Exception ( ) NL } NL case c => rd . store ( c ) NL number_ ( rd ) NL } NL }","func_name":"json_","docstring":""}
{"repo":"json","file":"jsonReader.cj","path":"json/src/json/jsonReader.cj","code_tokens":"func next_ < T > ( rd : T ) : Char where T <: JsonReader {  while ( true ) {  match ( rd . read ( ) ) { case   | \\t | \\n | \\r => continue NL case chr => return chr NL } NL } NL \\0 NL }","func_name":"next_","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"func trimRight ( c : Char ) {   var left = this . size NL while ( left > 0 && this [ left - 1 ] == c ) {  left -- NL } NL if ( left == this . size ) {  return this NL } NL this [ 0 .. left ] NL }","func_name":"trimRight","docstring":"/*\n     * Remove all the `c` at the end of the original string\n     * @return New converted string\n     */"}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"func escape ( os : JsonSerializer ) {  for ( c in this ) {  match ( c ) { case \\\" => os . append ( \\\\\\\" ) NL case \\\\ => os . append ( \\\\\\\\ ) NL case \\b => os . append ( \\\\b ) NL case \\f => os . append ( \\\\f ) NL case \\t => os . append ( \\\\t ) NL case \\n => os . append ( \\\\n ) NL case \\r => os . append ( \\\\r ) NL case _ => os . append ( c ) NL } NL } NL os NL }","func_name":"escape","docstring":"/* Escaping special characters to JsonSerializer */"}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"func parseToNumber ( ) {  this . toFloat64 ( ) . getOrThrow ( ) NL }","func_name":"parseToNumber","docstring":"/* convert to number */"}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"func toInt64 ( ) : ? Int64","func_name":"toInt64","docstring":"/* exceeding `Int64.max`, a negative number will be returned. */"}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"func toFloat64 ( ) : ? Float64","func_name":"toFloat64","docstring":"/* if there is no '.' in string, `None` is the return value of `parseFloat64`. (cangjie 0.31.4) */"}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"@ overflowWrapping   public func toInt64 ( ) : ? Int64 {  if ( let Some ( v ) = Int64 . tryParse ( this ) ) {  return v NL } NL if ( let Some ( v ) = UInt64 . tryParse ( this ) ) {  return Int64 ( v ) NL } NL None NL }","func_name":"toInt64","docstring":"/* exceeding `Int64.max`, a negative number will be returned. */"}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"@ overflowWrapping   public func toFloat64 ( ) : ? Float64 {  if ( this . contains ( . ) ) {  return Float64 . tryParse ( this ) NL } NL if ( let Some ( v ) = this . toInt64 ( ) ) {  return Float64 ( v ) NL } NL None NL }","func_name":"toFloat64","docstring":"/* if there is no '.' in string, `None` is the return value of `parseFloat64`. (cangjie 0.31.4) */"}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"static public func isSafeNumber ( v : Int64 ) {  v <= MAX_SAFE_INTEGER && v > = MIN_SAFE_INTEGER NL }","func_name":"isSafeNumber","docstring":"/* @return whether `v` is a safe JSON number. */"}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"static public func integer ( v : Int64 ) {  Float64 ( v ) NL }","func_name":"integer","docstring":"/* @return JSON number converted from integer */"}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  Float64 ( this ) NL }","func_name":"toJson","docstring":""}
{"repo":"json","file":"extend.cj","path":"json/src/json/extend.cj","code_tokens":"public func toJson ( ) : Json {  this . toString ( ) NL }","func_name":"toJson","docstring":""}
