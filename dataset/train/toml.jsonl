{"repo":"toml","file":"toml_tz.cj","path":"toml/src/decoders/toml_tz.cj","code_tokens":"public func tzname ( ) {  return UTC + rawOffset NL }","func_name":"tzname","docstring":"/**\n     * The Function is tzname\n     *\n     *\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"toml_tz.cj","path":"toml/src/decoders/toml_tz.cj","code_tokens":"public func utcOffset ( ) {  return ( Duration . hour ( hour ) + Duration . minute ( minute ) * sign ) NL }","func_name":"utcOffset","docstring":"/**\n     * The Function is utcOffset\n     *\n     *\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"toml_tz.cj","path":"toml/src/decoders/toml_tz.cj","code_tokens":"public func dst ( ) {  return Duration . hour ( 0 ) + Duration . minute ( 0 ) + Duration . second ( 0 ) + Duration . microsecond ( 0 ) + Duration . nanosecond ( 0 ) NL }","func_name":"dst","docstring":"/**\n     * The Function is dst\n     *\n     *\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"toml_tz.cj","path":"toml/src/decoders/toml_tz.cj","code_tokens":"public func location ( ) : Location {  Location ( tzname ( ) , utcOffset ( ) ) NL }","func_name":"location","docstring":"/**\n     * The Function is location\n     *\n     *\n     * @return Type of Location\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"public func load ( pn : String ) {   let arr = pn . split ( / ) NL if ( ! arr [ arr . size - 1 ] . contains ( . ) || arr [ arr . size - 1 ] . size == 0 ) {  throw IllegalArgumentException ( The format of the file is not supported. ) NL } NL load ( File . openRead ( pn ) ) NL }","func_name":"load","docstring":"/**\n     * The Function is load\n     *\n     * @param pn of String, file path\n     *\n     * @since 0.28.4\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"public func load ( file : File ) {  match ( data ) { case Some ( v ) => throw Exception ( Can't use string decode and stream decode at the same time ) NL case None => ( ) NL } NL mode = DecodeMode . STREAM NL if ( ! file . canRead ( ) ) {  throw Exception ( Open file failed ) NL } NL if ( ! file . info . path . fileName . getOrThrow ( ) . endsWith ( .toml ) ) {  throw IllegalArgumentException ( The format of the file is not supported. ) NL } NL stream = Some ( file ) NL }","func_name":"load","docstring":"/**\n     * The Function is load\n     *\n     * @param pn of String, file path\n     *\n     * @since 0.28.4\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"public func decode ( ) : JsonObject {   let implicitGroups : ArrayList < String > = ArrayList < String > ( ) NL  let original : String = readData ( ) NL  var sl : Array < Char > = original . toCharArray ( ) NL  var openArr : Int64 = 0 NL  var openString : Bool = false NL  var openStrChar : Char = 0 NL  var multilineStr : Bool = false NL  var arrayOfTables : Bool = false NL  var beginLine : Bool = true NL  var keyGroup : Bool = false NL  var dottedKey : Bool = false NL  var keyName : Int64 = 0 NL  var key : String =  NL  var prevKey : String =  NL  var lineNo : Int64 = 1 NL  let jsons : JsonObject = JsonObject ( ) NL  var subjo : JsonValue = jsons NL  let nilJson : JsonValue = JsonObject ( ) NL for ( i in 0 .. sl . size ) {   let item : Char = sl [ i ] NL if ( item == Symbols . CR [ 0 ] && sl [ i + 1 ] == Symbols . LF [ 0 ] ) {  sl [ i ] = Char ( 0x20 ) NL continue NL } NL if ( 0 != keyName ) {  key += item NL if ( item == \\n ) {  throw TomlDecodeErrorException ( Key name found without value. Reach end of line. ) NL } NL if ( openString ) {  if ( item == openStrChar ) {   var oddBackSlash : Bool = false NL  var k : Int64 = 1 NL if ( ! oddBackSlash ) {  keyName = 2 NL openString = false NL openStrChar = 0 NL } NL } NL continue NL } else if ( keyName == 1 ) {  if ( item . isAsciiWhiteSpace ( ) ) {  keyName = 2 NL continue NL } else if ( item == Symbols . DOT [ 0 ] ) {  dottedKey = true NL continue NL } else if ( ( item . isAsciiLetter ( ) || item . isAsciiNumber ( ) ) || item == _ || item == - ) {  continue NL } NL } else if ( keyName == 2 ) {  if ( item . isAsciiWhiteSpace ( ) ) {  continue NL } NL } NL if ( item == = ) {  keyName = 0 NL prevKey = key [ .. key . size - 1 ] . trimRight ( ) NL key =  NL dottedKey = false NL } else {  throw TomlDecodeErrorException ( Found invalid character in key name: ' + item + ' Try quoting the key name. ) NL } NL } NL if ( item == ' && openStrChar != \\\" ) {   var k : Int64 = 1 NL try {  while ( sl [ i - k ] == Symbols . SINGLE_QUOTE [ 0 ] ) {  k += 1 NL if ( k == 3 ) {  break NL } NL } NL } catch ( e : IndexOutOfBoundsException ) {  } NL if ( k == 3 ) {  multilineStr = ! multilineStr NL openString = multilineStr NL } else {  openString = ! openString NL } NL if ( openString ) {  openStrChar = Symbols . SINGLE_QUOTE [ 0 ] NL } else {  openStrChar = 0 NL } NL } NL if ( item == \\\" && openStrChar != ' ) {   var oddBackSlash : Bool = false NL  var k : Int64 = 1 NL  var tripQuote : Bool = false NL try {  while ( sl [ i - k ] == Symbols . QUOTE [ 0 ] ) {  k += 1 NL if ( k == 3 ) {  tripQuote = true NL break NL } NL } NL if ( k == 1 || ( k == 3 && tripQuote ) ) {  while ( sl [ i - k ] == Symbols . BACK_SLASH [ 0 ] ) {  oddBackSlash = ! oddBackSlash NL k += 1 NL } NL } NL } catch ( e : IndexOutOfBoundsException ) {  } NL if ( ! oddBackSlash ) {  if ( tripQuote ) {  multilineStr = ! multilineStr NL openString = multilineStr NL } else {  openString = ! openString NL } NL } NL if ( openString ) {  openStrChar = Symbols . QUOTE [ 0 ] NL } else {  openStrChar = 0 NL } NL } NL if ( item == # && ( ! openString && ! keyGroup && ! arrayOfTables ) ) {   var j : Int64 = i NL  var comment : String =  NL try {  while ( sl [ j ] != \\n ) {  comment += sl [ j ] NL sl [ j ] = Symbols . SPACE [ 0 ] NL j += 1 NL } NL } catch ( e : IndexOutOfBoundsException ) {  break NL } NL if ( openArr == 0 ) {  } NL } NL if ( item == Symbols . LEFT_SQUARE_BRACKET [ 0 ] && ( ! openString && ! keyGroup && ! arrayOfTables ) ) {  if ( beginLine ) {  if ( sl . size > ( i + 1 ) && ( sl [ i + 1 ] ) == Symbols . LEFT_SQUARE_BRACKET [ 0 ] ) {  arrayOfTables = true NL } else {  keyGroup = true NL } NL } else {  openArr += 1 NL } NL } NL if ( item == Symbols . RIGHT_SQUARE_BRACKET [ 0 ] && ! openString ) {  if ( keyGroup ) {  keyGroup = false NL } NL } NL if ( item == Symbols . LF [ 0 ] ) {  if ( openString || multilineStr ) {  if ( ! multilineStr ) {  throw TomlDecodeErrorException ( Unbalanced quotes ) NL } NL if ( ( sl [ i - 1 ] == Symbols . SINGLE_QUOTE [ 0 ] || sl [ i - 1 ] == Symbols . QUOTE [ 0 ] ) && ( sl [ i - 2 ] == sl [ i - 1 ] ) ) {  sl [ i ] == sl [ i - 1 ] NL if ( sl [ i - 3 ] == sl [ i - 1 ] ) {  sl [ i - 3 ] = Symbols . SPACE [ 0 ] NL } NL } NL } else {  beginLine = true NL } NL lineNo += 1 NL } else if ( beginLine && sl [ i ] !=   && sl [ i ] != \\t ) {  beginLine = false NL if ( ! keyGroup && ! arrayOfTables ) {  keyName = 1 NL key += item NL } NL } NL } NL  var s : String = joinChar ( sl ) NL  var ss : Array < String > = s . split ( Symbols . LF ) NL  var multiKey : Bool = false NL  var multilineStrStr : String =  NL  var multiBackSlash : Bool = false NL  var pos : Int64 = 0 NL for ( idx in 0 .. ss . size ) {   var line : String = ss [ idx ] . trim ( ) NL if ( line . isEmpty ( ) ) {  continue NL } NL if ( idx > 0 ) {  pos += ss [ idx - 1 ] . size + 1 NL } NL if ( multilineStrStr . size == 0 || multiBackSlash || ( multilineStrStr . indexOf ( Symbols . LF ) ?? - 1 ) == - 1 ) {  line = line . trim ( ) NL } NL if ( line . equals (  ) && ( ! multiKey || multiBackSlash ) ) {  continue NL } NL if ( line [ 0 ] == [ ) {  arrayOfTables = false NL if ( line . size == 1 ) {  throw TomlDecodeErrorException ( Opening key group bracket on line by itself ) NL } NL  var splitStr : String =  NL if ( line [ 1 ] == Symbols . LEFT_SQUARE_BRACKET [ 0 ] ) {  arrayOfTables = true NL } else {  line = line . slice ( 1 , line . size - 1 ) NL splitStr = Symbols . RIGHT_SQUARE_BRACKET NL } NL  var i : Int64 = 1 NL  var quotesplits : ArrayList < String > = ArrayList < String > ( ) NL  var quoted : Bool = false NL  let lineSplited : Array < String > = line . split ( splitStr ) NL if ( lineSplited . size < i + 1 || lineSplited [ lineSplited . size - 1 ] . trim ( ) !=  ) {  throw TomlDecodeErrorException ( Key group not on a line by itself. ) NL } NL  let groups : ArrayList < String > = ArrayList < String > ( String . join ( lineSplited . slice ( 0 , lineSplited . size - 1 ) , delimiter : splitStr ) . split ( . ) ) NL for ( index in groups . size - 1 ..= 0 : - 1 ) {  if ( groups [ index ] . equals (  ) ) {  groups . remove ( index ) NL } NL } NL i = 0 NL while ( i < groups . size ) {  groups . set ( i , groups [ i ] . trim ( ) ) NL if ( groups [ i ] . size > 0 && ( groups [ i ] [ 0 ] == Symbols . QUOTE [ 0 ] || groups [ i ] [ 0 ] == Symbols . SINGLE_QUOTE [ 0 ] ) ) {  } else {  if ( ! match ( groupNameRe . matches ( groups [ i ] ) ) { case None => false NL case Some ( x ) => true NL } ) {  throw TomlDecodeErrorException ( Invalid group name ) NL } NL } NL i += 1 NL } NL for ( l in 0 .. groups . size ) {   let group : String = groups [ l ] NL if (  . equals ( group ) ) {  throw TomlDecodeErrorException ( Can't have a keygroup with an empty ) NL } NL try {  subjo . asObject ( ) . get ( group ) NL if ( l == groups . size - 1 ) {  if ( arrayListContains ( implicitGroups , group ) ) {  implicitGroups . removeIf ( { item => item == group NL } ) NL } NL } NL } catch ( e : Exception ) {  if ( e . toString ( ) . contains ( JsonException: ) ) {  if ( i != groups . size - 1 ) {  implicitGroups . append ( group ) NL } NL subjo . asObject ( ) . put ( group , nilJson ) NL if ( ( i == groups . size - 1 ) && arrayOfTables ) {  } NL } else {  throw Exception ( ${e.toString()} ) NL } NL } NL subjo = subjo . asObject ( ) . get ( group ) . getOrThrow ( ) NL } NL } else if ( line . contains ( = ) ) {  loadLine ( subjo . asObject ( ) , line , multilineStrStr , multiBackSlash ) NL } NL } NL return jsons NL }","func_name":"decode","docstring":"/**\n     * The Function is decode\n     *\n     * @since 0.28.4\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func loadLineMultilineStr ( pstr : String ) : ( Int64 , Int64 ) {   var p = pstr NL  var poffset = 0 NL if ( p . size < 3 ) {  return ( - 1 , poffset ) NL } NL if ( p [ 0 ] != \\\" && p [ 0 ] != ' ) {  return ( - 1 , poffset ) NL } NL if ( p [ 1 ] != p [ 0 ] || p [ 2 ] != p [ 0 ] ) {  return ( - 1 , poffset ) NL } NL if ( p . size > 5 && p [ p . size - 1 ] == p [ 0 ] && p [ p . size - 2 ] == p [ 0 ] && p [ p . size - 3 ] == p [ 0 ] ) {  return ( - 1 , poffset ) NL } NL return ( p . size - 1 , poffset ) NL }","func_name":"loadLineMultilineStr","docstring":"/*\n     * The Function is loadLineMultilineStr\n     *\n     * @param pstr of String)\n     * @param String) of (Int64,Int64\n     *\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func arrayListContains < T > ( al : ArrayList < T > , element : T ) : Bool where T <: Equatable < T > {  for ( item in al ) {  if ( item == element ) {  return true NL } NL } NL return false NL }","func_name":"arrayListContains","docstring":"/*\n     * The Function is arrayListContains<T>\n     *\n     * @param al of ArrayList<T>\n     * @param element of T\n     *\n     * @return Type of Bool where T <: Equatable<T>\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func joinChar ( chars : Array < Char > ) : String {   var result : String =  NL for ( c in chars ) {  result += c . toString ( ) NL } NL result NL }","func_name":"joinChar","docstring":"/*\n     * The Function is joinChar\n     *\n     * @param chars of Array<Char>\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func loadValue ( vs : String ) : String {   var v : String = vs NL if ( v . isEmpty ( ) ) {  throw Exception ( ) NL } NL if ( v . equals ( true ) ) {  return true . toString ( ) NL } else if ( v . toLower ( ) == true ) {  throw Exception ( ) NL } else if ( v . equals ( false ) ) {  return false . toString ( ) NL } else if ( v . toLower ( ) == false ) {  throw Exception ( ) NL } else if ( v [ 0 ] == \\\" || v [ 0 ] == ' ) {   let quotechar = v [ 0 ] NL  var testv = v [ 1 .. ] . split ( quotechar ) NL  var triplequolte = false NL  var triplequoltecount = 0 NL if ( testv . size > 1 && testv [ 0 ] ==  && testv [ 1 ] ==  ) {  testv = if ( testv . size > 2 ) {  testv [ 2 .. ] NL } else {  Array < String > ( ) NL } NL triplequolte = true NL } NL  var closed = false NL for ( tv in testv ) {  if ( tv ==  ) {  if ( triplequolte ) {  triplequoltecount += 1 NL } else {  closed = true NL } NL } else {   var oddbackslash = false NL try {   var i = tv . size - 1 NL  var j = tv [ i ] NL while ( j == \\\\ ) {  oddbackslash = ! oddbackslash NL i -- NL j = tv [ i ] NL } NL } catch ( e : Exception ) {  continue NL } NL if ( ! oddbackslash ) {  if ( closed ) {  throw Exception ( ) NL } else {  if ( ! triplequolte || triplequoltecount > 1 ) {  closed = true NL } else {  triplequoltecount = 0 NL } NL } NL } NL } NL } NL if ( quotechar == \\\" ) {   var escapeseqs = if ( v . contains ( \\\\ ) ) {  v . split ( \\\\ ) [ 1 .. ] NL } else {  Array < String > ( ) NL } NL  var backslash = false NL for ( i in escapeseqs ) {  if ( i ==  ) {  backslash = ! backslash NL } else {  if ( ! getInchars ( i [ 0 ] ) && i [ 0 ] != u && i [ 0 ] != U && ! backslash ) {  throw Exception ( ) NL } NL } NL } NL for ( prefix in [ \\\\u , \\\\U ] ) {  if ( v . contains ( prefix ) ) {   let hexbytes = v . split ( prefix ) NL v = load_unicode_escapes ( hexbytes [ 0 ] , hexbytes [ 1 .. ] , prefix ) NL } NL } NL v = unescape ( v ) NL } NL if ( v . size > 1 && v [ 1 ] == quotechar && ( v . size < 3 || v [ 1 ] == v [ 2 ] ) ) {  v = v [ 2 .. v . size - 2 ] NL } NL return v [ 1 .. v . size - 1 ] NL } else if ( v [ 0 ] == [ ) {  throw Exception (  not support1 ) NL } else if ( v [ 0 ] == { ) {   let inlineObj = JsonObject ( ) NL loadInlineObject ( v , inlineObj ) NL return inlineObj . toString ( ) NL } else {  return v NL } NL }","func_name":"loadValue","docstring":"/*\n     * The Function is loadValue\n     *\n     * @param vs of String\n     * @param strictlyValid of Bool, and the Default value is true\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func loadInlineObject ( str : String , obj : JsonObject , multiBackSlash ! : Bool = false ) {   var candidate_groups = ArrayList < String > ( str [ 1 .. str . size - 1 ] . split ( , ) ) NL  var groups = ArrayList < String > ( ) NL if ( candidate_groups . size == 1 && candidate_groups [ 0 ] . trim ( ) . isEmpty ( ) ) {  throw Exception ( not Support3 ) NL } NL while ( candidate_groups . size > 0 ) {   var candidate_group : String = candidate_groups [ 0 ] NL candidate_groups . remove ( 0 ) NL  let val = candidate_group . split ( = , 2 ) NL  let value = val [ 1 ] . trim ( ) NL if ( value [ 0 ] == value [ value . size - 1 ] && ( value [ 0 ] == ' || value [ 0 ] == \\\" ) || -0123456789 . contains ( value [ 0 ] ) || ( value == true || value == false ) || ( value [ 0 ] == [ && value [ value . size - 1 ] == ] ) || ( value [ 0 ] == { && value [ value . size - 1 ] == } ) ) {  groups . append ( candidate_group ) NL } else {  throw Exception ( not Support4 ) NL } NL } NL for ( group in groups ) {  match ( loadLine ( obj , group ,  , multiBackSlash ) ) { case Some ( v ) => break NL case None => ( ) NL } NL } NL }","func_name":"loadInlineObject","docstring":"/*\n     * The Function is loadInlineObject\n     *\n     * @param str of String\n     * @param obj of JsonObject\n     * @param multikey of Bool, and the Default value is false\n     * @param multiBackSlash of Bool, and the Default value is false\n     *\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func load_unicode_escapes ( v : String , hexbytes : Array < String > , prefix : String ) : String {  return v NL }","func_name":"load_unicode_escapes","docstring":"/*\n     * The Function is load_unicode_escapes\n     *\n     * @param v of String\n     * @param hexbytes of Array<String>\n     * @param prefix of String\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func getInchars ( c : Char ) : Bool {  for ( m in mypsbs ) {  if ( c == m ) {  return true NL } NL } NL return false NL }","func_name":"getInchars","docstring":"/*\n     * The Function is getInchars\n     *\n     * @param c of Char\n     *\n     * @return Type of Bool\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func unescape ( vs : String ) : String {   var v = vs NL  var i : Int64 = 0 NL  var backslash = false NL while ( i < v . size ) {  if ( backslash ) {  backslash = false NL if ( getInchars ( v [ i ] ) ) {  v = v [ 0 .. i - 1 ] + v [ i ] + v [ i + 1 .. ] NL } else {  throw Exception ( ) NL } NL continue NL } else if ( v [ i ] == \\\\ ) {  backslash = true NL } NL i ++ NL } NL return v NL }","func_name":"unescape","docstring":"/*\n     * The Function is unescape\n     *\n     * @param vs of String\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func readData ( ) : String {   let data : String = match ( mode ) { case STREAM => { =>  let s : InputStream = match ( stream ) { case Some ( st : InputStream ) => st NL case _ => throw Exception ( The stream must be initialize ) NL } NL  let res : StringBuilder = StringBuilder ( ) NL  var readLength : Int64 = 0 NL  var buffer : Array < Byte > = Array < Byte > ( DEFAULT_BUFFER_SIZE , item : 0 ) NL do {  readLength = s . read ( buffer ) NL if ( 0 != readLength ) {  res . append ( String . fromUtf8 ( buffer [ 0 .. readLength ] ) ) NL } NL } while ( readLength == DEFAULT_BUFFER_SIZE ) NL res . toString ( ) NL } ( ) NL case _ => throw Exception ( Must specify the data source first ) NL } NL data NL }","func_name":"readData","docstring":"/*\n     * The Function is readData\n     *\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func getSplitOnQuotes ( line : String ) : Collection < String > {   var doubuleQuoteArr : Array < String > = line . split ( \\\" ) NL  var quoted : Bool = false NL  let quotesplits = ArrayList < String > ( ) NL if ( doubuleQuoteArr . size > 1 && doubuleQuoteArr [ 0 ] . contains ( ' ) ) {   var singleQuotesArr : ArrayList < String > = ArrayList < String > ( doubuleQuoteArr [ 0 ] . split ( ' ) ) NL doubuleQuoteArr = doubuleQuoteArr . slice ( 1 , doubuleQuoteArr . size - 1 ) NL while ( singleQuotesArr . size % 2 == 0 && doubuleQuoteArr . size > 0 ) {  singleQuotesArr [ singleQuotesArr . size - 1 ] = #\"\"${doubuleQuoteArr[0]}\"# + singleQuotesArr [ singleQuotesArr . size - 1 ] NL if ( doubuleQuoteArr . size > 1 ) {  doubuleQuoteArr = doubuleQuoteArr . slice ( 1 , doubuleQuoteArr . size - 1 ) NL } else {  doubuleQuoteArr = Array < String > ( ) NL } NL } NL quotesplits . appendAll ( singleQuotesArr ) NL } NL for ( item in doubuleQuoteArr ) {  if ( quoted ) {  quotesplits . append ( item ) NL } else {  quotesplits . appendAll ( item . split ( ' ) ) NL quoted = ! quoted NL } NL } NL return quotesplits NL }","func_name":"getSplitOnQuotes","docstring":"/*\n     * The Function is getSplitOnQuotes\n     *\n     * @param line of String\n     *\n     * @return Type of Collection<String>\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"private func strictlyValidNum ( str : String ) : Bool {   let n = str . trim ( ) NL  let syb = [ . , o , b , x ] NL return match { case n . isEmpty ( ) => false NL case n [ 0 ] == _ => false NL case n [ n . size - 1 ] == _ => false NL case n . contains ( _. ) || n . contains ( ._ ) => false NL case n . size == 1 => true NL case n [ 0 ] == 0 && syb . contains ( n [ 1 ] ) => false NL case n [ 0 ] == + || n [ 0 ] == - => return if ( n . size > 2 && n [ 1 ] == 0 && n [ 2 ] != . ) {  false NL } else {  true NL } NL case n . contains ( __ ) => false NL case _ => true NL } NL }","func_name":"strictlyValidNum","docstring":"/*\n     * The Function is strictlyValidNum\n     *\n     * @param str of String\n     *\n     * @return Type of Bool\n     * @since 0.29.3\n     */"}
{"repo":"toml","file":"decoder.cj","path":"toml/src/decoders/decoder.cj","code_tokens":"func loadLine ( jvconst : JsonObject , line : String , mls : String , mbs : Bool ) : Option < ( String , String , Bool ) > {   var multiBackSlash = mbs NL  var multikey = mls NL  var jv = jvconst NL  var i = 1 NL  var quoteSplits = getSplitOnQuotes ( line ) NL  var quoted = false NL for ( quoteSplit in quoteSplits ) {  if ( ! quoted && quoteSplit . contains ( = ) ) {  break NL } NL i += quoteSplit . count ( = ) NL quoted = ! quoted NL } NL  var pair = line . split ( = , i + 1 ) NL  let strictlyValid : Bool = strictlyValidNum ( pair [ pair . size - 1 ] ) NL match ( numberWithUnderScores . matcher ( pair [ pair . size - 1 ] ) . fullMatch ( ) ) { case Some ( v ) => pair [ pair . size - 1 ] = pair [ pair . size - 1 ] . replace ( _ ,  ) NL case None => ( ) NL } NL  var pairLast : String = pair [ pair . size - 1 ] NL for ( index in 0 .. pair . size ) {  pair [ index ] = pair [ index ] . trim ( ) NL } NL if ( pair [ 0 ] . contains ( . ) ) {   var levels : ArrayList < String > NL if ( pair [ 0 ] . contains ( \\\" ) || pair [ 0 ] . contains ( ' ) ) {  quoteSplits = getSplitOnQuotes ( pair [ 0 ] ) NL quoted = false NL levels = ArrayList < String > ( ) NL for ( quoteSplit in quoteSplits ) {  if ( quoted ) {  levels . append ( quoteSplit ) NL } else {  for ( arri in quoteSplit . split ( . ) ) {  levels . append ( arri . trim ( ) ) NL } NL } NL quoted = ! quoted NL } NL } else {  levels = ArrayList < String > ( pair [ 0 ] . split ( . ) ) NL } NL while ( levels [ levels . size - 1 ] ==  ) {  levels . remove ( levels . size - 1 ) NL } NL for ( levelIndx in 0 .. levels . size - 2 ) {  if ( ! jv . containsKey ( levels [ levelIndx ] ) ) {  jv . put ( levels [ levelIndx ] , JsonObject ( ) ) NL } NL jv = jv . get ( levels [ levelIndx ] ) . getOrThrow ( ) . asObject ( ) NL } NL pair [ 0 ] = levels [ levels . size - 1 ] . trim ( ) NL } NL  let ( k_tuple , koffset_tuple ) = loadLineMultilineStr ( pair [ 1 ] ) NL  var k = k_tuple NL  var koffset = koffset_tuple NL  var value =  NL  var multiLineStr =  NL if ( k > - 1 ) {  while ( k > - 1 && pair [ 1 ] [ k + koffset ] == \\\\ ) {  multiBackSlash = ! multiBackSlash NL k -= 1 NL } NL if ( multiBackSlash ) {  multiLineStr = pair [ 1 ] [ .. pair [ 1 ] . size - 1 ] NL } NL multikey = pair [ 0 ] NL } else {  value = loadValue ( pair [ 1 ] ) NL } NL if ( multikey . isEmpty ( ) ) {  jvconst . put ( pair [ 0 ] , JsonString ( value . replace ( \\\\ ,  ) ) ) NL return None NL } else {  return Some ( ( multikey , multiLineStr , multiBackSlash ) ) NL } NL }","func_name":"loadLine","docstring":"/*\n     * The Function is loadLine\n     *\n     * @param jvconst of JsonObject\n     * @param line of String\n     * @param mls of String\n     * @param mbs of Bool)\n     * @param Bool) of Option<(String,String,Bool)>\n     *\n     * @since 0.29.3\n     */"}
