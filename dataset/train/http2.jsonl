{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func size ( ) : Int64 {  return this . name . size + this . value . size + HpkConf . CONST_32_I64 NL }","func_name":"size","docstring":"/**\n     * Size func.\n     *\n     * @return Type of Int64\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func isPseudo ( ) : Bool {  return this . name . size != 0 && this . name [ 0 ] == : NL }","func_name":"isPseudo","docstring":""}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func toString ( ) : String {  return ${name}: ${value} [${sensitive}] NL }","func_name":"toString","docstring":"/**\n     * The Function is toString\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"static public func getIndex ( index : Int64 ) : HeaderField {  if ( index <= 0 || index > staticTable . size ) {  throw HpackStaticTableOutOfBoundsException ( ) NL } NL return staticTable [ index - 1 ] NL }","func_name":"getIndex","docstring":"/**\n     * Get index func.\n     *\n     * @return the HeaderField\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"static public func getIndexName ( index : Int64 ) : String {  if ( index <= 0 || index > staticTable . size ) {  throw HpackStaticTableOutOfBoundsException ( ) NL } NL return staticTable [ index - 1 ] . name NL }","func_name":"getIndexName","docstring":"/* return */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"static public func searchFull ( f : HeaderField ) : ( Int64 , Int64 ) {  match ( hashStaticTable . get ( f . name ) ) { case Some ( v ) => for ( i in 0 .. v . size where f . value == staticTable [ v [ i ] - 1 ] . value ) {  return ( v [ i ] , v [ i ] ) NL } NL return ( v [ 0 ] , - 1 ) NL case None => return ( - 1 , - 1 ) NL } NL }","func_name":"searchFull","docstring":"/**\n     * Search full func.\n     *\n     * @return the Int64 * Int64\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func size ( ) : Int64 {  return this . mySize NL }","func_name":"size","docstring":"/**\n     * Size func.\n     *\n     * @return Type of Int64\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func capacity ( ) : Int64 {  return this . myCapacity NL }","func_name":"capacity","docstring":"/**\n     * Capacity func.\n     *\n     * @return the Int64\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func length ( ) : Int64 {  return if ( this . head < this . tail ) {  this . dynamicArr . size + this . head - this . tail NL } else {  this . head - this . tail NL } NL }","func_name":"length","docstring":"/**\n     * Length func.\n     *\n     * @return the Int64\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func add ( header : HeaderField ) : Unit {   let headerSize : Int64 = header . size ( ) NL if ( headerSize > this . myCapacity ) {  this . clear ( ) NL return NL } NL while ( this . myCapacity - this . mySize < headerSize ) {  this . remove ( ) NL } NL this . dynamicArr [ head ] = header NL match ( this . hashDynamicTable . get ( header . name ) ) { case Some ( v ) => v . append ( head ) NL case None =>  let list = ArrayList < Int64 > ( ) NL list . append ( head ) NL this . hashDynamicTable [ header . name ] = list NL } NL this . head ++ NL this . mySize += headerSize NL if ( this . head == dynamicArr . size ) {  this . head = 0 NL } NL }","func_name":"add","docstring":"/**\n     * Add func.\n     * It is not an error to try to add an entry larger than the maximum size;\n     * Attempting to add an entry larger than the maximum size causes the table to\n     * empty all existing entries and results in an empty table.\n     *\n     * @return the Unit\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func getEntry ( ind : Int64 ) : HeaderField {   let index = ind - 62 NL if ( index < 0 || index > length ( ) || this . length ( ) == 0 ) {  throw HpackDynamicTableOutOfBoundsException ( ) NL } NL  let i : Int64 = this . head - 1 - index NL if ( i < 0 ) {  return dynamicArr [ i + dynamicArr . size ] . getOrThrow ( ) NL } else if ( i > = 0 ) {  return dynamicArr [ i ] . getOrThrow ( ) NL } NL throw NoneValueException ( ) NL }","func_name":"getEntry","docstring":"/**\n     * Get entry func.\n     *\n     * @return the HeaderField\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func getHeader ( ind : Int64 ) : Option < HeaderField > {   let index = ind - 62 NL if ( index < 0 || index > length ( ) || this . length ( ) == 0 ) {  throw HpackDynamicTableOutOfBoundsException ( index ${index} out of bounds for length ${this.length()} ) NL } NL  let i : Int64 = index + this . tail NL if ( i < 0 ) {  return dynamicArr [ i + dynamicArr . size ] NL } else {  return dynamicArr [ i ] NL } NL }","func_name":"getHeader","docstring":"/**\n     * Get header func.\n     *\n     * @return the func\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func remove ( ) : Option < HeaderField > {  match ( this . dynamicArr [ this . tail ] ) { case None => return None NL case Some ( v ) => this . mySize = this . mySize - v . size ( ) NL  let list = this . hashDynamicTable [ v . name ] NL  var index = 0 NL for ( ind in list ) {  if ( ind == index ) {  break NL } NL index ++ NL } NL if ( list . size == 1 ) {  this . hashDynamicTable . remove ( v . name ) NL } else {  list . remove ( index ) NL } NL this . dynamicArr [ this . tail ] = NULL NL this . tail ++ NL if ( this . tail == this . dynamicArr . size ) {  this . tail = 0 NL } NL return v NL } NL }","func_name":"remove","docstring":"/**\n     * Remove func.\n     *\n     * @return the Option<HeaderField>\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func clear ( ) : Unit {  while ( this . tail != this . head ) {  this . dynamicArr [ this . tail ] = NULL NL this . tail ++ NL if ( this . tail == this . dynamicArr . size ) {  this . tail = 0 NL } NL } NL this . head = 0 NL this . tail = 0 NL this . mySize = 0 NL this . hashDynamicTable = HashMap < String , ArrayList < Int64 > > ( ) NL }","func_name":"clear","docstring":"/**\n     * Clear func.\n     *\n     * @return the Unit\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func setCapacity ( s : UInt32 ) : Bool {   let newSize : Int64 = Int64 ( s ) NL if ( newSize == this . myCapacity ) {  return false NL } NL this . myCapacity = newSize NL if ( newSize == 0 ) {  this . clear ( ) NL return false NL } else {  while ( this . mySize > newSize ) {  this . remove ( ) NL } NL } NL  var maxEntries : Int64 = newSize / HpkConf . CONST_32_I64 NL if ( ( newSize - HpkConf . CONST_32_I64 * maxEntries ) != 0 ) {  maxEntries ++ NL } NL if ( this . dynamicArr . size == maxEntries ) {  return false NL } NL  let newFields : Array < Option < HeaderField > > = Array < Option < HeaderField > > ( maxEntries , item : NULL ) NL this . hashDynamicTable . clear ( ) NL  let len : Int64 = this . length ( ) NL  var cur : Int64 = this . tail NL for ( i in 0 .. len ) {  newFields [ i ] = this . dynamicArr [ cur ] NL  let name = this . dynamicArr [ cur ] . getOrThrow ( ) . name NL match ( this . hashDynamicTable . get ( name ) ) { case Some ( v ) => v . append ( i ) NL case None =>  let list = ArrayList < Int64 > ( ) NL list . append ( i ) NL this . hashDynamicTable [ name ] = list NL } NL cur ++ NL if ( cur == this . dynamicArr . size ) {  cur = 0 NL } NL } NL this . tail = 0 NL this . head = this . tail + len NL this . dynamicArr = newFields NL return true NL }","func_name":"setCapacity","docstring":"/* size <= 0xFFFF_FFFF */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func search ( f : HeaderField ) : ( Int64 , Int64 ) {  return this . search ( f . name , f . value ) NL }","func_name":"search","docstring":"/**\n     * Search func.\n     *\n     * @return the Int64*Int64*Bool\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"protected func search ( name : String , value : String ) : ( Int64 , Int64 ) {   let offset = if ( this . tail > this . head ) {  this . dynamicArr . size - this . tail + this . head NL } else {  this . head - this . tail NL } NL match ( this . hashDynamicTable . get ( name ) ) { case Some ( v ) => for ( i in 0 .. v . size ) {   let field = dynamicArr [ v [ i ] ] . getOrThrow ( ) NL if ( value . equals ( field . value ) ) {  return ( offset - v [ i ] + 61 , offset - v [ i ] + 61 ) NL } NL } NL return ( offset - v [ 0 ] + 61 , - 1 ) NL case None => return ( - 1 , - 1 ) NL } NL }","func_name":"search","docstring":"/**\n     * Search func.\n     *\n     * @return the Int64*Int64*Bool\n     */"}
{"repo":"http2","file":"HpackTables.cj","path":"http2/src/hpack/HpackTables.cj","code_tokens":"public func toString ( ) : String {   var str =  NL  var index = 62 NL for ( i in this . head ..= this . tail : - 1 ) {  match ( dynamicArr [ i ] ) { case Some ( v ) => str += ${index}=[${dynamicArr[i].toString()}]\\r\\n NL index ++ NL case None => ( ) NL } NL } NL return str NL }","func_name":"toString","docstring":"/**\n     * The Function is toString\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"Huffman.cj","path":"http2/src/hpack/Huffman.cj","code_tokens":"public func huff_encode_count ( src : Array < UInt8 > ) : Int64 {   var nbits : Int64 = 0 NL for ( i in 0 .. src . size ) {  nbits += Int64 ( HUFF_SYM_TABLE [ Int64 ( src [ i ] ) ] [ 0 ] ) NL } NL return ( nbits + HpkConf . VAILD_BIT ) / HpkConf . BYTE_SIZE NL }","func_name":"huff_encode_count","docstring":"/**\n * Huff encode count func.\n *\n * @return the Int64\n */"}
{"repo":"http2","file":"Huffman.cj","path":"http2/src/hpack/Huffman.cj","code_tokens":"@ overflowWrapping   public func huff_encode ( bufs : ArrayList < UInt8 > , src : Array < UInt8 > ) {   var code : UInt64 = 0 NL  var nbits : Int64 = 0 NL  var index = bufs . size NL  var avail : Int64 = bufs . capacity ( ) - index NL for ( i in 0 .. src . size ) {   let sym = HUFF_SYM_TABLE [ Int64 ( src [ i ] ) ] NL code |= UInt64 ( UInt64 ( sym [ 1 ] ) << ( 32 - nbits ) ) NL nbits += Int64 ( sym [ 0 ] ) NL if ( nbits < 32 ) {  continue NL } NL if ( avail > = 4 ) {   let temp = code >> 32 NL bufs . append ( UInt8 ( ( temp >> 24 ) & 0xff ) ) NL bufs . append ( UInt8 ( ( temp >> 16 ) & 0xff ) ) NL bufs . append ( UInt8 ( ( temp >> 8 ) & 0xff ) ) NL bufs . append ( UInt8 ( temp & 0xff ) ) NL index += 4 NL avail -= 4 NL code <<= UInt64 ( 32 ) NL nbits -= 32 NL continue NL } NL while ( nbits > = 8 ) {  bufs . append ( UInt8 ( code >> 56 ) ) NL index += 1 NL code <<= UInt64 ( 8 ) NL nbits -= 8 NL } NL avail = bufs . capacity ( ) - index NL } NL while ( nbits > = 8 ) {  bufs . append ( UInt8 ( code >> 56 ) ) NL index += 1 NL code <<= UInt64 ( 8 ) NL nbits -= 8 NL } NL if ( nbits != 0 ) {  bufs . append ( UInt8 ( code >> 56 ) | UInt8 ( ( ( 1 << ( 8 - nbits ) ) - 1 ) ) ) NL index += 1 NL } NL }","func_name":"huff_encode","docstring":"/**\n * Huff encode func.\n *\n * @return the func\n */"}
{"repo":"http2","file":"Huffman.cj","path":"http2/src/hpack/Huffman.cj","code_tokens":"public func huff_decode ( src : Array < Byte > , buf : Array < Byte > ) : ( Int64 , ? String ) {   var decoder = HuffDecoder ( ) NL  var index = 0 NL for ( b in 0 .. src . size ) {  match ( decoder . decode ( src [ b ] >> 4 ) ) { case Some ( v ) => buf [ index ] = v NL index ++ NL case None => ( ) NL } NL match ( decoder . decode ( src [ b ] & 0xf ) ) { case Some ( v ) => buf [ index ] = v NL index ++ NL case None => ( ) NL } NL } NL if ( ! decoder . isFinal ( ) ) {  return ( 0 , InvalidHuffmanCode ) NL } NL return ( index , None ) NL }","func_name":"huff_decode","docstring":""}
{"repo":"http2","file":"Huffman.cj","path":"http2/src/hpack/Huffman.cj","code_tokens":"mut func decode ( src : UInt8 ) : ? UInt8 {   let ( next , byte , flags ) = DECODE_TABLE [ this . state ] [ Int64 ( src ) ] NL if ( ( flags & ERROR ) == ERROR ) {  throw InvalidHuffmanCodeException ( ) NL } NL  var ret : ? UInt8 = None NL if ( ( flags & DECODED ) == DECODED ) {  ret = Some ( byte ) NL } NL this . state = next NL this . maybe_eos = ( flags & MAYBE_EOS ) == MAYBE_EOS NL return ret NL }","func_name":"decode","docstring":""}
{"repo":"http2","file":"Huffman.cj","path":"http2/src/hpack/Huffman.cj","code_tokens":"func isFinal ( ) : Bool {  this . state == 0 || this . maybe_eos NL }","func_name":"isFinal","docstring":""}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"static public func newEncoder ( ) : Encoder {  return Encoder ( DynamicTables ( 4096 ) , 4096 ) NL }","func_name":"newEncoder","docstring":"/* init encoder */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"static public func newEncoder ( maxSize : Int64 ) : Encoder {  return Encoder ( DynamicTables ( maxSize ) , maxSize ) NL }","func_name":"newEncoder","docstring":"/* init encoder */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"public func encode ( headers : Collection < HeaderField > ) : Array < UInt8 > {  synchronized ( lock ) {   let myBuffer = ArrayList < UInt8 > ( 256 ) NL if ( this . tableSizeUpdate ) {  this . updateMaxSize ( UInt32 ( this . minSize ) ) NL addTableSize ( UInt32 ( this . minSize ) , myBuffer ) NL this . tableSizeUpdate = true NL } NL for ( header in headers ) {   var ( keyIndex , keyValueIndex ) : ( Int64 , Int64 ) = doReadAndHandleFull ( header ) NL if ( keyValueIndex > 0 ) {  addIndexed ( UInt64 ( keyValueIndex ) , myBuffer ) NL } else {   let canIndex : Bool = canIndex ( header ) NL if ( canIndex ) {  this . dynTab . add ( header ) NL } NL if ( keyIndex <= 0 ) {  addNewField ( header , canIndex , myBuffer ) NL } else {  addIndexedName ( header , keyIndex , canIndex , myBuffer ) NL } NL } NL } NL return unsafe {  myBuffer . getRawArray ( ) [ 0 .. myBuffer . size ] NL } NL } NL }","func_name":"encode","docstring":"/**\n     * Encode func.\n     *\n     * @return the Array<UInt8>\n     */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"public func updateMaxSize ( size : UInt32 ) : Unit {   let len : UInt32 = size - UInt32 ( HeaderStaticTable . capacity ) NL if ( ! this . tableSizeUpdate ) {  if ( this . dynTab . setCapacity ( len ) ) {  this . tableSizeUpdate = true NL } NL } NL }","func_name":"updateMaxSize","docstring":"/**\n     * Update max size func.\n     *\n     * @return the Unit\n     */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"public func toString ( ) : String {  return this . dynTab . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"public func clear ( ) : Unit {  this . dynTab . clear ( ) NL }","func_name":"clear","docstring":""}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"func canIndex ( f : HeaderField ) : Bool {  return ! f . sensitive && f . size ( ) < this . dynTab . capacity ( ) NL }","func_name":"canIndex","docstring":"/**\n     * Can index func.\n     *\n     * @return the func\n     */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"func doReadAndHandleFull ( f : HeaderField ) : ( Int64 , Int64 ) {   let ( keyIndex , kvIndex ) = HeaderStaticTable . searchFull ( f ) NL if ( keyIndex > 0 && kvIndex > 0 ) {  return ( keyIndex , kvIndex ) NL } NL  let ( dykeyIndex , dykvIndex ) = this . dynTab . search ( f ) NL if ( keyIndex > 0 && dykeyIndex > 0 ) {  return ( keyIndex , dykvIndex ) NL } else if ( keyIndex > 0 && dykeyIndex < 0 ) {  return ( keyIndex , kvIndex ) NL } else if ( keyIndex < 0 && dykvIndex > 0 ) {  return ( dykeyIndex , dykvIndex ) NL } else if ( keyIndex < 0 && dykeyIndex > 0 ) {  return ( dykeyIndex , dykvIndex ) NL } NL return ( keyIndex , kvIndex ) NL }","func_name":"doReadAndHandleFull","docstring":""}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"func addIndexed ( i : UInt64 , myBuffer : ArrayList < UInt8 > ) {   let first : Int64 = myBuffer . size NL addByteInt ( HpkConf . VAILD_BIT , i , myBuffer ) NL myBuffer [ first ] |= HpkConf . CONST_128_U8 NL }","func_name":"addIndexed","docstring":"/**\n     * Add indexed func.\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 1 |       Max size (7+)       |\n     *     +---+---------------------------+\n     * @return the func\n     */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"func addNewField ( f : HeaderField , indexing : Bool , myBuffer : ArrayList < UInt8 > ) {  myBuffer . append ( encodeTypeByte ( indexing , f . sensitive ) ) NL addHpackString ( f . name , myBuffer ) NL addHpackString ( f . value , myBuffer ) NL }","func_name":"addNewField","docstring":"/**\n     * Literal Header Field without Indexing – New Name.\n     *     0   1   2   3   4   5   6   7\n     *   +---+---+---+---+---+---+---+---+\n     *   | 0 | 0 | 0 | 0 |       0       |\n     *   +---+---+-----------------------+\n     *   | H |     Name Length (7+)      |\n     *   +---+---------------------------+\n     *   |  Name String (Length octets)  |\n     *   +---+---------------------------+\n     *   | H |     Value Length (7+)     |\n     *   +---+---------------------------+\n     *   | Value String (Length octets)  |\n     *   +-------------------------------+\n     *\n     * Literal Header Field Never Indexed – New Name\n     *    0   1   2   3   4   5   6   7\n     *  +---+---+---+---+---+---+---+---+\n     *  | 0 | 0 | 0 | 1 |       0       |\n     *  +---+---+-----------------------+\n     *  | H |     Name Length (7+)      |\n     *  +---+---------------------------+\n     *  |  Name String (Length octets)  |\n     *  +---+---------------------------+\n     *  | H |     Value Length (7+)     |\n     *  +---+---------------------------+\n     *  | Value String (Length octets)  |\n     *  +-------------------------------+\n     *\n     */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"func addTableSize ( v : UInt32 , myBuffer : ArrayList < UInt8 > ) {   let len : Int64 = myBuffer . size NL addByteInt ( HpkConf . CHANGE_TABLE , UInt64 ( v ) , myBuffer ) NL myBuffer [ len ] |= HpkConf . CONST_32_U8 NL }","func_name":"addTableSize","docstring":"/**\n     *   Maximum Dynamic Table Size Change.\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 0 | 0 | 1 |   Max size (5+)   |\n     *     +---+---------------------------+\n     */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"func addIndexedName ( field : HeaderField , index : Int64 , canIndex : Bool , myBuffer : ArrayList < UInt8 > ) {   let first : Int64 = myBuffer . size NL  let N : Int64 = if ( canIndex ) {  HpkConf . INDEXD_TRUE NL } else {  HpkConf . INDEXD_NONE NL } NL addByteInt ( N , UInt64 ( index ) , myBuffer ) NL myBuffer [ first ] |= encodeTypeByte ( canIndex , field . sensitive ) NL addHpackString ( field . value , myBuffer ) NL }","func_name":"addIndexedName","docstring":"/**\n     * Add indexed name func.\n     *\n     * @return the func\n     */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"func addHpackString ( str : String , myBuffer : ArrayList < UInt8 > ) {   let strArr = str . toUtf8Array ( ) NL  let len : Int64 = huff_encode_count ( strArr ) NL if ( len < str . utf8View . size ) {   let first : Int64 = myBuffer . size NL addByteInt ( 7 , UInt64 ( len ) , myBuffer ) NL huff_encode ( myBuffer , strArr ) NL myBuffer [ first ] |= 0x80 NL } else {  myBuffer . append ( UInt8 ( strArr . size ) ) NL myBuffer . appendAll ( strArr ) NL } NL }","func_name":"addHpackString","docstring":"/**\n     *    value is not in the table.\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+-----------------------+\n     *     | H |     Value Length (7+)     |\n     *     +---+---------------------------+\n     *     | Value String (Length octets)  |\n     *     +-------------------------------+\n     *\n     *    Huffman encoding is greater than the length of the string and uses ascII directly\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+-----------------------+\n     *     | 0 |     Value Length (7+)     |\n     *     +---+---------------------------+\n     *     | ascII                         |\n     *     +-------------------------------+\n     *     | ........                      |\n     *     +-------------------------------+\n     */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"func addByteInt ( N : Int64 , v : UInt64 , myBuffer : ArrayList < UInt8 > ) {   let line : UInt8 = UInt8 ( ( 1 << N ) - 1 ) NL if ( v < UInt64 ( line ) ) {  myBuffer . append ( UInt8 ( v ) ) NL return NL } NL  var n : UInt64 = v - UInt64 ( line ) NL myBuffer . append ( line ) NL while ( n > = 128 ) {  myBuffer . append ( UInt8 ( n & 0x7f | 0x80 ) ) NL n >>= 7 NL } NL myBuffer . append ( UInt8 ( n ) ) NL }","func_name":"addByteInt","docstring":"/**\n     * An integer is used to indicate a name index, header field index, or string length.\n     * Integers indicate that you can start anywhere within eight bytes. To optimize processing,\n     * integer representations always end at the end of the octet.\n     *      0   1   2   3   4   5   6   7\n     *    +---+---+---+---+---+---+---+---+\n     *    | ? | ? | ? | 1   1   1   1   1 |\n     *    +---+---+---+-------------------+\n     *    | 1 |    Value-(2^N-1) LSB      |\n     *    +---+---------------------------+\n     *                   ...\n     *    +---+---------------------------+\n     *    | 0 |    Value-(2^N-1) MSB      |\n     *    +---+---------------------------+\n     */"}
{"repo":"http2","file":"HpackEncoder.cj","path":"http2/src/hpack/HpackEncoder.cj","code_tokens":"func encodeTypeByte ( indexing : Bool , sensitive : Bool ) : UInt8 {  if ( sensitive ) {  return 0x10 NL } NL if ( indexing ) {  return 0x40 NL } NL return 0 NL }","func_name":"encodeTypeByte","docstring":"/**\n     * A text header field that is not indexed\n     *   0   1   2   3   4   5   6   7\n     *  +---+---+---+---+---+---+---+---+\n     *  | 0 | 0 | 0 | 1 |  Index (4+)   |\n     *  +---+---+-----------------------+\n     *\n     * A text header field with an incremental index\n     *   0   1   2   3   4   5   6   7\n     *  +---+---+---+---+---+---+---+---+\n     *  | 0 | 1 |      Index (6+)       |\n     *  +---+---+-----------------------+\n     *\n     * A text header field without an index.\n     *   0   1   2   3   4   5   6   7\n     *  +---+---+---+---+---+---+---+---+\n     *  | 0 | 0 | 0 | 0 |       0       |\n     *  +---+---+-----------------------+\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"public func indexed ( ) : Bool {  return match ( this ) { case INCREMENTAL => true NL case NONE => false NL case NEVER => false NL } NL }","func_name":"indexed","docstring":"/**\n     * Indexed func.\n     *\n     * @return Bool\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"public func sensitive ( ) : Bool {  return match ( this ) { case INCREMENTAL => false NL case NONE => false NL case NEVER => true NL } NL }","func_name":"sensitive","docstring":"/**\n     * Sensitive func.\n     *\n     * @return Bool\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"static public func newDecode ( ) : Decoder {  return Decoder ( DynamicTables ( 4096 ) ) NL }","func_name":"newDecode","docstring":"/**\n     * Instantiates a new New decode.\n     *\n     * @return Type of Decoder\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"public func toString ( ) : String {  return this . dynTab . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"public func clear ( ) : Unit {  this . dynTab . clear ( ) NL }","func_name":"clear","docstring":""}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"static public func newDecode ( capa : Int64 ) : Decoder {  return Decoder ( DynamicTables ( capa ) ) NL }","func_name":"newDecode","docstring":"/**\n     * Instantiates a new New decode.\n     *\n     * @return Type of Decoder\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"public func decode ( src : Array < UInt8 > ) : Array < HeaderField > {  synchronized ( lock ) {   let headerBuf = ArrayList < HeaderField > ( ) NL  var i : Int64 = 0 NL while ( i < src . size && i != - 1 ) {  if ( ( src [ i ] & INDEXD [ 0 ] ) != INDEXD [ 1 ] ) {  i = this . parseFieldIndexed ( src , i , headerBuf ) NL } else if ( ( src [ i ] & LITERAL_WITH_INDEXING [ 0 ] ) == LITERAL_WITH_INDEXING [ 1 ] ) {  i = this . parseFieldLiteral ( src , i , HpkConf . INDEXD_TRUE , INCREMENTAL , headerBuf ) NL } else if ( ( src [ i ] & SIZE_UPDATE [ 0 ] ) == SIZE_UPDATE [ 1 ] ) {  i = this . parseUpdateDynamicTableSize ( src , i ) NL } else if ( ( src [ i ] & LITERAL_NEVER_INDEXED [ 0 ] ) == LITERAL_NEVER_INDEXED [ 1 ] ) {  i = this . parseFieldLiteral ( src , i , HpkConf . INDEXD_NEVER , NEVER , headerBuf ) NL } else if ( ( src [ i ] & LITERAL [ 0 ] ) == LITERAL [ 1 ] ) {  i = this . parseFieldLiteral ( src , i , HpkConf . INDEXD_NONE , NONE , headerBuf ) NL } NL } NL return unsafe {  headerBuf . getRawArray ( ) [ 0 .. headerBuf . size ] NL } NL } NL }","func_name":"decode","docstring":"/**\n     * Decode func.\n     *       0   1   2  ... n-3 n-2 n-1  n\n     *     +---+---+---+---+---+---+---+---+\n     *     | b | b | b |...| b | b | b | b |\n     *     +---+---+---+---+---+---+---+---+\n     *       ^ ->\n     *       i = i + 1\n     * @return the func\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"public func decode ( src : Array < UInt8 > , target : Array < HeaderField > ) : Int64 {  synchronized ( lock ) {  if ( target . size == 0 ) {  return - 1 NL } NL targetIndex = - 1 NL tableUpdateIndex = 0 NL  var i : Int64 = 0 NL while ( i < src . size && i != - 1 ) {  if ( ( src [ i ] & INDEXD [ 0 ] ) != INDEXD [ 1 ] ) {  i = this . parseFieldIndexed ( src , i , target ) NL } else if ( ( src [ i ] & LITERAL_WITH_INDEXING [ 0 ] ) == LITERAL_WITH_INDEXING [ 1 ] ) {  i = this . parseFieldLiteral ( src , i , HpkConf . INDEXD_TRUE , INCREMENTAL , target ) NL } else if ( ( src [ i ] & SIZE_UPDATE [ 0 ] ) == SIZE_UPDATE [ 1 ] ) {  i = this . parseUpdateDynamicTableSize ( src , i ) NL } else if ( ( src [ i ] & LITERAL_NEVER_INDEXED [ 0 ] ) == LITERAL_NEVER_INDEXED [ 1 ] ) {  i = this . parseFieldLiteral ( src , i , HpkConf . INDEXD_NEVER , NEVER , target ) NL } else if ( ( src [ i ] & LITERAL [ 0 ] ) == LITERAL [ 1 ] ) {  i = this . parseFieldLiteral ( src , i , HpkConf . INDEXD_NONE , NONE , target ) NL } NL } NL return this . targetIndex NL } NL }","func_name":"decode","docstring":"/**\n     * Decode func.\n     *       0   1   2  ... n-3 n-2 n-1  n\n     *     +---+---+---+---+---+---+---+---+\n     *     | b | b | b |...| b | b | b | b |\n     *     +---+---+---+---+---+---+---+---+\n     *       ^ ->\n     *       i = i + 1\n     * @return the func\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"public func parseUpdateDynamicTableSize ( src : Array < UInt8 > , index : Int64 ) : Int64 {  if ( index != tableUpdateIndex ) {  throw DynamicTableSizeUpdateException ( ) NL } NL if ( index > = src . size ) {  return - 1 NL } NL  let ( idx , newIdx ) = readVarInt ( src , index , HpkConf . CHANGE_TABLE ) NL if ( idx > http2HeaderTableSize ) {  throw DynamicTableSizeUpdateException ( ) NL } NL this . dynTab . setCapacity ( UInt32 ( idx ) ) NL tableUpdateIndex = newIdx NL return newIdx NL }","func_name":"parseUpdateDynamicTableSize","docstring":"/**\n     *   Maximum Dynamic Table Size Change.\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 0 | 0 | 1 |   Max size (5+)   |\n     *     +---+---------------------------+\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"public func updateMaxSize ( size : UInt32 ) : Unit {   let len : UInt32 = size - UInt32 ( HeaderStaticTable . capacity ) NL if ( ! this . maxDynamicTableSizeChangeRequired ) {   let isSetCap : Bool = this . dynTab . setCapacity ( len ) NL if ( isSetCap ) {  this . maxDynamicTableSizeChangeRequired = true NL } NL } NL }","func_name":"updateMaxSize","docstring":""}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"protected func parseFieldLiteral ( src : Array < UInt8 > , index : Int64 , N : Int64 , that : IndexType , buf : ArrayList < HeaderField > ) : Int64 {  if ( index > = src . size ) {  return - 1 NL } NL  let ( idx , newIdx ) = readVarInt ( src , index , N ) NL  var ( name , newIndex ) = if ( idx > 0 ) {  ( this . getHeader ( idx ) . name , newIdx ) NL } else {  this . readString ( src , newIdx ) NL } NL  let ( value , len ) = this . readString ( src , newIndex ) NL newIndex = len NL  let header : HeaderField = HeaderField ( name , value , that . sensitive ( ) ) NL  let ( indexA , indexB ) = this . dynTab . search ( name , value ) NL if ( indexA < 0 || indexB < 0 ) {  this . dynTab . add ( header ) NL } NL buf . append ( header ) NL return newIndex NL }","func_name":"parseFieldLiteral","docstring":"/**\n     * Parse field literal func.\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 0 | 1 |   Max size (6+)       |\n     *     +---+---------------------------+\n     *\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 0 | 0 | 0 | 0 |  size (4+)    |\n     *     +---+---------------------------+\n     *\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 0 | 0 | 0 | 1 |  size (4+)    |\n     *     +---+---------------------------+\n     * @return the func\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"protected func parseFieldLiteral ( src : Array < UInt8 > , index : Int64 , N : Int64 , that : IndexType , buf : Array < HeaderField > ) : Int64 {  if ( index > = src . size ) {  return - 1 NL } NL  let ( idx , newIdx ) = readVarInt ( src , index , N ) NL  var ( name , newIndex ) = if ( idx > 0 ) {  ( this . getHeader ( idx ) . name , newIdx ) NL } else {  this . readString ( src , newIdx ) NL } NL  let ( value , len ) = this . readString ( src , newIndex ) NL newIndex = len NL  let header : HeaderField = HeaderField ( name , value , that . sensitive ( ) ) NL if ( that . indexed ( ) ) {  this . dynTab . add ( header ) NL } NL this . targetIndex ++ NL buf [ targetIndex ] = header NL return newIndex NL }","func_name":"parseFieldLiteral","docstring":"/**\n     * Parse field literal func.\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 0 | 1 |   Max size (6+)       |\n     *     +---+---------------------------+\n     *\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 0 | 0 | 0 | 0 |  size (4+)    |\n     *     +---+---------------------------+\n     *\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 0 | 0 | 0 | 1 |  size (4+)    |\n     *     +---+---------------------------+\n     * @return the func\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"protected func readString ( src : Array < UInt8 > , i : Int64 ) : ( String , Int64 ) {  if ( i > = src . size ) {  return (  , - 1 ) NL } NL  var index = i NL  let ( len , idx ) = readVarInt ( src , index , HpkConf . INDEXD_SUCCESS ) NL  var length = len + idx NL  let strArr = if ( ( src [ i ] & HpkConf . CONST_128_U8 ) == 0 ) {  index ++ NL if ( index == length ) {  return (  , length ) NL } NL src [ index .. length ] NL } else {   let arr = Array < UInt8 > ( ( length - idx ) * 2 , item : 0 ) NL  let ( arrSize , str ) = huff_decode ( src [ idx .. length ] , arr ) NL match ( str ) { case Some ( v ) => throw InvalidHuffmanCodeException ( ) NL case None => ( ) NL } NL arr [ 0 .. arrSize ] NL } NL return ( String . fromUtf8 ( strArr ) , length ) NL }","func_name":"readString","docstring":"/**\n     *    value is not in the table.\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+-----------------------+\n     *     | H |     Value Length (7+)     |\n     *     +---+---------------------------+\n     *     | Value String (Length octets)  |\n     *     +-------------------------------+\n     *\n     *    Huffman encoding is greater than the length of the string and uses ascII directly\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+-----------------------+\n     *     | 0 |     Value Length (7+)     |\n     *     +---+---------------------------+\n     *     |           ASCII               |\n     *     +-------------------------------+\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"protected func parseFieldIndexed ( src : Array < UInt8 > , index : Int64 , buf : ArrayList < HeaderField > ) : Int64 {  if ( src . size <= index ) {  return - 1 NL } NL  let ( idx , newIndex ) = readVarInt ( src , index , HpkConf . INDEXD_SUCCESS ) NL buf . append ( this . getHeader ( idx ) ) NL return newIndex NL }","func_name":"parseFieldIndexed","docstring":"/**\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 1 |       Max size (7+)       |\n     *     +---+---------------------------+\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"protected func parseFieldIndexed ( src : Array < UInt8 > , index : Int64 , buf : Array < HeaderField > ) : Int64 {  if ( src . size <= index ) {  return - 1 NL } NL  let ( idx , newIndex ) = readVarInt ( src , index , HpkConf . INDEXD_SUCCESS ) NL targetIndex ++ NL buf [ targetIndex ] = this . getHeader ( idx ) NL return newIndex NL }","func_name":"parseFieldIndexed","docstring":"/**\n     *       0   1   2   3   4   5   6   7\n     *     +---+---+---+---+---+---+---+---+\n     *     | 1 |       Max size (7+)       |\n     *     +---+---------------------------+\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"@ overflowWrapping   protected func readVarInt ( src : Array < UInt8 > , index : Int64 , N : Int64 ) : ( Int64 , Int64 ) {   var indexVar : Int64 = index NL if ( src . size <= indexVar || N <= 0 || N > HpkConf . BYTE_SIZE ) {  throw HpackException ( ) NL } NL  var srci : Int64 = Int64 ( src [ indexVar ] ) NL indexVar ++ NL if ( N < HpkConf . BYTE_SIZE ) {  srci &= ( 1 << N ) - 1 NL } NL if ( srci < ( 1 << N ) - 1 ) {  return ( srci , indexVar ) NL } NL  var bit = 0 NL for ( i in indexVar .. src . size ) {  indexVar ++ NL srci += Int64 ( src [ i ] & HpkConf . CONST_127_U8 ) << bit NL bit += HpkConf . VAILD_BIT NL if ( bit > = HpkConf . CONST_63_I64 ) {  throw HpackException ( ) NL } NL if ( ( src [ i ] & HpkConf . CONST_128_U8 ) == 0 ) {  break NL } NL } NL return ( srci , indexVar ) NL }","func_name":"readVarInt","docstring":"/**\n     * An integer is used to indicate a name index, header field index, or string length.\n     * Integers indicate that you can start anywhere within eight bytes. To optimize processing,\n     * integer representations always end at the end of the octet.\n     *      0   1   2   3   4   5   6   7\n     *    +---+---+---+---+---+---+---+---+\n     *    | ? | ? | ? | 1   1   1   1   1 |\n     *    +---+---+---+-------------------+\n     *    | 1 |    Value-(2^N-1) LSB      |\n     *    +---+---------------------------+\n     *                   ...\n     *    +---+---------------------------+\n     *    | 0 |    Value-(2^N-1) MSB      |\n     *    +---+---------------------------+\n     */"}
{"repo":"http2","file":"HpackDecoder.cj","path":"http2/src/hpack/HpackDecoder.cj","code_tokens":"protected func getHeader ( index : Int64 ) : HeaderField {  if ( index <= 0 ) {  throw IndexOutOfBoundsException ( ) NL } NL if ( index <= HpkConf . STATIC_TABLE_SIZE ) {  return HeaderStaticTable . getIndex ( index ) NL } NL return this . dynTab . getEntry ( index ) NL }","func_name":"getHeader","docstring":"/**\n     * Get header func.\n     *\n     * @return HeaderField\n     */"}
{"repo":"http2","file":"pusher.cj","path":"http2/src/annotation/pusher.cj","code_tokens":"func appendPusherCode ( input : Tokens , push : H2Pusher ) : Tokens {   var tokens = Tokens ( ) NL  var flage = false NL  var count = 0 NL  let list : Array < Token > = Array < Token > ( input . size , item : Token ( ) ) NL  var varName =  NL  var index = 0 NL for ( inp in input ) {  tokens = tokens + inp NL list [ index ] = inp NL match ( inp . kind ) { case DOUBLE_ARROW => count ++ NL case NL => if ( count != 1 || flage ) {  continue NL } NL varName = list [ index - 4 ] . value NL flage = true NL tokens += addFileToken ( push , varName ) NL case _ => ( ) NL } NL index ++ NL } NL if ( ! flage ) {  throw IllegalArgumentException ( The code format does not meet the requirements. ) NL } NL return tokens NL }","func_name":"appendPusherCode","docstring":""}
{"repo":"http2","file":"pusher.cj","path":"http2/src/annotation/pusher.cj","code_tokens":"func addFileToken ( pushs : H2Pusher , variableNamestr : String ) : Tokens {   let method = Token ( IDENTIFIER , pushs . method . toString ( ) ) NL  let nameA = Token ( IDENTIFIER , getRandomVariableName ( ) ) NL  let nameB = Token ( IDENTIFIER , getRandomVariableName ( ) ) NL  let variableName = Token ( IDENTIFIER , variableNamestr ) NL  var token = Tokens ( ) NL token += Token ( NL ) NL token += quote ( let $nameA = $variableName as $pusherName ) NL token += Token ( NL ) NL token += quote ( match ( $nameA ) { ) NL token += Token ( NL ) NL token += quote ( case None => ( ) ) NL token += Token ( NL ) NL token += quote ( case Some ( obj ) => ) NL token += Token ( NL ) NL for ( push in pushs ) {  match ( push ) { case File ( v ) =>  let path = fs . Path ( v ) NL try {  if ( path . isDirectory ( ) || ! path . isFile ( ) ) {  Console . stdOut . write ( warning: The path may not exist in the file system: ${v}\\n ) NL } NL } catch ( e : FSException ) {  Console . stdOut . write ( warning: The path may not exist in the file system: ${v}\\n ) NL } NL token += quote ( obj . $pusherfunction ( $v , $pushOptionsName ( method : $method ) , true ) ) NL token += Token ( NL ) NL case String ( v ) => throw IllegalArgumentException ( ) NL } NL } NL token += quote ( } ) NL token += Token ( NL ) NL return token NL }","func_name":"addFileToken","docstring":"/* \nlet $nameA =  w as Http2Pusher\nmatch($nameA){ NL\n    case None => () NL\n    case Some(v) =>\npush.push(\"adfadsf\", PushOptions(method: GET), true)\n\n */"}
{"repo":"http2","file":"pusher.cj","path":"http2/src/annotation/pusher.cj","code_tokens":"public func isEmpty ( ) : Bool {  return parms . size == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"http2","file":"pusher.cj","path":"http2/src/annotation/pusher.cj","code_tokens":"public func iterator ( ) : Iterator < PushParm > {  return this . parms . iterator ( ) NL }","func_name":"iterator","docstring":""}
{"repo":"http2","file":"pusher.cj","path":"http2/src/annotation/pusher.cj","code_tokens":"public func toString ( ) : String {  match ( this ) { case HEAD => return HEAD NL case GET => return GET NL } NL }","func_name":"toString","docstring":""}
{"repo":"http2","file":"pusher.cj","path":"http2/src/annotation/pusher.cj","code_tokens":"func getRandomVariableName ( ) : String {   let random = Random ( ) NL  let sb = StringBuilder ( ) NL for ( i in 0 .. 5 ) {   var rand : UInt8 = UInt8 . Max NL while ( rand > = 8 * UInt8 ( characters . size ) ) {  rand = random . nextUInt8 ( ) NL } NL sb . append ( characters [ Int64 ( rand ) % characters . size ] ) NL } NL for ( i in 0 .. 3 ) {   var rand : UInt8 = UInt8 . Max NL while ( rand > = 25 * UInt8 ( integers . size ) ) {  rand = random . nextUInt8 ( ) NL } NL sb . append ( integers [ Int64 ( rand ) % integers . size ] ) NL } NL return sb . toString ( ) NL }","func_name":"getRandomVariableName","docstring":""}
{"repo":"http2","file":"pusher.cj","path":"http2/src/annotation/pusher.cj","code_tokens":"func putSet ( list : ArrayList < Token > , push : H2Pusher ) {  if ( list . size != 3 ) {  throw IllegalArgumentException ( ) NL } NL match ( list [ 0 ] . kind ) { case IDENTIFIER => ( ) NL case _ => throw IllegalArgumentException ( ) NL } NL match ( list [ 1 ] . kind ) { case ASSIGN => ( ) NL case _ => throw IllegalArgumentException ( ) NL } NL match ( list [ 2 ] . kind ) { case IDENTIFIER | STRING_LITERAL => ( ) NL case _ => throw IllegalArgumentException ( ) NL } NL match ( list [ 0 ] . value ) { case PushMethod => match ( list [ 2 ] . value ) { case HEAD | Head => push . method = HEAD NL case GET | Get => ( ) NL case _ => throw IllegalArgumentException ( If it is a service push, it must be a get or head method If not set, get is the default. ) NL } NL case String => push . parms . append ( String ( list [ 2 ] . value ) ) NL case File => push . parms . append ( File ( list [ 2 ] . value ) ) NL case _ => throw IllegalArgumentException ( ) NL } NL list . clear ( ) NL }","func_name":"putSet","docstring":""}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"func roundTrip ( req : Request ) : H1Response","func_name":"roundTrip","docstring":"/**\n     * The Function is roundTrip\n     *\n     * @param req of Request\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"static public func getDefault ( reader : HttpReader ) : Transport {   var defaultTransport = Transport ( reader ) NL defaultTransport . proxy = Option < ( Request ) -> URL > . None NL defaultTransport . forceAttemptHTTP2 = true NL defaultTransport . maxIdleConns = 100 NL defaultTransport . idleConnTimeout = Duration . second ( 90 ) NL defaultTransport . tlsHandshakeTimeout = Duration . second ( 10 ) NL defaultTransport . expectContinueTimeout = Duration . second ( 1 ) NL return defaultTransport NL }","func_name":"getDefault","docstring":"/**\n     * The Function is getDefault\n     *\n     * @return Type of Transport\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"public open func roundTrip ( req : Request ) : H1Response {   var scheme = req . url . scheme NL  var isHTTP : Bool = scheme == http || scheme == https NL if ( isHTTP ) {  try {  req . header . checkHeaderNameVal ( ) NL } catch ( e : Exception ) {  return H1Response ( ) NL } NL } NL if ( ! isHTTP ) {  throw HttpException ( unsupported protocol scheme ${scheme} ) NL } NL if ( ! validMethod ( req . method . toString ( ) ) ) {  throw HttpException ( net/http: invalid method ${req.method.toString()} ) NL } NL if ( req . url . host ==  ) {  throw HttpException ( http: no Host in request URL ) NL } NL try {  return conn ( req ) ?? H1Response ( ) NL } catch ( e : Exception ) {  e . printStackTrace ( ) NL } NL return H1Response ( ) NL }","func_name":"roundTrip","docstring":"/**\n     * The Function is roundTrip\n     *\n     * @param req of Request\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"static public func validMethod ( method : String ) : Bool {  return true NL }","func_name":"validMethod","docstring":"/**\n     * The Function is validMethod\n     *\n     * @param method of String\n     *\n     * @return Type of Bool\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"private func requiresHTTP1 ( r : Request ) : Bool {   var con = match ( r . header . get ( Connection ) ) { case Some ( x ) => x NL case None =>  NL } NL  var upgrade = match ( r . header . get ( Upgrade ) ) { case Some ( x ) => x NL case None =>  NL } NL return true NL }","func_name":"requiresHTTP1","docstring":""}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"private func canonicalAddrs ( url : URL ) : String {   var addr : String = url . hostname ( ) NL  var vRes : ( String , String ) = idnaASCII ( addr ) NL if ( vRes [ 1 ] ==  ) {  addr = vRes [ 0 ] NL } NL  var port : String = url . port ( ) NL if ( port ==  ) {  port = DEFAULT_PROTOCOL_PORT [ url . scheme ] NL } NL return joinHostPort ( addr , port ) NL }","func_name":"canonicalAddrs","docstring":""}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"public func joinHostPort ( host : String , port : String ) : String {   var res = match ( host . indexOf ( : ) ) { case Some ( x ) => x NL case None => - 1 NL } NL if ( res > = 0 ) {  return [ ${host} ]: ${port} NL } NL return ${host} : ${port} NL }","func_name":"joinHostPort","docstring":"/**\n     * The Function is joinHostPort\n     *\n     * @param host of String\n     * @param port of String\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"public func idnaASCII ( v : String ) : ( String , String ) {  if ( isASCII ( v ) ) {  return ( v ,  ) NL } NL return toASCII ( v ) NL }","func_name":"idnaASCII","docstring":"/**\n     * The Function is idnaASCII\n     *\n     * @param v of String\n     *\n     * @return Type of (String, String)\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"public func toASCII ( s : String ) : ( String , String ) {  if ( isASCII ( s ) ) {  return ( s ,  ) NL } NL  let labels = s . split ( . ) NL  var output = StringBuilder (  ) NL for ( i in 0 .. labels . size ) {   var label = labels [ i ] NL if ( i != 0 ) {  output . append ( . ) NL } NL if ( ! isASCII ( label ) ) {   let res = encode ( xn-- , label ) NL if ( ! res [ 1 ] . isEmpty ( ) ) {  return (  , res [ 1 ] ) NL } NL output . append ( res [ 0 ] ) NL } else {  output . append ( label ) NL } NL } NL return ( output . toString ( ) ,  ) NL }","func_name":"toASCII","docstring":"/**\n     * The Function is toASCII\n     *\n     * @param s of String\n     *\n     * @return Type of (String, String)\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"private func encode ( prefix : String , s : String ) : ( String , String ) {   var ( output , b , remaining , delta , n , bias ) = ( StringBuilder ( ) , 0 , 0 , 0 , 128 , 72 ) NL output . append ( prefix ) NL for ( i in 0 .. s . size where UInt32 ( s [ i ] ) < 0x80 ) {  output . append ( s [ i ] ) NL b ++ NL } NL remaining = s . size - b NL  var ft = b NL if ( b > 0 ) {  output . append ( - ) NL } NL while ( remaining != 0 ) {   var m = Int64 ( 0x7fffffff ) NL for ( i in 0 .. s . size where m > Int64 ( UInt32 ( s [ i ] ) ) && Int64 ( UInt32 ( s [ i ] ) ) > = n ) {  m = Int64 ( UInt32 ( s [ i ] ) ) NL } NL delta += ( m - n ) * ( ft + 1 ) NL if ( delta < 0 ) {  return (  , cookjar: invalid label + s ) NL } NL n = m NL for ( i in 0 .. s . size ) {   var v = Int64 ( UInt32 ( s [ i ] ) ) NL if ( v < n ) {  delta ++ NL if ( delta < 0 ) {  return (  , cookjar: invalid label + s ) NL } NL continue NL } NL if ( v > n ) {  continue NL } NL  var ( q , k , t ) = ( delta , 36 , 36 - bias ) NL while ( q > = t ) {  if ( t < 1 ) {  t = 1 NL } else if ( t > 26 ) {  t = 26 NL } NL output . append ( encodeDigit ( t + ( q - t ) % ( 36 - t ) ) ) NL q = ( q - t ) / ( 36 - t ) NL k += 36 NL } NL output . append ( encodeDigit ( q ) ) NL bias = adaptcj ( delta , ft + 1 , b == ft ) NL remaining -- NL delta = 0 NL ft ++ NL } NL n ++ NL delta ++ NL } NL return ( output . toString ( ) ,  ) NL }","func_name":"encode","docstring":""}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"private func adaptcj ( d : Int64 , n : Int64 , flag : Bool ) : Int64 {   var delta = d NL if ( flag ) {  delta /= 700 NL } else {  delta /= 2 NL } NL delta += delta / n NL  var k = 0 NL while ( delta > ( ( 36 - 1 ) * 26 ) / 2 ) {  delta /= 36 - 1 NL k += 36 NL } NL return k + 36 * delta / ( delta + 38 ) NL }","func_name":"adaptcj","docstring":""}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"private func encodeDigit ( digit : Int64 ) : Char {  if ( 0 < digit && digit < 26 ) {  return Char ( UInt32 ( digit ) + UInt32 ( UInt32 ( a ) ) ) NL } else if ( 26 < digit && digit < 36 ) {  return Char ( UInt32 ( digit + Int64 ( UInt32 ( 0 ) ) - 26 ) ) NL } else {  throw Exception ( encodeDigit error ) NL } NL }","func_name":"encodeDigit","docstring":""}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"private func isASCII ( s : String ) : Bool {  for ( temp in s ) {  if ( Int64 ( UInt32 ( temp ) ) > = Int64 ( 0x80 ) ) {  return false NL } NL } NL return true NL }","func_name":"isASCII","docstring":""}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"public func setClientOverTimeDur ( durTime ! : Option < Duration > = None ) {  this . clientOverTimeDur = durTime NL }","func_name":"setClientOverTimeDur","docstring":"/**\n     * The Function is setClientOverTimeDur\n     *\n     * @param durTime of Option<Duration>, and the Default value is None\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"private func conn ( request : Request ) : Option < H1Response > {   let socket = this . reader . getSocket ( ) NL try {  match ( socket . sockClient ) { case SocketC ( socketConn ) => request . copyTo ( socketConn ) NL case TlsC ( tlsConn ) => request . copyTo ( tlsConn ) NL } NL } catch ( e : Exception ) {  socket . close ( ) NL return None NL } NL this . reader . clientRun ( request ) NL this . reader . close ( ) NL if ( ! this . reader . isReadEnd ( ) ) {  return None NL } NL  var ( startLine , header , body , allData ) : ( String , Header , ByteArrayStream , ByteArrayStream ) = this . reader . getData ( ) NL  var startList = startLine . split (   , 3 ) NL  var proto : String =  NL  var status : String =  NL  var statusCode : Int64 = 200 NL if ( startList . size == 3 ) {  proto = startList [ 0 ] NL status = startList [ 1 ] +   + startList [ 2 ] NL statusCode = match ( Int64 . tryParse ( startList [ 1 ] ) ) { case Some ( x ) => x NL case None => throw HttpException ( statuscode is invalid ) NL } NL } else if ( startList . size == 2 ) {  proto = startList [ 0 ] NL status = startList [ 1 ] NL statusCode = match ( Int64 . tryParse ( startList [ 1 ] ) ) { case Some ( x ) => x NL case None => throw HttpException ( statuscode is invalid ) NL } NL } else {  throw HttpException ( start line is invalid ) NL } NL  var protoMajor : Int64 = request . protoMajor NL  var protoMinor : Int64 = request . protoMajor NL  let contentLengthStr = header . get ( Content-Length ) ?? -1 NL  var contentLength : Int64 = Int64 . parse ( contentLengthStr . trim ( ) ) NL  var trailer : Header = Header ( ) NL  var resp = H1Response ( proto , statusCode , header , trailer , body , allData , 1 , 1 , contentLength ) NL resp . transferEncoding = request . transferEncoding . toArray ( ) NL resp . request = request NL return Some ( resp ) NL }","func_name":"conn","docstring":""}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"public func toArray ( a : Array < UInt8 > ) : Array < Char > {   var buf2 = Array < Char > ( a . size , item : \\0 ) NL for ( i in 0 .. buf2 . size ) {  buf2 [ i ] = Char ( UInt32 ( a [ i ] ) ) NL } NL return buf2 NL }","func_name":"toArray","docstring":"/**\n * The Function is toArray\n *\n * @param a of Array<UInt8>\n *\n * @return Type of Array<Char>\n * @since 0.29.3\n */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"public func toArray ( a : Array < Char > ) : Array < UInt8 > {   var buf2 = Array < UInt8 > ( a . size , item : 0 ) NL for ( i in 0 .. buf2 . size ) {  buf2 [ i ] = UInt8 ( UInt32 ( a [ i ] ) ) NL } NL return buf2 NL }","func_name":"toArray","docstring":"/**\n * The Function is toArray\n *\n * @param a of Array<UInt8>\n *\n * @return Type of Array<Char>\n * @since 0.29.3\n */"}
{"repo":"http2","file":"http1Transport.cj","path":"http2/src/http/http1Transport.cj","code_tokens":"public func toArray ( a : ArrayList < String > ) : Array < String > {  return Array < String > ( a . size , { i => a [ i ] NL } ) NL }","func_name":"toArray","docstring":"/**\n * The Function is toArray\n *\n * @param a of Array<UInt8>\n *\n * @return Type of Array<Char>\n * @since 0.29.3\n */"}
{"repo":"http2","file":"http1ClientUtil.cj","path":"http2/src/http/http1ClientUtil.cj","code_tokens":"func send ( req : Request , rt : H1RoundTripper ) : H1Response {   let u = req . url . user NL  let s : Option < String > = req . header . get ( Authorization ) NL  let str = s ??  NL if ( u . username ( ) !=  && str . isEmpty ( ) ) {  req . header . set ( Authorization , Basic  + basicAuth ( u . username ( ) , u . password ( ) ??  ) ) NL } NL return match ( rt as Transport ) { case Some ( v ) => v . roundTrip ( req ) NL case None => rt . roundTrip ( req ) NL } NL }","func_name":"send","docstring":""}
{"repo":"http2","file":"http1ClientUtil.cj","path":"http2/src/http/http1ClientUtil.cj","code_tokens":"public func basicAuth ( username : String , password : String ) : String {   let auth = username + : + password NL  let arr = auth . toUtf8Array ( ) NL return toHexString ( arr ) NL }","func_name":"basicAuth","docstring":"/**\n * The Function is basicAuth\n *\n * @param username of String\n * @param password of String\n *\n * @return Type of String\n * @since 0.29.3\n */"}
{"repo":"http2","file":"http1ClientUtil.cj","path":"http2/src/http/http1ClientUtil.cj","code_tokens":"public func getRequestMethod ( m : String ) : RequestMethod {  return match { case m . contains ( Get ) || m . contains ( GET ) => RequestMethod . GET NL case m . contains ( Head ) || m . contains ( HEAD ) => RequestMethod . HEAD NL case m . contains ( Post ) || m . contains ( POST ) => RequestMethod . POST NL case m . contains ( Put ) || m . contains ( PUT ) => RequestMethod . PUT NL case m . contains ( Delete ) || m . contains ( DELETE ) => RequestMethod . DELETE NL case m . contains ( Connect ) || m . contains ( CONNECT ) => RequestMethod . CONNECT NL case m . contains ( Options ) || m . contains ( OPTIONS ) => RequestMethod . OPTIONS NL case m . contains ( Patch ) || m . contains ( PATCH ) => RequestMethod . PATCH NL case m . contains ( Trace ) || m . contains ( TRACE ) => RequestMethod . TRACE NL case _ => RequestMethod . GET NL } NL }","func_name":"getRequestMethod","docstring":"/**\n * The Function is getRequestMethod\n *\n * @param m of String)\n *\n * @return Type of RequestMethod\n * @since 0.29.3\n */"}
{"repo":"http2","file":"http1ClientUtil.cj","path":"http2/src/http/http1ClientUtil.cj","code_tokens":"func indexFunc ( str : String ) : Int64 {  return indexFunc ( str , true ) NL }","func_name":"indexFunc","docstring":""}
{"repo":"http2","file":"http1ClientUtil.cj","path":"http2/src/http/http1ClientUtil.cj","code_tokens":"func indexFunc ( str : String , b : Bool ) : Int64 {   var i = 0 NL for ( c in str ) {  if ( isNotToken ( Int64 ( UInt32 ( c ) ) ) == b ) {  return i NL } NL i ++ NL } NL return - 1 NL }","func_name":"indexFunc","docstring":""}
{"repo":"http2","file":"http1ClientUtil.cj","path":"http2/src/http/http1ClientUtil.cj","code_tokens":"func isNotToken ( n : Int64 ) : Bool {  return ! checkToken ( n ) NL }","func_name":"isNotToken","docstring":""}
{"repo":"http2","file":"http1ClientUtil.cj","path":"http2/src/http/http1ClientUtil.cj","code_tokens":"func checkToken ( n : Int64 ) : Bool {   let isTokenTable = [ false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , false , true , false , true , true , true , true , true , false , false , true , true , false , true , true , false , true , true , true , true , true , true , true , true , true , true , false , false , false , false , false , false , false , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , false , false , false , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , false , true , false , true ] NL return n > = 0 && n < isTokenTable . size && isTokenTable [ n ] NL }","func_name":"checkToken","docstring":""}
{"repo":"http2","file":"http1Util.cj","path":"http2/src/http/http1Util.cj","code_tokens":"func isTT ( b : UInt8 ) : Bool {   let ch = Char ( UInt32 ( b ) ) NL if ( ch ==   || ch == > ) {  return true NL } NL return false NL }","func_name":"isTT","docstring":""}
{"repo":"http2","file":"http1Util.cj","path":"http2/src/http/http1Util.cj","code_tokens":"func isWS ( b : UInt8 ) : Bool {  return ( b == b' ' || b == b'\\\\n' || b == b'\\\\r' || b == b'\\\\t' || b == b'\\\\u{0c}' ) NL }","func_name":"isWS","docstring":""}
{"repo":"http2","file":"http1Util.cj","path":"http2/src/http/http1Util.cj","code_tokens":"func DetectContentType ( data : Array < UInt8 > ) : String {  DetectContentType1 ( data . slice ( 0 , data . size ) ) NL }","func_name":"DetectContentType","docstring":""}
{"repo":"http2","file":"http1Util.cj","path":"http2/src/http/http1Util.cj","code_tokens":"func DetectContentType1 ( data : Array < UInt8 > ) : String {   let newData = if ( data . size > SNIFF_LEN ) {  data [ 0 .. SNIFF_LEN ] NL } else {  data NL } NL  var firstNonWS = 0 NL for ( i in 0 .. newData . size ) {  if ( isWS ( newData [ i ] ) ) {  firstNonWS = i NL break NL } NL } NL for ( sig in sniffSignatures ) {   let ct = sig . matchSig ( newData , firstNonWS ) NL if ( ct . size != 0 ) {  return ct NL } NL } NL return application/octet-stream NL }","func_name":"DetectContentType1","docstring":""}
{"repo":"http2","file":"http1Util.cj","path":"http2/src/http/http1Util.cj","code_tokens":"func appendTime ( sb : StringBuilder ) : Unit {   let t = Time . now ( ) NL  let ( yy , mm , dd ) = t . date ( ) NL  let ( hh , mi , ss ) = t . clock ( ) NL  let ( zone , _ ) = t . zone ( ) NL  let day : String = days [ t . weekDay ( ) . value ( ) ] NL sb . append ( day ) . append ( ,  ) . append ( dd ) . append (   ) . append ( months [ mm . value ( ) ] ) . append (   ) . append ( yy ) . append (   ) NL if ( hh < 10 ) {  sb . append ( 0 ) NL } NL sb . append ( hh ) . append ( : ) NL if ( mi < 10 ) {  sb . append ( 0 ) NL } NL sb . append ( mi ) . append ( : ) NL if ( ss < 10 ) {  sb . append ( 0 ) NL } NL sb . append ( ss ) . append (   ) . append ( zone ) NL }","func_name":"appendTime","docstring":""}
{"repo":"http2","file":"http1Util.cj","path":"http2/src/http/http1Util.cj","code_tokens":"public func appendTime ( ) : String {   let sb = StringBuilder ( ) NL  let t = Time . now ( ) NL  let ( yy , mm , dd ) = t . date ( ) NL  let ( hh , min , ss ) = t . clock ( ) NL  let ( zone , _ ) = t . zone ( ) NL  let day : String = days [ t . weekDay ( ) . value ( ) ] NL sb . append ( day ) . append ( ,  ) . append ( dd ) . append (   ) . append ( months [ mm . value ( ) ] ) . append (   ) . append ( yy ) . append (   ) NL if ( hh < 10 ) {  sb . append ( 0 ) NL } NL sb . append ( hh ) . append ( : ) NL if ( min < 10 ) {  sb . append ( 0 ) NL } NL sb . append ( min ) . append ( : ) NL if ( ss < 10 ) {  sb . append ( 0 ) NL } NL sb . append ( ss ) . append (   ) . append ( zone ) NL return sb . toString ( ) NL }","func_name":"appendTime","docstring":""}
{"repo":"http2","file":"http1Util.cj","path":"http2/src/http/http1Util.cj","code_tokens":"public func appendTime ( t : Time ) : String {   let sb = StringBuilder ( ) NL  let ( yy , mm , dd ) = t . date ( ) NL  let ( hh , mn , ss ) = t . clock ( ) NL  let ( zone , _ ) = t . zone ( ) NL  let day : String = days [ t . weekDay ( ) . value ( ) ] NL sb . append ( day ) . append ( ,  ) . append ( dd ) . append (   ) . append ( months [ mm . value ( ) ] ) . append (   ) . append ( yy ) . append (   ) NL if ( hh < 10 ) {  sb . append ( 0 ) NL } NL sb . append ( hh ) . append ( : ) NL if ( mn < 10 ) {  sb . append ( 0 ) NL } NL sb . append ( mn ) . append ( : ) NL if ( ss < 10 ) {  sb . append ( 0 ) NL } NL sb . append ( ss ) . append (   ) . append ( zone ) NL return sb . toString ( ) NL }","func_name":"appendTime","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"func UInt64ToHexString ( n : UInt64 ) : Array < Byte > {   var num : UInt64 = n NL  var arrSize : Int64 = 0 NL for ( i in 0 .. 16 ) {  if ( num > 0 ) {  arrSize ++ NL num = num >> 4 NL } else {  break NL } NL } NL  var arr = Array < Byte > ( arrSize , item : UInt8 ( CHAR_ZERO ) ) NL  var mask : UInt64 = 0x0f NL  var idx = 0 NL num = n NL for ( i in arrSize - 1 .. - 1 : - 1 ) {  if ( num > 0 ) {   var item = num & mask NL arr [ i ] = UInt64ToHex [ Int64 ( item ) ] NL num = num >> 4 NL } else {  break NL } NL } NL return arr NL }","func_name":"UInt64ToHexString","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"public func header ( ) : Header {  return this . header_ NL }","func_name":"header","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"public func writeStatusCode ( statusCode : Int64 ) : Unit {  if ( statusCode < 100 || statusCode > 999 ) {  throw HttpException ( invalid writeStatusCode code ) NL } NL this . status = statusCode NL }","func_name":"writeStatusCode","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"public func write ( data : Array < Byte > ) : Unit {  body . write ( data ) NL }","func_name":"write","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"public func flush ( ) : Unit {  this . isChunked = true NL this . chunkedWrite ( this . body . bytes ( ) ) NL this . sock . flush ( ) NL this . body . clear ( ) NL }","func_name":"flush","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"public func writeFinished ( ) {  if ( ! this . isChunked ) {  match ( this . header_ . get ( HEADER_TRANSFER_ENCODING_KEY ) ) { case Some ( v ) => if ( v == chunked ) {  this . isChunked = true NL } NL case None => ( ) NL } NL } NL if ( ! this . isChunked ) {   var buffer : StringBuilder = StringBuilder ( ) NL  let bodyData : Array < Byte > = this . body . bytes ( ) NL this . writeStartLine ( buffer ) NL  let contentLength = bodyData . size NL buffer . append ( HEADER_CONTENT_LENGTH_KEY ) . append ( :  ) . append ( contentLength ) . append ( CRLF_STR ) NL this . writeHeaderText ( buffer , bodyData ) NL buffer . append ( CRLF_STR ) NL  let headerSize = buffer . byteCount ( ) NL this . sock . write ( unsafe {  buffer . rawData ( ) . slice ( 0 , headerSize ) NL } ) NL if ( this . req . method != RequestMethod . HEAD ) {  this . sock . write ( bodyData ) NL this . body . clear ( ) NL } NL } else {  this . flush ( ) NL this . sock . write ( ZERO_CRLF_CRLF ) NL } NL this . sock . flush ( ) NL }","func_name":"writeFinished","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"private func chunkedWrite ( data : Array < Byte > ) : Unit {   let dataSize = data . size NL if ( ! this . wroteHeader ) {  this . wroteHeader = true NL  var buffer : StringBuilder = StringBuilder ( ) NL this . writeStartLine ( buffer ) NL this . writeHeaderText ( buffer , data ) NL buffer . append ( HEADER_TRANSFER_ENCODING_KEY ) . append ( :  ) . append ( chunked ) . append ( CRLF_STR ) NL buffer . append ( CRLF_STR ) NL  let headerSize = buffer . byteCount ( ) NL this . sock . write ( unsafe {  buffer . rawData ( ) . slice ( 0 , headerSize ) NL } ) NL if ( this . req . method == RequestMethod . HEAD ) {  return NL } NL } NL if ( dataSize == 0 ) {  return NL } NL  var lengthHex = UInt64ToHexString ( UInt64 ( dataSize ) ) NL this . sock . write ( lengthHex ) NL this . sock . write ( CRLF ) NL this . sock . write ( data ) NL this . sock . write ( CRLF ) NL }","func_name":"chunkedWrite","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"private func writeStartLine ( headerBuf : StringBuilder ) : Unit {   var version = if ( this . req . protoAtLeast ( 1 , 1 ) ) {  HTTP/1.1 NL } else {  HTTP/1.0 NL } NL  var text = STATUS_TEXT [ this . status ] NL headerBuf . append ( version ) . append (   ) NL headerBuf . append ( this . status ) . append (   ) NL headerBuf . append ( text ) . append ( CRLF_STR ) NL }","func_name":"writeStartLine","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"private func writeHeaderText ( headerBuf : StringBuilder , data : Array < Byte > ) {  headerBuf . append ( HEADER_DATE_KEY ) . append ( :  ) NL appendTime ( headerBuf ) NL headerBuf . append ( CRLF_STR ) NL  var connection : String NL if ( req . protoAtLeast ( 1 , 1 ) ) {  connection = keep-alive NL } else {  connection = close NL } NL connection = this . req . header . get ( HEADER_CONNECTION_KEY ) ?? connection NL connection = this . header_ . get ( HEADER_CONNECTION_KEY ) ?? connection NL headerBuf . append ( HEADER_CONNECTION_KEY ) . append ( :  ) . append ( connection ) . append ( CRLF_STR ) NL  let defultContentType = DetectContentType ( data ) NL  let contentType = this . header_ . get ( HEADER_CONTENT_TYPE_KEY ) ?? defultContentType NL headerBuf . append ( HEADER_CONTENT_TYPE_KEY ) . append ( :  ) . append ( contentType ) . append ( CRLF_STR ) NL  var xOptions = this . req . header . get ( X-Content-Type-Options ) ??  NL if ( ! xOptions . isEmpty ( ) ) {  headerBuf . append ( X-Content-Type-Options:  ) . append ( xOptions ) . append ( CRLF_STR ) NL } NL for ( ( ks , v ) in this . header_ ) {  if ( ks == HEADER_CONTENT_TYPE_KEY || ( ks == HEADER_TRANSFER_ENCODING_KEY && this . isChunked ) ) {  continue NL } NL  var k = HeaderDfaUtil . canonicalHeaderKey ( ks ) NL headerBuf . append ( k ) . append ( :  ) NL for ( i in v ) {  headerBuf . append ( i ) . append ( ; ) NL } NL headerBuf . removeLast ( ) NL headerBuf . append ( CRLF_STR ) NL } NL }","func_name":"writeHeaderText","docstring":""}
{"repo":"http2","file":"http1Response.cj","path":"http2/src/http/http1Response.cj","code_tokens":"public func setCookie ( w : ResponseWriteStream , cookie : Cookie ) : Unit {   var v = cookie . toString ( ) NL if ( v !=  ) {  w . header ( ) . add ( Set-Cookie , v ) NL } NL }","func_name":"setCookie","docstring":""}
{"repo":"http2","file":"http2Response.cj","path":"http2/src/http/http2Response.cj","code_tokens":"public func appendHeader ( head : HeadersFrame ) {  if ( this . isEndStream ) {  return this . unknownFrames . append ( head ) NL } NL this . myheaders . append ( head ) NL if ( head . getFlag ( 0x4 ) ) {  this . isEndHeader = true NL } NL if ( head . getFlag ( 0x1 ) ) {  this . isEndStream = true NL } NL }","func_name":"appendHeader","docstring":"/**\n     * The Function is appendHeader\n     *\n     * @param head of Http2Frame\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2Response.cj","path":"http2/src/http/http2Response.cj","code_tokens":"public func appendData ( data : DataFrame ) {  if ( this . isEndStream ) {  return this . unknownFrames . append ( data ) NL } NL this . mydatas . append ( data ) NL if ( data . getFlag ( 0x1 ) ) {  this . isEndStream = true NL } NL }","func_name":"appendData","docstring":"/**\n     * The Function is appendData\n     *\n     * @param data of Http2Frame\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2Response.cj","path":"http2/src/http/http2Response.cj","code_tokens":"public func rawCreatResponse ( requ : H2Request ) : Bool {   var contentLen = 0 NL  let allData = ByteArrayStream ( ) NL  let body = ByteArrayStream ( ) NL  var stat : String =  NL  var statInt = 200 NL  var isGzip = false NL try {  for ( h in this . myheaders ) {  for ( block in h . headerBlocks ) {   let headerFieldsSize : Int64 = decode . decode ( ByteBufferToArray ( block ) , headerFields ) NL  var index = 0 NL while ( index < headerFieldsSize && headerFields [ index ] . name != :status ) {  index ++ NL } NL if ( index != headerFieldsSize ) {  statInt = Int64 . parse ( headerFields [ index ] . value ) NL allData . write ( ${myproto} ${headerFields[index].value}\\n . toUtf8Array ( ) ) NL this . myheader . add ( headerFields [ index ] . name , headerFields [ index ] . value ) NL } NL for ( i in 0 .. headerFieldsSize where headerFields [ i ] . name != :status ) {  if ( headerFields [ i ] . name == content-encoding && headerFields [ i ] . value == gzip ) {  isGzip = true NL } NL allData . write ( ${headerFields[i].name}: ${headerFields[i].value}\\n . toUtf8Array ( ) ) NL this . myheader . add ( headerFields [ i ] . name , headerFields [ i ] . value ) NL if ( headerFields [ i ] . name == content-length || headerFields [ i ] . name == Content-Length ) {  contentLen = Int64 . parse ( headerFields [ i ] . value ) NL } NL } NL } NL } NL  let respTemp = H1Response ( myproto , statInt , this . myheader , Header ( ) , body , allData , 2 , 0 , contentLen ) NL this . respOpt = Some ( respTemp ) NL this . hReq = requ NL respTemp . request = requ . req NL match ( requ . req . method ) { case HEAD => ( ) NL case _ => allData . write ( \\n . toUtf8Array ( ) ) NL if ( isGzip ) {  gzipDeCompress ( ByteArrayStream ( ) , body , allData ) NL } else {  dataCopy ( body , allData ) NL } NL } NL return true NL } catch ( e : Exception ) {  e . printStackTrace ( ) NL return false NL } NL }","func_name":"rawCreatResponse","docstring":"/**\n     * The Function is rawCreatResponse\n     *\n     * @return Type of Bool\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2Response.cj","path":"http2/src/http/http2Response.cj","code_tokens":"func dataCopy ( output1 : OutputStream , output2 : OutputStream ) {  for ( d in this . mydatas ) {  for ( data in d . data ) {   let bytes = ByteBufferToArray ( data ) NL output1 . write ( bytes ) NL output2 . write ( bytes ) NL } NL } NL }","func_name":"dataCopy","docstring":""}
{"repo":"http2","file":"http2Response.cj","path":"http2/src/http/http2Response.cj","code_tokens":"func gzipDeCompress ( input : ByteArrayStream , output1 : OutputStream , output2 : OutputStream ) : Unit {  for ( d in this . mydatas ) {  for ( data in d . data ) {  input . write ( ByteBufferToArray ( data ) ) NL } NL } NL  var decompressInputStream = DecompressInputStream ( input , wrap : GzipFormat , bufLen : 10000 ) NL while ( true ) {   var readNum = decompressInputStream . read ( tempBuf ) NL if ( readNum <= 0 ) {  break NL } NL  let utf8data = tempBuf [ 0 .. readNum ] NL output1 . write ( utf8data ) NL output2 . write ( utf8data ) NL } NL decompressInputStream . close ( ) NL }","func_name":"gzipDeCompress","docstring":""}
{"repo":"http2","file":"http2Response.cj","path":"http2/src/http/http2Response.cj","code_tokens":"public func getBody ( ) : Array < Byte > {   let byteas = ByteArrayStream ( ) NL resp . copyTo ( byteas ) NL return byteas . readToEnd ( ) NL }","func_name":"getBody","docstring":"/**\n     * The Function is write\n     *\n     * @param w of WriteStream\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2Request.cj","path":"http2/src/http/http2Request.cj","code_tokens":"public func appendHeader ( head : HeaderFrame ) {  match ( this . hReq ) { case Some ( v ) => return NL case None => ( ) NL } NL if ( this . isEndHeader ) {  this . unknownFrames . append ( head ) NL } NL match ( ( head as HeadersFrame ) ) { case Some ( v ) => headersCount ++ NL case None => ( ) NL } NL match ( ( head as ContinuationFrame ) ) { case Some ( v ) => isContinueation = true NL case None => ( ) NL } NL for ( bytes in head . headerBlocks ) {  this . blocksArr . appendAll ( ByteBufferToArray ( bytes ) ) NL } NL if ( head . getFlag ( 0x4 ) ) {  this . isEndHeader = true NL } NL if ( head . getFlag ( 0x1 ) ) {  this . isEndStream = true NL } else {  if ( headersCount > 1 ) {  throw Http2Exception ( ) NL } NL } NL if ( this . isEndHeader && this . isEndStream ) {  this . rawCreatResquest ( ) NL } NL }","func_name":"appendHeader","docstring":"/**\n     * The Function is appendHeader\n     *\n     * @param head of Http2Frame\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2Request.cj","path":"http2/src/http/http2Request.cj","code_tokens":"public func appendData ( data : DataFrame ) {  match ( this . hReq ) { case Some ( v ) => return NL case None => ( ) NL } NL if ( this . isEndStream ) {  throw Http2Exception ( Sends a DATA frame after sending RST_STREAM frame, The endpoint MUST treat this as a stream error of type ) NL } NL if ( isContinueation && ! this . isEndHeader ) {  throw Http2Exception ( ) NL } NL this . mydatas . append ( data ) NL if ( data . getFlag ( 0x4 ) ) {  this . isEndHeader = true NL } NL if ( data . getFlag ( 0x1 ) ) {  this . isEndStream = true NL } NL if ( this . isEndHeader && this . isEndStream ) {  this . rawCreatResquest ( ) NL } NL }","func_name":"appendData","docstring":"/**\n     * The Function is appendData\n     *\n     * @param data of Http2Frame\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2Request.cj","path":"http2/src/http/http2Request.cj","code_tokens":"func rawCreatResquest ( ) : Unit {  synchronized ( muLock ) {   var http1Method : ? RequestMethod = None NL  var http1Path =  NL  var http1Scheme =  NL  var http1Authority =  NL  var emptyPath = true NL while ( ! this . isdecoded ) {   let reqHeader = Header ( ) NL  let headerFields : Array < HeaderField > = unsafe {  this . decode . getOrThrow ( ) . decode ( this . blocksArr . getRawArray ( ) [ 0 .. blocksArr . size ] ) NL } NL for ( i in 0 .. headerFields . size ) {   let headerField = headerFields [ i ] NL if ( headerField . isPseudo ( ) ) {  if ( i > = 4 ) {  throw Http2Exception ( ) NL } NL match ( headerField . name ) { case :method => http1Method = match ( http1Method ) { case Some ( v ) => throw Http2Exception ( ) NL case None => getRequestMethod ( headerField . value ) NL } NL case :path => http1Path = if ( headerField . value !=  && http1Path ==  ) {  emptyPath = false NL headerField . value NL } else {  throw Http2Exception ( ) NL } NL case :scheme => http1Scheme = if ( ! headerField . value . isEmpty ( ) && http1Scheme . isEmpty ( ) ) {  headerField . value NL } else {  throw Http2Exception ( ) NL } NL case :authority => http1Authority = headerField . value NL case _ => throw Http2Exception ( ) NL } NL } else {  for ( c in headerField . name where c . isUpperCase ( ) ) {  throw Http2Exception ( ) NL } NL if ( headerField . name == connection || headerField . name == Connection ) {  throw Http2Exception ( ) NL } NL if ( headerField . name == te && headerField . value != trailers ) {  throw Http2Exception ( ) NL } NL reqHeader . add ( headerField . name , headerField . value ) NL } NL } NL if ( emptyPath ) {  throw Http2Exception ( ) NL } NL setReqField ( http1Method . getOrThrow ( ) , ${http1Scheme}://${http1Authority}${http1Path} , reqHeader ) NL } NL } NL }","func_name":"rawCreatResquest","docstring":"/**\n     * The Function is rawCreatResponse\n     *\n     * @return Type of Bool\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2Request.cj","path":"http2/src/http/http2Request.cj","code_tokens":"protected func setReqField ( http1Method : RequestMethod , urlpath : String , header : Header ) {  this . hReq = Request ( http1Method , urlpath ) NL this . req . header . remove ( User-Agent ) NL this . protoMajor = 2 NL this . protoMinor = 0 NL this . proto = myproto NL this . req . header = header NL this . isdecoded = true NL  let body = ( this . req . body as ByteArrayStream ) . getOrThrow ( ) NL for ( d in this . mydatas ) {  for ( data in d . data ) {  body . write ( ByteBufferToArray ( data ) ) NL } NL } NL match ( this . req . header . get ( content-length ) ) { case Some ( v ) => if ( v != body . length . toString ( ) ) {  throw Http2Exception ( ) NL } NL case None => ( ) NL } NL }","func_name":"setReqField","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func serverRun ( ) {  this . run ( Option < Request > . None ) NL }","func_name":"serverRun","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func clientRun ( req : Request ) {  this . run ( Option < Request > . Some ( req ) ) NL }","func_name":"clientRun","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"private func run ( cr : Option < Request > ) : Unit {  if ( this . readEnd ) {  return NL } NL  let requestMethod = match ( cr ) { case Some ( v ) => v . method . toString ( ) NL case None =>  NL } NL while ( true ) {   var lenNum = 0 NL match ( this . readTimeOut ) { case Some ( timeout ) => lenNum = this . socket . read ( this . readBuf , timeout ) NL case None => try {  lenNum = this . socket . read ( this . readBuf , Duration . millisecond ( 100 ) ) NL } catch ( e : SocketTimeoutException ) {  if ( this . httpReaderSuspend ) {  return NL } NL continue NL } NL } NL if ( lenNum <= 0 ) {  break NL } NL this . myLenNum = lenNum NL this . allBuf . write ( this . readBuf . slice ( 0 , lenNum ) ) NL if ( this . isParsingHeader ) {  this . parseHead ( ) NL if ( this . isParsingHeader ) {  continue NL } NL this . filteHeader ( ) NL } NL if ( requestMethod == HEAD ) {  break NL } NL if ( this . isChunked ) {   let crlfCrlfIndex = indexOf ( this . allBuf . bytes ( ) . slice ( this . bodyItemIndex , this . allBuf . length - this . bodyItemIndex ) , ZERO_CRLF_CRLF ) NL match ( crlfCrlfIndex ) { case Some ( x ) => break NL case None => this . filteBody ( lenNum ) NL continue NL } NL } else {  if ( this . allBuf . length - this . parsedIndex > = contentLength ) {  break NL } NL continue NL } NL } NL this . readEnd = true NL }","func_name":"run","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"protected func filteBody ( lenNum : Int64 ) {  if ( this . bodyItemIndex == this . parsedIndex ) {  this . bodyItemIndex = this . allBuf . length - ZERO_CRLF_CRLF . size NL } else {  this . bodyItemIndex += lenNum NL } NL }","func_name":"filteBody","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"protected func filteHeader ( ) {  match ( this . header . get ( Content-Length ) ) { case Some ( s ) => match ( Int64 . tryParse ( s ) ) { case Some ( n ) => this . contentLength = n NL case None => HttpException ( Content-Length is invalid: ${s}. ) NL } NL case None => this . contentLength = - 1 NL } NL match ( this . header . get ( Transfer-Encoding ) ) { case Some ( s ) => if ( s == chunked ) {  this . isChunked = true NL } NL case None => ( ) NL } NL this . bodyItemIndex = this . parsedIndex NL }","func_name":"filteHeader","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func getData ( ) : ( String , Header , ByteArrayStream , ByteArrayStream ) {   var body : ByteArrayStream = this . parseBody ( ) NL return ( this . startLine , this . header , body , this . allBuf ) NL }","func_name":"getData","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func getUnresolve ( ) : Array < Byte > {  return this . readBuf [ 24 .. this . myLenNum ] NL }","func_name":"getUnresolve","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func suspend ( ) : Unit {  if ( this . httpReaderSuspend ) {  return NL } NL this . httpReaderSuspend = true NL }","func_name":"suspend","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func resume ( ) : Unit {  if ( ! this . httpReaderSuspend ) {  return NL } NL this . httpReaderSuspend = false NL }","func_name":"resume","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func isSuspended ( ) : Bool {  return this . httpReaderSuspend NL }","func_name":"isSuspended","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func getSocket ( ) : SyncSockClient {  return this . socket NL }","func_name":"getSocket","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func isReadEnd ( ) : Bool {  return this . readEnd NL }","func_name":"isReadEnd","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func close ( ) {  this . closed = true NL }","func_name":"close","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"public func isClosed ( ) : Bool {  return this . closed NL }","func_name":"isClosed","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"private func parseHead ( ) : Unit {  if ( this . parsedIndex == 0 ) {   var crlfIndex = ( indexOf ( this . allBuf . bytes ( ) , CRLF ) ?? return ) NL this . parsedIndex = crlfIndex + CRLF . size NL this . startLine = String . fromUtf8 ( this . allBuf . bytes ( ) . slice ( 0 , crlfIndex ) ) NL } NL while ( true ) {  match ( indexOf ( this . allBuf . bytes ( ) . slice ( this . parsedIndex , this . allBuf . length - this . parsedIndex ) , CRLF ) ) { case Some ( i ) => if ( i == 0 ) {  this . isParsingHeader = false NL this . parsedIndex += ( i + CRLF . size ) NL return NL } NL  var oneLine = this . allBuf . bytes ( ) . slice ( this . parsedIndex , i ) NL  var colonIndex = indexOf ( oneLine , b':' ) ?? - 1 NL if ( colonIndex == - 1 ) {  throw HttpException ( Header data is invalid ) NL } NL  var key = String . fromUtf8 ( oneLine . slice ( 0 , colonIndex ) ) NL  var val = String . fromUtf8 ( trim ( oneLine . slice ( colonIndex + 1 , i - colonIndex - 1 ) , TRIM_BYTE ) ) NL this . header . add ( key , val ) NL this . parsedIndex += ( i + CRLF . size ) NL case None => return NL } NL } NL }","func_name":"parseHead","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"private func parseBody ( ) : ByteArrayStream {  if ( this . parsedIndex == this . allBuf . length ) {  return ByteArrayStream ( 0 ) NL } NL if ( this . startLine == PRI * HTTP/2.0 ) {   let arr = ByteArrayStream ( 2 ) NL arr . read ( SM ) NL return arr NL } NL if ( ! this . isChunked ) {   var bufferSlice = this . allBuf . bytes ( ) NL  var body = ByteArrayStream ( this . contentLength ) NL body . write ( bufferSlice . slice ( this . parsedIndex , this . contentLength ) ) NL return body NL } else {   var body = ByteArrayStream ( this . allBuf . length - this . parsedIndex ) NL  var bufferSlice = this . allBuf . bytes ( ) . slice ( this . parsedIndex , this . allBuf . length - this . parsedIndex ) NL do {   var crlfIndex = match ( indexOf ( bufferSlice , CRLF ) ) { case Some ( x ) => x NL case None => throw HttpException ( chunked data is invalid in the body ) NL } NL  var chunkLenStr = bufferSlice . slice ( 0 , crlfIndex ) NL  var chunkLen = match ( HexStringToUInt64 ( chunkLenStr ) ) { case Some ( x ) => Int64 ( x ) NL case None => throw HttpException ( chunked length data is invalid ) NL } NL if ( chunkLen == 0 ) {  break NL } NL body . write ( bufferSlice . slice ( crlfIndex + CRLF . size , chunkLen ) ) NL  var chunkStart = crlfIndex + CRLF . size + chunkLen + CRLF . size NL bufferSlice = bufferSlice . slice ( chunkStart , bufferSlice . size - chunkStart ) NL } while ( true ) NL return body NL } NL }","func_name":"parseBody","docstring":""}
{"repo":"http2","file":"http1Reader.cj","path":"http2/src/http/http1Reader.cj","code_tokens":"func HexStringToUInt64 ( arr : Array < Byte > ) : Option < UInt64 > {   var arrSize = arr . size NL  var num : UInt64 = 0 NL for ( i in 0 .. arrSize ) {   var b = arr [ i ] NL if ( b'0' <= b && b <= b'9' ) {  b = b - b'0' NL } else if ( b'a' <= b && b <= b'f' ) {  b = b - ( b'a' - 10 ) NL } else if ( b'A' <= b && b <= b'F' ) {  b = b - ( b'A' - 10 ) NL } else {  return None NL } NL num = num * 16 + UInt64 ( b ) NL } NL return Some ( num ) NL }","func_name":"HexStringToUInt64","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func checkRequest ( req : Request ) {  if ( this . httpClientSuspend . load ( ) ) {  throw Exception ( Client is suspended ) NL } NL if ( this . tlsEnabled ( ) && req . url . scheme == http ) {  throw Exception ( The https client can not send http request ) NL } else if ( ! this . tlsEnabled ( ) && req . url . scheme == https ) {  match ( this . transport ) { case Some ( v ) => ( ) NL case _ => throw Exception ( The http client can not send https request ) NL } NL } NL }","func_name":"checkRequest","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func filteRequest ( req : Request , icookies : HashMap < String , ArrayList < Cookie > > ) {  if ( keepalives ) {  req . header . set ( Connection , keep-alive ) NL } else {  req . header . set ( Connection , close ) NL } NL for ( c in req . cookies ( ) ) {  if ( icookies . contains ( c . name ) ) {  icookies [ c . name ] . append ( c ) NL } else {  icookies . put ( c . name , ArrayList ( [ c ] ) ) NL ( ) NL } NL } NL }","func_name":"filteRequest","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func doRedirect ( req : Request , resp : H1Response , redirectMethod : String , includeBody : Bool , clonedHeader : Header , reqs : ArrayList < Request > , icookies : HashMap < String , ArrayList < Cookie > > ) : Request {   var ireq = req NL  var loc = match ( resp . header . get ( Location ) ) { case Some ( v ) => v . trim ( ) NL case None => throw HttpResponseException ( response missing Location header, status code: ${resp.statusCode} ) NL } NL  let url = URL . parse ( loc ) NL  let refUrl = ireq . url . resolveReference ( url ) NL  var host =  NL if ( ireq . host !=  && ireq . host != ireq . url . host && ! url . isAbs ( ) ) {  host = ireq . host NL } NL ireq = reqs [ 0 ] NL  let redReq = Request ( getRequestMethod ( redirectMethod ) , refUrl . toString ( ) ) NL if ( includeBody ) {  redReq . body = ireq . body NL } NL if ( keepalives ) {  redReq . header . set ( Connection , keep-alive ) NL } else {  redReq . header . set ( Connection , close ) NL } NL copyHeader ( ireq , redReq , clonedHeader , icookies ) NL  let ref = refererForURL ( reqs [ reqs . size - 1 ] . url , redReq . url ) NL if ( ref !=  ) {  redReq . header . set ( Referer , ref ) NL } NL checkRedirect ( redReq , reqs ) NL return redReq NL }","func_name":"doRedirect","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func doRequest ( req : Request ) : H1Response {   var ireq = req NL this . checkRequest ( ireq ) NL  var shouldRedirect : Bool = false NL  var redirectMethod =  NL  var includeBody = false NL  let reqs : ArrayList < Request > = ArrayList < Request > ( ) NL  var resp : H1Response = H1Response ( ) NL  let icookies : HashMap < String , ArrayList < Cookie > > = HashMap < String , ArrayList < Cookie > > ( ) NL this . filteRequest ( ireq , icookies ) NL try {  do {  if ( shouldRedirect ) {  ireq = doRedirect ( ireq , resp , redirectMethod , includeBody , ireq . header . clone ( ) , reqs , icookies ) NL } NL reqs . append ( ireq ) NL  let url : URL = ireq . url NL for ( cookie in jar . cookies ( url ) ) {  ireq . addCookie ( cookie ) NL } NL match ( this . transport ) { case Some ( trans ) => if ( readable ) {  ireq = parserfile ( ireq ) NL ireq . body = filedata . clone ( ) NL readable = false NL } NL if ( downloadable ) {  ireq = parsefile ( ireq ) NL } NL resp = send ( ireq , trans ) NL case None =>  let socket : SyncSockClient = this . createSocket ( ireq ) NL try {   var reader = HttpReader ( socket , this . timeout ) NL synchronized ( clientReaderListLock ) {  clientReaderList . append ( reader ) NL } NL resp = send ( ireq , Transport . getDefault ( reader ) ) NL } catch ( e : Exception ) {  throw e NL } finally {  socket . close ( ) NL } NL } NL  let cookieArr : Array < Cookie > = resp . cookies ( ) NL if ( cookieArr . size > 0 ) {  jar . setCookies ( url , cookieArr ) NL } NL  let ( should , include , method ) = checkResp ( ireq . method . toString ( ) , resp , reqs [ 0 ] ) NL shouldRedirect = should NL includeBody = include NL redirectMethod = method NL if ( downloadable ) {  resp = creatFile ( resp ) NL downloadable = false NL } NL } while ( shouldRedirect ) NL return resp NL } catch ( e : Exception ) {  throw e NL } NL }","func_name":"doRequest","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func createSocket ( request : Request ) : SyncSockClient {   var host : String = request . url . hostname ( ) NL  var port : UInt16 = 80 NL match ( UInt16 . tryParse ( request . url . port ( ) ) ) { case Some ( v ) => port = v NL case None => if ( request . url . rawurl . startsWith ( https ) ) {  port = 443 NL } else {  port = 80 NL } NL } NL if ( request . url . rawurl . startsWith ( https ) ) {  match ( this . tlsCfg ) { case Some ( v ) =>  var vv = v NL vv . verifyMode = VerifyNone NL  var tls : TlsSocket = TlsSocket ( TCP , host , port , vv ) NL return SyncSockClient ( tls ) NL case None => throw Exception ( TlsClientConfig must be set when sending https request. ) NL } NL } else {   var client : Socket = Socket ( TCP , host , port ) NL client . connect ( ) NL return SyncSockClient ( client ) NL } NL }","func_name":"createSocket","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func refererForURL ( lastReq : URL , newReq : URL ) : String {  if ( lastReq . scheme == https && newReq . scheme == http ) {  return  NL } NL  var referer = lastReq . toString ( ) NL if ( lastReq . user . username ( ) !=  ) {   var auth = lastReq . user . toString ( ) + @ NL referer = referer . replace ( auth ,  ) NL } NL return referer NL }","func_name":"refererForURL","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func parserfile ( req : Request ) : Request {   var resq : Request = req NL resq . header . set ( Content-Type , ${types}; boundary=----WebKitFormBoundaryari0emH33oMihIU4 ) NL return resq NL }","func_name":"parserfile","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func uploadFile ( filepath : String , url : String ) : Unit {  readable = true NL  let files : ( String , String ) = isFilePathValid ( filepath ) NL types = MimeType . getMimeType ( files [ 1 ] ) NL  let condis : String = form-data; name=\\\"file\\\"; filename=\\\" + files [ 0 ] + \\\";  NL  let fs : Array < Byte > = File . readFrom ( filepath ) NL filedata . write ( ------WebKitFormBoundaryari0emH33oMihIU4\\r\\n . toUtf8Array ( ) ) NL filedata . write ( ( Content-Disposition:  + condis + Content-Type:  + types + \\r\\n\\r\\n ) . toUtf8Array ( ) ) NL filedata . write ( fs ) NL filedata . write ( \\r\\n . toUtf8Array ( ) ) NL filedata . write ( ------WebKitFormBoundaryari0emH33oMihIU4-- . toUtf8Array ( ) ) NL this . filePost ( url ) NL }","func_name":"uploadFile","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func filePost ( url : String ) : Unit {   let body = ByteArrayStream ( ) NL  let req = Request ( RequestMethod . POST , url , body ) NL this . doRequest ( req ) NL }","func_name":"filePost","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func downloadFile ( downloadpath : String , url : String ) : Unit {  downloadable = true NL this . downloadpath = downloadpath NL this . filePost ( url ) NL }","func_name":"downloadFile","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func parsefile ( req : Request ) : Request {   var resq : Request = req NL  let isFiles : ( String , String ) = isFilePathValid ( downloadpath ) NL  let fileTypes : String = MimeType . getMimeType ( isFiles [ 1 ] ) NL  let contents : Option < String > = resq . header . get ( Content-Type ) NL match ( contents ) { case Some ( v ) => resq . header . set ( Content-Type , ${v}; +   + filename=\\\" + downloadpath + \\\" ) NL case None => resq . header . set ( Content-Type , ${fileTypes}; filename=\\\" + downloadpath + \\\" ) NL } NL return resq NL }","func_name":"parsefile","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func creatFile ( rep : H1Response ) : H1Response {   var resp : H1Response = rep NL  let bodys : String = String . fromUtf8 ( resp . body_ . readToEnd ( ) ) NL writeFile ( bodys ) NL resp . body_ = parseData ( bodys ) . clone ( ) NL  var allData : String = String . fromUtf8 ( resp . allData . readToEnd ( ) ) NL  let str : Int64 = allData . indexOf ( bodys ) . getOrThrow ( ) NL  let headerData : String = allData . substring ( 0 , str ) NL  let strs : Int64 = headerData . indexOf ( content-length ) . getOrThrow ( ) NL  let lastIndex : Int64 = headerData . indexOf ( \\n , strs + 1 ) . getOrThrow ( ) NL  let contents : String = headerData . substring ( strs , lastIndex - strs ) NL  let ssss = content-Length: ${resp.body_.length} NL allData = allData . replace ( contents , ssss ) NL resp . allData = parseData ( allData ) . clone ( ) NL return resp NL }","func_name":"creatFile","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func parseData ( data : String ) : ByteArrayStream {   let strs : Int64 = data . indexOf ( ------WebKitFormBoundaryari0emH33oMihIU4 ) . getOrThrow ( ) NL  let fileDatas : String = data . substring ( 0 , strs ) NL  var bodyData : ByteArrayStream = ByteArrayStream ( ) NL bodyData . write ( fileDatas . toUtf8Array ( ) ) NL return bodyData NL }","func_name":"parseData","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func writeFile ( str : String ) {   let strs : Int64 = str . indexOf ( filename ) . getOrThrow ( ) NL  let fileIndex : Int64 = str . indexOf ( \\r\\n , strs + 1 ) . getOrThrow ( ) NL  let secondIndex : Int64 = str . lastIndexOf ( ------WebKitFormBoundaryari0emH33oMihIU4-- ) . getOrThrow ( ) NL  let fileData : String = str . substring ( fileIndex + 2 , secondIndex - fileIndex - 4 ) NL  let strIndex : Int64 = str . indexOf ( \\\" , strs + 1 ) . getOrThrow ( ) NL  let str2 : Int64 = str . indexOf ( \\\" , strIndex + 1 ) . getOrThrow ( ) NL  let filename : String = str . substring ( strIndex + 1 , str2 - strIndex - 1 ) NL  let path = getcwd ( ) + / + filename NL  let fs : File = File ( path , CreateOrTruncate ( false ) ) NL if ( fs . canWrite ( ) ) {   let readFile = fs . write ( fileData . toUtf8Array ( ) ) NL fs . flush ( ) NL fs . close ( ) NL } else {  throw WriteException ( Can not write file ) NL } NL }","func_name":"writeFile","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func checkResp ( reqMethod : String , resp : H1Response , ireq : Request ) : ( Bool , Bool , String ) {   var redirectMethod = reqMethod NL  var shouldRedirect : Bool = true NL  var includeBody : Bool = false NL  var flag : Bool = true NL match ( resp . statusCode ) { case 301 | 302 | 303 => if ( reqMethod != GET && reqMethod != HEAD ) {  redirectMethod = GET NL } NL case 307 | 308 => match ( resp . header . get ( Location ) ) { case Some ( loc ) => if ( loc . size > 0 ) {  includeBody = true NL } else {  flag = false NL } NL case None => flag = false NL } NL case _ => shouldRedirect = false NL } NL return ( shouldRedirect , includeBody , redirectMethod ) NL }","func_name":"checkResp","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func canonicalAddr ( url : URL ) : String {   var ihost = url . hostname ( ) NL  let port = url . port ( ) NL if ( port ==  ) {  ihost = ihost + DEFAULT_PROTOCOL_PORT [ url . scheme ] NL } NL return ihost NL }","func_name":"canonicalAddr","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func isDomainOrSubdomain ( sub : String , parent : String ) {  if ( sub == parent ) {  return true NL } NL if ( ! sub . endsWith ( parent ) ) {  return false NL } NL return sub . endsWith ( . + parent ) NL }","func_name":"isDomainOrSubdomain","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func shouldCopyHeaderOnRedirect ( hrKey : String , pre : URL , dest : URL ) {   let chKey = HeaderDfaUtil . canonicalHeaderKey ( hrKey ) NL if ( chKey == Authorization || chKey == Www-Authenticate || chKey == Cookie || chKey == Cookie2 ) {   var ihost = canonicalAddr ( pre ) NL  var dhost = canonicalAddr ( dest ) NL return isDomainOrSubdomain ( dhost , ihost ) NL } else {  return true NL } NL }","func_name":"shouldCopyHeaderOnRedirect","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func copyHeader ( src : Request , dst : Request , header : MimeHeader , cookies : HashMap < String , ArrayList < Cookie > > ) {  if ( ! cookies . isEmpty ( ) ) {   var changed = false NL  var dstResp = H1Response ( ) NL  let respCookies = dstResp . cookies ( ) NL for ( c in respCookies ) {  cookies . remove ( c . name ) NL changed = true NL } NL if ( changed ) {   let ss = ArrayList < String > ( ) NL for ( ( _ , v ) in cookies ) {  for ( vv in v ) {  ss . append ( vv . name + = + vv . value ) NL } NL } NL ss . sortBy ( { a , b => a . compare ( b ) NL } , stable : true ) NL header . set ( Cookie , String . join ( Array < String > ( ss ) , delimiter : ; ) ) NL } NL } NL for ( ( k , vs ) in header ) {  if ( shouldCopyHeaderOnRedirect ( k , src . url , dst . url ) ) {  if ( dst . method . toString ( ) . equals ( GET ) && k . equals ( Content-Length ) ) {  continue NL } NL for ( vv in vs ) {  dst . header . set ( k , vv ) NL } NL } NL } NL }","func_name":"copyHeader","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"private func stripPassword ( u : URL ) : String {   var passSet = u . user . password ( ) NL match ( passSet ) { case Some ( x ) => u . toString ( ) . replace ( u . user . toString ( ) , u . user . username ( ) + :***@ ) NL case None => u . toString ( ) NL } NL }","func_name":"stripPassword","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func send ( req : Request ) : H1Response {  return this . doRequest ( req ) NL }","func_name":"send","docstring":"/**\n     * The Function is send\n     *\n     * @param req of Request\n     *\n     * @return Type of Option<H1Response>\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func get ( url : String ) : H1Response {   let req = Request ( RequestMethod . GET , url . replace ( 0.0.0.0 , 127.0.0.1 ) ) NL return this . doRequest ( req ) NL }","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @param url of String\n     *\n     * @return Type of Option<H1Response>\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func head ( url : String ) : H1Response {   let req = Request ( RequestMethod . HEAD , url . replace ( 0.0.0.0 , 127.0.0.1 ) ) NL return this . doRequest ( req ) NL }","func_name":"head","docstring":"/**\n     * The Function is head\n     *\n     * @param url of String\n     *\n     * @return Type of Option<H1Response>\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func post ( url : String , contentType : String , body : InputStream ) : H1Response {   let req = Request ( RequestMethod . POST , url . replace ( 0.0.0.0 , 127.0.0.1 ) , body ) NL req . header . set ( Content-Type , contentType ) NL return this . doRequest ( req ) NL }","func_name":"post","docstring":"/**\n     * The Function is post\n     *\n     * @param url of String\n     * @param contentType of String\n     * @param body of ReadStream\n     *\n     * @return Type of Option<H1Response>\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func postForm ( url : String , data : Form ) : H1Response {   var formData = data . encode ( ) NL  var input = ByteArrayStream ( ) NL input . write ( formData . toUtf8Array ( ) ) NL  let req = Request ( RequestMethod . POST , url . replace ( 0.0.0.0 , 127.0.0.1 ) , input ) NL req . header . set ( Content-Type , application/x-www-form-urlencoded ) NL return this . doRequest ( req ) NL }","func_name":"postForm","docstring":"/**\n     * The Function is postForm\n     *\n     * @param url of String\n     * @param data of Form\n     *\n     * @return Type of Option<H1Response>\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func postJson ( url : String , json : JsonValue ) : H1Response {   var jsonString = json . toString ( ) NL  var input = ByteArrayStream ( ) NL input . write ( jsonString . toUtf8Array ( ) ) NL  let req = Request ( RequestMethod . POST , url . replace ( 0.0.0.0 , 127.0.0.1 ) , input ) NL req . header . set ( Content-Type , application/json; charset=UTF-8 ) NL return this . doRequest ( req ) NL }","func_name":"postJson","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func put ( url : String , contentType : String , body : InputStream ) : H1Response {   let req = Request ( RequestMethod . PUT , url . replace ( 0.0.0.0 , 127.0.0.1 ) , body ) NL req . header . set ( Content-Type , contentType ) NL return this . doRequest ( req ) NL }","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param url of String\n     * @param contentType of String.\n     * @param body of ReadStream\n     *\n     * @return Type of Option<H1Response>\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func putForm ( url : String , data : Form ) : H1Response {   var formData = data . encode ( ) NL  var input = ByteArrayStream ( ) NL input . write ( formData . toUtf8Array ( ) ) NL  let req = Request ( RequestMethod . PUT , url . replace ( 0.0.0.0 , 127.0.0.1 ) , input ) NL req . header . set ( Content-Type , application/x-www-form-urlencoded ) NL return this . doRequest ( req ) NL }","func_name":"putForm","docstring":"/**\n     * The Function is putForm\n     *\n     * @param url of String\n     * @param data of Form\n     *\n     * @return Type of Option<H1Response>\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func putJson ( url : String , json : JsonValue ) : H1Response {   var jsonString = json . toString ( ) NL  var input = ByteArrayStream ( ) NL input . write ( jsonString . toUtf8Array ( ) ) NL  let req = Request ( RequestMethod . PUT , url . replace ( 0.0.0.0 , 127.0.0.1 ) , input ) NL req . header . set ( Content-Type , application/json; charset=UTF-8 ) NL return this . doRequest ( req ) NL }","func_name":"putJson","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func deleteForm ( url : String , data : Form ) : H1Response {   var formData = data . encode ( ) NL  var input = ByteArrayStream ( ) NL input . write ( formData . toUtf8Array ( ) ) NL  let req = Request ( RequestMethod . DELETE , url . replace ( 0.0.0.0 , 127.0.0.1 ) , input ) NL req . header . set ( Content-Type , application/x-www-form-urlencoded ) NL return this . doRequest ( req ) NL }","func_name":"deleteForm","docstring":"/**\n     * The Function is deleteForm\n     *\n     * @param url of String\n     * @param data of Form\n     *\n     * @return Type of Option<H1Response>\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func deleteJson ( url : String , json : JsonValue ) : H1Response {   var jsonString = json . toString ( ) NL  var input = ByteArrayStream ( ) NL input . read ( jsonString . toUtf8Array ( ) ) NL  let req = Request ( RequestMethod . DELETE , url . replace ( 0.0.0.0 , 127.0.0.1 ) , input ) NL req . header . set ( Content-Type , application/json; charset=UTF-8 ) NL return this . doRequest ( req ) NL }","func_name":"deleteJson","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func delete ( url : String , contentType : String , body : InputStream ) : H1Response {   let req = Request ( RequestMethod . DELETE , url . replace ( 0.0.0.0 , 127.0.0.1 ) , body ) NL req . header . set ( Content-Type , contentType ) NL return this . doRequest ( req ) NL }","func_name":"delete","docstring":"/**\n     * The Function is delete\n     *\n     * @param url of String\n     * @param contentType of String\n     * @param body of ReadStream\n     *\n     * @return Type of Option<H1Response>\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func suspend ( ) : Unit {  if ( this . tlsEnabled ( ) ) {  throw Exception ( https client does not support suspension ) NL } NL this . httpClientSuspend . store ( true ) NL synchronized ( clientReaderListLock ) {  for ( r in clientReaderList ) {  r . suspend ( ) NL } NL clientReaderList . clear ( ) NL } NL }","func_name":"suspend","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func resume ( ) : Unit {  if ( this . tlsEnabled ( ) ) {  throw Exception ( https client does not support suspension ) NL } NL this . httpClientSuspend . store ( false ) NL this . startScheduledTask ( ) NL }","func_name":"resume","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func isSuspended ( ) : Bool {  if ( this . tlsEnabled ( ) ) {  throw Exception ( https client does not support suspension ) NL } NL return this . httpClientSuspend . load ( ) NL }","func_name":"isSuspended","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public func tlsEnabled ( ) : Bool {  return match ( this . tlsCfg ) { case Some ( v ) => true NL case None => false NL } NL }","func_name":"tlsEnabled","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"public open func startScheduledTask ( ) {  spawn {  var sleepTime = TIMEOUT_100ms . nanoseconds ( ) NL  var allSleepTime = TIMEOUT_100ms . nanoseconds ( ) * 100 NL while ( true ) {   var i : Int64 = 0 NL while ( i < allSleepTime ) {  if ( this . httpClientSuspend . load ( ) ) {  return NL } NL sleep ( sleepTime ) NL i += sleepTime NL } NL synchronized ( clientReaderListLock ) {  if ( ! this . clientReaderList . isEmpty ( ) ) {  this . clientReaderList . removeIf ( { r : HttpReader => r . isClosed ( ) NL } ) NL } NL } NL } NL } NL }","func_name":"startScheduledTask","docstring":""}
{"repo":"http2","file":"http1Client.cj","path":"http2/src/http/http1Client.cj","code_tokens":"func defaultCheckRedirect ( req : Request , reqs : ArrayList < Request > ) : Unit {  if ( reqs . size > 10 ) {  throw Exception ( stopped after 10 redirects ) NL } NL }","func_name":"defaultCheckRedirect","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"public func isClosed ( ) : Bool {  return this . close NL }","func_name":"isClosed","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"public func isUncompressed ( ) : Bool {  return this . uncompressed NL }","func_name":"isUncompressed","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"public func cookies ( ) : Array < Cookie > {  return readSetCookies ( this . header ) NL }","func_name":"cookies","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"public func location ( ) : URL {   var lv = match ( this . header . get ( Location ) ) { case Some ( x ) => x NL case None => throw Exception ( no location ) NL } NL  var resUlr = URL . parse ( lv ) NL return resUlr NL }","func_name":"location","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"public func protoAtLeast ( major : Int64 , minor : Int64 ) : Bool {  return this . protoMajor > major || ( this . protoMajor == major && this . protoMinor > = minor ) NL }","func_name":"protoAtLeast","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"public func copyTo ( output : OutputStream ) : Unit {  this . body_ . copyTo ( output ) NL }","func_name":"copyTo","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"public func readToEnd ( ) : Array < Byte > {  return this . body_ . readToEnd ( ) NL }","func_name":"readToEnd","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"public func readTextToEnd ( ) : String {   var str = String . fromUtf8 ( this . body_ . bytes ( ) ) NL return str NL }","func_name":"readTextToEnd","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"func trimCookies ( cookies : Array < Cookie > ) : Array < Cookie > {   var buffer : ArrayList < Cookie > = ArrayList < Cookie > ( ) NL for ( temp in cookies ) {  if ( ! temp . toString ( ) . isEmpty ( ) ) {  buffer . append ( temp ) NL } NL } NL return Array < Cookie > ( buffer ) NL }","func_name":"trimCookies","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"func readSetCookies ( h : Header ) : Array < Cookie > {   var cookieCountBuffer = ArrayList < String > ( ) NL  var cookieCount = 0 NL try {  cookieCountBuffer = h . getAll ( Set-Cookie ) NL cookieCount = cookieCountBuffer . size NL } catch ( e : Exception ) {  return Array < Cookie > ( 0 , { i => Cookie ( ) NL } ) NL } NL  var cookies = Array < Cookie > ( cookieCount , { i => Cookie ( ) NL } ) NL for ( line in h . getAll ( Set-Cookie ) ) {   var parts = line . trim ( ) . split ( ; ) NL if ( parts . size == 1 && parts [ 0 ] ==  ) {  continue NL } NL parts . set ( 0 , parts [ 0 ] . trim ( ) ) NL  var jm = parts [ 0 ] . indexOf ( = ) NL  var j = match ( jm ) { case Some ( x ) => x NL case None => - 1 NL } NL if ( j < 0 ) {  continue NL } NL  var name = parts [ 0 ] . substring ( 0 , j ) NL  var value = parts [ 0 ] . substring ( j + 1 ) NL if ( ! isCookieNameValid ( name ) ) {  continue NL } NL  var valuehe = parseCookieValue ( value , true ) NL value = valuehe [ 0 ] NL if ( ! valuehe [ 1 ] ) {  continue NL } NL  var c = Cookie ( name , value , raw : line ) NL doCookieSplit ( parts , c ) NL  var buffer : ArrayList < Cookie > = ArrayList < Cookie > ( cookies ) NL buffer . append ( c ) NL cookies = Array < Cookie > ( buffer ) NL } NL return trimCookies ( cookies ) NL }","func_name":"readSetCookies","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"func doCookieSplit ( parts : Array < String > , c : Cookie ) {  for ( i in 1 .. parts . size ) {  parts . set ( i , parts [ i ] . trim ( ) ) NL if ( parts . size == 0 ) {  continue NL } NL  var ( lowerAttr , val ) = doFilterString ( parts , i ) NL  var valhe = parseCookieValue ( val , false ) NL val = valhe [ 0 ] NL if ( ! valhe [ 1 ] ) {   var buffer : ArrayList < String > = ArrayList < String > ( c . unparsed ) NL buffer . append ( parts [ i ] ) NL c . unparsed = Array < String > ( buffer ) NL continue NL } NL match ( lowerAttr ) { case samesite => match ( val . toLower ( ) ) { case lax => c . sameSite = SameSite . Lax NL case strict => c . sameSite = SameSite . Strict NL case none => c . sameSite = SameSite . None NL case _ => c . sameSite = SameSite . Default NL } NL continue NL case secure => c . secure = true NL continue NL case httponly => c . httpOnly = true NL continue NL case domain => c . domain = val NL continue NL case max-age =>  var secs = Int64 . tryParse ( val ) ?? 0 NL if ( secs != 0 && UInt8 ( UInt32 ( val [ 0 ] ) ) == UInt8 ( UInt32 ( 0 ) ) ) {  break NL } NL if ( secs <= 0 ) {  secs = - 1 NL } NL c . maxAge = secs NL continue NL case expires => c . rawExpires = val NL try {  c . expires = Time . parse ( val , FormatStyle . RFC1123 . value ( ) ) NL continue NL } catch ( e : Exception ) {  c . expires = Time ( 0 , 0 ) NL break NL } NL case path => c . path = val NL continue NL case _ => ( ) NL } NL  var buffer : ArrayList < String > = ArrayList < String > ( c . unparsed ) NL buffer . append ( parts [ i ] ) NL c . unparsed = Array < String > ( buffer ) NL } NL }","func_name":"doCookieSplit","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"func doFilterString ( parts : Array < String > , i : Int64 ) : ( String , String ) {   var attr = parts [ i ] NL  var val =  NL  var jd = attr . indexOf ( = ) NL  var j = match ( jd ) { case Some ( x ) => x NL case None => - 1 NL } NL if ( j > = 0 ) {   var yarr = attr NL attr = attr . substring ( 0 , j ) NL val = yarr . substring ( j + 1 ) NL } NL return ( attr . toLower ( ) , val ) NL }","func_name":"doFilterString","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"func isCookieNameValid ( str : String ) : Bool {  if ( str . equals (  ) ) {  return false NL } NL return indexFunc ( str ) < 0 NL }","func_name":"isCookieNameValid","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"func parseCookieValue ( raw : String , flag : Bool ) : ( String , Bool ) {   var str = raw NL if ( flag && str . size > 1 && str [ 0 ] == \\\" && str [ str . size - 1 ] == \\\" ) {  str = str . substring ( 1 , str . size - 1 ) NL } NL for ( i in str ) {  if ( ! validCookieValueByte ( i ) ) {  return (  , false ) NL } NL } NL return ( str , true ) NL }","func_name":"parseCookieValue","docstring":""}
{"repo":"http2","file":"h1Response.cj","path":"http2/src/http/h1Response.cj","code_tokens":"func validCookieValueByte ( c : Char ) : Bool {  return 0x20 <= UInt32 ( c ) && UInt32 ( c ) < 0x7f && c != \\\" && c != ; && c != \\\\ NL }","func_name":"validCookieValueByte","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func idleTimeoutFunc ( ) : Duration {  if ( idleTimeout . nanoseconds ( ) != 0 ) {  return idleTimeout NL } NL return readTimeout NL }","func_name":"idleTimeoutFunc","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func readHeaderTimeoutFunc ( ) : Duration {  if ( readHeaderTimeout . nanoseconds ( ) != 0 ) {  return readHeaderTimeout NL } NL return readTimeout NL }","func_name":"readHeaderTimeoutFunc","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func close ( ) : Unit {  if ( this . isClosed ( ) || this . isClosing ( ) ) {  return NL } NL this . status . store ( H1Server . CLOSING ) NL try {  for ( closeFunc in onShutdown ) {  closeFunc ( ) NL } NL } finally {  synchronized ( this . socketServerListLock ) {  for ( ss in this . socketServerList ) {  ss . close ( ) NL } NL this . socketServerList . clear ( ) NL } NL synchronized ( this . readerListLock ) {  for ( r in this . readerList ) {  r . close ( ) NL } NL this . readerList . clear ( ) NL } NL this . status . store ( H1Server . CLOSED ) NL onShutdown . clear ( ) NL } NL }","func_name":"close","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func suspend ( ) : Unit {  if ( this . isClosed ( ) || this . isClosing ( ) ) {  return NL } NL if ( this . tlsEnabled ( ) ) {  throw HttpException ( Https server does not support suspension. ) NL } NL if ( this . httpServerSuspend . load ( ) ) {  return NL } NL this . httpServerSuspend . store ( true ) NL synchronized ( this . readerListLock ) {  for ( r in this . readerList ) {  r . suspend ( ) NL } NL } NL sleep ( TIMEOUT_100ms . nanoseconds ( ) ) NL this . isAddingSocketServerList . store ( false ) NL }","func_name":"suspend","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func resume ( ) : Unit {  if ( this . isClosed ( ) || this . isClosing ( ) ) {  return NL } NL if ( this . tlsEnabled ( ) ) {  throw HttpException ( Https server does not support suspension. ) NL } NL if ( ! this . httpServerSuspend . load ( ) ) {  return NL } NL this . httpServerSuspend . store ( false ) NL synchronized ( this . readerListLock ) {  for ( r in this . readerList ) {  r . resume ( ) NL this . handle ( r ) NL } NL } NL synchronized ( this . socketServerListLock ) {  for ( s in this . socketServerList ) {  match ( s ) { case SockServer . SocketS ( server ) => spawn { this . serve ( server ) NL } NL case SockServer . TlsS ( server ) => throw HttpException ( Https does not support suspension. ) NL } NL } NL } NL this . startScheduledTask ( ) NL this . isAddingSocketServerList . store ( true ) NL }","func_name":"resume","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func isSuspended ( ) : Bool {  if ( this . tlsEnabled ( ) ) {  throw HttpException ( Https does not support suspension. ) NL } NL return this . httpServerSuspend . load ( ) NL }","func_name":"isSuspended","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func tlsEnabled ( ) : Bool {  return match ( this . tlsCfg ) { case Some ( v ) => true NL case None => false NL } NL }","func_name":"tlsEnabled","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public open func listenAndServe ( ) : Unit {  if ( this . isClosed ( ) || this . isClosing ( ) ) {  throw IllegalArgumentException ( Server closed ) NL } NL try {  if ( ! this . tlsEnabled ( ) ) {   var server = SocketServer ( SocketNet . TCP , 127.0.0.1 , port ) NL this . serve ( server ) NL } else {  match ( this . tlsCfg ) { case Some ( v ) =>  var tlsServer = TlsSocketServer ( SocketNet . TCP , 127.0.0.1 , port , v ) NL this . serve ( tlsServer ) NL case None => throw HttpException ( The https server must have TlsServerConfig. ) NL } NL } NL } catch ( e : SocketException ) {  if ( e . message . contains ( 10048: Unknown error ) ) {  throw Exception ( Address already in use. ) NL } NL } finally {  this . close ( ) NL } NL }","func_name":"listenAndServe","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public open func serve ( listener : SocketServer ) : Unit {  if ( this . isClosed ( ) || this . isClosing ( ) ) {  throw IllegalArgumentException ( Server is closed ) NL } NL if ( this . tlsEnabled ( ) ) {  throw HttpException ( The server is http server, server function need param of TlsSocketServer type.. ) NL } NL if ( this . isAddingSocketServerList . load ( ) ) {  synchronized ( socketServerListLock ) {  this . socketServerList . append ( SockServer . SocketS ( listener ) ) NL } NL } NL for ( f in this . onStart ) {  f ( listener ) NL } NL while ( true ) {  if ( this . isClosing ( ) || this . isClosed ( ) ) {  break NL } NL sleep ( 100 ) NL  var socket : Socket = try {  listener . accept ( TIMEOUT_100ms ) NL } catch ( e : SocketTimeoutException ) {  if ( this . httpServerSuspend . load ( ) || this . isClosing ( ) || this . isClosed ( ) ) {  return NL } else {  continue NL } NL } catch ( e : SocketException ) {  continue NL } NL try {  if ( this . isClosing ( ) || this . isClosed ( ) ) {  return NL } NL for ( f in this . afterAccept ) {  f ( listener , socket ) NL } NL  var reader = HttpReader ( SyncSockClient ( socket ) ) NL synchronized ( this . readerListLock ) {  this . readerList . append ( reader ) NL } NL this . handle ( reader ) NL } catch ( e : Exception ) {  e . printStackTrace ( ) NL } NL } NL }","func_name":"serve","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public open func serve ( listener : TlsSocketServer ) : Unit {  if ( this . isClosed ( ) || this . isClosing ( ) ) {  throw IllegalArgumentException ( Server is closed ) NL } NL if ( ! this . tlsEnabled ( ) ) {  throw HttpException ( The server is http server, server function need param of TlsSocketServer type.. ) NL } NL if ( this . isAddingSocketServerList . load ( ) ) {  synchronized ( socketServerListLock ) {  this . socketServerList . append ( SockServer . TlsS ( listener ) ) NL } NL } NL for ( f in this . onStart ) {  f ( listener . socketServer ) NL } NL while ( true ) {  if ( this . isClosing ( ) || this . isClosed ( ) ) {  return NL } NL try {   let tls = listener . accept ( ) NL if ( this . isClosing ( ) || this . isClosed ( ) ) {  return NL } NL for ( f in this . afterAccept ) {  f ( listener . socketServer , tls . socket ) NL } NL  var reader = HttpReader ( SyncSockClient ( tls ) ) NL synchronized ( this . readerListLock ) {  this . readerList . append ( reader ) NL } NL this . handle ( reader ) NL } catch ( e : Exception ) {  e . printStackTrace ( ) NL } NL } NL }","func_name":"serve","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func registerOnShutdown ( f : ( ) -> Unit ) : Unit {  if ( this . isClosing ( ) || this . isClosed ( ) ) {  return NL } NL onShutdown . append ( f ) NL }","func_name":"registerOnShutdown","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func registerOnStart ( f : ( SocketServer ) -> Unit ) {  if ( this . isClosing ( ) || this . isClosed ( ) ) {  return NL } NL this . onStart . append ( f ) NL }","func_name":"registerOnStart","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func registerAfterAccept ( f : ( SocketServer , Socket ) -> Unit ) {  if ( this . isClosing ( ) || this . isClosed ( ) ) {  return NL } NL this . afterAccept . append ( f ) NL }","func_name":"registerAfterAccept","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"protected func setKeepAlivesEnabled ( v : Bool ) : Unit {  if ( v ) {  this . disableKeepAlives = 0 NL return NL } NL this . disableKeepAlives = 1 NL }","func_name":"setKeepAlivesEnabled","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"protected open func handle ( reader : HttpReader ) : Unit {  if ( reader . isClosed ( ) ) {  return NL } NL spawn {  let socket = reader . getSocket ( ) NL try {  if ( ! reader . isReadEnd ( ) ) {  reader . serverRun ( ) NL } NL if ( ! reader . isReadEnd ( ) ) {  return NL } NL  var ( startLine , header , body , _ ) : ( String , Header , ByteArrayStream , ByteArrayStream ) = reader . getData ( ) NL  var conn = H1Conn ( this , socket ) NL conn . serve ( startLine , header , body ) NL if ( conn . httpVs == HTTP/1.0 ) {  socket . close ( ) NL } else if ( conn . httpVs == HTTP/1.1 ) {  if ( conn . connection == close ) {  socket . close ( ) NL } NL } NL } catch ( e : Exception ) {  socket . close ( ) NL e . printStackTrace ( ) NL } finally {  reader . close ( ) NL } NL } NL }","func_name":"handle","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"protected func startScheduledTask ( ) {  spawn {  var sleepTime = Duration . millisecond ( 100 ) . nanoseconds ( ) NL  var allSleepTime = Duration . millisecond ( 1000 ) . nanoseconds ( ) * 10 NL while ( true ) {   var i : Int64 = 0 NL while ( i < allSleepTime ) {  if ( this . httpServerSuspend . load ( ) || this . isClosing ( ) || this . isClosed ( ) ) {  return NL } NL sleep ( sleepTime ) NL i += sleepTime NL } NL synchronized ( this . socketServerListLock ) {  if ( ! this . socketServerList . isEmpty ( ) ) {  this . socketServerList . removeIf ( { ss : SockServer => ss . isClosed ( ) NL } ) NL } NL } NL synchronized ( this . readerListLock ) {  if ( ! this . readerList . isEmpty ( ) ) {  this . readerList . removeIf ( { r : HttpReader => r . isClosed ( ) NL } ) NL } NL } NL } NL } NL }","func_name":"startScheduledTask","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"protected func isClosed ( ) {  return this . status . load ( ) == 0 NL }","func_name":"isClosed","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"protected func isClosing ( ) {  return this . status . load ( ) == 2 NL }","func_name":"isClosing","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"protected func serve ( startLine : String , header : Header , body : ByteArrayStream ) : Unit {   var req : Request = Request ( RequestMethod . GET , / , body ) NL req . header = header NL this . readRequest ( req , startLine ) NL if ( ! this . http1ServerSupportsRequest ( req ) ) {  throw Exception ( unsupported protocol version ) NL } NL  var response = Http1Response ( req , this . socket ) NL server . handler . serveHTTP ( response , req ) NL response . writeFinished ( ) NL  var con : Option < String > = req . header . get ( Connection ) NL match ( con ) { case Some ( value ) => connection = value . trim ( ) NL case _ => ( ) NL } NL timer . reset ( server . httpKeepAliveTimeout , { => this . socket . close ( ) NL } ) NL return NL }","func_name":"serve","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"protected func readRequest ( req : Request , startLine : String ) {   var ( method , requestURI , proto ) = this . parseRequestLine ( startLine ) NL req . requestURI = requestURI NL match ( RequestMethod . parse ( method ) ) { case Some ( v ) => ( ) NL case None => throw IllegalArgumentException ( invalid method + method + \\n ) NL } NL httpVs = proto NL  var httpVersion : ( Int64 , Int64 , Bool ) = this . parseHTTPVersion ( proto ) NL if ( ! httpVersion [ 2 ] ) {  throw IllegalArgumentException ( malformed HTTP version + \\n ) NL } NL req . method = this . matchMethod ( method ) NL  var rawurl : String = requestURI NL  var justAuthority : Bool = ( method == CONNECT ) && rawurl . startsWith ( / ) NL if ( justAuthority ) {  if ( ! this . server . tlsEnabled ( ) ) {  rawurl = http:// + rawurl NL } else {  rawurl = https:// + rawurl NL } NL } NL req . url = URL . parse ( rawurl ) NL if ( justAuthority ) {  req . url . scheme =  NL } NL req . host = req . url . host NL if ( req . host . isEmpty ( ) ) {  req . host = req . header . get ( Host ) . getOrThrow ( ) NL } NL fixPragmaCacheControl ( req . header ) NL }","func_name":"readRequest","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"private func parseRequestLine ( line : String ) : ( String , String , String ) {   let arr : Array < String > = line . split (   ) NL  var method : String = arr [ 0 ] NL  var requestUri : String = arr [ 1 ] NL  var proto : String = arr [ 2 ] NL return ( method . trim ( ) , requestUri . trim ( ) , proto . trim ( ) ) NL }","func_name":"parseRequestLine","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"private func parseHTTPVersion ( vers : String ) : ( Int64 , Int64 , Bool ) {   let big : Int64 = 1000000 NL if ( vers == HTTP/1.1 ) {  return ( 1 , 1 , true ) NL } else if ( vers == HTTP/1.0 ) {  return ( 1 , 0 , true ) NL } NL if ( ! vers . startsWith ( HTTP/ ) ) {  return ( 0 , 0 , false ) NL } NL  var index : Int64 = getIndex ( vers , . , true ) NL if ( index == - 1 ) {  return ( 0 , 0 , false ) NL } NL  var majorStr : String = vers . substring ( 5 , index - 5 ) NL  var resultMajor : Option < Int64 > = Int64 . tryParse ( majorStr ) NL  var major : Int64 = 0 NL  var minor : Int64 = 0 NL  var err = false NL match ( resultMajor ) { case Some ( v ) => major = v NL case None => err = true NL } NL if ( err || major < 0 || major > big ) {  return ( 0 , 0 , false ) NL } NL  var minorStr : String = vers . substring ( index + 1 , ( vers . size - index - 1 ) ) NL  var resultMinor : Option < Int64 > = Int64 . tryParse ( minorStr ) NL match ( resultMinor ) { case Some ( v ) => minor = v NL case None => err = true NL } NL if ( err || major < 0 || major > big ) {  return ( 0 , 0 , false ) NL } NL return ( major , minor , true ) NL }","func_name":"parseHTTPVersion","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"public func fixPragmaCacheControl ( header : Header ) : Unit {   var hp : Option < String > = header . get ( Pragma ) NL  var result : String = match ( hp ) { case Some ( v ) => v NL case None =>  NL } NL if ( result . size > 0 && result == no-cache ) {   var presentcc : Option < String > = header . get ( Cache-Control ) NL match ( presentcc ) { case Some ( v ) => ( ) NL case None => header . set ( Cache-Control , no-cache ) NL } NL } NL }","func_name":"fixPragmaCacheControl","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"private func http1ServerSupportsRequest ( req : Request ) : Bool {  if ( req . protoMajor == 1 ) {  return true NL } NL if ( req . protoMajor == 2 && req . protoMinor == 0 && req . method . toString ( ) == PRI && req . requestURI == * ) {  return true NL } NL return false NL }","func_name":"http1ServerSupportsRequest","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"private func matchMethod ( method : String ) : RequestMethod {  return match ( method ) { case GET => RequestMethod . GET NL case HEAD => RequestMethod . HEAD NL case POST => RequestMethod . POST NL case PUT => RequestMethod . PUT NL case DELETE => RequestMethod . DELETE NL case CONNECT => RequestMethod . CONNECT NL case OPTIONS => RequestMethod . OPTIONS NL case PATCH => RequestMethod . PATCH NL case TRACE => RequestMethod . TRACE NL case _ => throw Exception ( ) NL } NL }","func_name":"matchMethod","docstring":""}
{"repo":"http2","file":"http1Server.cj","path":"http2/src/http/http1Server.cj","code_tokens":"func getIndex ( str : String , c : Char , b : Bool ) : Int64 {   var l : Option < Int64 > NL if ( b ) {  l = str . indexOf ( c ) NL } else {  l = str . lastIndexOf ( c ) NL } NL  let index : Int64 = match ( l ) { case Some ( x ) => x NL case None => - 1 NL } NL return index NL }","func_name":"getIndex","docstring":""}
{"repo":"http2","file":"http1Sig.cj","path":"http2/src/http/http1Sig.cj","code_tokens":"func HasPrefix ( s : Array < UInt8 > , prefix : Array < UInt8 > ) : Bool {  if ( s . size < prefix . size ) {  return false NL } NL for ( i in 0 .. s . size where s [ i ] != prefix [ i ] ) {  return false NL } NL return true NL }","func_name":"HasPrefix","docstring":""}
{"repo":"http2","file":"http1Sig.cj","path":"http2/src/http/http1Sig.cj","code_tokens":"public func matchSig ( data : Array < UInt8 > , firstNonWS : Int64 ) : String","func_name":"matchSig","docstring":""}
{"repo":"http2","file":"http1Sig.cj","path":"http2/src/http/http1Sig.cj","code_tokens":"public func matchSig ( data : Array < UInt8 > , firstNonWS : Int64 ) : String {   let newData = data [ 0 .. firstNonWS ] NL if ( newData . size < value . size + 1 ) {  return  NL } NL  var i = 0 NL for ( b in value ) {   var db = newData [ i ] NL  let ch = Char ( UInt32 ( b ) ) NL if ( A <= ch && ch <= Z ) {  db = db & 0xDF NL } NL if ( b != db ) {  return  NL } NL i ++ NL } NL if ( ! isTT ( newData [ value . size ] ) ) {  return  NL } NL return text/html; charset=utf-8 NL }","func_name":"matchSig","docstring":""}
{"repo":"http2","file":"http1Sig.cj","path":"http2/src/http/http1Sig.cj","code_tokens":"public func matchSig ( data : Array < UInt8 > , firstNonWS : Int64 ) : String {   let newData = if ( skipWS ) {  data [ 0 .. firstNonWS ] NL } else {  data NL } NL if ( pat . size != mask . size ) {  return  NL } NL if ( newData . size < pat . size ) {  return  NL } NL  var i = 0 NL for ( pb in 0 .. pat . size ) {   var maskedData = newData [ i ] & mask [ i ] NL i ++ NL if ( maskedData != pat [ pb ] ) {  return  NL } NL } NL return ct NL }","func_name":"matchSig","docstring":""}
{"repo":"http2","file":"http1Sig.cj","path":"http2/src/http/http1Sig.cj","code_tokens":"public func matchSig ( data : Array < UInt8 > , firstNonWS : Int64 ) : String {  if ( HasPrefix ( data , sig ) ) {  return ct NL } NL return  NL }","func_name":"matchSig","docstring":""}
{"repo":"http2","file":"http1Sig.cj","path":"http2/src/http/http1Sig.cj","code_tokens":"public func matchSig ( data : Array < UInt8 > , firstNonWS : Int64 ) : String {  if ( data . size < 12 ) {  return  NL } NL return  NL }","func_name":"matchSig","docstring":""}
{"repo":"http2","file":"http1Sig.cj","path":"http2/src/http/http1Sig.cj","code_tokens":"public func matchSig ( data : Array < UInt8 > , firstNonWS : Int64 ) : String {   let newData = Array < UInt8 > ( data . size - firstNonWS , { i => data [ firstNonWS + i ] NL } ) NL for ( b in newData ) {  if ( b <= 0x08 || ( b > = 0x0E && b <= 0x1A ) || ( b > = 0x1C && b <= 0x1F ) ) {  return  NL } NL } NL return text/plain; charset=utf-8 NL }","func_name":"matchSig","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"static public func build ( t : TlsSocketServer ) : SockServer {  return SockServer . TlsS ( t ) NL }","func_name":"build","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"static public func build ( t : SocketServer ) : SockServer {  return SockServer . SocketS ( t ) NL }","func_name":"build","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public func close ( ) : Unit {  return match ( this ) { case SocketS ( server ) => server . close ( ) NL case TlsS ( server ) => server . close ( ) NL } NL }","func_name":"close","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public func isClosed ( ) : Bool {  return match ( this ) { case SocketS ( server ) => server . isClosed ( ) NL case TlsS ( server ) => server . isClosed ( ) NL } NL }","func_name":"isClosed","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public func hashCode ( ) : Int64 {  return match ( this ) { case SocketS ( v ) => v . toString ( ) . hashCode ( ) << 16 | Int64 ( v . port ) NL case TlsS ( v ) => v . toString ( ) . hashCode ( ) << 16 | Int64 ( v . port ) NL } NL }","func_name":"hashCode","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public operator func == ( that : SockServer ) : Bool {  return match ( ( this , that ) ) { case ( SocketS ( n ) , SocketS ( m ) ) => if ( n . port != m . port ) {  return false NL } NL if ( n . address != m . address ) {  return false NL } NL return true NL case ( TlsS ( n ) , TlsS ( m ) ) => if ( n . port != m . port ) {  return false NL } NL if ( n . address != m . address ) {  return false NL } NL return true NL case ( SocketS ( n ) , TlsS ( m ) ) => false NL case ( TlsS ( n ) , SocketS ( m ) ) => false NL } NL }","func_name":"==","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public operator func != ( that : SockServer ) : Bool {  return ! ( this == that ) NL }","func_name":"!=","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"static public func build ( t : TlsSocket ) : SyncSockClient {  return SyncSockClient ( t ) NL }","func_name":"build","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"static public func build ( t : Socket ) : SyncSockClient {  return SyncSockClient ( t ) NL }","func_name":"build","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"@ fastCall   public func read ( buffer : Array < Byte > ) : Int64 {  synchronized ( readLock ) {  return match ( socketConn ) { case SocketC ( conn ) => conn . read ( buffer ) NL case TlsC ( conn ) => conn . read ( buffer ) NL } NL } NL }","func_name":"read","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"@ fastCall   public func read ( buffer : Array < Byte > , timeout : Duration ) : Int64 {  synchronized ( readLock ) {  return match ( socketConn ) { case SocketC ( conn ) => conn . read ( buffer , timeout ) NL case TlsC ( conn ) => conn . read ( buffer ) NL } NL } NL }","func_name":"read","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public func write ( buffer : Array < Byte > ) : Unit {  synchronized ( writeLock ) {  return match ( socketConn ) { case SocketC ( conn ) => this . writeBuff . write ( buffer ) NL case TlsC ( conn ) => this . writeBuff . write ( buffer ) NL } NL } NL }","func_name":"write","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public func write ( frame : Http2Frame ) : Unit {  synchronized ( writeLock ) {  getUInt8FromFrames ( frame ) NL } NL }","func_name":"write","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public func writeAndFlush ( buffer : Array < Byte > ) : Unit {  synchronized ( writeLock ) {  this . writeBuff . flush ( ) NL return match ( socketConn ) { case SocketC ( conn ) => conn . write ( buffer ) NL case TlsC ( conn ) => conn . write ( buffer ) NL } NL } NL }","func_name":"writeAndFlush","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public func writeAndFlush ( frame : Http2Frame ) : Unit {  synchronized ( writeLock ) {  getUInt8FromFrames ( frame ) NL this . writeBuff . flush ( ) NL } NL }","func_name":"writeAndFlush","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"func getUInt8FromFrames ( frame : Http2Frame ) : Unit {   func callback ( bb : ByteBuffer ) : Unit {  this . write ( ByteBufferToArray ( bb ) ) NL } NL fe . encodeFrame ( frame , callback ) NL }","func_name":"getUInt8FromFrames","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"func callback ( bb : ByteBuffer ) : Unit {  this . write ( ByteBufferToArray ( bb ) ) NL }","func_name":"callback","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public func close ( ) : Unit {  return match ( socketConn ) { case SocketC ( conn ) => conn . close ( ) NL case TlsC ( conn ) => conn . close ( ) NL } NL }","func_name":"close","docstring":""}
{"repo":"http2","file":"socket.cj","path":"http2/src/tcp/socket.cj","code_tokens":"public func flush ( ) {  synchronized ( writeLock ) {  this . writeBuff . flush ( ) NL } NL }","func_name":"flush","docstring":""}
{"repo":"http2","file":"http2StateMachine.cj","path":"http2/src/proto/http2StateMachine.cj","code_tokens":"func updateStreamState ( cs : H2ServerStream , action : Int64 , streamAction : Int64 ) : Unit {  cs . state = match ( cs . state ) { case IDLE => STREAM_IDLE_MACHINE [ action ] [ streamAction ] NL case OPEN => STREAM_OPEN_MACHINE [ action ] [ streamAction ] NL case RESERVED_LOCAL => STREAM_RESERVED_LOCAL_MACHINE [ action ] [ streamAction ] NL case RESERVED_REMOTE => STREAM_RESERVED_REMOTE_MACHINE [ action ] [ streamAction ] NL case HALF_CLOSED_REMOTE => STREAM_HALF_CLOSED_REMOTE_MACHINE [ action ] [ streamAction ] NL case HALF_CLOSED_LOCAL => STREAM_HALF_CLOSED_LOCAL_MACHINE [ action ] [ streamAction ] NL case CLOSED => STREAM_CLOSED_MACHINE [ action ] [ streamAction ] NL case ERROR => throw Http2Exception ( ) NL } NL match ( cs . state ) { case ERROR => throw Http2Exception ( ) NL case _ => ( ) NL } NL }","func_name":"updateStreamState","docstring":"// nextStreamState"}
{"repo":"http2","file":"http2StateMachine.cj","path":"http2/src/proto/http2StateMachine.cj","code_tokens":"func updateConnState ( cs : H2ServerConn , action : Int64 , connAction : Int64 ) : Unit {  cs . connState = match ( cs . connState ) { case IDLE => CONNECT_IDLE_MACHINE [ action ] [ connAction ] NL case SERVER_OPEN => CONNECT_SERVER_OPEN_MACHINE [ action ] [ connAction ] NL case CLIENT_OPEN => CONNECT_CLIENT_OPEN_MACHINE [ action ] [ connAction ] NL case CLOSE => CONNECT_CLOSE_MACHINE [ action ] [ connAction ] NL case ERROR => throw Http2Exception ( ) NL } NL match ( cs . connState ) { case ERROR => throw Http2Exception ( ) NL case _ => ( ) NL } NL }","func_name":"updateConnState","docstring":""}
{"repo":"http2","file":"http2StateMachine.cj","path":"http2/src/proto/http2StateMachine.cj","code_tokens":"func updateStreamState ( cs : H2ClientStream , action : Int64 , streamAction : Int64 ) : Unit {  cs . state = match ( cs . state ) { case IDLE => STREAM_IDLE_MACHINE [ action ] [ streamAction ] NL case OPEN => STREAM_OPEN_MACHINE [ action ] [ streamAction ] NL case RESERVED_LOCAL => STREAM_RESERVED_LOCAL_MACHINE [ action ] [ streamAction ] NL case RESERVED_REMOTE => STREAM_RESERVED_REMOTE_MACHINE [ action ] [ streamAction ] NL case HALF_CLOSED_REMOTE => STREAM_HALF_CLOSED_REMOTE_MACHINE [ action ] [ streamAction ] NL case HALF_CLOSED_LOCAL => STREAM_HALF_CLOSED_LOCAL_MACHINE [ action ] [ streamAction ] NL case CLOSED => STREAM_CLOSED_MACHINE [ action ] [ streamAction ] NL case ERROR => throw Http2Exception ( ) NL } NL match ( cs . state ) { case ERROR => throw Http2Exception ( ) NL case _ => ( ) NL } NL }","func_name":"updateStreamState","docstring":"// nextStreamState"}
{"repo":"http2","file":"http2StateMachine.cj","path":"http2/src/proto/http2StateMachine.cj","code_tokens":"func updateConnState ( cs : H2ClientConn , action : Int64 , connAction : Int64 ) : Unit {  cs . connState = match ( cs . connState ) { case IDLE => CONNECT_IDLE_MACHINE [ action ] [ connAction ] NL case SERVER_OPEN => CONNECT_SERVER_OPEN_MACHINE [ action ] [ connAction ] NL case CLIENT_OPEN => CONNECT_CLIENT_OPEN_MACHINE [ action ] [ connAction ] NL case CLOSE => CONNECT_CLOSE_MACHINE [ action ] [ connAction ] NL case ERROR => throw Http2Exception ( ) NL } NL match ( cs . connState ) { case ERROR => throw Http2Exception ( ) NL case _ => ( ) NL } NL }","func_name":"updateConnState","docstring":""}
{"repo":"http2","file":"http2StateMachine.cj","path":"http2/src/proto/http2StateMachine.cj","code_tokens":"public operator func == ( that : ConnectionState ) : Bool {  return match ( ( this , that ) ) { case ( IDLE , IDLE ) => true NL case ( SERVER_OPEN , SERVER_OPEN ) => true NL case ( CLIENT_OPEN , CLIENT_OPEN ) => true NL case ( CLOSE , CLOSE ) => true NL case _ => false NL } NL }","func_name":"==","docstring":""}
{"repo":"http2","file":"http2StateMachine.cj","path":"http2/src/proto/http2StateMachine.cj","code_tokens":"public operator func != ( that : ConnectionState ) : Bool {  return ! ( this == that ) NL }","func_name":"!=","docstring":""}
{"repo":"http2","file":"http2StateMachine.cj","path":"http2/src/proto/http2StateMachine.cj","code_tokens":"public operator func == ( that : StreamState ) : Bool {  return match ( ( this , that ) ) { case ( IDLE , IDLE ) => true NL case ( OPEN , OPEN ) => true NL case ( RESERVED_LOCAL , RESERVED_LOCAL ) => true NL case ( RESERVED_REMOTE , RESERVED_REMOTE ) => true NL case ( HALF_CLOSED_REMOTE , HALF_CLOSED_REMOTE ) => true NL case ( HALF_CLOSED_LOCAL , HALF_CLOSED_LOCAL ) => true NL case ( CLOSED , CLOSED ) => true NL case _ => false NL } NL }","func_name":"==","docstring":""}
{"repo":"http2","file":"http2StateMachine.cj","path":"http2/src/proto/http2StateMachine.cj","code_tokens":"public operator func != ( that : StreamState ) : Bool {  return ! ( this == that ) NL }","func_name":"!=","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"static public func createServerConn ( servers : H2Server , socket : SyncSockClient , cfg : H2Config , unresolved ! : ? Array < UInt8 > = None ) : H2ServerConn {  return doCreateServerConn ( H2ServerConn ( servers , socket , cfg ) , unresolved : unresolved ) NL }","func_name":"createServerConn","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"static public func createServerConn ( servers : H2Server , socket : SyncSockClient , cfg : H2Config , req : Request , unresolved ! : ? Array < UInt8 > = None ) : H2ServerConn {   let connection = H2ServerConn ( servers , socket , cfg ) NL H2ServerStream . newFristUpgradeStream ( connection , req ) NL return doCreateServerConn ( connection , unresolved : unresolved ) NL }","func_name":"createServerConn","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"static protected func doCreateServerConn ( serConn : H2ServerConn , unresolved ! : ? Array < UInt8 > = None ) : H2ServerConn {  serConn . unresolvedArr = unresolved NL serConn . doReadAndHandle ( ) NL if ( serConn . server . isOpenLog ) {  serConn . server . logger . info ( Connection builded: ${serConn.remoteAddrStr} ) NL } NL return serConn NL }","func_name":"doCreateServerConn","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"protected open func doReadAndHandle ( ) : Unit {   let readLoop = H2ServerConnReadLoop ( this , this . conn ) NL Timer ( Duration . second ( 2 ) , { => if ( this . isEmptySetting . load ( ) ) {  if ( this . server . isOpenLog ) {  this . server . logger . warn ( The client sets the frame sending timeout ) NL } NL this . conn . write ( GoAwayFrame ( this . currentClientStreamID , Int64 ( ErrorCodes . SETTINGS_TIMEOUT . value ( ) ) ) ) NL this . conn . flush ( ) NL this . conn . close ( ) NL } NL } ) NL spawn { try {  match ( readLoop . run ( ) ) { case Some ( v ) => this . conn . write ( GoAwayFrame ( 0 , v . value ( ) ) ) NL case None => ( ) NL } NL this . conn . flush ( ) NL this . conn . close ( ) NL } catch ( e : Exception ) {  ( ) NL } finally {  this . close ( ) NL } NL } NL }","func_name":"doReadAndHandle","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"private func close ( ) {  this . isClosed . store ( true ) NL this . streamMap . clear ( ) NL this . hpackDecode . clear ( ) NL this . hpackEncode . clear ( ) NL this . conn . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"public func isPushed ( ) : Bool {  return this . ID % 2 == 0 NL }","func_name":"isPushed","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"static public func newStream ( id : Int64 , conn : H2ServerConn ) : H2ServerStream {   let stream = H2ServerStream ( id , conn ) NL conn . streamMap . put ( id , stream ) NL return stream NL }","func_name":"newStream","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"static protected func newFristUpgradeStream ( conn : H2ServerConn , request : Request ) {  spawn {  let stream = H2ServerStream ( 1 , conn ) NL conn . streamMap . put ( 1 , stream ) NL conn . concurrentStreams . fetchAdd ( 1 ) NL  let rws : ResponseWriterState = ResponseWriterState ( stream , H2Request ( request ) , stream . sc ) NL stream . sc . handler . serveHTTP ( rws , request ) NL rws . serve ( ) NL conn . conn . flush ( ) NL } NL }","func_name":"newFristUpgradeStream","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"public open func putHeaderFrame ( header : HeaderFrame ) : Unit {  match ( req ) { case Some ( r ) => r . appendHeader ( header ) NL case None =>  let re = H2Request ( this . sc . hpackDecode ) NL re . appendHeader ( header ) NL this . req = re NL } NL if ( this . req . getOrThrow ( ) . endStream ) {  updateStreamState ( this , Action . RECV , StreamAction . END_STREAM ) NL  let request = this . req . getOrThrow ( ) NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . info ( [putHeaderFrame] ${request.method.toString()} ${request.requestURI} ${request.proto} ) NL } NL  let rws : ResponseWriterState = ResponseWriterState ( this , this . req . getOrThrow ( ) , this . sc ) NL this . sc . handler . serveHTTP ( rws , this . req . getOrThrow ( ) . req ) NL rws . serve ( ) NL sc . conn . flush ( ) NL this . clear ( ) NL this . sc . streamMap . put ( ID , Option < H2ServerStream > . None ) NL } NL }","func_name":"putHeaderFrame","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"public open func putDataFrame ( data : DataFrame ) : Unit {  this . req . getOrThrow ( ) . appendData ( data ) NL if ( this . req . getOrThrow ( ) . endStream ) {  updateStreamState ( this , Action . RECV , StreamAction . END_STREAM ) NL  let request = this . req . getOrThrow ( ) NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . info ( [putDataFrame] ${request.method.toString()} ${request.requestURI} ${request.proto} ) NL } NL  let rws : ResponseWriterState = ResponseWriterState ( this , this . req . getOrThrow ( ) , this . sc ) NL this . sc . handler . serveHTTP ( rws , this . req . getOrThrow ( ) . req ) NL rws . serve ( ) NL sc . conn . flush ( ) NL this . clear ( ) NL this . sc . streamMap . put ( ID , Option < H2ServerStream > . None ) NL } NL }","func_name":"putDataFrame","docstring":""}
{"repo":"http2","file":"Http2ServerConn.cj","path":"http2/src/proto/Http2ServerConn.cj","code_tokens":"protected func clear ( ) {  this . resp = None NL this . req = None NL }","func_name":"clear","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func push ( target : String , opts : PushOptions , isFile : Bool ) : Unit","func_name":"push","docstring":"/**\n     *  +-----------------------------------------------+\n     *  |                Length (24)                    |\n     *  +---------------+---------------+---------------+\n     *  |  0x5 (8)      | 0000 ??00 (8) |\n     *  +-+-------------+---------------+-------------------------------+\n     *  |R|                Stream Identifier (32)                       |\n     *  +=+=============================================================+\n     *  |Pad Length? (8)|\n     *  +-+-------------+-----------------------------------------------+\n     *  |R|                Promised Stream ID (31)                      |\n     *  +-+-------------------------------------------------------------+\n     *  |                  Header Block Fragment (*)                . . .\n     *  +---------------------------------------------------------------+\n     *  |                           Padding (*)                     . . .\n     *  +---------------------------------------------------------------+\n     *\n     *  The server notifies the peer to initialize a new push stream to push data later:\n     *  -The push stream is required to be in the open or half closed (remote) state, otherwise it will be reported to PROTOCOL_ ERROR Error:\n     *  -The committed stream must not be used in the order in which it is opened, but only for later use\n     *  -SETTINGS set by the receiving end_ ENABLE_ The PUSH flag determines whether to send, otherwise it is used as PROTOCOL_ ERROR\n     *  -Once the receiver refuses to receive push, it will send RST_ STREAM frame informs the other party that the push is invalid\n     *  Field list:\n     *  -Promised Stream ID: 31 bits represent an unsigned natural number, which is a stream identifier reserved for push, and is subsequently applicable to sending push data\n     *  -Header Block Fragment, the field value of the request header, which can be regarded as a resource request initiated by the server simulating the client\n     *  Flag bit:\n     *  END_ HEADERS (0x4/000000 10), this frame contains a complete header block, instead of being followed by CONTINUATION frame, PADDED (0x8/00000 100),\n     *  The fill switch determines whether the following Pad Length and Padding should be filled, which is consistent with the HEADERS frame content, not to mention\n     */"}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"public func push ( target : String , opts : PushOptions , isFile : Bool ) : Unit {  if ( ! this . conn . server . globalCfg . ishttp2 ) {  this . conn . server . logger . error ( The protocol is not a correct HTTP/2.0 ) NL return NL } NL if ( this . conn . connCfg . ENABLE_PUSH == 0 ) {  this . conn . server . logger . error ( This client connection setting prohibits the use of service push. ) NL return NL } NL if ( this . stream . isPushed ( ) ) {  this . conn . server . logger . error ( http2: recursive push not allowed. ) NL return NL } NL  let HeaderFields : LinkedList < HeaderField > = LinkedList < HeaderField > ( ) NL HeaderFields . append ( HeaderField ( :authority , req . host , true ) ) NL match ( this . stream . sc . conn . sockClient ) { case SocketC ( v ) => HeaderFields . append ( HeaderField ( :scheme , http ) ) NL case TlsC ( v ) => HeaderFields . append ( HeaderField ( :scheme , https ) ) NL } NL match ( opts . method ) { case GET => HeaderFields . append ( HeaderField ( :method , GET ) ) NL case HEAD => HeaderFields . append ( HeaderField ( :method , HEAD , true ) ) NL case _ => this . conn . server . logger . error ( The RFC effectively limits promised requests to GET and HEAD ) NL return NL } NL  let path = fs . Path ( target ) NL try {  if ( path . isDirectory ( ) || ! path . isFile ( ) ) {  this . conn . server . logger . error ( The file path is not a file: ${target} ) NL return NL } NL HeaderFields . append ( HeaderField ( :path , path . fileName . getOrThrow ( ) ) ) NL  let data = ByteBuffer . wrap ( this . conn . hpackEncode . encode ( HeaderFields ) ) NL  let pushId = Int64 ( this . conn . nextStreamPushID ) NL  let push_promise = PushPromiseFrame ( this . stream . ID , 0 , pushId , [ data ] , 0 ) NL this . conn . conn . write ( push_promise ) NL  let file = File ( path , Open ( true , true ) ) NL  let strSplit : Array < String > = target . split ( . ) NL HeaderFields . clear ( ) NL HeaderFields . append ( HeaderField ( :status , 200 ) ) NL HeaderFields . append ( HeaderField ( content-length , ${file.length} , true ) ) NL HeaderFields . append ( HeaderField ( last-modified , appendTime ( file . info . lastModificationTime ) , true ) ) NL HeaderFields . append ( HeaderField ( content-type , MimeType . getMimeType ( strSplit [ strSplit . size - 1 ] ) , true ) ) NL HeaderFields . append ( HeaderField ( date , appendTime ( ) , true ) ) NL  let headerData = this . conn . hpackEncode . encode ( HeaderFields ) NL  let header = HeadersFrame ( pushId , 4 , [ ByteBuffer . wrap ( headerData ) ] , 0 ) NL this . conn . conn . write ( header ) NL  let data_arr = Array < Byte > ( conn . connCfg . MAX_FRAME_SIZE , item : 0 ) NL  var length = file . read ( data_arr ) NL while ( length > 0 ) {   var first : Bool = false NL  let push_data : DataFrame = if ( length == conn . connCfg . MAX_FRAME_SIZE ) {  first = true NL DataFrame ( pushId , 0 , [ ByteBuffer . wrap ( data_arr ) ] , 0 ) NL } else {  first = false NL DataFrame ( pushId , 1 , [ ByteBuffer . wrap ( data_arr , 0 , length ) ] , 0 ) NL } NL if ( length <= 0 && first ) {  push_data . flags = 1 NL } NL this . conn . conn . write ( push_data ) NL length = file . read ( data_arr ) NL } NL HeaderFields . clear ( ) NL } catch ( e : FSException ) {  this . conn . server . logger . warn ( The path may not exist in the file system: ${target} ) NL } catch ( e : Exception ) {  this . conn . server . logger . error ( e . message ) NL } finally {  return NL } NL }","func_name":"push","docstring":"/**\n     *  +-----------------------------------------------+\n     *  |                Length (24)                    |\n     *  +---------------+---------------+---------------+\n     *  |  0x5 (8)      | 0000 ??00 (8) |\n     *  +-+-------------+---------------+-------------------------------+\n     *  |R|                Stream Identifier (32)                       |\n     *  +=+=============================================================+\n     *  |Pad Length? (8)|\n     *  +-+-------------+-----------------------------------------------+\n     *  |R|                Promised Stream ID (31)                      |\n     *  +-+-------------------------------------------------------------+\n     *  |                  Header Block Fragment (*)                . . .\n     *  +---------------------------------------------------------------+\n     *  |                           Padding (*)                     . . .\n     *  +---------------------------------------------------------------+\n     *\n     *  The server notifies the peer to initialize a new push stream to push data later:\n     *  -The push stream is required to be in the open or half closed (remote) state, otherwise it will be reported to PROTOCOL_ ERROR Error:\n     *  -The committed stream must not be used in the order in which it is opened, but only for later use\n     *  -SETTINGS set by the receiving end_ ENABLE_ The PUSH flag determines whether to send, otherwise it is used as PROTOCOL_ ERROR\n     *  -Once the receiver refuses to receive push, it will send RST_ STREAM frame informs the other party that the push is invalid\n     *  Field list:\n     *  -Promised Stream ID: 31 bits represent an unsigned natural number, which is a stream identifier reserved for push, and is subsequently applicable to sending push data\n     *  -Header Block Fragment, the field value of the request header, which can be regarded as a resource request initiated by the server simulating the client\n     *  Flag bit:\n     *  END_ HEADERS (0x4/000000 10), this frame contains a complete header block, instead of being followed by CONTINUATION frame, PADDED (0x8/00000 100),\n     *  The fill switch determines whether the following Pad Length and Padding should be filled, which is consistent with the HEADERS frame content, not to mention\n     */"}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"public override func header ( ) : Header {  return this . handlerHeader NL }","func_name":"header","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"public override func write ( data : Array < UInt8 > ) : Unit {  this . body . write ( data ) NL return NL }","func_name":"write","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"public override func writeStatusCode ( statusCode : Int64 ) : Unit {  if ( statusCode < 100 || statusCode > 999 ) {  throw Http2Exception ( invalid writeStatusCode code. ) NL } NL this . status = statusCode NL }","func_name":"writeStatusCode","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"public override func flush ( ) : Unit {   let arr : Array < UInt8 > = Array < UInt8 > ( this . body . length , item : 0 ) NL this . body . read ( arr ) NL this . writeChunk ( arr ) NL }","func_name":"flush","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func serve ( ) : Unit {   let contents : String = this . req . header . get ( Content-Type ) ??  NL if ( contents . contains ( filename ) ) {  try {  parserContent ( contents ) NL } catch ( e : Exception ) {  this . conn . server . logger . error ( e . message ) NL } NL } NL this . flush ( ) NL return NL }","func_name":"serve","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"private func parserContent ( con : String ) {   let conindex : Int64 = con . indexOf ( filename ) . getOrThrow ( ) NL  let scon : Int64 = con . indexOf ( \\\" , conindex ) . getOrThrow ( ) NL  let sconex : Int64 = con . indexOf ( \\\" , scon + 1 ) . getOrThrow ( ) NL  let filename : String = con . substring ( scon + 1 , sconex - scon - 1 ) NL  let path : ( String , String ) = isFilePathValid ( filename ) NL  var data : Array < UInt8 > = Array < UInt8 > ( ) NL  let fs : File = File ( filename , Open ( true , false ) ) NL if ( fs . canRead ( ) ) {  data = fs . readToEnd ( ) NL fs . flush ( ) NL fs . close ( ) NL } else {  throw ReadException ( Can not read file ) NL } NL  var fileData = StringBuilder ( ) NL fileData . append ( ------WebKitFormBoundaryari0emH33oMihIU4\\r\\n ) NL fileData . append ( filename=\\\" + path [ 0 ] + \\\" ) NL fileData . append ( \\r\\n ) NL fileData . append ( String . fromUtf8 ( data ) ) NL fileData . append ( \\r\\n ) NL fileData . append ( ------WebKitFormBoundaryari0emH33oMihIU4-- ) NL this . write ( fileData . toString ( ) . toUtf8Array ( ) ) NL }","func_name":"parserContent","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func write ( lenData : Int64 , dataB : Array < UInt8 > , dataS : String ) : ( Int64 , String ) {  if ( ! this . wroteHeader ) {  this . writeHeader ( 200 ) NL } NL if ( ! bodyAllowedForStatus ( this . status ) ) {  return ( 0 , http2 ErrBodyNotAllowed ) NL } NL this . wroteBytes += ( dataB . size + dataS . size ) NL if ( this . sentContentLen != 0 && this . wroteBytes > this . sentContentLen ) {  return ( 0 , http2: handler wrote more than declared Content-Length ) NL } NL  var num : Int64 = if ( ! dataB . isEmpty ( ) ) {  this . body . write ( dataB ) NL dataB . size NL } else {  this . body . write ( dataS . toUtf8Array ( ) ) NL dataB . size NL } NL return ( num ,  ) NL }","func_name":"write","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func hasTrailers ( ) : Bool {  return this . trailers . size > 0 NL }","func_name":"hasTrailers","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func hasNonemptyTrailers ( ) : Bool {  for ( trailer in this . trailers ) {  if ( ! this . handlerHeader . getAll ( trailer ) . isEmpty ( ) ) {  return true NL } NL } NL return false NL }","func_name":"hasNonemptyTrailers","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func declareTrailer ( key : String ) : Unit {   let k : String = canonicalHeaderKey ( key ) NL if ( ! validTrailerHeader ( k ) ) {  return NL } NL  var contains = false NL for ( trailer in this . trailers where trailer == k ) {  contains = true NL } NL if ( ! contains ) {  this . trailers . append ( k ) NL } NL }","func_name":"declareTrailer","docstring":"/*\n     * Called for each Trailer header when the response header is written.\n     * It points out that at the end of the response, the title needs to be written in the trailer.\n     */"}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func foreachHeaderElement ( str : String , fn : ( String ) -> Unit ) : Unit {   var v : String = str . trim ( ) NL if ( v . isEmpty ( ) ) {  return NL } NL if ( ! v . contains ( , ) ) {  fn ( v ) NL return NL } NL for ( s in v . split ( , ) where ! s . trim ( ) . isEmpty ( ) ) {  fn ( s ) NL } NL }","func_name":"foreachHeaderElement","docstring":"/* Split V is constructed according to the \"rules\" in Section 7 of RFC 7230, and FN is called for each non empty element. */"}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"private func extractFlags ( length : Int64 , first : Bool , pushData : DataFrame ) {  if ( length <= 0 && first ) {  pushData . flags = 1 NL } NL }","func_name":"extractFlags","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func writeChunk ( data : Array < UInt8 > ) : Int64 {  if ( ! this . wroteHeader ) {  writeHeader ( this . status ) NL } NL  let isHeadResp : Bool = match ( this . req . method ) { case HEAD => true NL case _ => false NL } NL this . req . method . toString ( ) . equals ( HEAD ) NL  let len : Int64 = data . size NL if ( ! this . sentHeader ) {  if ( writeChunkUtil ( data , len , isHeadResp ) ) {  return 0 NL } NL } NL if ( isHeadResp ) {  return len NL } NL if ( len == 0 && ! this . handlerDone ) {  return 0 NL } NL if ( this . handlerDone ) {  promoteUndeclaredTrailers ( ) NL } NL  let hasNonemptyTrailers : Bool = hasNonemptyTrailers ( ) NL  let endStream : Bool = this . handlerDone && ! hasNonemptyTrailers NL if ( len > 0 || endStream ) {   let datas : String = String . fromUtf8 ( data ) NL if ( datas . contains ( ------WebKitFormBoundaryari0emH33oMihIU4\\r\\n ) && datas . contains ( ------WebKitFormBoundaryari0emH33oMihIU4-- ) && datas . contains ( filename= ) ) {   let data_arr = Array < UInt8 > ( conn . connCfg . MAX_FRAME_SIZE , item : 0 ) NL  var bodyData : ByteArrayStream = ByteArrayStream ( ) NL bodyData . write ( data ) NL  var length = bodyData . read ( data_arr ) NL while ( length > 0 ) {   var first : Bool = false NL  let pushData : DataFrame = if ( length == conn . connCfg . MAX_FRAME_SIZE ) {  first = true NL DataFrame ( this . stream . ID , 0 , [ ByteBuffer . wrap ( data_arr ) ] , 0 ) NL } else {  first = false NL DataFrame ( this . stream . ID , 1 , [ ByteBuffer . wrap ( data_arr , 0 , length ) ] , 0 ) NL } NL extractFlags ( length , first , pushData ) NL this . conn . conn . write ( pushData ) NL length = bodyData . read ( data_arr ) NL } NL } else {  this . conn . conn . write ( writeDataPadded ( this . stream . ID , endStream , data , 0 ) ) NL } NL } NL if ( this . handlerDone && hasNonemptyTrailers ) {  H2WriteResHeaders ( this . stream . ID , this . handlerHeader , this . trailers , true ) . writeFrameHeader ( this . conn ) NL } NL return len NL }","func_name":"writeChunk","docstring":"/* Write blocks from the body. However, since the body may bypass its blocking, sometimes P may be arbitrarily large.\n     * Writechunk is also responsible for sending the header response (on the first block).\n     * (n int, err error) => Int64, String\n     */"}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func writeChunkUtil ( arrBody : Array < UInt8 > , len : Int64 , isHeadResp : Bool ) : Bool {   let ( endStream , ctype , clen , date ) : ( Bool , String , String , String ) = getWRHparam ( arrBody , len , isHeadResp ) NL  let h2WriteResHeaders : H2WriteResHeaders = H2WriteResHeaders ( this . stream . ID , this . status , this . snapHeader , endStream , ctype , clen , date ) NL h2WriteResHeaders . writeFrameHeader ( this . conn ) NL return endStream NL }","func_name":"writeChunkUtil","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func getWRHparam ( arrBody : Array < UInt8 > , len : Int64 , isHeadResp : Bool ) : ( Bool , String , String , String ) {  this . sentHeader = true NL  let clen : String = if ( bodyAllowedForStatus ( this . status ) && ( len > 0 || ! isHeadResp ) ) {  itoa ( len ) NL } else {   NL } NL handlerDone = true NL  let hasContentType : Bool = false NL  let hasCE : Bool = false NL  let ctype : String = if ( ! hasCE && ! hasContentType && bodyAllowedForStatus ( this . status ) && len > 0 ) {  text/plain; charset=utf-8 NL } else {   NL } NL  let date : String = appendTime ( ) NL return ( ( ( this . handlerDone && ! hasTrailers ( ) && len == 0 ) || isHeadResp ) , ctype , clen , date ) NL }","func_name":"getWRHparam","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func writeHeader ( code : Int64 ) : Unit {  if ( this . wroteHeader ) {  return NL } NL if ( code < 100 || code > 999 ) {  throw Http2Exception ( invalid WriteHeader code: ${code}. ) NL } NL if ( code > = 100 && code <= 199 ) {  match ( this . handlerHeader . get ( Content-Length ) ) { case None => ( ) NL case _ => this . handlerHeader . remove ( Content-Length ) NL } NL match ( this . handlerHeader . get ( Transfer-Encoding ) ) { case None => ( ) NL case _ => this . handlerHeader . remove ( Transfer-Encoding ) NL } NL  let endStream : Bool = this . handlerDone && ! hasTrailers ( ) NL H2WriteResHeaders ( this . stream . ID , code , this . handlerHeader , endStream ) . writeFrameHeader ( this . conn ) NL return NL } NL this . wroteHeader = true NL this . status = code NL if ( ! headerIsEmpty ( this . handlerHeader ) ) {  this . snapHeader = this . handlerHeader NL } NL }","func_name":"writeHeader","docstring":""}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func promoteUndeclaredTrailers ( ) : Unit {  for ( ( k , vv ) in this . handlerHeader ) {  if ( ! k . startsWith ( TRAILERPREFIX ) ) {  continue NL } NL  let trailerKey : String = k . trimLeft ( TRAILERPREFIX ) NL declareTrailer ( trailerKey ) NL for ( v in vv ) {  this . handlerHeader . add ( canonicalHeaderKey ( trailerKey ) , v ) NL } NL } NL }","func_name":"promoteUndeclaredTrailers","docstring":"/* Allows HTTP handlers to set the tail after refreshing the header. */"}
{"repo":"http2","file":"ResponseWriterState.cj","path":"http2/src/proto/ResponseWriterState.cj","code_tokens":"func headerIsEmpty ( header : Header ) : Bool {  return match ( header . iterator ( ) . next ( ) ) { case None => true NL case _ => false NL } NL }","func_name":"headerIsEmpty","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"@ when [ os == linux ]   func GetLocalIP ( ) : String {  return 0.0.0.0 NL }","func_name":"GetLocalIP","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"@ when [ os == windows ]   func GetLocalIP ( ) : String {  return 127.0.0.1 NL }","func_name":"GetLocalIP","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"func setHttp2configALPN ( cfg : TlsServerConfig ) : TlsServerConfig {   var tlscfg = cfg NL tlscfg . alpnList = [ h2 , http/1.1 ] NL return tlscfg NL }","func_name":"setHttp2configALPN","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"static public func createH2Server ( handler : Handler , h2cfg : Http2Cfg ) : H2Server {  return H2Server ( handler , h2cfg ) NL }","func_name":"createH2Server","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"static public func createH2Server ( handler : Handler , cfg : TlsServerConfig , h2cfg : Http2Cfg ) : H2Server {  return H2Server ( handler , cfg , h2cfg ) NL }","func_name":"createH2Server","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func doClosedServer ( serverPort : UInt16 ) : Unit {   var closeSocket : ? Socket = None NL try {   let closedServer = SocketServer ( TCP , localIP , globalCfg . shutdownPort ) NL if ( this . isOpenLog ) {  this . logger . info ( Listening on port:${globalCfg.shutdownPort}, close the port. ) NL } NL closeSocket = closedServer . accept ( ) NL } catch ( e : Exception ) {   let closedServer = SocketServer ( TCP , localIP , 0 ) NL if ( this . isOpenLog ) {  this . logger . warn ( The port number is occupied and port ${this.globalCfg.shutdownPort} is discarded, Enabling other ports: ${closedServer.port} ) NL } NL closeSocket = closedServer . accept ( ) NL } NL try {  closeSocket . getOrThrow ( ) . close ( ) NL } catch ( e : Exception ) {  if ( this . isOpenLog ) {  this . logger . error ( A serious error occurred in the Cangjie server. Please check the log. If the server cannot be shut down, please kill the process. ) NL } NL } NL if ( this . isOpenLog ) {  this . logger . info ( Shutting down the cangjie server... ... ) NL } NL this . myServerOpen . store ( false ) NL try {   let conn = Socket ( TCP , 127.0.0.1 , serverPort ) NL conn . connect ( ) NL conn . close ( ) NL } catch ( e : Exception ) {  ( ) NL } NL }","func_name":"doClosedServer","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"public open func listenAndServe ( ) : Unit {  try {  if ( this . isOpenLog ) {  this . logger . info ( Cangjie Server Running, HTTP/2.0 protocol:${this.globalCfg.ishttp2} ) NL } NL if ( super . isClosed ( ) ) {  throw IllegalArgumentException ( Server closed ) NL } NL match ( this . tlsCfg ) { case Some ( v ) => if ( this . isOpenLog ) {  this . logger . info ( Listening on port:${port}. Service port. TLS: true, H2: true. ) NL } NL this . serve ( TlsSocketServer ( SocketNet . TCP , localIP , port , v ) ) NL case None => if ( this . isOpenLog ) {  this . logger . info ( Listening on port:${port}. Service port. TLS: false, H2C: true. ) NL } NL this . serve ( SocketServer ( SocketNet . TCP , localIP , port ) ) NL } NL } catch ( e : Exception ) {  if ( this . isOpenLog ) {  this . logger . error ( H2Server.listenAndServe - ${e.toString()} ) NL } NL if ( e . message . contains ( 10048: Unknown error ) ) {  throw Exception ( Address already in use. ) NL } NL } finally {  this . close ( ) NL } NL }","func_name":"listenAndServe","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"public override open func serve ( listener : SocketServer ) : Unit {  listener . noDelay = true NL listener . quickAck = true NL spawn { this . doClosedServer ( listener . port ) NL } NL if ( tlsEnabled ( ) ) {  throw HttpException ( The server is http server, server function need param of TlsSocketServer type.. ) NL } NL if ( this . isAddingSocketServerList . load ( ) ) {  this . socketServerList . append ( SockServer . SocketS ( listener ) ) NL } NL this . globalCfg . serverPort = listener . port NL for ( f in onStart ) {  f ( listener ) NL } NL while ( this . serverOpen ) {  if ( this . isClosed ( ) ) {  return NL } NL  let socket = try {  listener . accept ( TIMEOUT_100ms ) NL } catch ( e : Exception ) {  continue NL } NL spawn { this . spawnServe ( SockServer . build ( listener ) , SyncSockClient . build ( socket ) ) NL } NL } NL return NL }","func_name":"serve","docstring":"// Upgrade-Insecure-Requests. todo"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"public override open func serve ( listener : TlsSocketServer ) : Unit {  spawn { this . doClosedServer ( listener . port ) NL } NL if ( ! this . tlsEnabled ( ) ) {  throw HttpException ( The server is http server, server function need param of TlsSocketServer type.. ) NL } NL if ( this . isAddingSocketServerList . load ( ) ) {  this . socketServerList . append ( SockServer . TlsS ( listener ) ) NL } NL this . globalCfg . serverPort = listener . port NL for ( f in this . onStart ) {  f ( listener . socketServer ) NL } NL while ( this . serverOpen ) {   let socket = try {  listener . accept ( ) NL } catch ( e : Exception ) {  continue NL } NL spawn { this . spawnServe ( SockServer . build ( listener ) , SyncSockClient . build ( socket ) ) NL } NL } NL return NL }","func_name":"serve","docstring":"// Upgrade-Insecure-Requests. todo"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func spawnServe ( listener : SockServer , socket : SyncSockClient ) {  if ( this . isClosed ( ) ) {  return NL } NL for ( f in this . afterAccept ) {  f ( listener . socketServer , socket . socket ) NL } NL  var reader = HttpReader ( socket ) NL if ( reader . isClosed ( ) ) {  return NL } NL  let ( startLine , header , body , _ ) : ( String , Header , ByteArrayStream , ByteArrayStream ) = try {  reader . serverRun ( ) NL reader . getData ( ) NL } catch ( e : IllegalArgumentException ) {  this . logger . error ( not a correct http protocol request. ) NL socket . write ( badRequestPrefix ) NL socket . write ( appendTime ( ) . toUtf8Array ( ) ) NL socket . writeAndFlush ( badRequestSuffix ) NL socket . close ( ) NL throw e NL } NL if ( this . isOpenLog ) {  this . logger . info ( startLine ) NL } NL if ( doUpgrade ( header ) ) {   var url = match ( socket . sockClient ) { case SocketC ( s ) => http:// NL case TlsC ( s ) => https:// NL } NL  let startLineArgs = startLine . split (   ) NL for ( head in header ) {  if ( head [ 0 ] == Host || head [ 0 ] == host ) {  url = url + ${head[1][0]}${startLineArgs[1]} NL break NL } NL } NL socket . writeAndFlush ( SwitchingArr ) NL this . doMagic ( socket , Request ( getRequestMethod ( startLineArgs [ 0 ] ) , url , body ) ) NL } else if ( startLine == PRI * HTTP/2.0 ) {  try {  socket . write ( SETTINGS_FRAME_ARRAY ) NL socket . write ( WINDOW_UPDATE_ARRAY ) NL socket . flush ( ) NL this . conns . append ( H2ServerConn . createServerConn ( this , socket , this . connectConfig , unresolved : reader . getUnresolve ( ) ) ) NL } catch ( e : Exception ) {  this . handle ( reader ) NL } NL } else {  this . readerList . append ( reader ) NL this . handle ( reader ) NL } NL }","func_name":"spawnServe","docstring":"/* Child thread function of function serve */"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"func doUpgrade ( header : Header ) : Bool {  match ( ( header . get ( Upgrade ) , header . get ( Connection ) , header . get ( HTTP2-Settings ) ) ) { case ( Some ( upgrade ) , Some ( connection ) , Some ( settings ) ) => if ( ! upgrade . contains ( h2c ) ) {  return false NL } NL if ( ! connection . contains ( HTTP2-Settings ) ) {  return false NL } NL  let arr = base64UrlDecode ( settings ) NL if ( arr . size % 6 != 0 ) {  return false NL } NL  var index = 0 NL while ( index < arr . size ) {   let id = Int64 ( arr [ index ] ) << 8 | Int64 ( arr [ index + 1 ] ) NL if ( id < 1 || id > 6 ) {  return false NL } NL this . connectConfig [ id ] = Int64 ( arr [ index + 2 ] ) << 24 | Int64 ( arr [ index + 3 ] ) << 16 | Int64 ( arr [ index + 4 ] ) << 8 | Int64 ( arr [ index + 5 ] ) NL index += 6 NL } NL return true NL case _ => false NL } NL }","func_name":"doUpgrade","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"func doMagic ( socket : SyncSockClient , req : Request ) {  try {   let data = Array < UInt8 > ( 128 , item : 0 ) NL  let size = socket . read ( data ) NL for ( m in 0 .. defaultRequestBytes . size where defaultRequestBytes [ m ] != data [ m ] ) {  return NL } NL socket . write ( SETTINGS_FRAME_ARRAY ) NL socket . write ( WINDOW_UPDATE_ARRAY ) NL socket . flush ( ) NL this . conns . append ( H2ServerConn . createServerConn ( this , socket , this . connectConfig , req , unresolved : data [ 24 .. size ] ) ) NL } catch ( e : Exception ) {  throw Exception ( ) NL } NL }","func_name":"doMagic","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"public open func run ( ) : ? ErrorCodes {   var length = - 1 NL  let logger = this . sc . server . logger NL  let framedecode = FramesDecoder ( doProcessFrames ) NL try {  while ( this . isNoError ) {   let connReadCache : Array < UInt8 > = Array < UInt8 > ( 1 << 10 , item : 0 ) NL match ( this . sc . unresolvedArr ) { case Some ( unresolve ) => framedecode . decode ( ByteBuffer . wrap ( unresolve ) ) NL this . sc . unresolvedArr = None NL case None => length = this . socket . read ( connReadCache ) NL if ( length <= 0 ) {  continue NL } NL framedecode . decode ( ByteBuffer . wrap ( connReadCache , 0 , length ) ) NL } NL if ( this . sc . server . isOpenLog ) {  logger . debug ( Reading, Read bytes in socket: ${length} ) NL  var n = if ( length == - 1 ) {  0 NL } else {  length NL } NL logger . trace ( Reading, ${connReadCache[0..n]} ) NL } NL length = - 1 NL } NL return this . errorCode NL } catch ( e : DynamicTableSizeUpdateException | HpackDecodeException ) {  return COMPRESSION_ERROR NL } catch ( e : SocketException ) {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . warn ( Remote connection closed ) NL } NL return CONNECT_ERROR NL } catch ( e : Exception ) {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( Server protocol processing error. ) NL } NL return PROTOCOL_ERROR NL } NL }","func_name":"run","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"func doProcessFrames ( frame : Http2Frame ) : Unit {  match ( frame . TYPE ) { case 0x06 => this . processPing ( ( frame as PingFrame ) . getOrThrow ( ) ) NL case 0x04 => this . processSettings ( ( frame as SettingsFrame ) . getOrThrow ( ) ) NL case 0x07 => this . processGoAway ( ( frame as GoAwayFrame ) . getOrThrow ( ) ) NL case 0x03 => this . processRstSream ( ( frame as ResetFrame ) . getOrThrow ( ) ) NL case 0x01 => this . processHeaders ( ( frame as HeadersFrame ) . getOrThrow ( ) ) NL case 0x00 => this . processData ( ( frame as DataFrame ) . getOrThrow ( ) ) NL case 0x08 => this . processWindowUpdate ( ( frame as WindowUpdateFrame ) . getOrThrow ( ) ) NL case 0x02 => this . processPriority ( ( frame as PriorityFrame ) . getOrThrow ( ) ) NL case 0x09 => this . processContinuation ( ( frame as ContinuationFrame ) . getOrThrow ( ) ) NL case 0x05 => this . processPushPromise ( ( frame as PushPromiseFrame ) . getOrThrow ( ) ) NL case - 1 => this . errorCode = ERROR_CODE [ ( frame as MalformedFrame ) . getOrThrow ( ) . errorCode ] NL case _ => this . sc . server . logger . error ( The [${frame.TYPE}] frame sent by the far end is not supported, frame message: ${frame} ) NL } NL }","func_name":"doProcessFrames","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func processData ( data : DataFrame ) : Unit {   let frameData : Collection < ByteBuffer > = data . data NL  var buf : StringBuilder = StringBuilder ( ) NL for ( bBuffer in frameData ) {  buf . append ( String . fromUtf8 ( ByteBufferToArray ( bBuffer ) ) ) NL } NL if ( buf . toString ( ) . contains ( Content-Disposition ) && buf . toString ( ) . contains ( Content-Type ) && buf . toString ( ) . contains ( filename= ) && buf . toString ( ) . contains ( name= ) ) {  this . parserFile ( buf . toString ( ) ) NL } NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . debug ( Received, remote send DATA frame ) NL  var datas =  NL for ( b in data . data ) {  datas += ByteBufferToArray ( b ) . toString ( ) NL } NL this . sc . server . logger . trace ( Received, remote send DATA frame, type=${data.TYPE}, length=${data.length}, streamid=${data.streamid}, flags=${data.flags}, data=${datas} ) NL } NL  let id = data . streamid NL if ( Int64 ( id ) % 2 != 1 ) {  this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processData: Int64(id) % 2 != 1 ) NL } NL return NL } NL updateStreamState ( this . sc . streamMap [ id ] . getOrThrow ( ) , Action . RECV , StreamAction . DATA ) NL if ( this . sc . streamMap . contains ( id ) ) {  if ( this . sc . streamMap [ id ] . getOrThrow ( ) . resetQueued ) {  return NL } NL if ( this . sc . streamMap [ id ] . getOrThrow ( ) . state == HALF_CLOSED_REMOTE ) {  this . errorCode = STREAM_CLOSED NL return NL } NL  let stateTemp = this . sc . streamMap [ id ] . getOrThrow ( ) . state NL if ( stateTemp == StreamState . CLOSED ) {  this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processData: stateTemp == StreamState.CLOSED ) NL } NL return NL } NL this . sc . streamMap [ id ] . getOrThrow ( ) . putDataFrame ( data ) NL return NL } NL this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processData: !this.sc.streamMap.contains(id) ) NL } NL }","func_name":"processData","docstring":"// DATA          0"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"private func parserFile ( str : String ) {   let strl : Int64 = str . indexOf ( filename ) . getOrThrow ( ) NL  let strIndex : Int64 = str . indexOf ( \\\" , strl ) . getOrThrow ( ) NL  let str2 : Int64 = str . indexOf ( \\\" , strIndex + 1 ) . getOrThrow ( ) NL  let filename : String = str . substring ( strIndex + 1 , str2 - strIndex - 1 ) NL  let str4 : Int64 = str . indexOf ( \\r\\n\\r\\n ) . getOrThrow ( ) NL  let str5 : Int64 = str . indexOf ( ------WebKitFormBoundaryari0emH33oMihIU4-- , str4 + 4 ) . getOrThrow ( ) NL  let filedata = str . substring ( str4 + 4 , str5 - str4 - 6 ) NL  let path = getcwd ( ) + / + filename NL  let fs : File = File ( path , CreateOrTruncate ( false ) ) NL if ( fs . canWrite ( ) ) {   let readFile = fs . write ( filedata . toUtf8Array ( ) ) NL fs . flush ( ) NL fs . close ( ) NL } else {  throw WriteException ( Can not write file ) NL } NL }","func_name":"parserFile","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func processHeaders ( header : HeadersFrame ) : Unit {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . debug ( Received, remote send HEADERS frame ) NL  var datas =  NL for ( b in header . headerBlocks ) {  datas += ByteBufferToArray ( b ) . toString ( ) NL } NL this . sc . server . logger . trace ( Received, remote send HEADERS frame, type=${header.TYPE}, length=${header.length}, streamid=${header.streamid}, flags=${header.flags}, headers=${datas} ) NL } NL  let id = header . streamid NL if ( Int64 ( id ) % 2 != 1 || id == header . streamDependency || id < this . sc . currentClientStreamID ) {  this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processHeaders: Int64(id) % 2 != 1 || id == header.streamDependency || id < this.sc.currentClientStreamID ) NL } NL return NL } NL if ( this . sc . concurrentStreams . load ( ) > = this . sc . connCfg . MAX_CONCURRENT_STREAMS ) {  this . errorCode = REFUSED_STREAM NL return NL } NL this . sc . concurrentStreams . fetchAdd ( 1 ) NL if ( this . sc . streamMap . contains ( id ) ) {  updateStreamState ( this . sc . streamMap [ id ] . getOrThrow ( ) , Action . RECV , StreamAction . HEADERS ) NL if ( this . sc . streamMap [ id ] . getOrThrow ( ) . resetQueued ) {  return NL } NL this . sc . streamMap [ id ] . getOrThrow ( ) . putHeaderFrame ( header ) NL return NL } NL this . sc . currentClientStreamID = id NL  let stream = H2ServerStream . newStream ( id , this . sc ) NL updateStreamState ( this . sc . streamMap [ id ] . getOrThrow ( ) , Action . RECV , StreamAction . HEADERS ) NL stream . putHeaderFrame ( header ) NL return NL }","func_name":"processHeaders","docstring":"// HEADER        1"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"func processPriority ( pri : PriorityFrame ) : Unit {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . debug ( Received, remote send PRIORITY frame ) NL this . sc . server . logger . trace ( Received, remote send PRIORITY frame, type=${pri.TYPE}, length=${pri.length}, streamid=${pri.streamid}, flags=${pri.flags} ) NL } NL if ( pri . streamid == 0 || pri . streamid == pri . streamDependency ) {  this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processPriority -1 ) NL } NL return NL } NL updateConnState ( this . sc , Action . RECV , ConnAction . PRIORITY ) NL match ( this . sc . streamMap . get ( pri . streamid ) ) { case Some ( v ) => match ( v ) { case Some ( strm ) => if ( ! strm . req . getOrThrow ( ) . endStream ) {  this . errorCode = PROTOCOL_ERROR NL return NL } NL case None => ( ) NL } NL case None => ( ) NL } NL }","func_name":"processPriority","docstring":"// PRIORITY      2"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func processRstSream ( ret : ResetFrame ) : Unit {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . debug ( Received, remote send RST_STREAM frame ) NL this . sc . server . logger . trace ( Received, remote send RST_STREAM frame, type=${ret.TYPE}, length=${ret.length}, streamid=${ret.streamid}, flags=${ret.flags}, errorCode=${ret.errorCode} ) NL } NL if ( ret . streamid == 0 ) {  this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processRstSream: ret.streamid == 0 ) NL } NL return NL } NL updateStreamState ( this . sc . streamMap [ ret . streamid ] . getOrThrow ( ) , Action . RECV , StreamAction . RST_STREAM ) NL match ( this . sc . streamMap . get ( ret . streamid ) ) { case None => this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processRstSream: None ) NL } NL return NL case Some ( v ) => match ( v ) { case Some ( stream ) => match ( stream . state ) { case IDLE => this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processRstSream: IDLE ) NL } NL return NL case _ => ( ) NL } NL case None => ( ) NL } NL } NL this . sc . streamMap [ ret . streamid ] . getOrThrow ( ) . state = CLOSED NL }","func_name":"processRstSream","docstring":"// Precautions: - received RST_ For a stream frame, the corresponding stream needs to be closed, so the stream must also be closed- The recipient cannot send any frames on this stream- The sending end needs to be prepared. The receiving end receives rst_ The frame sent before the stream frame needs to be processed- If the flow identifier is 0x0, the receiver needs to respond to protocol_ Error type connection error- When the stream is in idle state, RST cannot be sent_ Stream frame, otherwise the receiver will reply with prootocol_ Error type connection error."}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func processSettings ( settings : SettingsFrame ) : Unit {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . debug ( Received, remote send SETTINGS frame ) NL this . sc . server . logger . trace ( Received, remote send SETTINGS frame, type=${settings.TYPE}, length=${settings.length}, streamid=${settings.streamid}, flags=${settings.flags}, settings=${settings} ) NL } NL if ( settings . flags == 0x1 ) {  return NL } NL this . sc . isEmptySetting . store ( false ) NL this . sc . hpackDecode . http2HeaderTableSize = settings [ 1 ] ?? initialHeaderTableSize NL for ( i in 1 ..= 6 ) {  match ( settings [ i ] ) { case None => ( ) NL case Some ( v ) => this . sc . connCfg [ i ] = v NL if ( i == 4 ) {  this . sc . windowUpdateSum = AtomicInt64 ( v ) NL } NL } NL } NL this . sc . conn . writeAndFlush ( SettingsFrame ( SettingsFrame . ACK ) ) NL }","func_name":"processSettings","docstring":"// SETTINGS      4"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func processPushPromise ( push : PushPromiseFrame ) : Unit {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processPushPromise ) NL } NL updateStreamState ( this . sc . streamMap [ push . streamid ] . getOrThrow ( ) , Action . RECV , StreamAction . PUSH_PROMISE ) NL this . errorCode = PROTOCOL_ERROR NL }","func_name":"processPushPromise","docstring":"// PUSH_PROMISE  5"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func processPing ( ping : PingFrame ) : Unit {  if ( ping . flags == 0x1 ) {  return NL } NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . debug ( Received, remote send PING frame ) NL this . sc . server . logger . trace ( Received, remote send PING frame, type=${ping.TYPE}, length=${ping.length}, streamid=${ping.streamid}, flags=${ping.flags}, data=${ping.data} ) NL } NL ping . flags = 0x1 NL this . sc . conn . writeAndFlush ( ping ) NL }","func_name":"processPing","docstring":"// PING          6"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func processGoAway ( goaway : GoAwayFrame ) : Unit {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . debug ( Received, remote send GOAWAY frame ) NL this . sc . server . logger . trace ( Received, remote send GOAWAY frame, type=${goaway.TYPE}, length=${goaway.length}, streamid=${goaway.streamid}, flags=${goaway.flags}, data=${goaway.debugData} ) NL } NL this . errorCode = NO_ERROR NL }","func_name":"processGoAway","docstring":"// GOAWAY        7"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"protected open func processWindowUpdate ( windows : WindowUpdateFrame ) : Unit {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . debug ( Received, remote send WINDOW_UPDATE frame ) NL this . sc . server . logger . trace ( Received, remote send WINDOW_UPDATE frame, type=${windows.TYPE}, length=${windows.length}, streamid=${windows.streamid}, flags=${windows.flags}, update=${windows.update} ) NL } NL if ( windows . update == 0 ) {  this . errorCode = PROTOCOL_ERROR NL return NL } NL if ( windows . streamid == 0 ) {  this . sc . windowUpdateSum . fetchAdd ( windows . update ) NL if ( this . sc . windowUpdateSum . load ( ) > = Int64 ( Int32 . Max ) ) {  this . errorCode = FLOW_CONTROL_ERROR NL return NL } NL return NL } NL this . sc . streamMap [ windows . streamid ] . getOrThrow ( ) . windowUpdate += windows . update NL this . sc . windowUpdateSum . fetchAdd ( windows . update ) NL if ( this . sc . streamMap [ windows . streamid ] . getOrThrow ( ) . windowUpdate > = Int64 ( Int32 . Max ) ) {  updateStreamState ( this . sc . streamMap [ windows . streamid ] . getOrThrow ( ) , Action . SEND , StreamAction . RST_STREAM ) NL this . sc . conn . write ( ResetFrame ( windows . streamid , ErrorFrame . LET_FLOW_CONTROL_ERROR ) ) NL this . sc . conn . flush ( ) NL return NL } NL updateStreamState ( this . sc . streamMap [ windows . streamid ] . getOrThrow ( ) , Action . RECV , StreamAction . WINDOW_UPDATE ) NL match ( this . sc . streamMap . get ( windows . streamid ) ) { case None => this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processWindowUpdate: None ) NL } NL return NL case Some ( v ) => match ( v ) { case Some ( stream ) => match ( stream . state ) { case IDLE => this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processWindowUpdate: IDLE ) NL } NL return NL case _ => ( ) NL } NL case None => ( ) NL } NL } NL }","func_name":"processWindowUpdate","docstring":"// WINDOW_UPDATE 8"}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/proto/http2Server.cj","code_tokens":"func processContinuation ( cont : ContinuationFrame ) : Unit {  if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . debug ( Received, remote send CONTINUATION frame ) NL this . sc . server . logger . trace ( Received, remote send CONTINUATION frame, type=${cont.TYPE}, length=${cont.length}, streamid=${cont.streamid}, flags=${cont.flags} ) NL } NL  let stream = this . sc . streamMap [ cont . streamid ] . getOrThrow ( ) NL  let stateTemp = this . sc . streamMap [ cont . streamid ] . getOrThrow ( ) . state NL if ( stateTemp == StreamState . CLOSED ) {  this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processContinuation: stateTemp == StreamState.CLOSED ) NL } NL return NL } NL updateStreamState ( this . sc . streamMap [ cont . streamid ] . getOrThrow ( ) , Action . RECV , StreamAction . HEADERS ) NL match ( stream . state ) { case IDLE => this . errorCode = PROTOCOL_ERROR NL if ( this . sc . server . isOpenLog ) {  this . sc . server . logger . error ( processContinuation: IDLE ) NL } NL return NL case _ => ( ) NL } NL stream . putHeaderFrame ( cont ) NL }","func_name":"processContinuation","docstring":"// CONTINUATION  9"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func writeHeadersFrame ( streamID : Int64 , chunk : Array < UInt8 > , endStream : Bool , endHeaders : Bool , padLength : Int64 ) : HeadersFrame {   var flags : Int64 = 0 NL if ( padLength != 0 ) {  flags |= HeadersFrame . PADDED NL } NL if ( endStream ) {  flags |= HeaderFrame . END_STREAM NL } NL if ( endHeaders ) {  flags |= HeaderFrame . END_HEADERS NL } NL return HeadersFrame ( Int64 ( streamID ) , flags , [ ByteBuffer . wrap ( chunk ) ] , padLength ) NL }","func_name":"writeHeadersFrame","docstring":"// +1 for sign of 64bit value in base 2"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func writeDataPadded ( streamID : Int64 , endStream : Bool , chunk : Array < UInt8 > , padLength : Int64 ) : DataFrame {   var flags : Int64 = 0 NL if ( endStream ) {  flags |= DataFrame . END_STREAM NL } NL if ( padLength != 0 ) {  flags |= DataFrame . PADDED NL } NL return DataFrame ( Int64 ( streamID ) , flags , [ ByteBuffer . wrap ( chunk ) ] , padLength ) NL }","func_name":"writeDataPadded","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func writeContinuation ( streamID : Int64 , endHeaders : Bool , headerBlockFragment : Array < UInt8 > ) : ContinuationFrame {  if ( endHeaders ) {  return ContinuationFrame ( Int64 ( streamID ) , ContinuationFrame . END_HEADERS , [ ByteBuffer . wrap ( headerBlockFragment ) ] ) NL } NL return ContinuationFrame ( Int64 ( streamID ) , 0 , [ ByteBuffer . wrap ( headerBlockFragment ) ] ) NL }","func_name":"writeContinuation","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func itoa ( num : Int64 ) : String {  return formatInt ( num , 10 ) NL }","func_name":"itoa","docstring":"// Itoa is equivalent to FormatInt(int64(i), 10)."}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func formatInt ( num : Int64 , base : Int64 ) : String {  if ( 0 <= num && num < NSMALLS && base == 10 ) {  return small ( num ) NL } NL return formatBits ( UInt64 ( num ) , base , num < 0 , false ) NL }","func_name":"formatInt","docstring":"// for digit values >= 10."}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func small ( num : Int64 ) : String {  if ( num < 10 ) {  return digits . substring ( num , 1 ) NL } NL return SMALLS_STR . substring ( num * 2 , 2 ) NL }","func_name":"small","docstring":"// small returns the string for an i with 0 <= i < nSmalls."}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func formatBits ( num : UInt64 , base : Int64 , neg : Bool , append_ : Bool ) : String {  if ( base < 2 || base > digits . size ) {  throw Exception ( strconv: illegal AppendInt/FormatInt base ) NL } NL  var i : Int64 = a . size NL  var u : UInt64 = num NL if ( neg ) {  u = - u NL } NL if ( base == 10 ) {   var us : UInt64 = u NL while ( us > = 100 ) {   let isu : Int64 = Int64 ( us % 100 * 2 ) NL us /= 100 NL i -= 2 NL a [ i + 1 ] = UInt8 ( UInt32 ( SMALLS_STRING [ isu + 1 ] ) ) NL a [ i ] = UInt8 ( UInt32 ( SMALLS_STRING [ isu ] ) ) NL } NL  let ius : Int64 = Int64 ( us * 2 ) NL i -- NL a [ i ] = UInt8 ( UInt32 ( SMALLS_STRING [ ius + 1 ] ) ) NL if ( us > = 10 ) {  i -- NL a [ i ] = UInt8 ( UInt32 ( SMALLS_STRING [ ius ] ) ) NL } NL } NL if ( neg ) {  i -- NL a [ i ] = UInt8 ( UInt32 ( - ) ) NL } NL if ( append_ ) {  return  NL } NL return String . fromUtf8 ( a [ i .. a . size ] ) NL }","func_name":"formatBits","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func shouldSendReqContentLength ( method : String , contentLength : Int64 ) : Bool {  if ( contentLength > 0 ) {  return true NL } NL if ( contentLength < 0 ) {  return false NL } NL if ( method . equals ( POST ) || method . equals ( PUT ) || method . equals ( PATCH ) ) {  return true NL } NL return false NL }","func_name":"shouldSendReqContentLength","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func validPseudoPath ( str : String ) : Bool {  return ( str . size > 0 && str [ 0 ] == / ) || str . equals ( * ) NL }","func_name":"validPseudoPath","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func punycodeHostPort ( str : String ) : ( String , String ) {  if ( isASCII ( str ) ) {  return ( str ,  ) NL } NL  var ( host , port , err ) : ( String , String , String ) = splitHostPort ( str ) NL if ( ! err . isEmpty ( ) ) {  host = str NL port =  NL } NL if ( port . isEmpty ( ) ) {  return ( host ,  ) NL } NL return ( joinHostPort ( host , port ) ,  ) NL }","func_name":"punycodeHostPort","docstring":"//(string, error) => (String, String)"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func isASCII ( str : String ) : Bool {  for ( c in str ) {  if ( UInt32 ( c ) > = RUNESELF ) {  return false NL } NL } NL return true NL }","func_name":"isASCII","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func canonicalHeaderKey ( str : String ) : String {  return canonicalMIMEHeaderKey ( str ) NL }","func_name":"canonicalHeaderKey","docstring":"/* For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". */"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func validHeaderFieldName ( str : String ) : Bool {  if ( str . size == 0 ) {  return false NL } NL for ( c in str ) {  if ( ! validHeaderFieldByte ( c ) ) {  return false NL } NL } NL return true NL }","func_name":"validHeaderFieldName","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func validTrailerHeader ( key : String ) : Bool {   let name : String = canonicalMIMEHeaderKey ( key ) NL return ! ( name . startsWith ( If- ) || badTrailer . contains ( name ) ) NL }","func_name":"validTrailerHeader","docstring":"/* Whether the report name is a valid title field name to be displayed in the trailer. */"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func validHeaderFieldByte ( c : Char ) : Bool {   let index : Int64 = Int64 ( UInt32 ( c ) ) NL return index > 0 && index < 0x7f && isTokenTable [ index ] NL }","func_name":"validHeaderFieldByte","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func canonicalMIMEHeaderKey ( str : String ) : String {   var charArray : Array < Char > = str . toCharArray ( ) NL  var upper : Bool = true NL for ( index in 0 .. charArray . size ) {   let c = charArray [ index ] NL if ( ! validHeaderFieldByte ( c ) ) {  return str NL } NL if ( upper && a <= c && c <= z ) {  charArray [ index ] = upperChar ( c ) NL } NL if ( ! upper && A <= c && c <= Z ) {  charArray [ index ] = lowerChar ( c ) NL } NL upper = ( c == - ) NL } NL return String ( charArray ) NL }","func_name":"canonicalMIMEHeaderKey","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func validHeaderFieldValue ( str : String ) : Bool {  for ( c in str where ( c <   || UInt32 ( c ) == 0x7f ) && ! ( c ==   || c == \\t ) ) {  return false NL } NL return true NL }","func_name":"validHeaderFieldValue","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func splitHostPort ( hostport : String ) : ( String , String , String ) {   var j : Int64 = 0 NL  var k : Int64 = 0 NL  var host : String =  NL  let lastColonIndex : Int64 = hostport . lastIndexOf ( : ) ?? - 1 NL if ( lastColonIndex < 0 ) {  return ( hostport ,  , missingPort ) NL } NL if ( hostport [ 0 ] == [ ) {   let end : Int64 = hostport . indexOf ( ] ) ?? - 1 NL if ( end < 0 ) {  return ( hostport ,  , missing ']' in address ) NL } NL  let colonNum : Int64 = end + 1 NL if ( colonNum != lastColonIndex && colonNum == hostport . size ) {  return ( hostport ,  , missingPort ) NL } else if ( colonNum != lastColonIndex && hostport [ end + 1 ] == : ) {  return ( hostport ,  , tooManyColons ) NL } else if ( colonNum != lastColonIndex ) {  return ( hostport ,  , missingPort ) NL } NL host = hostport [ 1 .. end ] NL j = 1 NL k = end + 1 NL } else {  host = hostport [ 0 .. lastColonIndex ] NL if ( ( hostport . indexOf ( : ) ?? - 1 ) > = 0 ) {  return ( hostport ,  , tooManyColons ) NL } NL } NL  let num : Int64 = hostport . size NL if ( ( hostport [ j .. num ] . indexOf ( [ ) ?? - 1 ) > = 0 ) {  return ( hostport ,  , unexpected '[' in address ) NL } NL if ( ( hostport [ k .. num ] . indexOf ( ] ) ?? - 1 ) > = 0 ) {  return ( hostport ,  , unexpected ']' in address ) NL } NL return ( host , hostport [ lastColonIndex + 1 .. num ] ,  ) NL }","func_name":"splitHostPort","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func joinHostPort ( host : String , port : String ) : String {  if ( host . contains ( : ) ) {  return [${host}]:${port} NL } NL return ${host}:${port} NL }","func_name":"joinHostPort","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func asciiEqualFold ( str : String , src : String ) : Bool {  if ( str . size != src . size ) {  return false NL } NL return str . toAsciiLower ( ) . equals ( src ) NL }","func_name":"asciiEqualFold","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func asciiToLower ( str : String ) : ( String , Bool ) {  if ( ! isASCIIPrint ( str . toCharArray ( ) ) ) {  return (  , false ) NL } NL return ( str . toAsciiLower ( ) , true ) NL }","func_name":"asciiToLower","docstring":"/* If s is ASCII and printable, the lowercase version of S is returned, regardless of whether it is ASCII and printable.\n * (lower string, ok bool) => (String, Bool)\n */"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func isASCIIPrint ( chars : Array < Char > ) : Bool {  for ( c in 0 .. chars . size ) {  if ( chars [ c ] <   || chars [ c ] > ~ ) {  return false NL } NL } NL return true NL }","func_name":"isASCIIPrint","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func lowerChar ( b : Char ) : Char {  if ( A <= b && b <= Z ) {  return Char ( UInt32 ( b ) + 32 ) NL } NL return b NL }","func_name":"lowerChar","docstring":"/* lower returns the ASCII lowercase version of b. */"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func upperChar ( b : Char ) : Char {  if ( a <= b && b <= z ) {  return Char ( UInt32 ( b ) - 32 ) NL } NL return b NL }","func_name":"upperChar","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func getHeaderSize ( header : Header ) : Int64 {   let arr : Iterable < ( String , ArrayList < String > ) > = header . iterator ( ) NL  var num : Int64 = 0 NL for ( ( k , v ) in arr ) {  num ++ NL } NL return num NL }","func_name":"getHeaderSize","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func base64UrlEncode ( bytes : Array < UInt8 > ) : String {  return toBase64String ( bytes ) . split ( = ) [ 0 ] . replace ( + , - ) . replace ( / , _ ) NL }","func_name":"base64UrlEncode","docstring":"/*\n * Base64url encoding process:\n *     1. Plaintext is encrypted using Base64\n *     2. The following coding is performed on the basis of Base64:\n *         - Remove trailing '='\n *         - Replace \"+\" with \"-\"\n *         - Replace \"/\" with \"/\"\n */"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func base64UrlDecode ( b64Url : String ) : Array < UInt8 > {   var b64 = b64Url . replace ( - , + ) . replace ( _ , / ) NL match ( b64 . size % 4 ) { case 3 => b64 += = NL case 2 => b64 += == NL case 0 => ( ) NL case _ => throw NoneValueException ( fail ) NL } NL return fromBase64String ( b64 ) . getOrThrow ( ) NL }","func_name":"base64UrlDecode","docstring":"/*\n * Base64url decoding process:\n *     1. Decode the base64url encoding as follows:\n *         - Replace \"-\" with \"+\"\n *         - Put \"\\u\" Replace with \"/\"\n *         - (Calculate base64url encoding length)%4\n *             - The result is 0, do not process\n *             - The result is 2, and \"= =\" is added to the string\n *             - The result is 3, and \"=\" is added to the string\n *     2. Decode ciphertext with Base64 to obtain original plaintext\n */"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func bodyAllowedForStatus ( status : Int64 ) : Bool {  return ! ( ( status > = 100 && status <= 199 ) || status == 204 || status == 304 ) NL }","func_name":"bodyAllowedForStatus","docstring":"/* Reports whether the given response status code allows the body */"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func validWireHeaderFieldName ( v : String ) : Bool {  if ( v . isEmpty ( ) ) {  return false NL } NL for ( r in v ) {  if ( ! ( Int64 ( UInt32 ( r ) ) < isTokenTable . size && isTokenTable [ Int64 ( UInt32 ( r ) ) ] ) ) {  return false NL } NL if ( A <= r && r <= Z ) {  return false NL } NL } NL return true NL }","func_name":"validWireHeaderFieldName","docstring":"/* Encode the HTTP header. If the key is not zero, then (k, h[k]) is encoded only when k is in the key. */"}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func lowerHeader ( v : String ) : ( String , Bool ) {  match ( commonHeader . get ( v ) ) { case Some ( v ) => return ( v , true ) NL case None => return asciiToLower ( v ) NL } NL }","func_name":"lowerHeader","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func httpCodeString ( code : Int64 ) : String {  if ( code == 200 ) {  return 200 NL } else if ( code == 404 ) {  return 404 NL } else {  return 404 NL } NL return formatInt ( code , 10 ) NL }","func_name":"httpCodeString","docstring":""}
{"repo":"http2","file":"Utils.cj","path":"http2/src/proto/Utils.cj","code_tokens":"func authorityAddr ( scheme : String , authority : String ) : String {   var ( host , port , err ) : ( String , String , String ) = splitHostPort ( authority ) NL if ( ! err . isEmpty ( ) ) {  port = 443 NL if ( scheme . equals ( http ) ) {  port = 80 NL } NL host = authority NL } NL if ( host . startsWith ( [ ) && host . endsWith ( ] ) ) {  return host + : + port NL } NL return joinHostPort ( host , port ) NL }","func_name":"authorityAddr","docstring":"/*\n * Returns the given permission (host /ip or host: port /ip: port) and returns host: port. If necessary, add port 443.\n * (scheme: String, authority: String) => req.URL.Scheme, req.URL.Host\n */"}
{"repo":"http2","file":"http2Cfg.cj","path":"http2/src/proto/http2Cfg.cj","code_tokens":"public operator func [ ] ( key : Int64 , value ! : Int64 ) : Unit {  match ( key ) { case 0x01 => this . HEADER_TABLE_SIZE = value NL case 0x02 => this . ENABLE_PUSH = value NL case 0x03 => this . MAX_CONCURRENT_STREAMS = value NL case 0x04 => this . INITIAL_WINDOW_SIZE = value NL case 0x05 => this . MAX_FRAME_SIZE = value NL case 0x06 => this . MAX_HEADER_LIST_SIZE = value NL case _ => throw ProtocolErrorException ( ) NL } NL }","func_name":"[]","docstring":""}
{"repo":"http2","file":"http2Cfg.cj","path":"http2/src/proto/http2Cfg.cj","code_tokens":"public operator func [ ] ( key : Int64 ) : Int64 {  return match ( key ) { case 0x01 => this . HEADER_TABLE_SIZE NL case 0x02 => this . ENABLE_PUSH NL case 0x03 => this . MAX_CONCURRENT_STREAMS NL case 0x04 => this . INITIAL_WINDOW_SIZE NL case 0x05 => this . MAX_FRAME_SIZE NL case 0x06 => this . MAX_HEADER_LIST_SIZE NL case _ => throw ProtocolErrorException ( ) NL } NL }","func_name":"[]","docstring":""}
{"repo":"http2","file":"http2Transport.cj","path":"http2/src/proto/http2Transport.cj","code_tokens":"public override func roundTrip ( h1req : Request ) : H1Response {   let req = H2Request ( h1req ) NL  var scheme = req . url . scheme NL try {  h1req . header . checkHeaderNameVal ( ) NL } catch ( e : Exception ) {  return H1Response ( ) NL } NL if ( req . url . host . isEmpty ( ) ) {  throw HttpException ( http: no Host in request URL ) NL } NL  let url = authorityAddr ( h1req . url . scheme , h1req . url . host ) NL return match ( this . connPool . get ( url ) ) { case Some ( v ) => v . doRequest ( req ) . resp NL case None =>  let clientConnection = H2ClientConn . createClientConn ( this , this . createClient ( req ) ) NL this . connPool . put ( url , clientConnection ) NL clientConnection . doRequest ( req ) . resp NL } NL }","func_name":"roundTrip","docstring":"// override"}
{"repo":"http2","file":"http2Transport.cj","path":"http2/src/proto/http2Transport.cj","code_tokens":"protected func createClient ( request : H2Request ) : SyncSockClient {   var host : String = request . url . hostname ( ) NL  var port : UInt16 = 80 NL  let isTls = if ( request . url . rawurl . startsWith ( https ) ) {  port = 443 NL true NL } else {  false NL } NL match ( UInt16 . tryParse ( request . url . port ( ) ) ) { case Some ( v ) => port = v NL case None => ( ) NL } NL if ( isTls ) {  match ( this . tlsClientCfg ) { case Some ( v ) =>  var vv = v NL vv . verifyMode = VerifyNone NL return createClientSocket ( TCP , host , port , vv ) NL case None =>  var cfg = TlsClientConfig (  ) NL cfg . verifyMode = VerifyNone NL this . tlsClientCfg = cfg NL return createClientSocket ( TCP , host , port , cfg ) NL } NL } else {  return createClientSocket ( TCP , host , port ) NL } NL }","func_name":"createClient","docstring":"/* Createsocket is in the dorequest function of the client */"}
{"repo":"http2","file":"http2Transport.cj","path":"http2/src/proto/http2Transport.cj","code_tokens":"protected func createClientSocket ( net : SocketNet , address : String , port : UInt16 ) : SyncSockClient {   let client : Socket = Socket ( net , address , port ) NL client . connect ( ) NL client . quickAck = true NL return SyncSockClient ( client ) NL }","func_name":"createClientSocket","docstring":""}
{"repo":"http2","file":"http2Transport.cj","path":"http2/src/proto/http2Transport.cj","code_tokens":"protected func createClientSocket ( net : SocketNet , address : String , port : UInt16 , cfg : TlsClientConfig ) : SyncSockClient {   var h2cfg = cfg NL h2cfg . alpnList = [ h2 ] NL  let client = TlsSocket ( net , address , port , h2cfg ) NL client . connect ( ) NL return SyncSockClient ( client ) NL }","func_name":"createClientSocket","docstring":""}
{"repo":"http2","file":"http2Transport.cj","path":"http2/src/proto/http2Transport.cj","code_tokens":"public func get ( url : String ) : ? H2ClientConn {  match ( this . connPool . get ( url ) ) { case None => return None NL case Some ( list ) =>  let first = list . getFirst ( ) NL if ( first . closed . load ( ) ) {  first . clear ( ) NL return None NL } NL return first NL } NL }","func_name":"get","docstring":""}
{"repo":"http2","file":"http2Transport.cj","path":"http2/src/proto/http2Transport.cj","code_tokens":"public func put ( url : String , conn : H2ClientConn ) {  match ( this . connPool . get ( url ) ) { case None =>  let list = LinkedList < H2ClientConn > ( ) NL list . append ( conn ) NL this . connPool [ url ] = list NL case Some ( list ) => list . prepend ( conn ) NL } NL }","func_name":"put","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"static public func createClientConn ( hts : H2Transport , conn : SyncSockClient , id : UInt32 , cfg : H2Config ) : H2ClientConn {   let hcc : H2ClientConn = H2ClientConn ( hts , conn , id , cfg ) NL  let wrote2 = hcc . conn . write ( defaultRequestBytes ) NL hcc . conn . write ( CLIENT_SETTING_FRAME_ARRAY ) NL hcc . conn . write ( CLIENT_WINDOWS_UPDATE_ARRAY ) NL hcc . timeout = Time . now ( ) NL hcc . conn . write ( PING ) NL hcc . conn . flush ( ) NL hcc . readLoop ( H2ClientConnReadLoop ( hcc , conn , cfg . MAX_CONCURRENT_STREAMS ) ) NL return hcc NL }","func_name":"createClientConn","docstring":"/**\n     * The Function is createClientConn\n     *\n     * @param hts of H2Transport\n     * @param conn of Socket\n     * @param id of UInt32\n     * @param mfs of UInt32\n     * @param iws of UInt32\n     * @param mcs of UInt32\n     * @param pmhls of UInt64\n     * @param streamMap of Map<UInt32,H2ClientStream>\n     *\n     * @return Type of H2ClientConn\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"static public func createClientConn ( hts : H2Transport , conn : SyncSockClient ) : H2ClientConn {  return H2ClientConn . createClientConn ( hts , conn , 1 , H2Config ( ) ) NL }","func_name":"createClientConn","docstring":"/**\n     * The Function is createClientConn\n     *\n     * @param hts of H2Transport\n     * @param conn of Socket\n     * @param id of UInt32\n     * @param mfs of UInt32\n     * @param iws of UInt32\n     * @param mcs of UInt32\n     * @param pmhls of UInt64\n     * @param streamMap of Map<UInt32,H2ClientStream>\n     *\n     * @return Type of H2ClientConn\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"func readLoop ( loop : H2ClientConnReadLoop ) {  Ticker ( Duration . second ( 15 ) , { => if ( ! isPong . load ( ) ) {  try {  for ( ( id , stream ) in this . streamMap ) {  match ( stream ) { case Some ( v ) => v . isEndStream . put ( - 1 ) NL case None => ( ) NL } NL } NL this . conn . writeAndFlush ( GoAwayFrame ( 0 , 10 ) ) NL this . conn . close ( ) NL this . closed . store ( true ) NL return NL } catch ( e : SocketException ) {  ( ) NL } NL } NL this . conn . writeAndFlush ( PING ) NL if ( ! this . isFirst ) {  this . timeout = Time . now ( ) NL } NL this . isFirst = false NL } ) NL spawn { try {  match ( loop . run ( ) ) { case Some ( v ) => this . conn . write ( GoAwayFrame ( 0 , v . value ( ) , Error frames that the server cannot process. ) ) NL case None => ( ) NL } NL this . conn . flush ( ) NL this . conn . close ( ) NL } catch ( e : SocketException ) {  ( ) NL } NL for ( ( id , stream ) in this . streamMap ) {  match ( stream ) { case Some ( v ) => v . isEndStream . put ( - 1 ) NL case None => ( ) NL } NL } NL this . closed . store ( true ) NL } NL }","func_name":"readLoop","docstring":"/**\n     * The Function is readLoop\n     *\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"protected open func clear ( ) {  spawn { for ( ( id , stream ) in this . streamMap ) {  match ( stream ) { case Some ( v ) => v . clear ( ) NL case None => ( ) NL } NL } NL this . streamMap . clear ( ) NL this . decode . clear ( ) NL this . encode . clear ( ) NL this . conn . close ( ) NL } NL }","func_name":"clear","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"public func doRequest ( req : H2Request ) : H2Response {  synchronized ( muLock ) {   let id = Int64 ( this . nextStreamID . load ( ) ) NL this . nextStreamID . fetchAdd ( 2 ) NL  let h2Stream : H2ClientStream = H2ClientStream . newStream ( id , this , req . body ) NL h2Stream . doRequestHttp2 ( req ) NL this . streamMap . put ( id , Some ( h2Stream ) ) NL for ( frame in h2Stream . getFrames ( ) ) {  this . conn . write ( frame ) NL } NL this . conn . flush ( ) NL if ( h2Stream . isEndStream . poll ( ) < 0 ) {  throw Http2Exception ( error in response result. ) NL } NL  let resp = h2Stream . resp NL h2Stream . clear ( ) NL this . streamMap . put ( id , Option < H2ClientStream > . None ) NL return resp NL } NL }","func_name":"doRequest","docstring":"/**\n     * The Function is doRequest\n     *\n     * @param req of H2Request\n     *\n     * @return Type of H2Response\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"public func doStreamRequest ( req : H2Request ) {  synchronized ( muLock ) {   let id = this . nextStreamID NL this . nextStreamID . fetchAdd ( 2 ) NL  var arr = Array < UInt8 > ( [ 0 ] ) NL  var emptybody = ByteArrayStream ( ) NL emptybody . write ( arr ) NL  let h2Stream : H2ClientStream = H2ClientStream . newStream ( Int64 ( id . load ( ) ) , this , emptybody ) NL h2Stream . writeStreamRequest ( req ) NL for ( frame in h2Stream . getFrames ( ) ) {  this . conn . write ( frame ) NL } NL this . streamMap . put ( Int64 ( id . load ( ) ) , h2Stream ) NL } NL }","func_name":"doStreamRequest","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"public func sendStreamMsg ( msg : Array < UInt8 > ) {  synchronized ( muLock ) {   var data = DataFrame ( Int64 ( this . nextStreamID . load ( ) ) , 0 , ByteBuffer . wrap ( msg ) ) NL this . conn . write ( data ) NL } NL }","func_name":"sendStreamMsg","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"public func closeAndRecv ( ) : H2Response {  synchronized ( muLock ) {   let id = this . nextStreamID NL  var data = DataFrame ( Int64 ( this . nextStreamID . load ( ) ) , 1 , ByteBuffer . allocate ( 0 ) ) NL this . conn . write ( data ) NL this . conn . flush ( ) NL  var h2Stream = this . streamMap . get ( Int64 ( id . load ( ) ) ) . getOrThrow ( ) . getOrThrow ( ) NL if ( h2Stream . isEndStream . poll ( ) < 0 ) {  throw Http2Exception ( ) NL } NL return h2Stream . resp NL } NL }","func_name":"closeAndRecv","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"public func run ( ) : ? ErrorCodes {   let framedecode = FramesDecoder ( doProcessFrames ) NL try {  while ( ! this . cc . closed . load ( ) && this . isNoError ) {   let connReadArray : Array < UInt8 > = Array < UInt8 > ( 1024 , item : 0 ) NL  let length = this . socket . read ( connReadArray ) NL if ( length == 0 ) {  continue NL } NL framedecode . decode ( ByteBuffer . wrap ( connReadArray , 0 , length ) ) NL } NL return errorCode NL } catch ( e : SocketException ) {  return NO_ERROR NL } catch ( e : Exception ) {  return PROTOCOL_ERROR NL } NL }","func_name":"run","docstring":"/**\n     * The Function is run\n     *\n     * @return Type of ?ErrorCodes\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"func doProcessFrames ( frame : Http2Frame ) {  try {  match ( frame . TYPE ) { case 0x06 => processPing ( ( frame as PingFrame ) . getOrThrow ( ) ) NL case 0x04 => processSettings ( ( frame as SettingsFrame ) . getOrThrow ( ) ) NL case 0x07 => processGoAway ( ( frame as GoAwayFrame ) . getOrThrow ( ) ) NL case 0x01 => processHeaders ( ( frame as HeadersFrame ) . getOrThrow ( ) ) NL case 0x00 => processData ( ( frame as DataFrame ) . getOrThrow ( ) ) NL case 0x08 => processWindowUpdate ( ( frame as WindowUpdateFrame ) . getOrThrow ( ) ) NL case 0x05 => processPushered ( ( frame as PushPromiseFrame ) . getOrThrow ( ) ) NL case _ => this . errorCode = PROTOCOL_ERROR NL } NL } catch ( e : Exception ) {  this . errorCode = PROTOCOL_ERROR NL } NL }","func_name":"doProcessFrames","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"func processPushered ( pushed : PushPromiseFrame ) : Unit {   let stream = H2ClientStream ( pushed . promisedStream , this . cc , ByteArrayStream ( ) ) NL stream . isPushed . store ( false ) NL try {   var isPath = false NL  var isMethod = false NL for ( da in pushed . headerBlocks ) {   let arr = this . cc . decode . decode ( ByteBufferToArray ( da ) ) NL for ( headerField in arr ) {  if ( headerField . name == :path ) {   let path = fs . Path ( getcwd ( ) ) . join ( headerField . value ) NL stream . pushedFile = fs . File ( path , CreateOrTruncate ( true ) ) NL isPath = true NL } NL if ( headerField . name == :method ) {  match ( headerField . value ) { case HEAD | Head => stream . req = H2Request ( HEAD ,  ) NL isMethod = true NL case GET | Get => stream . req = H2Request ( GET ,  ) NL isMethod = true NL case _ => ( ) NL } NL } NL } NL } NL if ( ! isPath || ! isMethod ) {  this . errorCode = PROTOCOL_ERROR NL } NL } catch ( e : Exception ) {  this . errorCode = PROTOCOL_ERROR NL } NL }","func_name":"processPushered","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"func processWindowUpdate ( WindowUpdate : WindowUpdateFrame ) : Unit {  spawn { this . cc . conf . INITIAL_WINDOW_SIZE = WindowUpdate . update NL } NL }","func_name":"processWindowUpdate","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"func processHeaders ( header : HeadersFrame ) : Unit {   let stream = this . cc . streamMap [ header . streamid ] . getOrThrow ( ) NL try {  stream . resp . appendHeader ( header ) NL if ( ( header . flags & 1 ) == 1 ) {  stream . rawCreatResponse ( ) NL spawn { if ( ! stream . isPushed . load ( ) ) {  stream . isPushedStream . poll ( ) NL } NL stream . isEndStream . put ( 1 ) NL } NL } NL } catch ( e : Exception ) {  stream . isEndStream . put ( - 1 ) NL this . errorCode = PROTOCOL_ERROR NL } NL }","func_name":"processHeaders","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"func processData ( data : DataFrame ) : Unit {   let stream = this . cc . streamMap [ data . streamid ] . getOrThrow ( ) NL try {  stream . resp . appendData ( data ) NL if ( data . streamid % 2 == 0 ) {  if ( ( data . flags & 0 ) == 0 ) {   let bytes = ArrayList < Byte > ( ) NL for ( da in data . data ) {  bytes . appendAll ( ByteBufferToArray ( da ) ) NL } NL stream . pushedFile . getOrThrow ( ) . write ( unsafe {  bytes . getRawArray ( ) [ 0 .. bytes . size ] NL } ) NL stream . isPushedStream . put ( 1 ) NL } NL } else if ( ( data . flags & 1 ) == 1 ) {  stream . rawCreatResponse ( ) NL spawn { if ( ! stream . isPushed . load ( ) ) {  stream . isPushedStream . poll ( ) NL } NL stream . isEndStream . put ( 1 ) NL } NL } NL } catch ( e : Exception ) {  stream . isEndStream . put ( - 1 ) NL this . errorCode = PROTOCOL_ERROR NL } NL }","func_name":"processData","docstring":""}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"func processGoAway ( goaway : GoAwayFrame ) : Unit {  spawn { try {  if ( goaway . flags != 0x0 ) {  this . errorCode = PROTOCOL_ERROR NL } NL this . cc . connState = CLOSE NL } catch ( e : Exception ) {  this . errorCode = PROTOCOL_ERROR NL } NL } NL }","func_name":"processGoAway","docstring":"/*\n     * GOAWAY frames apply to connections, not specific streamMap.\n     * The endpoint must treat GOAWAY frames with stream identifiers other than 0x0 as PROTOCOL_ ERROR type connection error (Section 5.4.1).\n     */"}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"func processPing ( ping : PingFrame ) : Unit {  spawn { try {  if ( ping . flags != 1 ) {  ping . flags = 1 NL this . cc . conn . write ( ping ) NL } else {   let timeDifference = Time . since ( this . cc . timeout ) NL this . cc . timeout = Time . now ( ) NL if ( timeDifference . seconds ( ) > 15 ) {  this . errCode = CONNECT_ERROR NL return NL } NL this . cc . isPong . store ( true ) NL } NL } catch ( e : Exception ) {  this . errCode = PROTOCOL_ERROR NL } NL } NL }","func_name":"processPing","docstring":"/**\n     * The Function is processPing\n     *\n     * @param ping of Http2Frame\n     * @param data of Array<UInt8>\n     *\n     * @return Type of ?ErrorCodes\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2ClientConn.cj","path":"http2/src/proto/http2ClientConn.cj","code_tokens":"func processSettings ( settings : SettingsFrame ) : Unit {  try {  if ( settings . length % 6 != 0 && settings . TYPE != 0x4 ) {  this . errCode = PROTOCOL_ERROR NL return NL } NL if ( settings . flags != 0x0 ) {  return NL } NL for ( i in 1 ..= 6 ) {  match ( settings [ i ] ) { case Some ( v ) => this . cc . conf [ i ] = v NL case None => ( ) NL } NL } NL this . cc . conn . writeAndFlush ( SettingsFrame ( 1 ) ) NL } catch ( e : Exception ) {  this . errCode = PROTOCOL_ERROR NL } NL }","func_name":"processSettings","docstring":"/**\n     * The Function is processSettings\n     *\n     * @param settings of Http2Frame\n     * @param data of Array<UInt8>\n     *\n     * @return Type of ?ErrorCodes\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"WriteResHeaders.cj","path":"http2/src/proto/WriteResHeaders.cj","code_tokens":"func writeFrameHeader ( serverConn : H2ServerConn ) {  arrHeaderField . clear ( ) NL if ( this . httpResCode != 0 ) {  arrHeaderField . append ( HeaderField ( :status , httpCodeString ( this . httpResCode ) ) ) NL } NL encodeHeaders ( arrHeaderField ) NL if ( ! this . contentType . isEmpty ( ) ) {  arrHeaderField . append ( HeaderField ( content-type , this . contentType ) ) NL } NL if ( ! this . contentLength . isEmpty ( ) ) {  arrHeaderField . append ( HeaderField ( content-length , this . contentLength ) ) NL } NL if ( ! this . date . isEmpty ( ) ) {  arrHeaderField . append ( HeaderField ( date , this . date , true ) ) NL } NL encKV ( arrHeaderField ) NL  let headerBlock : Array < UInt8 > = serverConn . hpackEncode . encode ( arrHeaderField ) NL  let isTrailersEmpty : Bool = this . trailers . isEmpty ( ) NL if ( headerBlock . size == 0 && isTrailersEmpty ) {  throw Http2Exception ( unexpected empty hpack. ) NL } NL splitHeaderBlock ( serverConn , headerBlock ) NL }","func_name":"writeFrameHeader","docstring":""}
{"repo":"http2","file":"WriteResHeaders.cj","path":"http2/src/proto/WriteResHeaders.cj","code_tokens":"func encKV ( arr : LinkedList < HeaderField > ) : Unit {   let buf = StringBuilder ( ) NL for ( ( name , values ) in this . header ) {  for ( i in 0 .. values . size ) {  if ( i == 0 ) {  buf . append ( values [ i ] ) NL } else {  buf . append ( ; ) NL buf . append ( values [ i ] ) NL } NL } NL arr . append ( HeaderField ( name , buf . toString ( ) ) ) NL buf . clear ( ) NL } NL }","func_name":"encKV","docstring":""}
{"repo":"http2","file":"WriteResHeaders.cj","path":"http2/src/proto/WriteResHeaders.cj","code_tokens":"func encodeHeaders ( arr : LinkedList < HeaderField > ) : Unit {  for ( key in this . trailers ) {   let vv = this . header . getAll ( key ) NL  let ( k , ascii ) : ( String , Bool ) = lowerHeader ( key ) NL if ( ! ascii ) {  continue NL } NL if ( ! validWireHeaderFieldName ( k ) ) {  continue NL } NL  let isTE : Bool = k . equals ( transfer-encoding ) NL for ( v in vv ) {  if ( ! validHeaderFieldValue ( v ) ) {  continue NL } NL if ( isTE && ! v . equals ( trailers ) ) {  continue NL } NL arr . append ( HeaderField ( k , v ) ) NL } NL } NL }","func_name":"encodeHeaders","docstring":""}
{"repo":"http2","file":"WriteResHeaders.cj","path":"http2/src/proto/WriteResHeaders.cj","code_tokens":"func writeHeaderBlock ( serverConn : H2ServerConn , frag : Array < UInt8 > , firstFrag : Bool , endHeaders : Bool ) : Unit {  if ( firstFrag ) {   let headersFrame : Http2Frame = writeHeadersFrame ( this . streamID , frag , this . endStream , endHeaders , 0 ) NL serverConn . conn . write ( headersFrame ) NL } else {   let continuationFrame : Http2Frame = writeContinuation ( this . streamID , endHeaders , frag ) NL serverConn . conn . write ( continuationFrame ) NL } NL }","func_name":"writeHeaderBlock","docstring":""}
{"repo":"http2","file":"WriteResHeaders.cj","path":"http2/src/proto/WriteResHeaders.cj","code_tokens":"func splitHeaderBlock ( serverConn : H2ServerConn , headerData : Array < UInt8 > ) : Unit {   let maxFrameSize = serverConn . connCfg . MAX_FRAME_SIZE NL  var first : Bool = true NL  var headerBlock : Array < UInt8 > = headerData NL while ( headerBlock . size > 0 ) {   var frag : Array < UInt8 > = headerBlock NL if ( frag . size > maxFrameSize ) {  frag = frag [ 0 .. maxFrameSize ] NL } NL if ( frag . size == headerBlock . size ) {  headerBlock = Array < UInt8 > ( ) NL } else {  headerBlock = headerBlock [ frag . size .. headerBlock . size ] NL } NL this . writeHeaderBlock ( serverConn , frag , first , headerBlock . isEmpty ( ) ) NL first = false NL } NL }","func_name":"splitHeaderBlock","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"public func rawCreatResponse ( ) {  this . resp . rawCreatResponse ( this . req . getOrThrow ( ) ) NL }","func_name":"rawCreatResponse","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"protected func clear ( ) {  allHttp2Frame . clear ( ) NL pushedFile = None NL req = None NL match ( reqBody ) { case bas : ByteArrayStream => bas . clear ( ) NL case _ => ( ) NL } NL reqBody = None NL }","func_name":"clear","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"static public func newStream ( ids : Int64 , cc : H2ClientConn , reqBody : InputStream ) : H2ClientStream {  return H2ClientStream ( ids , cc , reqBody ) NL }","func_name":"newStream","docstring":"/**\n     * The Function is newStream\n     *\n     * @param ids of UInt32\n     * @param cc of H2ClientConn\n     * @param reqBody of ByteArrayStream\n     *\n     * @return Type of H2ClientStream\n     * @since 0.29.3\n     */"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func doRequestHttp2 ( req : H2Request ) : Unit {  this . req = req NL  let err : String = this . writeRequest ( req ) NL }","func_name":"doRequestHttp2","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"protected func getFrames ( ) : Collection < Http2Frame > {  return allHttp2Frame NL }","func_name":"getFrames","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func encodeHeaders ( req : H2Request , addGzipHeader : Bool , trailers : String , contentLength : Int64 , encode : Encoder ) : ( Array < UInt8 > , String ) {  if ( req . url . rawurl . isEmpty ( ) ) {  return ( EMPTY_ARRAY , errNilRequestURL ) NL } NL  var host : String = req . host NL if ( host . isEmpty ( ) ) {  host = req . url . host NL } NL  var ( hostp , err ) : ( String , String ) = punycodeHostPort ( host ) NL host = hostp NL if ( ! err . isEmpty ( ) ) {  return ( EMPTY_ARRAY , err ) NL } NL  var path : String = req . url . path NL for ( ( k , vv ) in req . header ) {  if ( ! validHeaderFieldName ( k ) ) {  return ( EMPTY_ARRAY , invalid HTTP header name ${k} ) NL } NL for ( i in 0 .. vv . size ) {  if ( ! validHeaderFieldValue ( vv [ i ] ) ) {  return ( EMPTY_ARRAY , invalid HTTP header value for header ${k} ) NL } NL } NL } NL  let arrHeaderField : LinkedList < HeaderField > = LinkedList < HeaderField > ( ) NL  var hlSize : Int64 = enumerateHeaders ( host , path , req , addGzipHeader , trailers , contentLength , true , arrHeaderField ) NL if ( hlSize > cc . conf . MAX_HEADER_LIST_SIZE ) {  return ( EMPTY_ARRAY , errRequestHeaderListSize ) NL } NL this . enumerateHeaders ( host , path , req , addGzipHeader , trailers , contentLength , false , arrHeaderField ) NL  let arrhbuf : Array < UInt8 > = this . cc . encode . encode ( arrHeaderField ) NL return ( arrhbuf ,  ) NL }","func_name":"encodeHeaders","docstring":"/* Array<UInt8>, error => (Array<UInt8>, String) */"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func encodeStreamHeaders ( streamreq : H2Request , addGzipHeader : Bool , trailers : String , encode : Encoder ) : ( Array < UInt8 > , String ) {  if ( streamreq . url . rawurl . isEmpty ( ) ) {  return ( EMPTY_ARRAY , errNilRequestURL ) NL } NL  var host : String = streamreq . host NL if ( host . isEmpty ( ) ) {  host = streamreq . url . host NL } NL  var ( hostp , err ) : ( String , String ) = punycodeHostPort ( host ) NL host = hostp NL if ( ! err . isEmpty ( ) ) {  return ( EMPTY_ARRAY , err ) NL } NL  var path : String = streamreq . url . requestURI ( ) NL if ( ! validPseudoPath ( path ) ) {   let orig : String = path NL path = path . trimLeft ( streamreq . url . scheme + :// + host ) NL if ( ! validPseudoPath ( path ) ) {  if ( ! streamreq . url . opaque . isEmpty ( ) ) {  return ( EMPTY_ARRAY , invalid request :path ${orig} from URL.Opaque = ${streamreq.url.opaque} ) NL } else {  return ( EMPTY_ARRAY , invalid request :path ${orig} ) NL } NL } NL } NL for ( ( k , vv ) in streamreq . header ) {  if ( ! validHeaderFieldName ( k ) ) {  return ( EMPTY_ARRAY , invalid HTTP header name ${k} ) NL } NL for ( i in 0 .. vv . size ) {  if ( ! validHeaderFieldValue ( vv [ i ] ) ) {  return ( EMPTY_ARRAY , invalid HTTP header value for header ${k} ) NL } NL } NL } NL  let arrHeaderField : LinkedList < HeaderField > = LinkedList < HeaderField > ( ) NL  var hlSize : Int64 = enumerateStreamHeaders ( host , path , streamreq , addGzipHeader , trailers , true , arrHeaderField ) NL if ( hlSize > cc . conf . MAX_HEADER_LIST_SIZE ) {  return ( EMPTY_ARRAY , errRequestHeaderListSize ) NL } NL enumerateStreamHeaders ( host , path , streamreq , addGzipHeader , trailers , false , arrHeaderField ) NL  let arrhbuf : Array < UInt8 > = this . cc . encode . encode ( arrHeaderField ) NL return ( arrhbuf ,  ) NL }","func_name":"encodeStreamHeaders","docstring":"/* Array<UInt8>, error => (Array<UInt8>, String) */"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"private func enumerateHeaders ( host : String , path : String , req : H2Request , addGzipHeader : Bool , trailers : String , contentLength : Int64 , isFirst : Bool , arr : LinkedList < HeaderField > ) : Int64 {   var hlSize : Int64 = 0 NL hlSize += enumerateHeader ( :authority , host , isFirst , arr ) NL hlSize += enumerateHeader ( :method , req . method . toString ( ) , isFirst , arr ) NL hlSize += enumerateHeader ( :path , path , isFirst , arr ) NL hlSize += enumerateHeader ( :scheme , req . url . scheme , isFirst , arr ) NL if ( ! trailers . isEmpty ( ) ) {  hlSize += enumerateHeader ( trailer , trailers , isFirst , arr ) NL } NL  let ( hlnum , didUA , cleanUA ) : ( Int64 , Bool , Bool ) = enumerateHeadersUtil ( req , isFirst , arr ) NL hlSize += hlnum NL if ( shouldSendReqContentLength ( req . method . toString ( ) , contentLength ) ) {  hlSize += enumerateHeader ( content-length , formatInt ( contentLength , 10 ) , isFirst , arr ) NL } NL if ( addGzipHeader ) {  hlSize += enumerateHeader ( accept-encoding , gzip , isFirst , arr ) NL } NL if ( cleanUA ) {  req . header . remove ( User-Agent ) NL } NL if ( ! didUA ) {  hlSize += enumerateHeader ( user-agent , defaultUserAgent , isFirst , arr ) NL } NL return hlSize NL }","func_name":"enumerateHeaders","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"private func enumerateStreamHeaders ( host : String , path : String , streamreq : H2Request , addGzipHeader : Bool , trailers : String , isFirst : Bool , arr : LinkedList < HeaderField > ) : Int64 {   var hlSize : Int64 = 0 NL hlSize += enumerateHeader ( :authority , host , isFirst , arr ) NL hlSize += enumerateHeader ( :method , streamreq . method . toString ( ) , isFirst , arr ) NL hlSize += enumerateHeader ( :path , path , isFirst , arr ) NL hlSize += enumerateHeader ( :scheme , streamreq . url . scheme , isFirst , arr ) NL if ( ! trailers . isEmpty ( ) ) {  hlSize += enumerateHeader ( trailer , trailers , isFirst , arr ) NL } NL  let ( hlnum , didUA , cleanUA ) : ( Int64 , Bool , Bool ) = enumerateHeadersUtil ( streamreq , isFirst , arr ) NL hlSize += hlnum NL if ( addGzipHeader ) {  hlSize += enumerateHeader ( accept-encoding , gzip , isFirst , arr ) NL } NL if ( cleanUA ) {  streamreq . header . remove ( User-Agent ) NL } NL if ( ! didUA ) {  hlSize += enumerateHeader ( user-agent , defaultUserAgent , isFirst , arr ) NL } NL return hlSize NL }","func_name":"enumerateStreamHeaders","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"private func enumerateHeadersUtil ( req : H2Request , isFirst : Bool , arr : LinkedList < HeaderField > ) : ( Int64 , Bool , Bool ) {   var hlSize : Int64 = 0 NL  var didUA : Bool = false NL  var cleanUA : Bool = false NL for ( ( k , value ) in req . header ) {   var vv : ArrayList < String > = value NL if ( asciiEqualFold ( k , host ) || asciiEqualFold ( k , content-length ) ) {  continue NL } else if ( asciiEqualFold ( k , connection ) || asciiEqualFold ( k , proxy-connection ) || asciiEqualFold ( k , transfer-encoding ) || asciiEqualFold ( k , upgrade ) || asciiEqualFold ( k , keep-alive ) ) {  continue NL } else if ( asciiEqualFold ( k , user-agent ) ) {  for ( str in vv ) {  if ( str . equals ( cangjie-http-client/1.1 ) ) {  cleanUA = true NL } NL } NL if ( ! cleanUA ) {  didUA = true NL if ( vv . size < 1 ) {  continue NL } NL vv = vv . slice ( 0 .. 1 ) NL if ( vv [ 0 ] . isEmpty ( ) ) {  continue NL } NL } NL } else if ( asciiEqualFold ( k , cookie ) ) {  hlSize += handleHeaderCookie ( vv , isFirst , arr ) NL continue NL } NL for ( v in vv ) {  hlSize += enumerateHeader ( k . toAsciiLower ( ) , v , isFirst , arr ) NL } NL } NL return ( hlSize , didUA , cleanUA ) NL }","func_name":"enumerateHeadersUtil","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func handleHeaderCookie ( vv : ArrayList < String > , isFirst : Bool , arr : LinkedList < HeaderField > ) : Int64 {   var hlSize : Int64 = 0 NL for ( v in 0 .. vv . size ) {   var str : String = vv [ v ] NL while ( true ) {   var p : Int64 = str . indexOf ( ; ) . getOrDefault ( { => - 1 NL } ) NL if ( p < 0 ) {  break NL } NL hlSize += enumerateHeader ( cookie , str . substring ( 0 , p ) , isFirst , arr ) NL p ++ NL while ( p + 1 <= str . size && str [ p ] ==   ) {  p ++ NL } NL str = str . substring ( p ) NL } NL if ( str . size > 0 ) {  hlSize += enumerateHeader ( cookie , str , isFirst , arr ) NL } NL } NL return hlSize NL }","func_name":"handleHeaderCookie","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func enumerateHeader ( name : String , value : String , isFirst : Bool , arr : LinkedList < HeaderField > ) : Int64 {   var num : Int64 = 0 NL if ( isFirst ) {  num = name . size + value . size + 32 NL } else {  arr . append ( HeaderField ( name , value ) ) NL } NL return num NL }","func_name":"enumerateHeader","docstring":"/* processing compressed headers */"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func writeHeaders ( streamID : Int64 , endStream : Bool , maxFrameSize : Int64 , hdrsArr : Array < UInt8 > ) : Unit {   var first : Bool = true NL  var hdrs : Array < UInt8 > = hdrsArr NL while ( hdrs . size > 0 ) {   var chunk : Array < UInt8 > = hdrs NL if ( chunk . size > maxFrameSize ) {  chunk = chunk [ 0 .. maxFrameSize ] NL } NL if ( chunk . size == hdrs . size ) {  hdrs = Array < UInt8 > ( ) NL } else {  hdrs = hdrs [ chunk . size .. hdrs . size ] NL } NL  let endHeaders : Bool = hdrs . size == 0 NL if ( first ) {   let headersFrame : Http2Frame = writeHeadersFrame ( streamID , chunk , endStream , endHeaders , 0 ) NL this . allHttp2Frame . append ( headersFrame ) NL first = false NL } else {   let continuationFrame : Http2Frame = writeContinuation ( streamID , endHeaders , chunk ) NL allHttp2Frame . append ( continuationFrame ) NL } NL } NL }","func_name":"writeHeaders","docstring":"/* error => String */"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func writeData ( streamID : Int64 , endStream : Bool , chunk : Array < UInt8 > , padLength : Int64 ) : String {   let dataFrame : Http2Frame = writeDataPadded ( streamID , endStream , chunk , padLength ) NL allHttp2Frame . append ( dataFrame ) NL this . dataLength += dataFrame . length + 9 NL return  NL }","func_name":"writeData","docstring":"// WriteData writes a DATA frame"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func encodeTrailers ( trailer : Header , encode : Encoder ) : ( Array < UInt8 > , String ) {   var hlSize : Int64 = 0 NL for ( ( k , vv ) in trailer ) {  for ( v in 0 .. vv . size ) {  hlSize += k . size + vv [ v ] . size + 32 NL } NL } NL if ( hlSize > cc . conf . MAX_HEADER_LIST_SIZE ) {  return ( EMPTY_ARRAY , errRequestHeaderListSize ) NL } NL for ( ( k , vv ) in trailer ) {   let ( lowKey , ascii ) : ( String , Bool ) = asciiToLower ( k ) NL if ( ! ascii ) {  continue NL } NL for ( i in 0 .. vv . size ) {  writeHeader ( lowKey , vv [ i ] , encode ) NL } NL } NL return ( Array < Byte > ( 2028 , item : 0 ) ,  ) NL }","func_name":"encodeTrailers","docstring":"/* ([]byte, error) => (Array<UInt8>, String) */"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func writeHeader ( name : String , value : String , encode : Encoder ) {   let hf : HeaderField = HeaderField ( name , value ) NL this . cc . encode . encode ( [ hf ] ) NL }","func_name":"writeHeader","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"private func writeRequest ( req : H2Request ) : String {   var err : String =  NL match ( req . header . get ( Accept-Encoding ) ) { case None => match ( req . header . get ( Range ) ) { case None => requestedGzip = true NL case _ => ( ) NL } NL case _ => ( ) NL } NL err = encodeAndWriteHeaders ( req ) NL if ( ! err . isEmpty ( ) ) {  return err NL } NL if ( reqBodyContentLength == 0 ) {  sentEndStream = true NL } else {  err = writeRequestBody ( req ) NL allHttp2Frame . append ( WindowUpdateFrame ( 0 , this . dataLength ) ) NL allHttp2Frame . append ( PING ) NL if ( ! err . isEmpty ( ) ) {  if ( ! err . equals ( errStopReqBodyWrite ) ) {  return err NL } NL } else {  sentEndStream = true NL } NL } NL return err NL }","func_name":"writeRequest","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func writeStreamRequest ( req : H2Request ) : String {  this . req = req NL  var err : String =  NL match ( req . header . get ( Accept-Encoding ) ) { case None => match ( req . header . get ( Range ) ) { case None => requestedGzip = true NL case _ => ( ) NL } NL case _ => ( ) NL } NL err = encodeAndWriteStreamHeaders ( req ) NL if ( ! err . isEmpty ( ) ) {  return err NL } NL sentEndStream = false NL return err NL }","func_name":"writeStreamRequest","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func encodeAndWriteStreamHeaders ( streamReq : H2Request ) : String {  sb . clear ( ) NL  var frist = true NL for ( ( name , v ) in streamReq . trailer ) {  if ( ! frist ) {  sb . append ( , ) NL } NL frist = false NL  let k : String = canonicalHeaderKey ( name ) NL if ( k . equals ( Transfer-Encoding ) || k . equals ( Trailer ) || k . equals ( Content-Length ) ) {  return invalid Trailer key ${k} NL } NL sb . append ( k ) NL } NL  let ( hdrs , errEH ) : ( Array < UInt8 > , String ) = this . encodeStreamHeaders ( streamReq , requestedGzip , sb . toString ( ) , this . cc . encode ) NL if ( ! errEH . isEmpty ( ) ) {  return errEH NL } NL this . writeHeaders ( ID , this . reqBodyContentLength == 0 && sb . size == 0 , cc . conf . MAX_FRAME_SIZE , hdrs ) NL return  NL }","func_name":"encodeAndWriteStreamHeaders","docstring":"/* String => error */"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func writeRequestBody ( req : H2Request ) : String {   var body : InputStream = this . reqBody . getOrThrow ( ) NL  var sentEnd : Bool = false NL  let trailerNum : Int64 = getHeaderSize ( req . trailer ) NL  var remainLen : Int64 = reqBodyContentLength NL  let hasContentLen : Bool = remainLen != - 1 NL  let maxFrameSize : Int64 = Int64 ( cc . conf . MAX_FRAME_SIZE ) NL  let scratchLen : Int64 = frameScratchBufferLen ( cc . conf . MAX_FRAME_SIZE ) NL  var buf : Array < Byte > = Array < Byte > ( scratchLen , item : 0 ) NL  var sawEOF : Bool = false NL while ( ! sawEOF ) {   let n : Int64 = body . read ( buf ) NL  var err : String =  NL if ( hasContentLen ) {  remainLen -= n NL if ( remainLen == 0 ) {  err = EOF NL } NL if ( remainLen < 0 ) {  err = errReqBodyTooLong NL return err NL } NL } NL if ( ! err . isEmpty ( ) ) {   let bodyClosed : Bool = reqBodyClosed NL if ( bodyClosed ) {  return errStopReqBodyWrite NL } else if ( err . equals ( EOF ) ) {  sawEOF = true NL err =  NL } else {  return err NL } NL } NL  let ( errFlag , sentEndFlag ) : ( String , Bool ) = writeRequestBodyUtil ( n , buf , err , sentEnd , sawEOF , trailerNum ) NL err = errFlag NL sentEnd = sentEndFlag NL if ( ! err . isEmpty ( ) ) {  return err NL } NL } NL if ( sentEnd ) {  return  NL } NL return writeRequestBodyEnd ( req , maxFrameSize , trailerNum ) NL }","func_name":"writeRequestBody","docstring":"/* (err error) => String */"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func writeRequestBodyUtil ( n : Int64 , buf : Array < UInt8 > , errFlag : String , sentEndFlag : Bool , sawEOF : Bool , trailerNum : Int64 ) : ( String , Bool ) {   var err : String = errFlag NL  var sentEnd : Bool = sentEndFlag NL  let hasTrailers : Bool = trailerNum != 0 NL  var remain : Array < UInt8 > = buf [ 0 .. n ] NL while ( remain . size > 0 && err . isEmpty ( ) ) {   var ( allowed , erral ) : ( Int64 , String ) = awaitFlowControl ( remain . size ) NL err = erral NL if ( ! err . isEmpty ( ) ) {  return ( err , sentEnd ) NL } NL  var data : Array < UInt8 > = remain NL if ( allowed < remain . size ) {  data = remain [ 0 .. allowed ] NL remain = remain [ allowed .. remain . size ] NL } else {  remain = Array < UInt8 > ( ) NL } NL sentEnd = sawEOF && remain . size == 0 && ! hasTrailers NL err = this . writeData ( ID , sentEnd , data , 0 ) NL } NL if ( ! err . isEmpty ( ) ) {  return ( err , sentEnd ) NL } NL return ( err , sentEnd ) NL }","func_name":"writeRequestBodyUtil","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func writeRequestBodyEnd ( req : H2Request , maxFrameSize : Int64 , trailerNum : Int64 ) : String {   let trailer : Header = req . trailer NL  var trls : Array < UInt8 > = Array < UInt8 > ( ) NL  var err : String =  NL if ( trailerNum > 0 ) {   let ( trlsArr , errtrls ) : ( Array < UInt8 > , String ) = this . encodeTrailers ( trailer , this . cc . encode ) NL trls = trlsArr NL err = errtrls NL if ( ! err . isEmpty ( ) ) {  return err NL } NL } NL if ( trls . size > 0 ) {  this . writeHeaders ( ID , true , maxFrameSize , trls ) NL } else {  err = this . writeData ( ID , true , Array < UInt8 > ( ) , 0 ) NL } NL return err NL }","func_name":"writeRequestBodyEnd","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func awaitFlowControl ( maxBytes : Int64 ) : ( Int64 , String ) {   var take : Int64 = maxBytes NL if ( cc . closed . load ( ) ) {  return ( 0 , errClientConnClosed ) NL } NL if ( reqBodyClosed ) {  return ( 0 , errStopReqBodyWrite ) NL } NL if ( maxBytes > Int64 ( cc . conf . MAX_FRAME_SIZE ) ) {  take = Int64 ( cc . conf . MAX_FRAME_SIZE ) NL } NL return ( take ,  ) NL }","func_name":"awaitFlowControl","docstring":"/* (taken int32, err error) */"}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func frameScratchBufferLen ( maxFrameSize : Int64 ) : Int64 {   let max : Int64 = 512 << 10 NL  var n : Int64 = Int64 ( maxFrameSize ) NL if ( n > max ) {  n = max NL } NL  let cl : Int64 = reqBodyContentLength NL if ( cl != - 1 && ( cl + 1 ) < n ) {  n = cl + 1 NL } NL if ( n < 1 ) {  return 1 NL } NL return n NL }","func_name":"frameScratchBufferLen","docstring":""}
{"repo":"http2","file":"http2ClientStream.cj","path":"http2/src/proto/http2ClientStream.cj","code_tokens":"func encodeAndWriteHeaders ( req : H2Request ) : String {  sb . clear ( ) NL  var frist = true NL for ( ( name , v ) in req . trailer ) {  if ( ! frist ) {  sb . append ( , ) NL } NL frist = false NL  let k : String = canonicalHeaderKey ( name ) NL if ( k . equals ( Transfer-Encoding ) || k . equals ( Trailer ) || k . equals ( Content-Length ) ) {  return invalid Trailer key ${k} NL } NL sb . append ( k ) NL } NL  let ( hdrs , errEH ) : ( Array < UInt8 > , String ) = this . encodeHeaders ( req , requestedGzip , sb . toString ( ) , this . reqBodyContentLength , this . cc . encode ) NL if ( ! errEH . isEmpty ( ) ) {  return errEH NL } NL this . writeHeaders ( ID , this . reqBodyContentLength == 0 && sb . size == 0 , cc . conf . MAX_FRAME_SIZE , hdrs ) NL return  NL }","func_name":"encodeAndWriteHeaders","docstring":"/* String => error */"}
{"repo":"http2","file":"ByteBufferUtils.cj","path":"http2/src/utils/ByteBufferUtils.cj","code_tokens":"public func ByteBufferToArray ( buf : ByteBuffer ) : Array < Byte > {  return buf . array ( ) [ buf . arrayOffset ( ) .. buf . limit ( ) + buf . arrayOffset ( ) ] NL }","func_name":"ByteBufferToArray","docstring":""}
{"repo":"http2","file":"http2MimeType.cj","path":"http2/src/utils/http2MimeType.cj","code_tokens":"static public func getMimeType ( str : String ) : String {  return application/octet-stream NL }","func_name":"getMimeType","docstring":""}
{"repo":"http2","file":"http2MimeType.cj","path":"http2/src/utils/http2MimeType.cj","code_tokens":"public func isFilePathValid ( filePath : String ) : ( String , String ) {   let con : Option < Int64 > = filePath . lastIndexOf ( / ) NL  var lastSlash : Int64 = 0 NL match ( con ) { case Some ( v ) => lastSlash = v NL case None => throw Exception ( Invalid filepath ) NL } NL  let directoryName : String = filePath . substring ( 0 , lastSlash ) NL  let fileName : String = filePath . substring ( lastSlash + 1 ) NL  let confield : Option < Int64 > = fileName . lastIndexOf ( . ) NL  var len : Int64 = 0 NL match ( confield ) { case Some ( v ) => len = v NL case None => throw Exception ( Invalid filepath. Need to include filename ) NL } NL  let fields : String = fileName . substring ( len + 1 ) NL return ( fileName , fields ) NL }","func_name":"isFilePathValid","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func close ( ) : Unit {  match ( this . execut ) { case HTTP1 ( server ) => server . close ( ) NL case HTTP2 ( server ) => server . close ( ) NL } NL }","func_name":"close","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func registerOnShutdown ( f : ( ) -> Unit ) : Unit {  match ( this . execut ) { case HTTP1 ( server ) => server . registerOnShutdown ( f ) NL case HTTP2 ( server ) => server . registerOnShutdown ( f ) NL } NL }","func_name":"registerOnShutdown","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func registerOnStart ( f : ( SocketServer ) -> Unit ) {  match ( this . execut ) { case HTTP1 ( server ) => server . registerOnStart ( f ) NL case HTTP2 ( server ) => server . registerOnStart ( f ) NL } NL }","func_name":"registerOnStart","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func registerAfterAccept ( f : ( SocketServer , Socket ) -> Unit ) {  match ( this . execut ) { case HTTP1 ( server ) => server . registerAfterAccept ( f ) NL case HTTP2 ( server ) => server . registerAfterAccept ( f ) NL } NL }","func_name":"registerAfterAccept","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func listenAndServe ( ) : Unit {  match ( this . execut ) { case HTTP1 ( server ) => server . listenAndServe ( ) NL case HTTP2 ( server ) => server . listenAndServe ( ) NL } NL }","func_name":"listenAndServe","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func serve ( listener : SocketServer ) : Unit {  match ( this . execut ) { case HTTP1 ( server ) => server . serve ( listener ) NL case HTTP2 ( server ) => server . serve ( listener ) NL } NL }","func_name":"serve","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func serve ( listener : TlsSocketServer ) : Unit {  match ( this . execut ) { case HTTP1 ( server ) => server . serve ( listener ) NL case HTTP2 ( server ) => server . serve ( listener ) NL } NL }","func_name":"serve","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func suspend ( ) : Unit {  match ( this . execut ) { case HTTP1 ( server ) => server . suspend ( ) NL case HTTP2 ( server ) => server . suspend ( ) NL } NL }","func_name":"suspend","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func resume ( ) : Unit {  match ( this . execut ) { case HTTP1 ( server ) => server . resume ( ) NL case HTTP2 ( server ) => server . resume ( ) NL } NL }","func_name":"resume","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func isSuspended ( ) : Bool {  match ( this . execut ) { case HTTP1 ( server ) => server . isSuspended ( ) NL case HTTP2 ( server ) => server . isSuspended ( ) NL } NL }","func_name":"isSuspended","docstring":""}
{"repo":"http2","file":"http2Server.cj","path":"http2/src/common/http2Server.cj","code_tokens":"public open func tlsEnabled ( ) : Bool {  match ( this . execut ) { case HTTP1 ( server ) => server . tlsEnabled ( ) NL case HTTP2 ( server ) => false NL } NL }","func_name":"tlsEnabled","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"public func encodeFrames ( frames : Collection < Http2Frame > ) : Collection < ByteBuffer > {   let bufs = LinkedList < ByteBuffer > ( ) NL for ( frame in frames ) {  bufs . appendAll ( encodeFrame ( frame ) ) NL } NL return bufs NL }","func_name":"encodeFrames","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"public func encodeFrame ( frame : Http2Frame ) : Collection < ByteBuffer > {  return match ( frame . TYPE ) { case 0x00 => encodeDataFrame ( ( frame as DataFrame ) . getOrThrow ( ) ) NL case 0x01 => encodeHeadersFrame ( ( frame as HeadersFrame ) . getOrThrow ( ) ) NL case 0x02 => encodePriorityFrame ( ( frame as PriorityFrame ) . getOrThrow ( ) ) NL case 0x03 => encodeResetFrame ( ( frame as ResetFrame ) . getOrThrow ( ) ) NL case 0x04 => encodeSettingsFrame ( ( frame as SettingsFrame ) . getOrThrow ( ) ) NL case 0x05 => encodePushPromiseFrame ( ( frame as PushPromiseFrame ) . getOrThrow ( ) ) NL case 0x06 => encodePingFrame ( ( frame as PingFrame ) . getOrThrow ( ) ) NL case 0x07 => encodeGoAwayFrame ( ( frame as GoAwayFrame ) . getOrThrow ( ) ) NL case 0x08 => encodeWindowUpdateFrame ( ( frame as WindowUpdateFrame ) . getOrThrow ( ) ) NL case 0x09 => encodeContinuationFrame ( ( frame as ContinuationFrame ) . getOrThrow ( ) ) NL case _ => throw Exception ( Not supported frame ${frame.TYPE} ) NL } NL }","func_name":"encodeFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"public func encodeFrame ( frame : Http2Frame , callBack : ( ByteBuffer ) -> Unit ) : Unit {  this . callback = callBack NL return match ( frame . TYPE ) { case 0x00 => encodeDataFrameCallBack ( ( frame as DataFrame ) . getOrThrow ( ) ) NL case 0x01 => encodeHeadersFrameCallBack ( ( frame as HeadersFrame ) . getOrThrow ( ) ) NL case 0x02 => encodePriorityFrameCallBack ( ( frame as PriorityFrame ) . getOrThrow ( ) ) NL case 0x03 => encodeResetFrameCallBack ( ( frame as ResetFrame ) . getOrThrow ( ) ) NL case 0x04 => encodeSettingsFrameCallBack ( ( frame as SettingsFrame ) . getOrThrow ( ) ) NL case 0x05 => encodePushPromiseFrameCallBack ( ( frame as PushPromiseFrame ) . getOrThrow ( ) ) NL case 0x06 => encodePingFrameCallBack ( ( frame as PingFrame ) . getOrThrow ( ) ) NL case 0x07 => encodeGoAwayFrameCallBack ( ( frame as GoAwayFrame ) . getOrThrow ( ) ) NL case 0x08 => encodeWindowUpdateFrameCallBack ( ( frame as WindowUpdateFrame ) . getOrThrow ( ) ) NL case 0x09 => encodeContinuationFrameCallBack ( ( frame as ContinuationFrame ) . getOrThrow ( ) ) NL case _ => throw Exception ( Not supported frame ${frame.TYPE} ) NL } NL }","func_name":"encodeFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func checkStreamid ( flag : Bool , streamid : Int64 ) : Unit {  if ( flag && streamid == 0 ) {  throw FramesEncoderException ( ) NL } NL if ( ! flag && streamid != 0 ) {  throw FramesEncoderException ( ) NL } NL }","func_name":"checkStreamid","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeDataFrame ( frame : DataFrame ) : Collection < ByteBuffer > {  this . checkStreamid ( true , frame . streamid ) NL  let buf = this . encodeDataFrameStart ( frame ) NL if ( frame . getFlag ( DataFrame . PADDED ) ) {  return this . joinWithPadding ( buf , frame . data , frame . padLength ) NL } NL return join ( buf , frame . data ) NL }","func_name":"encodeDataFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeDataFrameCallBack ( frame : DataFrame ) : Unit {  this . checkStreamid ( true , frame . streamid ) NL  let buf = this . encodeDataFrameStart ( frame ) NL if ( frame . getFlag ( DataFrame . PADDED ) ) {  return this . joinWithPaddingCallBack ( buf , frame . data , frame . padLength ) NL } NL return joinCallBack ( buf , frame . data ) NL }","func_name":"encodeDataFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeHeadersFrame ( frame : HeadersFrame ) : Collection < ByteBuffer > {  this . checkStreamid ( true , frame . streamid ) NL  let buf = this . encodeHeadersFrameStart ( frame ) NL if ( frame . getFlag ( HeadersFrame . PADDED ) ) {  return this . joinWithPadding ( buf , frame . headerBlocks , frame . padLength ) NL } NL return join ( buf , frame . headerBlocks ) NL }","func_name":"encodeHeadersFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeHeadersFrameCallBack ( frame : HeadersFrame ) : Unit {  this . checkStreamid ( true , frame . streamid ) NL  let buf = this . encodeHeadersFrameStart ( frame ) NL if ( frame . getFlag ( HeadersFrame . PADDED ) ) {  return this . joinWithPaddingCallBack ( buf , frame . headerBlocks , frame . padLength ) NL } NL return joinCallBack ( buf , frame . headerBlocks ) NL }","func_name":"encodeHeadersFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodePriorityFrame ( frame : PriorityFrame ) : Collection < ByteBuffer > {  this . checkStreamid ( true , frame . streamid ) NL  let length = 5 NL  let buf = this . getBuffer ( FRAME_HEADER_SIZE + length ) NL this . putHeader ( buf , length , frame . TYPE , NO_FLAGS , frame . streamid ) NL this . putPriority ( buf , frame . exclusive , frame . streamDependency , frame . weight ) NL buf . flip ( ) NL return [ buf ] NL }","func_name":"encodePriorityFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodePriorityFrameCallBack ( frame : PriorityFrame ) : Unit {  this . checkStreamid ( true , frame . streamid ) NL  let length = 5 NL  let buf = this . getBuffer ( FRAME_HEADER_SIZE + length ) NL this . putHeader ( buf , length , frame . TYPE , NO_FLAGS , frame . streamid ) NL this . putPriority ( buf , frame . exclusive , frame . streamDependency , frame . weight ) NL buf . flip ( ) NL callback ( buf ) NL }","func_name":"encodePriorityFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeResetFrame ( frame : ResetFrame ) : Collection < ByteBuffer > {  this . checkStreamid ( true , frame . streamid ) NL  let length : Int64 = 4 NL  var buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + length ) NL this . putHeader ( buf , length , frame . TYPE , NO_FLAGS , frame . streamid ) NL buf . putInt ( Int32 ( frame . errorCode ) ) NL buf . flip ( ) NL return [ buf ] NL }","func_name":"encodeResetFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeResetFrameCallBack ( frame : ResetFrame ) : Unit {  this . checkStreamid ( true , frame . streamid ) NL  let length : Int64 = 4 NL  var buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + length ) NL this . putHeader ( buf , length , frame . TYPE , NO_FLAGS , frame . streamid ) NL buf . putInt ( Int32 ( frame . errorCode ) ) NL buf . flip ( ) NL callback ( buf ) NL }","func_name":"encodeResetFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeSettingsFrame ( frame : SettingsFrame ) : Collection < ByteBuffer > {  this . checkStreamid ( false , frame . streamid ) NL  let length : Int64 = frame . length NL  var buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + length ) NL this . putSettingsFrame ( buf , frame , length ) NL buf . flip ( ) NL return [ buf ] NL }","func_name":"encodeSettingsFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeSettingsFrameCallBack ( frame : SettingsFrame ) : Unit {  this . checkStreamid ( false , frame . streamid ) NL  let length : Int64 = frame . length NL  var buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + length ) NL this . putSettingsFrame ( buf , frame , length ) NL buf . flip ( ) NL callback ( buf ) NL }","func_name":"encodeSettingsFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodePushPromiseFrame ( frame : PushPromiseFrame ) : Collection < ByteBuffer > {  this . checkStreamid ( true , frame . streamid ) NL  let isPadded = frame . getFlag ( frame . PADDED ) NL  let length = if ( isPadded ) {  frame . headerLength + 5 NL } else {  frame . headerLength + 4 NL } NL  let buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + if ( isPadded ) {  5 NL } else {  4 NL } ) NL this . putHeader ( buf , length , frame . TYPE , frame . flags , frame . streamid ) NL if ( isPadded ) {  buf . put ( UInt8 ( frame . padLength ) ) NL } NL buf . putInt ( Int32 ( frame . promisedStream ) ) NL buf . flip ( ) NL if ( frame . getFlag ( frame . PADDED ) ) {  return joinWithPadding ( buf , frame . headerBlocks , frame . padLength ) NL } NL return join ( buf , frame . headerBlocks ) NL }","func_name":"encodePushPromiseFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodePushPromiseFrameCallBack ( frame : PushPromiseFrame ) : Unit {  this . checkStreamid ( true , frame . streamid ) NL  let isPadded = frame . getFlag ( frame . PADDED ) NL  let length = if ( isPadded ) {  frame . headerLength + 5 NL } else {  frame . headerLength + 4 NL } NL  let buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + if ( isPadded ) {  5 NL } else {  4 NL } ) NL this . putHeader ( buf , length , frame . TYPE , frame . flags , frame . streamid ) NL if ( isPadded ) {  buf . put ( UInt8 ( frame . padLength ) ) NL } NL buf . putInt ( Int32 ( frame . promisedStream ) ) NL buf . flip ( ) NL if ( frame . getFlag ( frame . PADDED ) ) {  return joinWithPaddingCallBack ( buf , frame . headerBlocks , frame . padLength ) NL } NL return joinCallBack ( buf , frame . headerBlocks ) NL }","func_name":"encodePushPromiseFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodePingFrame ( frame : PingFrame ) : Collection < ByteBuffer > {  this . checkStreamid ( false , frame . streamid ) NL  let buf = this . getBuffer ( FRAME_HEADER_SIZE + frame . length ) NL this . putHeader ( buf , frame . length , frame . TYPE , frame . flags , ZERO_STREAM ) NL buf . put ( frame . data ) NL buf . flip ( ) NL return [ buf ] NL }","func_name":"encodePingFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodePingFrameCallBack ( frame : PingFrame ) : Unit {  this . checkStreamid ( false , frame . streamid ) NL  let buf = this . getBuffer ( FRAME_HEADER_SIZE + frame . length ) NL this . putHeader ( buf , frame . length , frame . TYPE , frame . flags , ZERO_STREAM ) NL buf . put ( frame . data ) NL buf . flip ( ) NL callback ( buf ) NL }","func_name":"encodePingFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeGoAwayFrame ( frame : GoAwayFrame ) : Collection < ByteBuffer > {  this . checkStreamid ( false , frame . streamid ) NL  let buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + frame . length ) NL this . putHeader ( buf , frame . length , frame . TYPE , NO_FLAGS , ZERO_STREAM ) NL buf . putInt ( Int32 ( frame . lastStream ) ) NL buf . putInt ( Int32 ( frame . errorCode ) ) NL if ( frame . debugData . size > 0 ) {  buf . put ( frame . debugData ) NL } NL buf . flip ( ) NL return [ buf ] NL }","func_name":"encodeGoAwayFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeGoAwayFrameCallBack ( frame : GoAwayFrame ) : Unit {  this . checkStreamid ( false , frame . streamid ) NL  let buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + frame . length ) NL this . putHeader ( buf , frame . length , frame . TYPE , NO_FLAGS , ZERO_STREAM ) NL buf . putInt ( Int32 ( frame . lastStream ) ) NL buf . putInt ( Int32 ( frame . errorCode ) ) NL if ( frame . debugData . size > 0 ) {  buf . put ( frame . debugData ) NL } NL buf . flip ( ) NL callback ( buf ) NL }","func_name":"encodeGoAwayFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeWindowUpdateFrame ( frame : WindowUpdateFrame ) : Collection < ByteBuffer > {   let buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + frame . length ) NL this . putHeader ( buf , frame . length , frame . TYPE , NO_FLAGS , frame . streamid ) NL buf . putInt ( Int32 ( frame . update ) ) NL buf . flip ( ) NL return [ buf ] NL }","func_name":"encodeWindowUpdateFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeWindowUpdateFrameCallBack ( frame : WindowUpdateFrame ) : Unit {   let buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + frame . length ) NL this . putHeader ( buf , frame . length , frame . TYPE , NO_FLAGS , frame . streamid ) NL buf . putInt ( Int32 ( frame . update ) ) NL buf . flip ( ) NL callback ( buf ) NL }","func_name":"encodeWindowUpdateFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeContinuationFrame ( frame : ContinuationFrame ) : Collection < ByteBuffer > {  this . checkStreamid ( true , frame . streamid ) NL  let buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE ) NL  let bufs = LinkedList < ByteBuffer > ( ) NL this . putHeader ( buf , frame . length , frame . TYPE , frame . flags , frame . streamid ) NL buf . flip ( ) NL bufs . append ( buf ) NL bufs . appendAll ( frame . headerBlocks ) NL return bufs NL }","func_name":"encodeContinuationFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeContinuationFrameCallBack ( frame : ContinuationFrame ) : Unit {  this . checkStreamid ( true , frame . streamid ) NL  let buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE ) NL this . putHeader ( buf , frame . length , frame . TYPE , frame . flags , frame . streamid ) NL buf . flip ( ) NL callback ( buf ) NL for ( block in frame . headerBlocks ) {  callback ( block ) NL } NL }","func_name":"encodeContinuationFrameCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func putSettingsFrame ( buf : ByteBuffer , frame : SettingsFrame , length : Int64 ) : Unit {  this . putHeader ( buf , length , frame . TYPE , frame . flags , ZERO_STREAM ) NL frame . toByteBuffer ( buf ) NL }","func_name":"putSettingsFrame","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeDataFrameStart ( frame : DataFrame ) : ByteBuffer {   let isPadded = frame . getFlag ( DataFrame . PADDED ) NL  let length = frame . length NL  let buf : ByteBuffer = this . getBuffer ( FRAME_HEADER_SIZE + if ( isPadded ) {  1 NL } else {  0 NL } ) NL this . putHeader ( buf , length , frame . TYPE , frame . flags , frame . streamid ) NL if ( isPadded ) {  buf . put ( UInt8 ( frame . padLength ) ) NL } NL buf . flip ( ) NL return buf NL }","func_name":"encodeDataFrameStart","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func encodeHeadersFrameStart ( frame : HeadersFrame ) : ByteBuffer {   let isPadded = frame . getFlag ( HeadersFrame . PADDED ) NL  let hasPriority = frame . getFlag ( HeadersFrame . PRIORITY ) NL  let length = frame . headerLength + match ( ( isPadded , hasPriority ) ) { case ( true , true ) => frame . padLength + 1 + 5 NL case ( false , true ) => 5 NL case ( true , false ) => frame . padLength + 1 NL case _ => 0 NL } NL  let buf = this . getBuffer ( FRAME_HEADER_SIZE + match ( ( isPadded , hasPriority ) ) { case ( true , true ) => 1 + 5 NL case ( false , true ) => 5 NL case ( true , false ) => 1 NL case _ => 0 NL } ) NL this . putHeader ( buf , length , frame . TYPE , frame . flags , frame . streamid ) NL if ( isPadded ) {  buf . put ( UInt8 ( frame . padLength ) ) NL } NL if ( hasPriority ) {  this . putPriority ( buf , frame . exclusive , frame . streamDependency , frame . weight ) NL } NL buf . flip ( ) NL return buf NL }","func_name":"encodeHeadersFrameStart","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func joinWithPadding ( buf : ByteBuffer , data : Collection < ByteBuffer > , padLength : Int64 ) : Collection < ByteBuffer > {  if ( data . size == 0 ) {  return [ buf , getPadding ( padLength ) ] NL } NL if ( data . size == 1 ) {  return [ buf , data . iterator ( ) . next ( ) . getOrThrow ( ) , getPadding ( padLength ) ] NL } NL if ( data . size == 2 ) {   let it = data . iterator ( ) NL return [ buf , it . next ( ) . getOrThrow ( ) , it . next ( ) . getOrThrow ( ) , getPadding ( padLength ) ] NL } NL  let list = LinkedList < ByteBuffer > ( ) NL list . append ( buf ) NL list . appendAll ( data ) NL list . append ( getPadding ( padLength ) ) NL return list NL }","func_name":"joinWithPadding","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func joinWithPaddingCallBack ( buf : ByteBuffer , data : Collection < ByteBuffer > , padLength : Int64 ) : Unit {  if ( data . size == 0 ) {  callback ( buf ) NL callback ( getPadding ( padLength ) ) NL return NL } NL if ( data . size == 1 ) {  callback ( buf ) NL callback ( data . iterator ( ) . next ( ) . getOrThrow ( ) ) NL callback ( getPadding ( padLength ) ) NL return NL } NL if ( data . size == 2 ) {   let it = data . iterator ( ) NL callback ( buf ) NL callback ( it . next ( ) . getOrThrow ( ) ) NL callback ( it . next ( ) . getOrThrow ( ) ) NL callback ( getPadding ( padLength ) ) NL return NL } NL callback ( buf ) NL for ( da in data ) {  callback ( da ) NL } NL callback ( getPadding ( padLength ) ) NL }","func_name":"joinWithPaddingCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func join ( buf : ByteBuffer , data : Collection < ByteBuffer > ) : Collection < ByteBuffer > {  if ( data . size == 0 ) {  return [ buf ] NL } NL if ( data . size == 1 ) {  return [ buf , data . iterator ( ) . next ( ) . getOrThrow ( ) ] NL } NL if ( data . size == 2 ) {   let it = data . iterator ( ) NL return [ buf , it . next ( ) . getOrThrow ( ) , it . next ( ) . getOrThrow ( ) ] NL } NL  let list = LinkedList < ByteBuffer > ( ) NL list . append ( buf ) NL list . appendAll ( data ) NL return list NL }","func_name":"join","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func joinCallBack ( buf : ByteBuffer , data : Collection < ByteBuffer > ) : Unit {  if ( data . size == 0 ) {  callback ( buf ) NL return NL } NL if ( data . size == 1 ) {  callback ( buf ) NL callback ( data . iterator ( ) . next ( ) . getOrThrow ( ) ) NL return NL } NL if ( data . size == 2 ) {   let it = data . iterator ( ) NL callback ( buf ) NL callback ( it . next ( ) . getOrThrow ( ) ) NL callback ( it . next ( ) . getOrThrow ( ) ) NL return NL } NL callback ( buf ) NL for ( da in data ) {  callback ( da ) NL } NL }","func_name":"joinCallBack","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"@ overflowWrapping   private func putHeader ( buf : ByteBuffer , length : Int64 , types : Int64 , flags : Int64 , streamId : Int64 ) : Unit {   let num : Int64 = ( length << 8 ) + types NL buf . putInt ( Int32 ( num ) ) NL buf . put ( UInt8 ( flags ) ) NL buf . putInt ( Int32 ( streamId ) ) NL }","func_name":"putHeader","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func putPriority ( buf : ByteBuffer , exclusive : Bool , streamDependency : Int64 , weight : Int64 ) : Unit {   let num : Int64 = if ( exclusive ) {  streamDependency + ( 1 << 31 ) NL } else {  streamDependency NL } NL buf . putInt ( Int32 ( num ) ) NL buf . put ( UInt8 ( weight ) ) NL }","func_name":"putPriority","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"private func getBuffer ( capacity : Int64 ) : ByteBuffer {  return ByteBuffer . allocate ( capacity ) NL }","func_name":"getBuffer","docstring":""}
{"repo":"http2","file":"FramesEncoder.cj","path":"http2/src/frame/FramesEncoder.cj","code_tokens":"protected func getPadding ( length : Int64 ) : ByteBuffer {  if ( length > 255 ) {  throw Exception ( Padding too big! ) NL } NL return ByteBuffer . allocate ( length ) NL }","func_name":"getPadding","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"func remaining ( datas : Collection < ByteBuffer > , max : Int64 ) : Int64 {   var remain = 0 NL for ( data in datas ) {  remain += data . remaining ( ) NL if ( remain > Int64 ( Int32 . Max ) ) {  throw IllegalArgumentException ( ) NL } NL } NL return remain NL }","func_name":"remaining","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"public open func getFlag ( f : Int64 ) : Bool {  return ( this . myFlags & f ) != 0 NL }","func_name":"getFlag","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"public open func toString ( ) : String {   let sb = StringBuilder ( ) NL  let typ : String = match ( this . TYPE ) { case 0x0 => DATA NL case 0x1 => HEADERS NL case 0x2 => PRIORITY NL case 0x3 => RST_STREAM NL case 0x4 => SETTINGS NL case 0x5 => PUSH_PROMISE NL case 0x6 => PING NL case 0x7 => GOAWAY NL case 0x8 => WINDOW_UPDATE NL case 0x9 => CONTINUATION NL case 0xa => ALTSVC NL case 0xb => BLOCKED NL case 0xc => ORIGIN NL case _ => unknown NL } NL sb . append ( typ ) . append ( : length= ) . append ( this . length ) . append ( , streamid= ) . append ( this . streamid ) NL return sb . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"public open func endHeaders ( ) : Bool {  return super . getFlag ( END_HEADERS ) NL }","func_name":"endHeaders","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"public func setPriority ( streamDependency : Int64 , exclusive : Bool , weight : Int64 ) {  this . mystreamDependency = streamDependency NL this . myexclusive = exclusive NL this . myweight = weight NL this . flags = PRIORITY NL }","func_name":"setPriority","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"public func toString ( ) {   let sb = StringBuilder ( ) NL sb . append ( super . toString ( ) ) . append (  [Settings:  ) NL for ( i in 0 .. 6 ) {  if ( parameters [ i ] != - 1 ) {  sb . append ( name ( i ) ) . append ( = ) . append ( parameters [ i ] ) . append (   ) NL } NL } NL sb . append ( ] ) NL return sb . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"private func name ( i : Int64 ) : String {  return match ( i + 1 ) { case 1 => HEADER_TABLE_SIZE NL case 2 => ENABLE_PUSH NL case 3 => MAX_CONCURRENT_STREAMS NL case 4 => INITIAL_WINDOW_SIZE NL case 5 => MAX_FRAME_SIZE NL case _ => MAX_HEADER_LIST_SIZE NL } NL }","func_name":"name","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"public operator func [ ] ( paramID : Int64 , value ! : Int64 ) : Unit {  if ( paramID > parameters . size ) {  throw IllegalArgumentException ( illegal parameter ) NL } NL parameters [ paramID - 1 ] = value NL }","func_name":"[]","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"public operator func [ ] ( paramID : Int64 ) : ? Int64 {  if ( paramID > parameters . size ) {  throw IllegalArgumentException ( illegal parameter ) NL } NL return parameters [ paramID - 1 ] NL }","func_name":"[]","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"func toByteBuffer ( buf : ByteBuffer ) {  for ( i in 0 .. 6 ) {  match ( parameters [ i ] ) { case Some ( v ) => buf . putShort ( Int16 ( i + 1 ) ) NL buf . putInt ( Int32 ( v ) ) NL case None => continue NL } NL } NL }","func_name":"toByteBuffer","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"public override func toString ( ) {  return super . toString ( ) +  [MalformedFrame] NL }","func_name":"toString","docstring":""}
{"repo":"http2","file":"Http2Frame.cj","path":"http2/src/frame/Http2Frame.cj","code_tokens":"public func toString ( ) {  return super . toString ( ) +  [Error: ${errorStrings[myErrorCode]}] NL }","func_name":"toString","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"public func decode ( byteBuffer : ByteBuffer ) : Unit {  if ( closed ) {  byteBuffer . position ( byteBuffer . limit ( ) ) NL return NL } NL  let remaining = byteBuffer . remaining ( ) NL if ( remaining > 0 ) {  match ( this . currentBuffer ) { case None => this . currentBuffer = byteBuffer NL case Some ( v ) =>  var b : ByteBuffer = v NL if ( ! this . tailBuffers . isEmpty ( ) ) {  b = this . tailBuffers . getLast ( ) NL } NL  var limit = b . limit ( ) NL  var freeSpace = b . capacity ( ) - limit NL if ( remaining <= COPY_THRESHOLD && freeSpace > = remaining ) {   let position = b . position ( ) NL b . position ( limit ) NL b . limit ( limit + byteBuffer . remaining ( ) ) NL b . put ( byteBuffer ) NL b . position ( position ) NL if ( b != this . currentBuffer . getOrThrow ( ) ) {  this . tailSize += remaining NL } NL } else {  this . tailBuffers . append ( byteBuffer ) NL this . tailSize += remaining NL } NL } NL } NL while ( true ) {  match ( nextFrame ( ) ) { case Some ( v ) => this . doProcessFrames ( v ) NL case None => break NL } NL } NL }","func_name":"decode","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func nextFrame ( ) : ? Http2Frame {  while ( true ) {  match ( this . currentBuffer ) { case None => return None NL case Some ( currentBuf ) =>  var available = currentBuf . remaining ( ) + this . tailSize NL if ( ! this . frameHeaderParsed ) {  if ( available > = FRAME_HEADER_SIZE ) {  parseFrameHeader ( ) NL if ( frameLength > maxFrameSize ) {  return MalformedFrame ( ErrorFrame . LET_FRAME_SIZE_ERROR , Frame type(${frameType}) length(${frameLength}) exceeds MAX_FRAME_SIZE(${maxFrameSize}) ) NL } NL frameHeaderParsed = true NL } else {  return None NL } NL } NL  var isNotNull = false NL available = match ( this . currentBuffer ) { case Some ( v ) => isNotNull = true NL v . remaining ( ) + this . tailSize NL case None => 0 NL } NL if ( ( this . frameLength == 0 ) || ( isNotNull && available > = this . frameLength ) ) {   let frame = parseFrameBody ( ) NL frameHeaderParsed = false NL match ( frame ) { case Some ( v ) => return v NL case None => ( ) NL } NL } else {  return None NL } NL } NL } NL return None NL }","func_name":"nextFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parseFrameBody ( ) : ? Http2Frame {  if ( ! this . frameHeaderParsed ) {  return None NL } NL return match ( this . frameType ) { case 0x0 => parseDataFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case 0x1 => parseHeadersFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case 0x2 => parsePriorityFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case 0x3 => parseResetFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case 0x4 => parseSettingsFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case 0x5 => parsePushPromiseFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case 0x6 => parsePingFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case 0x7 => parseGoAwayFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case 0x8 => parseWindowUpdateFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case 0x9 => parseContinuationFrame ( this . frameLength , this . frameStreamid , this . frameFlags ) NL case _ => skipBytes ( this . frameLength ) NL return MalformedFrame ( 1 , Unknown extended frame ) NL } NL }","func_name":"parseFrameBody","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parseDataFrame ( framelength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {   var frameLength : Int64 = framelength NL if ( streamid == 0 ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , zero streamId for DataFrame ) NL } NL  var padLength : Int64 = 0 NL if ( ( flags & DataFrame . PADDED ) != 0 ) {  padLength = Int64 ( this . getByte ( ) ) NL if ( padLength > = Int64 ( frameLength ) ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , the length of the padding is the length of the frame payload or greater ) NL } NL frameLength -- NL } NL  let df = DataFrame ( streamid , flags , getBuffers ( true , frameLength - padLength ) , padLength ) NL this . skipBytes ( padLength ) NL return df NL }","func_name":"parseDataFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parseHeadersFrame ( framelength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {  if ( streamid == 0 ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , zero streamId for HeadersFrame ) NL } NL  var frameLength : Int64 = framelength NL  var padLength = 0 NL if ( ( flags & HeadersFrame . PADDED ) != 0 ) {  padLength = Int64 ( getByte ( ) ) NL frameLength -- NL } NL  let hasPriority = ( flags & HeadersFrame . PRIORITY ) != 0 NL  var exclusive = false NL  var streamDependency = 0 NL  var weight = 0 NL if ( hasPriority ) {   let x = Int64 ( getInt ( ) ) NL exclusive = ( x & 0x80000000 ) != 0 NL streamDependency = x & 0x7fffffff NL weight = Int64 ( getByte ( ) ) NL frameLength -= 5 NL } NL if ( frameLength < padLength ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , Padding exceeds the size remaining for the header block ) NL } NL  let hf = HeadersFrame ( streamid , flags , getBuffers ( false , frameLength - padLength ) , padLength ) NL skipBytes ( padLength ) NL if ( hasPriority ) {  hf . setPriority ( streamDependency , exclusive , weight ) NL } NL return hf NL }","func_name":"parseHeadersFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parsePriorityFrame ( frameLength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {  if ( streamid == 0 ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , zero streamId for PriorityFrame ) NL } NL if ( frameLength != 5 ) {  skipBytes ( frameLength ) NL return MalformedFrame ( ErrorFrame . LET_FRAME_SIZE_ERROR , streamid , PriorityFrame length is ${frameLength}, expected 5 ) NL } NL  let x = Int64 ( this . getInt ( ) ) NL  let weight = Int64 ( this . getByte ( ) ) NL return PriorityFrame ( streamid , x & 0x7fffffff , ( x & 0x80000000 ) != 0 , weight ) NL }","func_name":"parsePriorityFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parseResetFrame ( frameLength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {  if ( streamid == 0 ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , zero streamId for ResetFrame ) NL } NL if ( frameLength != 4 ) {  return MalformedFrame ( ErrorFrame . LET_FRAME_SIZE_ERROR , ResetFrame length is ${frameLength}, expected 4 ) NL } NL return ResetFrame ( streamid , Int64 ( getInt ( ) ) ) NL }","func_name":"parseResetFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parseSettingsFrame ( frameLength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {  if ( streamid != 0 ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , non-zero streamId for SettingsFrame ) NL } NL if ( ( SettingsFrame . ACK & flags ) != 0 && frameLength > 0 ) {  return MalformedFrame ( ErrorFrame . LET_FRAME_SIZE_ERROR , ACK SettingsFrame is not empty ) NL } NL if ( frameLength % 6 != 0 ) {  return MalformedFrame ( ErrorFrame . LET_FRAME_SIZE_ERROR , invalid SettingsFrame size: ${frameLength} ) NL } NL  let sf = SettingsFrame ( flags ) NL for ( i in 0 .. frameLength / 6 ) {   let id = getShort ( ) NL  let val = getInt ( ) NL if ( id > 0 && id <= SettingsFrame . MAX_PARAM ) {  sf [ Int64 ( id ) ] = Int64 ( val ) NL } NL } NL return sf NL }","func_name":"parseSettingsFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parsePushPromiseFrame ( framelength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {   var frameLength : Int64 = framelength NL if ( streamid == 0 ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , zero streamId for PushPromiseFrame ) NL } NL  var padLength : Int32 = 0 NL if ( ( flags & 0x8 ) != 0 ) {  padLength = getByte ( ) NL frameLength -- NL } NL  var promisedStream = Int64 ( getInt ( ) ) & 0x7fffffff NL frameLength -= 4 NL if ( frameLength < Int64 ( padLength ) ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , Padding exceeds the size remaining for the PushPromiseFrame ) NL } NL  let ppf = PushPromiseFrame ( streamid , flags , promisedStream , getBuffers ( false , frameLength - Int64 ( padLength ) ) , Int64 ( padLength ) ) NL skipBytes ( Int64 ( padLength ) ) NL return ppf NL }","func_name":"parsePushPromiseFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parsePingFrame ( frameLength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {  if ( streamid != 0 ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , non-zero streamId for PingFrame ) NL } NL if ( frameLength != 8 ) {  return MalformedFrame ( ErrorFrame . LET_FRAME_SIZE_ERROR , PingFrame length is ${frameLength}, expected 8 ) NL } NL return PingFrame ( flags , getBytes ( 8 ) ) NL }","func_name":"parsePingFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parseGoAwayFrame ( frameLength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {  if ( streamid != 0 ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , non-zero streamId for GoAwayFrame ) NL } NL if ( frameLength < 8 ) {  return MalformedFrame ( ErrorFrame . LET_FRAME_SIZE_ERROR , Invalid GoAway frame size ) NL } NL  let lastStream = getInt ( ) & 0x7fffffff NL  let errorCode = getInt ( ) NL  let debugData = getBytes ( frameLength - 8 ) NL return GoAwayFrame ( Int64 ( lastStream ) , Int64 ( errorCode ) , debugData ) NL }","func_name":"parseGoAwayFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parseWindowUpdateFrame ( frameLength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {  if ( frameLength != 4 ) {  return MalformedFrame ( ErrorFrame . LET_FRAME_SIZE_ERROR , WindowUpdateFrame length is ${frameLength}, expected 4 ) NL } NL return WindowUpdateFrame ( streamid , Int64 ( getInt ( ) ) & 0x7fffffff ) NL }","func_name":"parseWindowUpdateFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parseContinuationFrame ( frameLength : Int64 , streamid : Int64 , flags : Int64 ) : ? Http2Frame {  if ( streamid == 0 ) {  return MalformedFrame ( ErrorFrame . LET_PROTOCOL_ERROR , zero streamId for ContinuationFrame ) NL } NL return ContinuationFrame ( streamid , flags , getBuffers ( false , frameLength ) ) NL }","func_name":"parseContinuationFrame","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func skipBytes ( bytecount : Int64 ) {   var byteCount : Int64 = bytecount NL while ( byteCount > 0 ) {   var remaining = this . currentBuffer . getOrThrow ( ) . remaining ( ) NL  var extract = math . min ( remaining , byteCount ) NL this . currentBuffer . getOrThrow ( ) . position ( this . currentBuffer . getOrThrow ( ) . position ( ) + extract ) NL byteCount -= remaining NL nextBuffer ( ) NL } NL }","func_name":"skipBytes","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func getBytes ( number : Int64 ) : Array < UInt8 > {   var bytes : Array < UInt8 > = Array < UInt8 > ( number , item : 0 ) NL  var offset : Int64 = 0 NL  var num : Int64 = number NL while ( num > 0 ) {   let length : Int64 = math . min ( num , this . currentBuffer . getOrThrow ( ) . remaining ( ) ) NL this . currentBuffer . getOrThrow ( ) . get ( bytes , offset , length ) NL offset += length NL num -= length NL nextBuffer ( ) NL } NL return bytes NL }","func_name":"getBytes","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func getBuffers ( isDataFrame : Bool , byteCount : Int64 ) : Collection < ByteBuffer > {   var res : LinkedList < ByteBuffer > = LinkedList < ByteBuffer > ( ) NL  var bytecount : Int64 = byteCount NL while ( bytecount > 0 ) {   let remaining : Int64 = this . currentBuffer . getOrThrow ( ) . remaining ( ) NL  let extract : Int64 = math . min ( remaining , bytecount ) NL  var extractedBuf : ByteBuffer NL if ( isDataFrame ) {  extractedBuf = sliceWithLimitedCapacity ( extract ) NL } else {  extractedBuf = sliceWithLimitedCapacity ( extract ) NL } NL res . append ( extractedBuf ) NL bytecount -= extract NL nextBuffer ( ) NL } NL return res NL }","func_name":"getBuffers","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func parseFrameHeader ( ) {   let x = getInt ( ) NL this . frameLength = Int64 ( ( x >> 8 ) & 0x00ffffff ) NL this . frameType = Int64 ( x & 0xff ) NL this . frameFlags = Int64 ( getByte ( ) ) NL this . frameStreamid = Int64 ( getInt ( ) & 0x7fffffff ) NL }","func_name":"parseFrameHeader","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"public func getInt ( ) : Int32 {  if ( this . currentBuffer . getOrThrow ( ) . remaining ( ) > = 4 ) {   let res = currentBuffer . getOrThrow ( ) . getInt ( ) NL nextBuffer ( ) NL return res NL } NL  var val = getByte ( ) NL val = ( val << 8 ) + getByte ( ) NL val = ( val << 8 ) + getByte ( ) NL val = ( val << 8 ) + getByte ( ) NL return val NL }","func_name":"getInt","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"public func getShort ( ) : Int32 {  if ( this . currentBuffer . getOrThrow ( ) . remaining ( ) > = 2 ) {   let res : Int32 = Int32 ( this . currentBuffer . getOrThrow ( ) . getShort ( ) ) & 0xffff NL nextBuffer ( ) NL return res NL } NL  var val = getByte ( ) NL val = ( val << 8 ) + getByte ( ) NL return val NL }","func_name":"getShort","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func nextBuffer ( ) {  if ( ! this . currentBuffer . getOrThrow ( ) . hasRemaining ( ) ) {  if ( this . tailBuffers . size == 0 ) {  this . currentBuffer = None NL } else {  this . currentBuffer = this . tailBuffers . removeFirst ( ) NL this . tailSize -= this . currentBuffer . getOrThrow ( ) . remaining ( ) NL } NL } NL }","func_name":"nextBuffer","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"@ overflowWrapping   public func getByte ( ) : Int32 {   let res = currentBuffer . getOrThrow ( ) . get ( ) & 0xff NL nextBuffer ( ) NL return Int32 ( res ) NL }","func_name":"getByte","docstring":""}
{"repo":"http2","file":"FramesDecoder.cj","path":"http2/src/frame/FramesDecoder.cj","code_tokens":"private func sliceWithLimitedCapacity ( amount : Int64 ) : ByteBuffer {  match ( this . currentBuffer ) { case Some ( buffer ) =>  let index : Int64 = buffer . position ( ) + amount NL  let limit : Int64 = buffer . limit ( ) NL if ( index != limit ) {  buffer . limit ( index ) NL } else {  buffer . limit ( buffer . capacity ( ) ) NL } NL  var newb : ByteBuffer = buffer . slice ( ) NL buffer . position ( index ) NL buffer . limit ( limit ) NL newb . limit ( amount ) NL return newb NL case None => throw FramesDecoderException ( ) NL } NL }","func_name":"sliceWithLimitedCapacity","docstring":""}
{"repo":"http2","file":"frameFlags.cj","path":"http2/src/frame/frameFlags.cj","code_tokens":"public func value ( ) : Int64 {  return match ( this ) { case NO_ERROR => 0x00 NL case PROTOCOL_ERROR => 0x01 NL case INTERNAL_ERROR => 0x02 NL case FLOW_CONTROL_ERROR => 0x03 NL case SETTINGS_TIMEOUT => 0x04 NL case STREAM_CLOSED => 0x05 NL case FRAME_SIZE_ERROR => 0x06 NL case REFUSED_STREAM => 0x07 NL case CANCEL => 0x08 NL case COMPRESSION_ERROR => 0x09 NL case CONNECT_ERROR => 0x0a NL case ENHANCE_YOUR_CALM => 0x0b NL case INADEQUATE_SECURITY => 0x0c NL case HTTP_1_1_REQUIRED => 0x0d NL } NL }","func_name":"value","docstring":""}
{"repo":"http2","file":"frameFlags.cj","path":"http2/src/frame/frameFlags.cj","code_tokens":"public func toString ( ) : String {  return this . value ( ) . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func put ( key : K , value : V ) : Option < V > {  synchronized ( lock ) {  return this . map . put ( key , value ) NL } NL }","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param The param is key of K\n     * @param The param is value of V\n     *\n     * @return The return type of Option<V>\n     * @since\n     */"}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func get ( key : K ) : Option < V > {  synchronized ( lock ) {  return this . map . get ( key ) NL } NL }","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @param The param is key of K\n     *\n     * @return The return type of Option<V>\n     * @since\n     */"}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func contains ( key : K ) : Bool {  synchronized ( lock ) {  return this . map . contains ( key ) NL } NL }","func_name":"contains","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  synchronized ( lock ) {  return this . map . containsAll ( keys ) NL } NL }","func_name":"containsAll","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  synchronized ( lock ) {  this . map . putAll ( elements ) NL } NL }","func_name":"putAll","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func remove ( key : K ) : Option < V > {  synchronized ( lock ) {  return this . map . remove ( key ) NL } NL }","func_name":"remove","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  synchronized ( lock ) {  this . map . removeAll ( keys ) NL } NL }","func_name":"removeAll","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  synchronized ( lock ) {  return this . map . removeIf ( predicate ) NL } NL }","func_name":"removeIf","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func clear ( ) : Unit {  synchronized ( lock ) {  return this . map . clear ( ) NL } NL }","func_name":"clear","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func reserve ( additional : Int64 ) : Unit {  synchronized ( lock ) {  return this . map . reserve ( additional ) NL } NL }","func_name":"reserve","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func capacity ( ) : Int64 {  synchronized ( lock ) {  return this . map . capacity ( ) NL } NL }","func_name":"capacity","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func clone ( ) : HashMap < K , V > {  synchronized ( lock ) {  return this . map . clone ( ) NL } NL }","func_name":"clone","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func keys ( ) : Keys < K > {  synchronized ( lock ) {  return this . map . keys ( ) NL } NL }","func_name":"keys","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func values ( ) : Values < V > {  synchronized ( lock ) {  return this . map . values ( ) NL } NL }","func_name":"values","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func iterator ( ) : HashMapIterator < K , V > {  synchronized ( lock ) {  return HashMap < K , V > ( this . map ) . iterator ( ) NL } NL }","func_name":"iterator","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  synchronized ( lock ) {  return this . map . isEmpty ( ) NL } NL }","func_name":"isEmpty","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  synchronized ( lock ) {  this . map . put ( key , value ) NL ( ) NL } NL }","func_name":"[]","docstring":""}
{"repo":"http2","file":"syncHashMap.cj","path":"http2/src/buffer/syncHashMap.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  synchronized ( lock ) {  return this . map [ key ] NL } NL }","func_name":"[]","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"static public func allocate ( capacity : Int64 ) : ByteBuffer {  if ( capacity < 0 ) {  throw IllegalArgumentException ( ) NL } NL return HeapByteBuffer ( capacity , capacity ) NL }","func_name":"allocate","docstring":"/**\n     * The Function is allocate\n     *\n     * @param capacity of Int64\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"static public func wrap ( array : Array < UInt8 > , offset : Int64 , length : Int64 ) : ByteBuffer {  try {  return HeapByteBuffer ( array , offset , length ) NL } catch ( e : IllegalArgumentException ) {  throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"wrap","docstring":"/**\n     * The Function is wrap\n     *\n     * @param array of Array<UInt8>\n     * @param offset of Int64\n     * @param length of Int64\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"static public func wrap ( array : Array < UInt8 > ) : ByteBuffer {  return wrap ( array , 0 , array . size ) NL }","func_name":"wrap","docstring":"/**\n     * The Function is wrap\n     *\n     * @param array of Array<UInt8>\n     * @param offset of Int64\n     * @param length of Int64\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func slice ( ) : ByteBuffer","func_name":"slice","docstring":"/**\n     * The Function is slice\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func duplicate ( ) : ByteBuffer","func_name":"duplicate","docstring":"/**\n     * The Function is duplicate\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func asReadOnlyBuffer ( ) : ByteBuffer","func_name":"asReadOnlyBuffer","docstring":"/**\n     * The Function is asReadOnlyBuffer\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func get ( ) : UInt8","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @return Type of UInt8\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func put ( b : UInt8 ) : ByteBuffer","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param b of UInt8\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func get ( index : Int64 ) : UInt8","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @return Type of UInt8\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func put ( index : Int64 , b : UInt8 ) : ByteBuffer","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param b of UInt8\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func putLong ( value : Int64 ) : ByteBuffer","func_name":"putLong","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func putInt ( value : Int32 ) : ByteBuffer","func_name":"putInt","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func putShort ( value : Int16 ) : ByteBuffer","func_name":"putShort","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func putUInt64 ( value : UInt64 ) : ByteBuffer","func_name":"putUInt64","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func putUInt32 ( value : UInt32 ) : ByteBuffer","func_name":"putUInt32","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func putUInt16 ( value : UInt16 ) : ByteBuffer","func_name":"putUInt16","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func getLong ( ) : Int64","func_name":"getLong","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func getInt ( ) : Int32","func_name":"getInt","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func getShort ( ) : Int16","func_name":"getShort","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func getUInt64 ( ) : UInt64","func_name":"getUInt64","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func getUInt32 ( ) : UInt32","func_name":"getUInt32","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func getUInt16 ( ) : UInt16","func_name":"getUInt16","docstring":""}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func get ( dst : Array < UInt8 > , offset : Int64 , length : Int64 ) : ByteBuffer","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @return Type of UInt8\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public open func get ( dst : Array < UInt8 > ) : ByteBuffer {  return get ( dst , 0 , dst . size ) NL }","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @return Type of UInt8\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func put ( src : ByteBuffer ) : ByteBuffer","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param b of UInt8\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func put ( src : Array < UInt8 > , offset : Int64 , length : Int64 ) : ByteBuffer","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param b of UInt8\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public open func put ( src : Array < UInt8 > ) : ByteBuffer {  return this . put ( src , 0 , src . size ) NL }","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param b of UInt8\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public open func hasArray ( ) : Bool {  return false NL }","func_name":"hasArray","docstring":"/**\n     * The Function is hasArray\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public override func array ( ) : Array < UInt8 > {  return this . hb NL }","func_name":"array","docstring":"/**\n     * The Function is array\n     *\n     * @return Type of Array<UInt8>\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public override func arrayOffset ( ) : Int64 {  return this . offset NL }","func_name":"arrayOffset","docstring":"/**\n     * The Function is arrayOffset\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public override func position ( newPosition : Int64 ) : ByteBuffer {  super . position ( newPosition ) NL return this NL }","func_name":"position","docstring":"/**\n     * The Function is position\n     *\n     * @param newPosition of Int64\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public override func limit ( newLimit : Int64 ) : ByteBuffer {  super . limit ( newLimit ) NL return this NL }","func_name":"limit","docstring":"/**\n     * The Function is limit\n     *\n     * @param newLimit of Int64\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public override func reset ( ) : ByteBuffer {  super . reset ( ) NL return this NL }","func_name":"reset","docstring":"/**\n     * The Function is reset\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public override func clear ( ) {  super . clear ( ) NL return this NL }","func_name":"clear","docstring":"/**\n     * The Function is clear\n     *\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public override func flip ( ) : ByteBuffer {  super . flip ( ) NL return this NL }","func_name":"flip","docstring":"/**\n     * The Function is flip\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public override func rewind ( ) : ByteBuffer {  super . rewind ( ) NL return this NL }","func_name":"rewind","docstring":"/**\n     * The Function is rewind\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func compact ( ) : ByteBuffer","func_name":"compact","docstring":"/**\n     * The Function is compact\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public open func toString ( ) : String {   let sb = StringBuilder ( ) NL sb . append ( ByteBuffer: [offset= ) NL sb . append ( this . offset ) NL sb . append (  mark= ) NL sb . append ( this . mar ) NL sb . append (  pos= ) NL sb . append ( position ( ) ) NL sb . append (  lim= ) NL sb . append ( limit ( ) ) NL sb . append (  cap= ) NL sb . append ( capacity ( ) ) NL sb . append ( ] ) NL  let src = sb . toString ( ) NL sb . clear ( ) NL return src NL }","func_name":"toString","docstring":"/**\n     * The Function is toString\n     *\n     * @return Type of String\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"@ overflowWrapping   public open func hashCode ( ) : Int64 {   var h : Int32 = 1 NL  var p = position ( ) NL for ( i in limit ( ) - 1 ..= p : - 1 ) {  h = 31 * h + Int32 ( get ( i ) ) NL } NL return Int64 ( h ) NL }","func_name":"hashCode","docstring":"/**\n     * The Function is hashCode\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public open operator func == ( that : Buffer ) : Bool {  return refEq ( this , that ) NL }","func_name":"==","docstring":"/**\n     * The Function is ==\n     *\n     * @param that of Buffer\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public open operator func != ( that : Buffer ) : Bool {  return ! refEq ( this , that ) NL }","func_name":"!=","docstring":"/**\n     * The Function is !=\n     *\n     * @param that of Buffer\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"ByteBuffer.cj","path":"http2/src/buffer/ByteBuffer.cj","code_tokens":"public func slice ( pos : Int64 , lim : Int64 ) : ByteBuffer","func_name":"slice","docstring":"/**\n     * The Function is slice\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func write ( out : ToString ) {  match ( this ) { case STDOUT => Console . stdOut . write ( out . toString ( ) ) NL case STREAM ( output ) => output . write ( out . toString ( ) . toUtf8Array ( ) ) NL } NL }","func_name":"write","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"func printERROR ( thatLevel : LogLevel , msg : String ) {  match ( thatLevel ) { case ERROR => out . write ( msg ) NL case _ => return NL } NL }","func_name":"printERROR","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"func printWARN ( thatLevel : LogLevel , msg : String ) {  match ( thatLevel ) { case ERROR => out . write ( msg ) NL case WARN => out . write ( msg ) NL case _ => return NL } NL }","func_name":"printWARN","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"func printINFO ( thatLevel : LogLevel , msg : String ) {  match ( thatLevel ) { case ALL => return NL case TRACE => return NL case DEBUG => return NL case _ => out . write ( msg ) NL } NL }","func_name":"printINFO","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"func printDEBUG ( thatLevel : LogLevel , msg : String ) {  match ( thatLevel ) { case ALL => return NL case TRACE => return NL case _ => out . write ( msg ) NL } NL }","func_name":"printDEBUG","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"func printTRACE ( thatLevel : LogLevel , msg : String ) {  match ( thatLevel ) { case ALL => return NL case _ => out . write ( msg ) NL } NL }","func_name":"printTRACE","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func setOutput ( output : OutputStream ) : Unit {  this . out = STREAM ( output ) NL }","func_name":"setOutput","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func setOutput ( output : File ) : Unit {  this . out = STREAM ( output ) NL }","func_name":"setOutput","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func trace ( msg : String ) : Unit {  this . queue . put ( ( TRACE , msg ) ) NL }","func_name":"trace","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func debug ( msg : String ) : Unit {  this . queue . put ( ( DEBUG , msg ) ) NL }","func_name":"debug","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func info ( msg : String ) : Unit {  this . queue . put ( ( INFO , msg ) ) NL }","func_name":"info","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func warn ( msg : String ) : Unit {  this . queue . put ( ( WARN , msg ) ) NL }","func_name":"warn","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func error ( msg : String ) : Unit {  this . queue . put ( ( ERROR , msg ) ) NL }","func_name":"error","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func log ( level : LogLevel , msg : String ) : Unit {  this . queue . put ( ( level , msg ) ) NL }","func_name":"log","docstring":""}
{"repo":"http2","file":"Logger.cj","path":"http2/src/buffer/Logger.cj","code_tokens":"public func close ( ) : Unit {  try {  opening . store ( false ) NL this . queue . put ( ( OFF ,  ) ) NL } catch ( e : Exception ) {  ( ) NL } NL }","func_name":"close","docstring":""}
{"repo":"http2","file":"syncblockQueue.cj","path":"http2/src/buffer/syncblockQueue.cj","code_tokens":"public func put ( item : T ) {  synchronized ( m ) {  while ( this . list . size == this . maxQueueMemory ) {  m . wait ( notFull ) NL } NL this . list . append ( item ) NL m . notify ( notEmpty ) NL } NL }","func_name":"put","docstring":"/**\n     * The Function is add\n     *\n     * @param The param is item of T\n     *\n     * @since\n     */"}
{"repo":"http2","file":"syncblockQueue.cj","path":"http2/src/buffer/syncblockQueue.cj","code_tokens":"public func poll ( ) : T {  synchronized ( m ) {  while ( this . list . size == 0 ) {  m . wait ( notEmpty ) NL } NL  let ret = this . list . removeFirst ( ) NL m . notify ( notFull ) NL return ret NL } NL }","func_name":"poll","docstring":"/**\n     * The Function is pull\n     *\n     * @return The return type of Option<T>\n     * @since\n     */"}
{"repo":"http2","file":"syncblockQueue.cj","path":"http2/src/buffer/syncblockQueue.cj","code_tokens":"public func recycle ( ) {  synchronized ( m ) {  this . list . clear ( ) NL } NL }","func_name":"recycle","docstring":"/**\n     * The Function is recycle\n     *\n     * @since\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public func ArrayCopy ( src : Array < Byte > , srcPos : Int64 , dest : Array < Byte > , destPos : Int64 , length : Int64 ) {  src . copyTo ( dest , srcPos , destPos , length ) NL }","func_name":"ArrayCopy","docstring":"/**\n * The Function is ArrayCopy\n *\n * @param src of Array<Byte>\n * @param srcPos of Int64\n * @param dest of Array<Byte>\n * @param destPos of Int64\n * @param length of Int64\n * @since 0.32.5\n */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func slice ( ) : ByteBuffer {  return HeapByteBuffer ( this . hb , - 1 , 0 , this . remaining ( ) , this . remaining ( ) , this . position ( ) + offset ) NL }","func_name":"slice","docstring":"/**\n     * The Function is slice\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func slice ( pos : Int64 , lim : Int64 ) : ByteBuffer {   let rem = lim - pos NL return HeapByteBuffer ( hb , - 1 , 0 , rem , rem , pos + offset ) NL }","func_name":"slice","docstring":"/**\n     * The Function is slice\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func duplicate ( ) : ByteBuffer {  return HeapByteBuffer ( hb , this . markValue ( ) , this . position ( ) , this . limit ( ) , this . capacity ( ) , offset ) NL }","func_name":"duplicate","docstring":"/**\n     * The Function is duplicate\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func asReadOnlyBuffer ( ) : ByteBuffer {  return HeapByteBuffer ( hb , this . markValue ( ) , this . position ( ) , this . limit ( ) , this . capacity ( ) , offset ) NL }","func_name":"asReadOnlyBuffer","docstring":"/**\n     * The Function is asReadOnlyBuffer\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public func ix ( i : Int64 ) : Int64 {  return i + offset NL }","func_name":"ix","docstring":"/**\n     * The Function is ix\n     *\n     * @param i of Int64\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func get ( ) : Byte {  return hb [ ix ( nextGetIndex ( ) ) ] NL }","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @return Type of Byte\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func get ( i : Int64 ) : Byte {  return hb [ ix ( checkIndex ( i ) ) ] NL }","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @return Type of Byte\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func get ( dst : Array < Byte > , offset : Int64 , length : Int64 ) : ByteBuffer {  checkBounds ( offset , length , dst . size ) NL if ( length > this . remaining ( ) ) {  throw Exception ( ) NL } NL ArrayCopy ( hb , ix ( position ( ) ) , dst , offset , length ) NL position ( position ( ) + length ) NL return this NL }","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @return Type of Byte\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func put ( x : Byte ) : ByteBuffer {  hb [ ix ( nextGetIndex ( ) ) ] = x NL return this NL }","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param x of Byte\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func put ( i : Int64 , x : Byte ) : ByteBuffer {  hb [ ix ( checkIndex ( i ) ) ] = x NL return this NL }","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param x of Byte\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func put ( src : Array < Byte > , offset : Int64 , length : Int64 ) : ByteBuffer {  checkBounds ( offset , length , src . size ) NL if ( length > remaining ( ) ) {  throw Exception ( ) NL } NL ArrayCopy ( src , offset , hb , ix ( position ( ) ) , length ) NL position ( position ( ) + length ) NL return this NL }","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param x of Byte\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func put ( src : ByteBuffer ) : ByteBuffer {  if ( src is HeapByteBuffer ) {  if ( src == this ) {  throw createSameBufferException ( ) NL } NL  let sb : HeapByteBuffer = match ( ( src as HeapByteBuffer ) ) { case None => throw NoneValueException ( ) NL case Some ( v ) => v NL } NL  let n = sb . remaining ( ) NL if ( n > remaining ( ) ) {  throw BufferOverflowException ( ) NL } NL ArrayCopy ( sb . hb , sb . ix ( sb . position ( ) ) , hb , ix ( position ( ) ) , n ) NL sb . position ( sb . position ( ) + n ) NL position ( position ( ) + n ) NL } NL return this NL }","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param x of Byte\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"public override func compact ( ) : ByteBuffer {  ArrayCopy ( hb , ix ( position ( ) ) , hb , ix ( 0 ) , remaining ( ) ) NL position ( remaining ( ) ) NL limit ( capacity ( ) ) NL discardMark ( ) NL return this NL }","func_name":"compact","docstring":"/**\n     * The Function is compact\n     *\n     * @return Type of ByteBuffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public override func putLong ( value : Int64 ) : ByteBuffer {  this . putUInt64 ( UInt64 ( value ) ) NL }","func_name":"putLong","docstring":"/**\n     * The Function is putLong\n     *\n     * @param value of Int64\n     *\n     * @return Type of ByteBuffer\n     * @since 0.33.3\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public override func putInt ( value : Int32 ) : ByteBuffer {  this . putUInt32 ( UInt32 ( value ) ) NL }","func_name":"putInt","docstring":"/**\n     * The Function is putInt\n     *\n     * @param value of Int32\n     *\n     * @return Type of ByteBuffer\n     * @since 0.33.3\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public override func putShort ( value : Int16 ) : ByteBuffer {  this . putUInt16 ( UInt16 ( value ) ) NL }","func_name":"putShort","docstring":"/**\n     * The Function is putShort\n     *\n     * @param value of Int16\n     *\n     * @return Type of ByteBuffer\n     * @since 0.33.3\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public override func getLong ( ) : Int64 {  return Int64 ( this . getUInt64 ( ) ) NL }","func_name":"getLong","docstring":"/**\n     * The Function is getLong\n     *\n     * @return Type of Int64\n     * @since 0.33.3\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public override func getInt ( ) : Int32 {  return Int32 ( this . getUInt32 ( ) ) NL }","func_name":"getInt","docstring":"/**\n     * The Function is getInt\n     *\n     * @return Type of Int32\n     * @since 0.33.3\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public override func getShort ( ) : Int16 {  return Int16 ( this . getUInt16 ( ) ) NL }","func_name":"getShort","docstring":"/**\n     * The Function is getShort\n     *\n     * @return Type of Int16\n     * @since 0.33.3\n     */"}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public func putUInt64 ( value : UInt64 ) : ByteBuffer {  return this . put ( UInt8 ( ( value >> 56 ) & 0xff ) ) . put ( UInt8 ( ( value >> 48 ) & 0xff ) ) . put ( UInt8 ( ( value >> 40 ) & 0xff ) ) . put ( UInt8 ( ( value >> 32 ) & 0xff ) ) . put ( UInt8 ( ( value >> 24 ) & 0xff ) ) . put ( UInt8 ( ( value >> 16 ) & 0xff ) ) . put ( UInt8 ( ( value >> 8 ) & 0xff ) ) . put ( UInt8 ( value & 0xff ) ) NL }","func_name":"putUInt64","docstring":""}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public func putUInt32 ( value : UInt32 ) : ByteBuffer {  return this . put ( UInt8 ( ( value >> 24 ) & 0xff ) ) . put ( UInt8 ( ( value >> 16 ) & 0xff ) ) . put ( UInt8 ( ( value >> 8 ) & 0xff ) ) . put ( UInt8 ( value & 0xff ) ) NL }","func_name":"putUInt32","docstring":""}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public func putUInt16 ( value : UInt16 ) : ByteBuffer {  return this . put ( UInt8 ( ( value >> 8 ) & 0xff ) ) . put ( UInt8 ( value & 0xff ) ) NL }","func_name":"putUInt16","docstring":""}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public func getUInt64 ( ) : UInt64 {  return UInt64 ( this . get ( ) ) << 56 | UInt64 ( this . get ( ) ) << 48 | UInt64 ( this . get ( ) ) << 40 | UInt64 ( this . get ( ) ) << 32 | UInt64 ( this . get ( ) ) << 24 | UInt64 ( this . get ( ) ) << 16 | UInt64 ( this . get ( ) ) << 8 | UInt64 ( this . get ( ) ) NL }","func_name":"getUInt64","docstring":""}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public func getUInt32 ( ) : UInt32 {  return UInt32 ( this . get ( ) ) << 24 | UInt32 ( this . get ( ) ) << 16 | UInt32 ( this . get ( ) ) << 8 | UInt32 ( this . get ( ) ) NL }","func_name":"getUInt32","docstring":""}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"@ overflowWrapping   public func getUInt16 ( ) : UInt16 {  return UInt16 ( this . get ( ) ) << 8 | UInt16 ( this . get ( ) ) NL }","func_name":"getUInt16","docstring":""}
{"repo":"http2","file":"HeapByteBuffer.cj","path":"http2/src/buffer/HeapByteBuffer.cj","code_tokens":"func createSameBufferException ( ) : IllegalArgumentException {  throw IllegalArgumentException ( The source buffer is this buffer ) NL }","func_name":"createSameBufferException","docstring":"/**\n     * The Function is createSameBufferException\n     *\n     *\n     * @return Type of IllegalArgumentException\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func clear ( ) : Unit {  this . mySize = 0 NL this . first = None NL this . last = None NL }","func_name":"clear","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func isEmpty ( ) : Bool {  this . mySize == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  LinkedListIterator ( this . first ) NL }","func_name":"iterator","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func getFirst ( ) : T {  return match ( this . first ) { case Some ( v ) => v . value NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"getFirst","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func getLast ( ) : T {  return match ( this . last ) { case Some ( v ) => v . value NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"getLast","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func get ( index : Int64 ) : T {  if ( index < 0 || index > = this . mySize ) {  throw IndexOutOfBoundsException ( ) NL } NL match ( at ( index ) ) { case Some ( v ) => v . value NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"get","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func set ( index : Int64 , element : T ) : T {  if ( index < 0 || index > = this . mySize ) {  throw IndexOutOfBoundsException ( ) NL } NL match ( at ( index ) ) { case Some ( v ) =>  let oldValue = v . value NL v . value = element NL return oldValue NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"set","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"@ fastCall   public func prepend ( element : T ) : Unit {  this . linkFirst ( element ) NL }","func_name":"prepend","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"@ fastCall   public func append ( element : T ) : Unit {  this . linkLast ( element ) NL }","func_name":"append","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func appendAll ( elements : Collection < T > ) : Unit {  for ( element in elements ) {  this . linkLast ( element ) NL } NL }","func_name":"appendAll","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func insert ( index : Int64 , element : T ) : Unit {  if ( index < 0 || index > this . mySize ) {  throw IndexOutOfBoundsException ( ) NL } NL if ( index == 0 ) {  this . linkFirst ( element ) NL } else if ( index == this . mySize - 1 ) {  this . linkLast ( element ) NL } else {  this . linkBefore ( element , at ( index ) ) NL } NL }","func_name":"insert","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func remove ( index : Int64 ) : T {  if ( index < 0 || index > = this . mySize ) {  throw IndexOutOfBoundsException ( ) NL } NL match ( at ( index ) ) { case Some ( v ) => this . unlink ( v ) NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"remove","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func removeFirst ( ) : T {  match ( first ) { case Some ( v ) => this . unlinkFirst ( v ) NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"removeFirst","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func removeLast ( ) : T {  match ( last ) { case Some ( v ) => this . unlinkLast ( v ) NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"removeLast","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"private func at ( index : Int64 ) : ? Node < T > {  if ( index < ( this . mySize >> 1 ) ) {   var x : ? Node < T > = first NL for ( i in 0 .. index ) {  match ( x ) { case Some ( v ) => x = v . next NL case _ => ( ) NL } NL } NL x NL } else {   var x = last NL  var i = this . mySize - 1 NL while ( i > index ) {  match ( x ) { case Some ( v ) => x = v . prev NL case _ => ( ) NL } NL i -- NL } NL x NL } NL }","func_name":"at","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"private func linkFirst ( element : T ) : Unit {   let first = this . first NL  let newNode = Node ( prev : None < Node < T > > , value : element , next : first ) NL this . first = newNode NL match ( first ) { case Some ( v ) => v . prev = newNode NL case _ => last = newNode NL } NL this . mySize ++ NL }","func_name":"linkFirst","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"private func linkLast ( element : T ) : Unit {   let last = this . last NL  let newNode = Node ( prev : last , value : element , next : None < Node < T > > ) NL this . last = newNode NL match ( last ) { case Some ( v ) => v . next = newNode NL case _ => first = newNode NL } NL this . mySize ++ NL }","func_name":"linkLast","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"private func linkBefore ( element : T , succ : ? Node < T > ) : Unit {  match ( succ ) { case Some ( v ) =>  let pred = v . prev NL  let newNode = Node ( prev : pred , value : element , next : succ ) NL v . prev = newNode NL match ( pred ) { case Some ( v2 ) => v2 . next = newNode NL case _ => first = newNode NL } NL this . mySize ++ NL case _ => ( ) NL } NL }","func_name":"linkBefore","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"private func unlinkFirst ( x : Node < T > ) : T {   let element = x . value NL  let next = x . next NL x . next = None NL this . first = next NL match ( next ) { case Some ( v ) => v . prev = None NL case _ => last = None NL } NL this . mySize -- NL element NL }","func_name":"unlinkFirst","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"private func unlinkLast ( x : Node < T > ) : T {   let elements = x . value NL  let prev = x . prev NL x . prev = None NL this . last = prev NL match ( prev ) { case Some ( v ) => v . next = None NL case _ => first = None NL } NL this . mySize -- NL elements NL }","func_name":"unlinkLast","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"private func unlink ( x : Node < T > ) : T {   let element = x . value NL  let next = x . next NL  let prev = x . prev NL match ( prev ) { case Some ( v ) => v . next = next NL x . prev = None NL case _ => first = next NL } NL match ( next ) { case Some ( v ) => v . prev = prev NL x . next = None NL case _ => last = prev NL } NL this . mySize -- NL element NL }","func_name":"unlink","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func next ( ) : ? T {  match ( current ) { case Some ( v ) =>  let element = v . value NL current = v . next NL element NL case _ => None NL } NL }","func_name":"next","docstring":""}
{"repo":"http2","file":"linkedList.cj","path":"http2/src/buffer/linkedList.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  this NL }","func_name":"iterator","docstring":""}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func capacity ( ) : Int64 {  return capa NL }","func_name":"capacity","docstring":"/**\n     * The Function is capacity\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func position ( ) : Int64 {  return pos NL }","func_name":"position","docstring":"/**\n     * The Function is position\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public open func position ( newPosition : Int64 ) : Buffer {  if ( newPosition > lim || newPosition < 0 ) {  throw IllegalArgumentException ( newPosition ) NL } NL if ( mar > newPosition ) {  mar = - 1 NL } NL pos = newPosition NL return this NL }","func_name":"position","docstring":"/**\n     * The Function is position\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func limit ( ) : Int64 {  return lim NL }","func_name":"limit","docstring":"/**\n     * The Function is limit\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public open func limit ( newLimit : Int64 ) : Buffer {  if ( newLimit > capa || newLimit < 0 ) {  throw IllegalArgumentException ( newLimit ) NL } NL lim = newLimit NL if ( pos > lim ) {  pos = lim NL } NL if ( mar > lim ) {  mar = - 1 NL } NL return this NL }","func_name":"limit","docstring":"/**\n     * The Function is limit\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func mark ( ) : Buffer {  mar = pos NL return this NL }","func_name":"mark","docstring":"/**\n     * The Function is mark\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public open func reset ( ) : Buffer {   var m = mar NL if ( m < 0 ) {  throw Exception ( ) NL } NL pos = m NL return this NL }","func_name":"reset","docstring":"/**\n     * The Function is reset\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public open func clear ( ) : Buffer {  pos = 0 NL lim = capa NL mar = - 1 NL return this NL }","func_name":"clear","docstring":"/**\n     * The Function is clear\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public open func flip ( ) : Buffer {  lim = pos NL pos = 0 NL mar = - 1 NL return this NL }","func_name":"flip","docstring":"/**\n     * The Function is flip\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public open func rewind ( ) : Buffer {  pos = 0 NL mar = - 1 NL return this NL }","func_name":"rewind","docstring":"/**\n     * The Function is rewind\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func remaining ( ) : Int64 {   let rem = lim - pos NL return if ( rem > 0 ) {  rem NL } else {  0 NL } NL }","func_name":"remaining","docstring":"/**\n     * The Function is remaining\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func hasRemaining ( ) : Bool {  return pos < lim NL }","func_name":"hasRemaining","docstring":"/**\n     * The Function is hasRemaining\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func arrayOffset ( ) : Int64","func_name":"arrayOffset","docstring":"/**\n     * The Function is arrayOffset\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func slice ( ) : Buffer","func_name":"slice","docstring":"/**\n     * The Function is slice\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func duplicate ( ) : Buffer","func_name":"duplicate","docstring":"/**\n     * The Function is duplicate\n     *\n     * @return Type of Buffer\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"public func array ( ) : Array < UInt8 >","func_name":"array","docstring":"/**\n     * The Function is array\n     *\n     * @return Type of Array<UInt8>\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"func nextGetIndex ( ) : Int64 {  if ( pos > = lim ) {  throw Exception ( ) NL } NL  let temp = pos NL pos ++ NL return temp NL }","func_name":"nextGetIndex","docstring":"/**\n     * The Function is nextGetIndex\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"func checkIndex ( t : Int64 ) : Int64 {  if ( ( t < 0 ) || ( t > = lim ) ) {  throw IndexOutOfBoundsException ( ) NL } NL return t NL }","func_name":"checkIndex","docstring":"/**\n     * The Function is checkIndex\n     *\n     * @param i of Int64\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"func markValue ( ) : Int64 {  return mar NL }","func_name":"markValue","docstring":"/**\n     * The Function is markValue\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"func discardMark ( ) {  mar = - 1 NL }","func_name":"discardMark","docstring":"/**\n     * The Function is discardMark\n     *\n     * @since 0.32.5\n     */"}
{"repo":"http2","file":"Buffer.cj","path":"http2/src/buffer/Buffer.cj","code_tokens":"func checkBounds ( off : Int64 , len : Int64 , size : Int64 ) {  if ( ( off | len | ( off + len ) | ( size - ( off + len ) ) ) < 0 ) {  throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"checkBounds","docstring":"/**\n     * The Function is checkBounds\n     *\n     * @param off of Int64\n     * @param len of Int64\n     * @param size of Int64\n     *\n     * @since 0.32.5\n     */"}
