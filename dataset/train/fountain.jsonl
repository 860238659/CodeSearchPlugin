{"repo":"fountain","file":"ExtendDirectory.cj","path":"fountain/src/fs/ExtendDirectory.cj","code_tokens":"static func createIfNotExists ( path : String , recursive ! : Bool ) : Directory","func_name":"createIfNotExists","docstring":""}
{"repo":"fountain","file":"ExtendDirectory.cj","path":"fountain/src/fs/ExtendDirectory.cj","code_tokens":"static func createIfNotExists ( path : Path , recursive ! : Bool ) : Directory","func_name":"createIfNotExists","docstring":""}
{"repo":"fountain","file":"ExtendDirectory.cj","path":"fountain/src/fs/ExtendDirectory.cj","code_tokens":"func exec ( ) : Directory {  if ( ! Directory . exists ( path ) ) {  synchronized ( mutex ) {  if ( ! Directory . exists ( path ) ) {  return Directory . create ( path , recursive : recursive ) NL } NL } NL } NL Directory ( path ) NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"ExtendDirectory.cj","path":"fountain/src/fs/ExtendDirectory.cj","code_tokens":"static public func createIfNotExists ( path : String , recursive ! : Bool = true ) : Directory {  DirectoryCreation ( path , recursive ) . exec ( ) NL }","func_name":"createIfNotExists","docstring":""}
{"repo":"fountain","file":"ExtendDirectory.cj","path":"fountain/src/fs/ExtendDirectory.cj","code_tokens":"static public func createIfNotExists ( path : Path , recursive ! : Bool = true ) : Directory {  createIfNotExists ( path . toString ( ) , recursive : recursive ) NL }","func_name":"createIfNotExists","docstring":""}
{"repo":"fountain","file":"ExtendFile.cj","path":"fountain/src/fs/ExtendFile.cj","code_tokens":"func exec ( ) {  if ( ! File . exists ( path ) ) {  synchronized ( mutex ) {  if ( ! File . exists ( path ) ) {  File . create ( path ) NL } NL } NL } NL File ( path , option ) NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"ExtendFile.cj","path":"fountain/src/fs/ExtendFile.cj","code_tokens":"static func createAndOpen ( path : String , option : OpenOption ) : File","func_name":"createAndOpen","docstring":""}
{"repo":"fountain","file":"ExtendFile.cj","path":"fountain/src/fs/ExtendFile.cj","code_tokens":"static func createAndOpen ( path : Path , option : OpenOption ) : File","func_name":"createAndOpen","docstring":""}
{"repo":"fountain","file":"ExtendFile.cj","path":"fountain/src/fs/ExtendFile.cj","code_tokens":"static public func createAndOpen ( path : String , option : OpenOption ) : File {  FileCreationAndOpen ( path , option ) . exec ( ) NL }","func_name":"createAndOpen","docstring":""}
{"repo":"fountain","file":"ExtendFile.cj","path":"fountain/src/fs/ExtendFile.cj","code_tokens":"static public func createAndOpen ( path : Path , option : OpenOption ) : File {  createAndOpen ( path . toString ( ) , option ) NL }","func_name":"createAndOpen","docstring":""}
{"repo":"fountain","file":"PipelineReceivers.cj","path":"fountain/src/net/PipelineReceivers.cj","code_tokens":"func isEmpty ( ) : Bool","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"PipelineReceivers.cj","path":"fountain/src/net/PipelineReceivers.cj","code_tokens":"func take ( received : R ) : ? PipelineReceiver < R >","func_name":"take","docstring":""}
{"repo":"fountain","file":"PipelineReceivers.cj","path":"fountain/src/net/PipelineReceivers.cj","code_tokens":"func put ( receiver : PipelineReceiver < R > ) : Unit","func_name":"put","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"private func grow ( async ! : Bool = false ) {  if ( ! ( isClosed ( ) || growing . compareAndSwap ( false , true ) ) ) {  return NL } NL  func doGrow ( ) {  try {   let old = clients . load ( ) NL  let oldSize = old . size NL  let size = if ( oldSize == 0 ) {  this . min NL } else {  math . min ( oldSize * 2 , max ) NL } NL  let new = ArrayList < PipelineConnection < D , R > > ( size ) { i => if ( i < oldSize ) {  old [ i ] NL } else {  PipelineConnection < D , R > ( codec , socketCreator , checkData , receivers : receivers , receiverCreator : receiverCreator , readTimeout : readTimeout , receivingTimeout : receivingTimeout ) NL } NL } NL if ( isClosed ( ) || ! clients . compareAndSwap ( old , new ) ) {   var i = oldSize NL while ( i < size ) {  new [ i ] . close ( ) NL i ++ NL } NL } NL } finally {  retried . store ( 0 ) NL growing . store ( false ) NL } NL } NL if ( ! async ) {  doGrow ( ) NL return NL } NL spawn { doGrow ( ) NL } NL }","func_name":"grow","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"func doGrow ( ) {  try {   let old = clients . load ( ) NL  let oldSize = old . size NL  let size = if ( oldSize == 0 ) {  this . min NL } else {  math . min ( oldSize * 2 , max ) NL } NL  let new = ArrayList < PipelineConnection < D , R > > ( size ) { i => if ( i < oldSize ) {  old [ i ] NL } else {  PipelineConnection < D , R > ( codec , socketCreator , checkData , receivers : receivers , receiverCreator : receiverCreator , readTimeout : readTimeout , receivingTimeout : receivingTimeout ) NL } NL } NL if ( isClosed ( ) || ! clients . compareAndSwap ( old , new ) ) {   var i = oldSize NL while ( i < size ) {  new [ i ] . close ( ) NL i ++ NL } NL } NL } finally {  retried . store ( 0 ) NL growing . store ( false ) NL } NL }","func_name":"doGrow","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"private func checkRetried ( c : Int64 ) {  if ( c > 0 ) {   let retried = this . retried . fetchAdd ( 1 ) NL if ( retried == 0 ) {  firstRetried . store ( Time . now ( ) ) NL } NL if ( this . retried . load ( ) > = maxRetring && Time . since ( firstRetried . load ( ) ) . nanoseconds ( ) <= growthDuration && clients . load ( ) . size < max ) {  grow ( async : true ) NL } NL } NL }","func_name":"checkRetried","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"public func isClosed ( ) : Bool {  closed . load ( ) NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"public func close ( ) : Unit {  closed . store ( true ) NL  let toClose = LinkedDeque < PipelineConnection < D , R > > ( elements : clients . load ( ) ) NL while ( ! toClose . isEmpty ( ) ) {   let client = toClose . poll ( ) . getOrThrow ( ) NL if ( ! client . isEmpty ( ) ) {  toClose . offer ( client ) NL ( ) NL } else {  client . close ( ) NL } NL } NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"public func exec ( data : D , connectionConfirmer : ( Int64 ) -> Int64 ) : Option < R > {  if ( isClosed ( ) ) {  return None < R > NL } NL  var c = 0 NL while ( true ) {  checkRetried ( c ) NL  let pool = clients . load ( ) NL  let selected = connectionConfirmer ( pool . size ) NL  let result = pool [ selected ] . exec ( timeout , data ) NL match ( result ) { case Some ( r ) => r NL case _ => c ++ NL continue NL } NL } NL throw UnreachableException ( ) NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"public func exec ( data : D ) : PipelineExec < D , R > {  PipelineExec < D , R > ( data , this ) NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"public func connectionConfirm ( confirmer : ( Int64 ) -> Int64 ) : PipelineExec < D , R > {  this . confirmer = confirmer NL this NL }","func_name":"connectionConfirm","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"public func thrown ( th : ( ) -> Exception ) {  exception = th NL }","func_name":"thrown","docstring":""}
{"repo":"fountain","file":"PipelineConnections.cj","path":"fountain/src/net/PipelineConnections.cj","code_tokens":"public func exec < V > ( fn : ( R ) -> V ) : Future < Result < V , Unit > > {  spawn { try {   let resp = pipeline . exec ( data , confirmer ) NL  let v = fn ( if ( let Some ( th ) = exception ) {  resp . getOrThrow ( th ) NL } else {  resp . getOrThrow ( ) NL } ) NL Result < V , Unit > . SuccessValue ( v ) NL } catch ( e : Exception ) {  log . error ( pipeline , e ) NL Result < V , Unit > . Thrown ( e ) NL } NL } NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"IdentifiableReceived.cj","path":"fountain/src/net/IdentifiableReceived.cj","code_tokens":"operator func == ( other : R ) {  this . id == other . id NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"IdentifiableReceived.cj","path":"fountain/src/net/IdentifiableReceived.cj","code_tokens":"operator func != ( other : R ) {  this . id != other . id NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"SequencePipelineReceivers.cj","path":"fountain/src/net/SequencePipelineReceivers.cj","code_tokens":"public func isEmpty ( ) : Bool {  queue . isEmpty ( ) NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"SequencePipelineReceivers.cj","path":"fountain/src/net/SequencePipelineReceivers.cj","code_tokens":"public func take ( received : R ) : ? PipelineReceiver < R > {  queue . take ( ) NL }","func_name":"take","docstring":""}
{"repo":"fountain","file":"SequencePipelineReceivers.cj","path":"fountain/src/net/SequencePipelineReceivers.cj","code_tokens":"public func put ( receiver : PipelineReceiver < R > ) : Unit {  queue . put ( receiver ) NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"Sender.cj","path":"fountain/src/net/Sender.cj","code_tokens":"func send ( data : D , timeout ! : Duration ) : Unit","func_name":"send","docstring":""}
{"repo":"fountain","file":"Decoder.cj","path":"fountain/src/net/Decoder.cj","code_tokens":"func decode ( src : Array < Byte > ) : R {  throw UnsupportedAccessException ( ) NL }","func_name":"decode","docstring":""}
{"repo":"fountain","file":"Decoder.cj","path":"fountain/src/net/Decoder.cj","code_tokens":"func decode ( src : Iterator < Byte > ) : R {  throw UnsupportedAccessException ( ) NL }","func_name":"decode","docstring":""}
{"repo":"fountain","file":"Decoder.cj","path":"fountain/src/net/Decoder.cj","code_tokens":"func decode ( src : ByteArrayIterator ) : R {  throw UnsupportedAccessException ( ) NL }","func_name":"decode","docstring":""}
{"repo":"fountain","file":"Encoder.cj","path":"fountain/src/net/Encoder.cj","code_tokens":"func encode ( data : D ) : Iterator < Array < Byte > >","func_name":"encode","docstring":""}
{"repo":"fountain","file":"ConnectionPool.cj","path":"fountain/src/net/ConnectionPool.cj","code_tokens":"public func isClosed ( ) : Bool {  pool . isClosed ( ) NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"ConnectionPool.cj","path":"fountain/src/net/ConnectionPool.cj","code_tokens":"public func close ( ) : Unit {  pool . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"ConnectionPool.cj","path":"fountain/src/net/ConnectionPool.cj","code_tokens":"public func getConnection ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : ? PooledConnection < D , R > {  if ( isClosed ( ) ) {  return None NL } NL pool . getObject ( timeout : timeout ) ? . activate ( pool . returnObject ) NL }","func_name":"getConnection","docstring":""}
{"repo":"fountain","file":"CompositeCodec.cj","path":"fountain/src/net/CompositeCodec.cj","code_tokens":"public func encode ( data : D ) : Iterator < Array < Byte > > {  encoder . encode ( data ) NL }","func_name":"encode","docstring":""}
{"repo":"fountain","file":"CompositeCodec.cj","path":"fountain/src/net/CompositeCodec.cj","code_tokens":"public func decode ( src : Array < Byte > ) : R {  decoder . decode ( src ) NL }","func_name":"decode","docstring":""}
{"repo":"fountain","file":"CompositeCodec.cj","path":"fountain/src/net/CompositeCodec.cj","code_tokens":"public func decode ( src : Iterator < Byte > ) : R {  decoder . decode ( src ) NL }","func_name":"decode","docstring":""}
{"repo":"fountain","file":"CompositeCodec.cj","path":"fountain/src/net/CompositeCodec.cj","code_tokens":"public func decode ( src : ByteArrayIterator ) : R {  decoder . decode ( src ) NL }","func_name":"decode","docstring":""}
{"repo":"fountain","file":"PipelineReceiver.cj","path":"fountain/src/net/PipelineReceiver.cj","code_tokens":"func receive ( received : R ) {  result . load ( ) . value = Result < R , Unit > . SuccessValue ( received ) NL }","func_name":"receive","docstring":""}
{"repo":"fountain","file":"PipelineReceiver.cj","path":"fountain/src/net/PipelineReceiver.cj","code_tokens":"func reconnected ( ) {  thrown ( PipelineReconnectedException ( connection is reconnected ) ) NL }","func_name":"reconnected","docstring":""}
{"repo":"fountain","file":"PipelineReceiver.cj","path":"fountain/src/net/PipelineReceiver.cj","code_tokens":"func thrown ( e : Exception ) {  result . load ( ) . value = Result < R , Unit > . Thrown ( e ) NL }","func_name":"thrown","docstring":""}
{"repo":"fountain","file":"PipelineReceiver.cj","path":"fountain/src/net/PipelineReceiver.cj","code_tokens":"func get ( ) : ? R {  while ( true ) {  match ( result . load ( ) . value ) { case SuccessValue ( r ) => r NL case Thrown ( e ) => throw e NL case _ => None < R > NL } NL } NL None NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"PipelineReceiver.cj","path":"fountain/src/net/PipelineReceiver.cj","code_tokens":"static func create ( lastReconnect : UInt64 ) : PipelineReceiver < R > {  PipelineReceiver < R > ( lastReconnect ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"Receiver.cj","path":"fountain/src/net/Receiver.cj","code_tokens":"func receive ( ) : R","func_name":"receive","docstring":""}
{"repo":"fountain","file":"ByteArrayIterator.cj","path":"fountain/src/net/ByteArrayIterator.cj","code_tokens":"public func next ( ) : ? Array < Byte > {   let off = last . size NL for ( i in 0 .. off ) {  buf [ i ] = last [ i ] NL } NL  let buf = if ( off == 0 ) {  this . buf NL } else {  this . buf . slice ( off , this . buf . size - off ) NL } NL  let read = if ( buf . size == 0 ) {  0 NL } else if ( timeout == INFINITE_TIMEOUT_DURATION ) {  socket . read ( buf ) NL } else {  socket . read ( buf , timeout ) NL } NL if ( off > 0 || read > 0 ) {  last = this . buf . slice ( 0 , off + read ) NL last NL } else {  None NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ByteArrayIterator.cj","path":"fountain/src/net/ByteArrayIterator.cj","code_tokens":"public func lastRemainder ( index : Int64 ) : Unit {  last = last . slice ( index , last . size - index ) NL }","func_name":"lastRemainder","docstring":""}
{"repo":"fountain","file":"IdentifiablePipelineReceiver.cj","path":"fountain/src/net/IdentifiablePipelineReceiver.cj","code_tokens":"static public func create < D > ( data : D , lastReconnect : UInt64 ) : IdentifiablePipelineReceiver < ID , R > where D <: IdentifiableData < ID > {  IdentifiablePipelineReceiver ( lastReconnect , data . id ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"IdentifiablePipelineReceivers.cj","path":"fountain/src/net/IdentifiablePipelineReceivers.cj","code_tokens":"public func isEmpty ( ) : Bool {  map . isEmpty ( ) NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"IdentifiablePipelineReceivers.cj","path":"fountain/src/net/IdentifiablePipelineReceivers.cj","code_tokens":"public func take ( received : R ) : ? PipelineReceiver < R > {  map . get ( received . id ) NL }","func_name":"take","docstring":""}
{"repo":"fountain","file":"IdentifiablePipelineReceivers.cj","path":"fountain/src/net/IdentifiablePipelineReceivers.cj","code_tokens":"public func put ( receiver : PipelineReceiver < R > ) : Unit {  map . put ( ( receiver as IdentifiablePipelineReceiver < ID , R > ) . getOrThrow ( ) . id , receiver ) NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"Server.cj","path":"fountain/src/net/Server.cj","code_tokens":"public func accept ( fn : ( R ) -> D ) {  while ( true ) {  try {   let socket = server . accept ( timeout ) NL spawn { afterInit ( socket ) NL  let connection = CommonConnection < D , R > ( socket , codec , ByteArrayIterator ( socket , timeout : readTimeout ) ) NL  let receivedCount = AtomicInt64 ( 0 ) NL  let lastReceivedCount = AtomicInt64 ( 0 ) NL  var receiveErrors = 0 NL  var lastErrorTime = Time . now ( ) NL  let ticker = Ticker ( maxIdleDuration ) { if ( lastReceivedCount . load ( ) == receivedCount . load ( ) ) {  connection . close ( ) NL } NL } NL while ( true ) {  if ( connection . isClosed ( ) ) {  break NL } NL lastReceivedCount . store ( receivedCount . load ( ) ) NL  let received = try {   let r = connection . receive ( ) NL receivedCount . fetchAdd ( 1 ) NL lastErrorTime = Time . now ( ) NL r NL } catch ( e : Exception ) {  logger . error ( ${socket} receiving which is from ${this.toString()} , e ) NL receiveErrors ++ NL if ( receiveErrors > = maxErrorsToClose && Time . since ( lastErrorTime ) <= checkDuration ) {  connection . close ( ) NL break NL } else if ( connection . isClosed ( ) ) {  break NL } NL continue NL } NL if ( received == closeTag ) {  try {  connection . send ( closeResp , timeout : timeout ) NL } catch ( e : Exception ) {  logger . error ( ${socket} closing which is from ${this.toString()} , e ) NL } finally {  try {  connection . close ( ) NL } catch ( _ ) {  } NL } NL break NL } else {  spawn {  let resp = fn ( received ) NL try {  connection . send ( resp , timeout : timeout ) NL } catch ( e : Exception ) {  logger . error ( ${socket} sending which is from ${this.toString()} , e ) NL } NL } NL } NL } NL } NL } catch ( e : Exception ) {  logger . error ( this . toString ( ) , e ) NL } NL } NL }","func_name":"accept","docstring":""}
{"repo":"fountain","file":"Server.cj","path":"fountain/src/net/Server.cj","code_tokens":"public func toString ( ) {  server . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"Server.cj","path":"fountain/src/net/Server.cj","code_tokens":"public func isClosed ( ) {  server . isClosed ( ) NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"Server.cj","path":"fountain/src/net/Server.cj","code_tokens":"public func close ( ) {  server . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"PipelineConnection.cj","path":"fountain/src/net/PipelineConnection.cj","code_tokens":"private func checkAndReconnect ( ) : Unit {  spawn {  func fn ( ) : Unit {  if ( connection . checkAndReconnect ( ) ) {  lastReconnect . fetchAdd ( 1 ) NL } NL } NL mutex . tryLock < Unit > ( 0 , false , fn ) NL } NL }","func_name":"checkAndReconnect","docstring":""}
{"repo":"fountain","file":"PipelineConnection.cj","path":"fountain/src/net/PipelineConnection.cj","code_tokens":"func fn ( ) : Unit {  if ( connection . checkAndReconnect ( ) ) {  lastReconnect . fetchAdd ( 1 ) NL } NL }","func_name":"fn","docstring":""}
{"repo":"fountain","file":"PipelineConnection.cj","path":"fountain/src/net/PipelineConnection.cj","code_tokens":"private func reconnect ( ) : Unit {  mutex . tryLock < Unit > ( 0 , false ) { connection . reconnect ( ) NL lastReconnect . fetchAdd ( 1 ) NL } NL }","func_name":"reconnect","docstring":""}
{"repo":"fountain","file":"PipelineConnection.cj","path":"fountain/src/net/PipelineConnection.cj","code_tokens":"func isEmpty ( ) : Bool {  receivers . isEmpty ( ) NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"PipelineConnection.cj","path":"fountain/src/net/PipelineConnection.cj","code_tokens":"func close ( ) : Unit {  connection . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"PipelineConnection.cj","path":"fountain/src/net/PipelineConnection.cj","code_tokens":"func exec ( timeout : UInt64 , data : D ) : ? R {  try {   let rec = mutex . tryLock < PipelineReceiver < R > > ( timeout , true ) { connection . send ( data ) NL  let rec = receiverCreator ( lastReconnect . load ( ) ) NL receivers . put ( rec ) NL Some ( rec ) NL } NL match ( rec ) { case ( Some ( r ) , true ) => r . get ( ) NL case _ => None NL } NL } catch ( e : PipelineReconnectedException ) {  throw e NL } catch ( e : Exception ) {  reconnect ( ) NL throw e NL } NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"Connection.cj","path":"fountain/src/net/Connection.cj","code_tokens":"static private func connect ( socketCreator : ( ) -> Socket , readTimeout : Duration ) {   let socket = socketCreator ( ) NL ( socket , ByteArrayIterator ( socket , timeout : readTimeout ) ) NL }","func_name":"connect","docstring":""}
{"repo":"fountain","file":"Connection.cj","path":"fountain/src/net/Connection.cj","code_tokens":"static func createSocket ( address : String , port : UInt16 ) {   let socket = Socket ( TCP , address , port ) NL socket . connect ( ) NL socket NL }","func_name":"createSocket","docstring":""}
{"repo":"fountain","file":"Connection.cj","path":"fountain/src/net/Connection.cj","code_tokens":"public func reconnect ( lock ! : Bool = true ) : Unit {   func reconnect ( ) {  try {  socket . load ( ) . close ( ) NL } catch ( _ ) {  } NL  let tuple = connect ( socketCreator , readTimeout ) NL socket . store ( tuple [ 0 ] ) NL byteArrayIterator = tuple [ 1 ] NL lastCheckSent = 0 NL sent . store ( 0 ) NL } NL if ( lock ) {  syncer . tryWrite ( reconnect ) NL } else {  reconnect ( ) NL } NL }","func_name":"reconnect","docstring":""}
{"repo":"fountain","file":"Connection.cj","path":"fountain/src/net/Connection.cj","code_tokens":"func reconnect ( ) {  try {  socket . load ( ) . close ( ) NL } catch ( _ ) {  } NL  let tuple = connect ( socketCreator , readTimeout ) NL socket . store ( tuple [ 0 ] ) NL byteArrayIterator = tuple [ 1 ] NL lastCheckSent = 0 NL sent . store ( 0 ) NL }","func_name":"reconnect","docstring":""}
{"repo":"fountain","file":"Connection.cj","path":"fountain/src/net/Connection.cj","code_tokens":"public func checkAndReconnect ( ) : Bool {  syncer . tryWrite < Bool > { try {  if ( ! check ( lock : false ) ) {  reconnect ( lock : false ) NL true NL } else {  false NL } NL } catch ( _ ) {  reconnect ( lock : false ) NL true NL } NL } ?? false NL }","func_name":"checkAndReconnect","docstring":"//发生重连接返回true"}
{"repo":"fountain","file":"Connection.cj","path":"fountain/src/net/Connection.cj","code_tokens":"public func check ( lock ! : Bool = true ) : Bool {   func fn ( ) : Bool {  if ( lastCheckSent == sent . load ( ) ) {  return false NL } NL lastCheckSent = sent . load ( ) NL  var checked = false NL super . send ( checkData ) NL checked = match ( super . receive ( ) . get ( ) ) { case x : Bool => x NL case _ => false NL } NL checked NL } NL if ( lock ) {  syncer . tryWrite < Bool > { fn ( ) NL } ?? true NL } else {  fn ( ) NL } NL }","func_name":"check","docstring":""}
{"repo":"fountain","file":"Connection.cj","path":"fountain/src/net/Connection.cj","code_tokens":"func fn ( ) : Bool {  if ( lastCheckSent == sent . load ( ) ) {  return false NL } NL lastCheckSent = sent . load ( ) NL  var checked = false NL super . send ( checkData ) NL checked = match ( super . receive ( ) . get ( ) ) { case x : Bool => x NL case _ => false NL } NL checked NL }","func_name":"fn","docstring":""}
{"repo":"fountain","file":"Connection.cj","path":"fountain/src/net/Connection.cj","code_tokens":"public func send ( data : D , timeout ! : Duration = INFINITE_TIMEOUT_DURATION ) : Unit {  syncer . tryRead { super . send ( data , timeout : timeout ) NL sent . fetchAdd ( 1 ) NL } NL }","func_name":"send","docstring":""}
{"repo":"fountain","file":"Connection.cj","path":"fountain/src/net/Connection.cj","code_tokens":"public func receive ( ) : R {  syncer . tryRead < R > { super . receive ( ) NL } . getOrThrow ( ) NL }","func_name":"receive","docstring":""}
{"repo":"fountain","file":"Received.cj","path":"fountain/src/net/Received.cj","code_tokens":"func get ( ) : Any {  this NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"Received.cj","path":"fountain/src/net/Received.cj","code_tokens":"operator func == ( other : R ) {  false NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"Received.cj","path":"fountain/src/net/Received.cj","code_tokens":"operator func != ( other : R ) {  true NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"CommonConnection.cj","path":"fountain/src/net/CommonConnection.cj","code_tokens":"public func isClosed ( ) : Bool {  socket . load ( ) . isClosed ( ) NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"CommonConnection.cj","path":"fountain/src/net/CommonConnection.cj","code_tokens":"public func close ( ) : Unit {  socket . load ( ) . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"CommonConnection.cj","path":"fountain/src/net/CommonConnection.cj","code_tokens":"public open func send ( data : D , timeout ! : Duration = INFINITE_TIMEOUT_DURATION ) : Unit {  for ( bytes in codec . encode ( data ) ) {  if ( timeout == INFINITE_TIMEOUT_DURATION ) {  socket . load ( ) . write ( bytes ) NL } else {  socket . load ( ) . write ( bytes , timeout ) NL } NL } NL }","func_name":"send","docstring":""}
{"repo":"fountain","file":"CommonConnection.cj","path":"fountain/src/net/CommonConnection.cj","code_tokens":"public open func receive ( ) : R {  codec . decode ( byteArrayIterator ) NL }","func_name":"receive","docstring":""}
{"repo":"fountain","file":"PooledConnection.cj","path":"fountain/src/net/PooledConnection.cj","code_tokens":"public func isClosed ( ) : Bool {  ! assigned NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"PooledConnection.cj","path":"fountain/src/net/PooledConnection.cj","code_tokens":"public func close ( ) : Unit {  assigned = false NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is returning ) NL } NL returnFn ( this ) NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is returned ) NL } NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"PooledConnection.cj","path":"fountain/src/net/PooledConnection.cj","code_tokens":"public func send ( data : D , timeout ! : Duration = INFINITE_TIMEOUT_DURATION ) : Unit {  connection . send ( data , timeout : timeout ) NL }","func_name":"send","docstring":""}
{"repo":"fountain","file":"PooledConnection.cj","path":"fountain/src/net/PooledConnection.cj","code_tokens":"public func receive ( ) : R {  connection . receive ( ) NL }","func_name":"receive","docstring":""}
{"repo":"fountain","file":"PooledConnection.cj","path":"fountain/src/net/PooledConnection.cj","code_tokens":"func activate ( returnFn : ( PooledConnection < D , R > ) -> Unit ) : PooledConnection < D , R > {  assigned = true NL this . returnFn = returnFn NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is assigned ) NL } NL this NL }","func_name":"activate","docstring":""}
{"repo":"fountain","file":"PooledConnection.cj","path":"fountain/src/net/PooledConnection.cj","code_tokens":"func isDestroied ( ) : Bool {  connection . isClosed ( ) NL }","func_name":"isDestroied","docstring":""}
{"repo":"fountain","file":"PooledConnection.cj","path":"fountain/src/net/PooledConnection.cj","code_tokens":"func check ( ) : Bool {  connection . check ( ) NL }","func_name":"check","docstring":""}
{"repo":"fountain","file":"PooledConnection.cj","path":"fountain/src/net/PooledConnection.cj","code_tokens":"func destroy ( ) : Unit {  if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is closing ) NL } NL if ( ! ( assigned || connection . isClosed ( ) ) ) {  connection . close ( ) NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is closed ) NL } NL } else if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} cannot close ) NL } NL }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"ExtendResponse.cj","path":"fountain/src/http/ExtendResponse.cj","code_tokens":"func readAsString ( ) : String","func_name":"readAsString","docstring":""}
{"repo":"fountain","file":"ExtendResponse.cj","path":"fountain/src/http/ExtendResponse.cj","code_tokens":"public func readAsString ( ) : String {  String . fromUtf8 ( this . readToEnd ( ) ) NL }","func_name":"readAsString","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func send ( method : RequestMethod , url : String ) : Response {   let request = createRequest ( method , url ) NL createClient ( ) . send ( request ) NL }","func_name":"send","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func get ( ) : Response {  send ( GET , url ) NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func head ( ) : Response {  send ( HEAD , url ) NL }","func_name":"head","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func post ( ) : Response {  send ( POST , url ) NL }","func_name":"post","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func put ( ) : Response {  send ( PUT , url ) NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func delete ( ) : Response {  send ( DELETE , url ) NL }","func_name":"delete","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func options ( ) : Response {  send ( OPTIONS , url ) NL }","func_name":"options","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func patch ( ) : Response {  send ( PATCH , url ) NL }","func_name":"patch","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func trace ( ) : Response {  send ( TRACE , url ) NL }","func_name":"trace","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func connect ( ) : Response {  send ( CONNECT , url ) NL }","func_name":"connect","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func createRequest ( method : RequestMethod , url : String ) {   let request = match ( data ) { case Some ( d ) where d is InputStream => createRequest ( method , url , ( d as InputStream ) . getOrThrow ( ) ) NL case Some ( d ) where d is Form =>  let form = ( d as Form ) . getOrThrow ( ) . encode ( ) NL createRequest ( method , url , form ) NL case Some ( d ) where d is ToString => createRequest ( method , url , ( d as ToString ) . getOrThrow ( ) . toString ( ) ) NL case Some ( d ) where d is Array < Byte > => createRequest ( method , url , ( d as Array < Byte > ) . getOrThrow ( ) ) NL case None < Any > => Request ( method , escape ( url ) ) NL case _ => throw IllegalAccessException ( unsupport data type for request body ) NL } NL populateHeaders ( request ) NL populateCookies ( request ) NL request NL }","func_name":"createRequest","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func createRequest ( method : RequestMethod , url : String , data : String ) {  createRequest ( method , url , data . toUtf8Array ( ) ) NL }","func_name":"createRequest","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func createRequest ( method : RequestMethod , url : String , data : Array < Byte > ) {   let input = escapeToInputStreamIfNecessary ( data ) NL createRequest ( method , url , input ) NL }","func_name":"createRequest","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func createRequest ( method : RequestMethod , url : String , data : InputStream ) {  Request ( method , escape ( url ) , data ) NL }","func_name":"createRequest","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func escape ( data : String ) : String {  escape ( data . toUtf8Array ( ) ) NL }","func_name":"escape","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func escapeIfNecessary ( data : String ) : String {  if ( toEscape_ ) {  escape ( data ) NL } else {  data NL } NL }","func_name":"escapeIfNecessary","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func escapeIfNecessary ( data : Array < Byte > ) : String {  if ( toEscape_ ) {  escape ( data ) NL } else {  String . fromUtf8 ( data ) NL } NL }","func_name":"escapeIfNecessary","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func escape ( data : Array < Byte > ) : String {  String . fromUtf8 ( escapeToBytes ( data ) ) NL }","func_name":"escape","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func escapeToBytes ( data : Array < Byte > ) : Array < Byte > {  escapeToInputStream ( data ) . readToEnd ( ) NL }","func_name":"escapeToBytes","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func escapeToInputStreamIfNecessary ( data : Array < Byte > ) : InputStream {  if ( toEscape_ ) {  escapeToInputStream ( data ) NL } else {   let input = ByteArrayStream ( ) NL input . write ( data ) NL input NL } NL }","func_name":"escapeToInputStreamIfNecessary","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func escapeToInputStream ( data : Array < Byte > ) : ByteArrayStream {   let input = ByteArrayStream ( ) NL for ( d in data ) {  if ( d > = 0 && d <= 127 ) {  input . write ( [ d ] ) NL } else {  input . write ( [ UInt8 ( UInt32 ( % ) ) ] ) NL input . write ( d . hex . toUtf8Array ( ) ) NL } NL } NL input NL }","func_name":"escapeToInputStream","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func populateHeaders ( request : Request ) {  setHeader ( Content-Type , contentType ) NL setHeader ( Accept , accept ) NL for ( h in header ) {  for ( v in h [ 1 ] ) {  addHeader ( h [ 0 ] , v ) NL } NL } NL }","func_name":"populateHeaders","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func populateCookies ( request : Request ) {  for ( cookie in cookies ) {  request . addCookie ( cookie ) NL } NL }","func_name":"populateCookies","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"private func createClient ( ) {   let client = if ( let Some ( tls ) = this . tlsCfg ) {  Client ( tls ) NL } else {  Client ( ) NL } NL if ( let Some ( cr ) = checkRedirect ) {  client . checkRedirect = cr NL } NL client . keepalives = keepalives NL client . timeout = timeout NL if ( let Some ( sin ) = socketInterfaceName ) {  client . socketInterfaceName = sin NL } NL client NL }","func_name":"createClient","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func toEscape ( ) : HttpClient {  this . toEscape_ = true NL this NL }","func_name":"toEscape","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func notEscape ( ) : HttpClient {  this . toEscape_ = false NL this NL }","func_name":"notEscape","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addHeaders ( headers : Iterable < ( String , ToString ) > ) : HttpClient {  for ( header in headers ) {  addHeader ( header [ 0 ] , header [ 1 ] ) NL } NL this NL }","func_name":"addHeaders","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addHeaders < T > ( headers : Iterable < ( String , T ) > ) : HttpClient where T <: ToString {  for ( header in headers ) {  addHeader < T > ( header [ 0 ] , header [ 1 ] ) NL } NL this NL }","func_name":"addHeaders","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addHeaders ( name : String , values : Iterable < ToString > ) : HttpClient {  for ( v in values ) {  addHeader ( name , v ) NL } NL this NL }","func_name":"addHeaders","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addHeaders < T > ( name : String , values : Iterable < T > ) : HttpClient where T <: ToString {  addHeaders ( name , IterableConverter < T , ToString > ( values ) ) NL }","func_name":"addHeaders","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addHeader < T > ( name : String , value : T ) : HttpClient where T <: ToString {   let key = HeaderDfaUtil . canonicalHeaderKey ( name ) NL header . add ( key , value . toString ( ) ) NL this NL }","func_name":"addHeader","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setHeader < T > ( name : String , value : T , toBase64 ! : Bool = false ) : HttpClient where T <: ToString {   let key = HeaderDfaUtil . canonicalHeaderKey ( name ) NL  var headVal = value . toString ( ) NL if ( toBase64 ) {  headVal = toBase64String ( headVal . toUtf8Array ( ) ) NL } NL header . set ( key , headVal ) NL this NL }","func_name":"setHeader","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setHeaders < T > ( name : String , values : Iterable < T > ) : HttpClient where T <: ToString {  setHeaders ( name , IterableConverter < T , ToString > ( values ) ) NL }","func_name":"setHeaders","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setHeaders ( name : String , values : Iterable < ToString > ) : HttpClient {  for ( v in values ) {  setHeader < ToString > ( name , v ) NL } NL this NL }","func_name":"setHeaders","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setHeaders ( pairs : Iterable < ( String , ToString ) > ) : HttpClient {  for ( pair in pairs ) {  setHeader < ToString > ( pair [ 0 ] , pair [ 1 ] ) NL } NL this NL }","func_name":"setHeaders","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setHeaders < T > ( pairs : Iterable < ( String , T ) > ) : HttpClient where T <: ToString {  for ( pair in pairs ) {  setHeader < T > ( pair [ 0 ] , pair [ 1 ] ) NL } NL this NL }","func_name":"setHeaders","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func remove ( name : String ) : HttpClient {   let key = HeaderDfaUtil . canonicalHeaderKey ( name ) NL header . remove ( key ) NL this NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setFormData < T > ( name : String , value : T ) : HttpClient where T <: ToString {  match ( data ) { case Some ( f ) where f is Form => ( f as Form ) . getOrThrow ( ) . set ( name , value . toString ( ) ) NL case Some ( _ ) => throw IllegalAccessException ( current data is not encoding/url.Form ) NL case _ => this . data = Form ( ${name}=${value} ) as Any NL } NL setContentType ( DEFAULT_REQUEST_MIME_TYPE ) NL }","func_name":"setFormData","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addFormData < T > ( name : String , value : T ) : HttpClient where T <: ToString {  match ( data ) { case Some ( f ) where f is Form => ( f as Form ) . getOrThrow ( ) . add ( name , value . toString ( ) ) NL case Some ( _ ) => throw IllegalAccessException ( current data is not encoding/url.Form ) NL case _ => this . data = Form ( ${name}=${value} ) as Any NL } NL setContentType ( DEFAULT_REQUEST_MIME_TYPE ) NL }","func_name":"addFormData","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setFormDatas ( name : String , values : Iterable < ToString > ) : HttpClient {  for ( v in values ) {  setFormData < ToString > ( name , v ) NL } NL this NL }","func_name":"setFormDatas","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setFormDatas < T > ( name : String , values : Iterable < T > ) : HttpClient where T <: ToString {  setFormDatas ( name , IterableConverter < T , ToString > ( values ) ) NL }","func_name":"setFormDatas","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addFormDatas ( name : String , values : Iterable < ToString > ) : HttpClient {  for ( v in values ) {  addFormData < ToString > ( name , v ) NL } NL this NL }","func_name":"addFormDatas","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addFormDatas < T > ( name : String , values : Iterable < T > ) : HttpClient where T <: ToString {  addFormDatas ( name , IterableConverter < T , ToString > ( values ) ) NL }","func_name":"addFormDatas","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setFormDatas ( pairs : Iterable < ( String , ToString ) > ) : HttpClient {  for ( pair in pairs ) {  setFormData ( pair [ 0 ] , pair [ 1 ] ) NL } NL this NL }","func_name":"setFormDatas","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setFormDatas < T > ( pairs : Iterable < ( String , T ) > ) : HttpClient where T <: ToString {  for ( pair in pairs ) {  setFormData < T > ( pair [ 0 ] , pair [ 1 ] ) NL } NL this NL }","func_name":"setFormDatas","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addFormDatas ( pairs : Iterable < ( String , ToString ) > ) : HttpClient {  for ( pair in pairs ) {  addFormData ( pair [ 0 ] , pair [ 1 ] ) NL } NL this NL }","func_name":"addFormDatas","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addFormDatas < T > ( pairs : Iterable < ( String , T ) > ) : HttpClient where T <: ToString {  for ( pair in pairs ) {  addFormData < T > ( pair [ 0 ] , pair [ 1 ] ) NL } NL this NL }","func_name":"addFormDatas","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setPlainTextData < T > ( data : T ) : HttpClient where T <: ToString {  this . data = data . toString ( ) NL setContentType ( PLAIN_TEXT_MIME_TYPE ) NL }","func_name":"setPlainTextData","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setJsonData < T > ( data : T ) : HttpClient where T <: ToJson {  setJsonData ( data . toJson ( ) ) NL }","func_name":"setJsonData","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setJsonData ( data : JsonValue ) : HttpClient {  this . data = data NL setContentType ( JSON_CONTENT_TYPE ) NL }","func_name":"setJsonData","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setData ( input : InputStream , contentType : String ) : HttpClient {  this . data = input NL setContentType ( contentType ) NL }","func_name":"setData","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setContentType ( contentType : String ) : HttpClient {  this . contentType = contentType NL this NL }","func_name":"setContentType","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setAccept ( accept : String ) : HttpClient {  this . accept = accept NL this NL }","func_name":"setAccept","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setCheckRedirect ( checkRedirect : ( Request , ArrayList < Request > ) -> Unit ) : HttpClient {  this . checkRedirect = checkRedirect NL this NL }","func_name":"setCheckRedirect","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addCookie ( cookie : Cookie ) : HttpClient {  cookies . append ( cookie ) NL this NL }","func_name":"addCookie","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addCookies ( cookies : Iterable < Cookie > ) : HttpClient {  for ( cookie in cookies ) {  addCookie ( cookie ) NL } NL this NL }","func_name":"addCookies","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addCookie ( cookieMaker : ( ) -> Cookie ) : HttpClient {  addCookie ( cookieMaker ) NL }","func_name":"addCookie","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addCookies ( cookieMakers : Iterable < ( ) -> Cookie > ) : HttpClient {  for ( maker in cookieMakers ) {  addCookie ( maker ) NL } NL this NL }","func_name":"addCookies","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func addCookie ( name : String , value : ToString , path ! : String =  , domain ! : String =  , expires ! : Time = Time . onetime , rawExpires ! : String =  , maxAge ! : Int64 = 0 , secure ! : Bool = false , httpOnly ! : Bool = false , sameSite ! : SameSite = SameSite . Default , raw ! : String =  , unparsed ! : Array < String > = Array < String > ( ) ) : Unit {  addCookie ( Cookie ( name , value . toString ( ) , path : path , domain : domain , expires : expires , rawExpires : rawExpires , maxAge : maxAge , secure : secure , httpOnly : httpOnly , sameSite : sameSite , raw : raw , unparsed : unparsed ) ) NL }","func_name":"addCookie","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setKeepalives ( keepalives : Bool ) : HttpClient {  this . keepalives = keepalives NL this NL }","func_name":"setKeepalives","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTimeout ( timeout : Duration ) : HttpClient {  this . timeout = timeout NL this NL }","func_name":"setTimeout","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setSocketInterfaceName ( socketInterfaceName : String ) : HttpClient {  this . socketInterfaceName = socketInterfaceName NL this NL }","func_name":"setSocketInterfaceName","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func changeTlsCfg ( caFile : String ) : HttpClient {  this . tlsCfg = TlsClientConfig ( caFile ) NL this NL }","func_name":"changeTlsCfg","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func replaceTlsCaFile ( caFile : String ) : HttpClient {  match ( tlsCfg ) { case Some ( cfg ) =>  var c = cfg NL c . caFile = caFile NL case _ => changeTlsCfg ( caFile ) NL } NL this NL }","func_name":"replaceTlsCaFile","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTlsCertificateChainFile ( certificateChainFile : String ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . certificateChainFile = certificateChainFile NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setTlsCertificateChainFile","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTlsPrivateKeyFile ( privateKeyFile : String ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . privateKeyFile = privateKeyFile NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setTlsPrivateKeyFile","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTlsVerifyMode ( verifyMode : TlsClientVerifyMode ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . verifyMode = verifyMode NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setTlsVerifyMode","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTlsVerifyNone ( ) : HttpClient {  setTlsVerifyMode ( VerifyNone ) NL }","func_name":"setTlsVerifyNone","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTlsVerifyServer ( ) : HttpClient {  setTlsVerifyMode ( VerifyServer ) NL }","func_name":"setTlsVerifyServer","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTlsDomain ( domain : String ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . domain = domain NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setTlsDomain","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTlsSni ( sni : Bool ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . sni = sni NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setTlsSni","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTlsMinVersion ( version : TlsVersion ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . minVersion = version NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setTlsMinVersion","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setTlsMaxVersion ( version : TlsVersion ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . maxVersion = version NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setTlsMaxVersion","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setCipherSuitesV1_2 ( cipherSuitesV1_2 : Array < String > ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . cipherSuitesV1_2 = cipherSuitesV1_2 NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setCipherSuitesV1_2","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setCipherSuitesV1_3 ( cipherSuitesV1_3 : Array < String > ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . cipherSuitesV1_3 = cipherSuitesV1_3 NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setCipherSuitesV1_3","docstring":""}
{"repo":"fountain","file":"HttpClient.cj","path":"fountain/src/http/HttpClient.cj","code_tokens":"public func setAlpnList ( alpnList : Array < String > ) : HttpClient {  try {   var cfg = this . tlsCfg . getOrThrow ( ) NL cfg . alpnList = alpnList NL } catch ( e : Exception ) {  IllegalAccessException ( caFile must be specified first ) NL } NL this NL }","func_name":"setAlpnList","docstring":""}
{"repo":"fountain","file":"StringMatcher.cj","path":"fountain/src/string/StringMatcher.cj","code_tokens":"public func indexOf ( text : String , start : Int64 ) : Int64 {  return text . indexOf ( delimiter , rotateIndex ( text , start ) ) ?? - 1 NL }","func_name":"indexOf","docstring":""}
{"repo":"fountain","file":"StringMatcher.cj","path":"fountain/src/string/StringMatcher.cj","code_tokens":"public func matches ( text : String , idx : Int64 ) : Bool {  return indexOf ( text , idx ) > = 0 NL }","func_name":"matches","docstring":""}
{"repo":"fountain","file":"StringMatcher.cj","path":"fountain/src/string/StringMatcher.cj","code_tokens":"public func delimiterLength ( ) : Int64 {  return delimiter . size NL }","func_name":"delimiterLength","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"public open func indexOf ( text : String , start : Int64 ) : Int64 {   var i = rotateIndex ( text , start ) NL while ( i < text . size ) {  if ( matches ( text , i ) ) {  return i NL } NL i ++ NL } NL return - 1 NL }","func_name":"indexOf","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"public func matches ( text : String , idx : Int64 ) : Bool","func_name":"matches","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"public open func delimiterLength ( ) : Int64 {  return 1 NL }","func_name":"delimiterLength","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"public func split ( text : String , start : Int64 ) : String {   var idx = indexOf ( text , start ) NL if ( idx == start && ignoreOnStartingCharMatched ) {   let s = start + delimiterLength ( ) NL if ( s > = text . size ) {  idx = - 1 NL } else {  idx = indexOf ( text , s ) NL } NL } NL if ( idx > 0 ) {  return text . substring ( start , idx ) NL } else if ( idx == 0 ) {  return  NL } else {  return text . substring ( start ) NL } NL }","func_name":"split","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"static public func ofRange ( ignoreOnStartingCharMatched : Bool , min : Char , max : Char ) : CharMatcher {  return RangeCharMatcher ( ignoreOnStartingCharMatched , min , max ) NL }","func_name":"ofRange","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"static public func ofSingle ( ignoreOnStartingCharMatched : Bool , ch : Char ) : CharMatcher {  return SingleCharMatcher ( ignoreOnStartingCharMatched , ch ) NL }","func_name":"ofSingle","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"static public func ofString ( ignoreOnStartingCharMatched : Bool , delim : String ) : CharMatcher {  return StringMatcher ( ignoreOnStartingCharMatched , delim ) NL }","func_name":"ofString","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"static public func ofMulti ( ignoreOnStartingCharMatched : Bool , chs : Array < Char > ) : CharMatcher {  return MultiCharMatcher ( ignoreOnStartingCharMatched , chs ) NL }","func_name":"ofMulti","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"static public func ofMulti ( ignoreOnStartingCharMatched : Bool , chs : Collection < Char > ) : CharMatcher {  return MultiCharMatcher ( ignoreOnStartingCharMatched , chs ) NL }","func_name":"ofMulti","docstring":""}
{"repo":"fountain","file":"CharMatcher.cj","path":"fountain/src/string/CharMatcher.cj","code_tokens":"static public func ofMulti ( ignoreOnStartingCharMatched : Bool , chs : String ) {  return MultiCharMatcher ( ignoreOnStartingCharMatched , chs ) NL }","func_name":"ofMulti","docstring":""}
{"repo":"fountain","file":"CaseFormat.cj","path":"fountain/src/string/CaseFormat.cj","code_tokens":"private func append ( part : String , appender : StringBuilder ) : Unit {  match ( this ) { case Pascal =>  let l = part . size NL if ( l > 1 ) {  appender . append ( part [ 0 ] . toUpperCase ( ) . toString ( ) ) . append ( part . substring ( 1 ) . toLowerCase ( ) ) NL } else if ( l == 1 ) {  appender . append ( part . toUpperCase ( ) ) NL } NL case Camel => if ( appender . size == 0 ) {  appender . append ( part . toLowerCase ( ) ) NL } else {  Pascal . append ( part , appender ) NL } NL case LowerUnderScore => append ( part . toLowerCase ( ) , appender , delimiter ) NL case UpperUnderScore => append ( part . toUpperCase ( ) , appender , delimiter ) NL case LowerHyphen => append ( part . toLowerCase ( ) , appender , delimiter ) NL case UpperHyphen => append ( part . toUpperCase ( ) , appender , delimiter ) NL } NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"CaseFormat.cj","path":"fountain/src/string/CaseFormat.cj","code_tokens":"private func split ( text : String , start : Int64 ) : String {  if ( start > = text . size ) {  return  NL } NL return matcher . split ( text , start ) NL }","func_name":"split","docstring":""}
{"repo":"fountain","file":"CaseFormat.cj","path":"fountain/src/string/CaseFormat.cj","code_tokens":"private func append ( part : String , appender : StringBuilder , delim : Char ) : Unit {  appender . append ( part ) . append ( delim ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"CaseFormat.cj","path":"fountain/src/string/CaseFormat.cj","code_tokens":"public func convert ( text : String , format : CaseFormat ) : String {   let appender = StringBuilder ( ) NL  var part : String NL  let l = text . size NL  var i = 0 NL while ( i < l ) {  part = split ( text , i ) NL format . append ( part , appender ) NL  let pl = part . size NL if ( pl > 0 ) {  if ( delimiter == empty ) {  i += pl NL } else {  i += pl + 1 NL } NL } else {  i ++ NL } NL } NL if ( ! ( format . delimiter == empty || text . charAt ( l - 1 ) == delimiter ) ) {  appender . remove ( appender . size - 1 ) NL } NL return appender . toString ( ) NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"functions.cj","path":"fountain/src/string/functions.cj","code_tokens":"func rotateIndex ( text : String , idx : Int64 ) : Int64 {  if ( idx < 0 ) {   let l = text . size NL return l + idx % l + 1 NL } NL return idx NL }","func_name":"rotateIndex","docstring":"//if idx>=0，return idx；if idx<0，return text.length()+idx%text.length()+1"}
{"repo":"fountain","file":"SingleCharMatcher.cj","path":"fountain/src/string/SingleCharMatcher.cj","code_tokens":"public func indexOf ( text : String , start : Int64 ) : Int64 {  return text . indexOf ( ch , rotateIndex ( text , start ) ) ?? - 1 NL }","func_name":"indexOf","docstring":""}
{"repo":"fountain","file":"SingleCharMatcher.cj","path":"fountain/src/string/SingleCharMatcher.cj","code_tokens":"public func matches ( text : String , idx : Int64 ) : Bool {  return indexOf ( text , idx ) > = 0 NL }","func_name":"matches","docstring":""}
{"repo":"fountain","file":"MultiCharMatcher.cj","path":"fountain/src/string/MultiCharMatcher.cj","code_tokens":"public func matches ( text : String , idx : Int64 ) : Bool {   let c = text . charAt ( idx ) NL return chs . contains ( c ) NL }","func_name":"matches","docstring":""}
{"repo":"fountain","file":"RangeCharMatcher.cj","path":"fountain/src/string/RangeCharMatcher.cj","code_tokens":"public func matches ( text : String , idx : Int64 ) : Bool {   let c = text . charAt ( idx ) NL return c > = min && c <= max NL }","func_name":"matches","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomBoolStream ( ) : Stream < Bool > {  Stream < Bool > ( RandomBoolIterator < R > ( current ) ) NL }","func_name":"randomBoolStream","docstring":"/*\n     * 随机获取一个布尔类型的值\n     * 返回值 Bool - 返回一个布尔类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt8Stream ( ) : Stream < UInt8 > {  Stream < UInt8 > ( RandomUInt8Iterator < R > ( current ) ) NL }","func_name":"randomUInt8Stream","docstring":"/*\n     * 获取 UInt8 的随机数\n     * 返回值 UInt8 - 返回一个 UInt8 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt16Stream ( ) : Stream < UInt16 > {  Stream < UInt16 > ( RandomUInt16Iterator < R > ( current ) ) NL }","func_name":"randomUInt16Stream","docstring":"/*\n     * 获取 UInt16 的随机数\n     * 返回值 UInt16 - 返回一个 UInt16 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt32Stream ( ) : Stream < UInt32 > {  Stream < UInt32 > ( RandomUInt32Iterator < R > ( current ) ) NL }","func_name":"randomUInt32Stream","docstring":"/*\n     * 获取 UInt32 的随机数\n     * 返回值 UInt32 - 返回一个 UInt32 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt64Stream ( ) : Stream < UInt64 > {  Stream < UInt64 > ( RandomUInt64Iterator < R > ( current ) ) NL }","func_name":"randomUInt64Stream","docstring":"/*\n     * 获取 UInt64 的随机数\n     * 返回值 UInt64 - 返回一个 UInt64 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt8Stream ( ) : Stream < Int8 > {  Stream < Int8 > ( RandomInt8Iterator < R > ( current ) ) NL }","func_name":"randomInt8Stream","docstring":"/*\n     * 获取 Int8 的随机数\n     * 返回值 Int8 - 返回一个 Int8 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt16Stream ( ) : Stream < Int16 > {  Stream < Int16 > ( RandomInt16Iterator < R > ( current ) ) NL }","func_name":"randomInt16Stream","docstring":"/*\n     * 获取 Int16 的随机数\n     * 返回值 Int16 - 返回一个 Int16 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt32Stream ( ) : Stream < Int32 > {  Stream < Int32 > ( RandomInt32Iterator < R > ( current ) ) NL }","func_name":"randomInt32Stream","docstring":"/*\n     * 获取 Int32 的随机数\n     * 返回值 Int32 - 返回一个 Int32 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt64Stream ( ) : Stream < Int64 > {  Stream < Int64 > ( RandomInt64Iterator < R > ( current ) ) NL }","func_name":"randomInt64Stream","docstring":"/*\n     * 获取 Int64 的随机数\n     * 返回值 Int64 - 返回一个 Int64 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt8Stream ( upper : UInt8 ) : Stream < UInt8 > {  Stream < UInt8 > ( UpperRandomUInt8Iterator < R > ( current , upper ) ) NL }","func_name":"randomUInt8Stream","docstring":"/*\n     * 获取 UInt8 的随机数\n     * 返回值 UInt8 - 返回一个 UInt8 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt16Stream ( upper : UInt16 ) : Stream < UInt16 > {  Stream < UInt16 > ( UpperRandomUInt16Iterator < R > ( current , upper ) ) NL }","func_name":"randomUInt16Stream","docstring":"/*\n     * 获取 UInt16 的随机数\n     * 返回值 UInt16 - 返回一个 UInt16 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt32Stream ( upper : UInt32 ) : Stream < UInt32 > {  Stream < UInt32 > ( UpperRandomUInt32Iterator < R > ( current , upper ) ) NL }","func_name":"randomUInt32Stream","docstring":"/*\n     * 获取 UInt32 的随机数\n     * 返回值 UInt32 - 返回一个 UInt32 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt64Stream ( upper : UInt64 ) : Stream < UInt64 > {  Stream < UInt64 > ( UpperRandomUInt64Iterator < R > ( current , upper ) ) NL }","func_name":"randomUInt64Stream","docstring":"/*\n     * 获取 UInt64 的随机数\n     * 返回值 UInt64 - 返回一个 UInt64 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt8Stream ( upper : Int8 ) : Stream < Int8 > {  Stream < Int8 > ( UpperRandomInt8Iterator < R > ( current , upper ) ) NL }","func_name":"randomInt8Stream","docstring":"/*\n     * 获取 Int8 的随机数\n     * 返回值 Int8 - 返回一个 Int8 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt16Stream ( upper : Int16 ) : Stream < Int16 > {  Stream < Int16 > ( UpperRandomInt16Iterator < R > ( current , upper ) ) NL }","func_name":"randomInt16Stream","docstring":"/*\n     * 获取 Int16 的随机数\n     * 返回值 Int16 - 返回一个 Int16 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt32Stream ( upper : Int32 ) : Stream < Int32 > {  Stream < Int32 > ( UpperRandomInt32Iterator < R > ( current , upper ) ) NL }","func_name":"randomInt32Stream","docstring":"/*\n     * 获取 Int32 的随机数\n     * 返回值 Int32 - 返回一个 Int32 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt64Stream ( upper : Int64 ) : Stream < Int64 > {  Stream < Int64 > ( UpperRandomInt64Iterator < R > ( current , upper ) ) NL }","func_name":"randomInt64Stream","docstring":"/*\n     * 获取 Int64 的随机数\n     * 返回值 Int64 - 返回一个 Int64 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt8sStream ( size : Int64 ) : Stream < Array < UInt8 > > {  Stream < Array < UInt8 > > ( RandomUInt8sIterator < R > ( current , size ) ) NL }","func_name":"randomUInt8sStream","docstring":"/*\n     * 生成随机数替换入参数组中的每个元素\n     * 参数类型 array - 传入一个数组\n     * 返回值 Array<UInt8> - 返回替换后的 Array\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomFloat16Stream ( ) : Stream < Float16 > {  Stream < Float16 > ( RandomFloat16Iterator < R > ( current ) ) NL }","func_name":"randomFloat16Stream","docstring":"/*\n     * 随机获取一个 Float16 类型的值\n     * 返回值 Float16 - 返回一个 Float16 类型的随机数，范围 [0.0，1.0)\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomFloat32Stream ( ) : Stream < Float32 > {  Stream < Float32 > ( RandomFloat32Iterator < R > ( current ) ) NL }","func_name":"randomFloat32Stream","docstring":"/*\n     * 随机获取一个 Float32 类型的值\n     * 返回值 Float32 - 返回一个 Float32 类型的随机数，范围 [0.0，1.0)\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomFloat64Stream ( ) : Stream < Float64 > {  Stream < Float64 > ( RandomFloat64Iterator < R > ( current ) ) NL }","func_name":"randomFloat64Stream","docstring":"/*\n     * 随机获取一个 Float64 类型的值\n     * 返回值 Float64 - 返回一个 Float64 类型的随机数，范围 [0.0，1.0)\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomGaussianFloat16Stream ( ) : Stream < Float16 > {  Stream < Float16 > ( RandomGaussianFloat16Iterator < R > ( current ) ) NL }","func_name":"randomGaussianFloat16Stream","docstring":"/*\n     * 获取高斯 Float16 的随机数\n     * 返回值 Float16 - 返回一个 Float16 类型的高斯随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomGaussianFloat32Stream ( ) : Stream < Float32 > {  Stream < Float32 > ( RandomGaussianFloat32Iterator < R > ( current ) ) NL }","func_name":"randomGaussianFloat32Stream","docstring":"/*\n     * 获取高斯 Float32 的随机数\n     * 返回值 Float32 - 返回一个 Float32 类型的高斯随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomGaussianFloat64Stream ( ) : Stream < Float64 > {  Stream < Float64 > ( RandomGaussianFloat64Iterator < R > ( current ) ) NL }","func_name":"randomGaussianFloat64Stream","docstring":"/*\n     * 获取高斯 Float64 的随机数\n     * 返回值 Float64 - 返回一个 Float64 类型的高斯随机数\n     */"}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt64 ( min : Int64 , max : Int64 , closed ! : Bool ) : Stream < Int64 >","func_name":"randomInt64","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt64 ( min : UInt64 , max : UInt64 , closed ! : Bool ) : Stream < UInt64 >","func_name":"randomUInt64","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomInt32 ( min : Int32 , max : Int32 , closed ! : Bool ) : Stream < Int32 >","func_name":"randomInt32","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"func randomUInt32 ( min : UInt32 , max : UInt32 , closed ! : Bool ) : Stream < UInt32 >","func_name":"randomUInt32","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func randomInt64 ( min : Int64 , max : Int64 , closed ! : Bool = false ) : Stream < Int64 > {  return Stream < Int64 > ( RangeRandomInt64Iterator < Random > ( this , min , max , closed ) ) NL }","func_name":"randomInt64","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func randomUInt64 ( min : UInt64 , max : UInt64 , closed ! : Bool = false ) : Stream < UInt64 > {  return Stream < UInt64 > ( RangeRandomUInt64Iterator < Random > ( this , min , max , closed ) ) NL }","func_name":"randomUInt64","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func randomInt32 ( min : Int32 , max : Int32 , closed ! : Bool = false ) : Stream < Int32 > {  return Stream < Int32 > ( RangeRandomInt32Iterator < Random > ( this , min , max , closed ) ) NL }","func_name":"randomInt32","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func randomUInt32 ( min : UInt32 , max : UInt32 , closed ! : Bool = false ) : Stream < UInt32 > {  return Stream < UInt32 > ( RangeRandomUInt32Iterator < Random > ( this , min , max , closed ) ) NL }","func_name":"randomUInt32","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func nextBytes ( length : Int32 ) : Array < Byte > {  return this . nextUInt8s ( Array < UInt8 > ( Int64 ( length ) , item : 0 ) ) NL }","func_name":"nextBytes","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func randomInt64 ( min : Int64 , max : Int64 , closed ! : Bool = false ) : Stream < Int64 > {  return Stream < Int64 > ( RangeRandomInt64Iterator < SecureRandom > ( this , min , max , closed ) ) NL }","func_name":"randomInt64","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func randomUInt64 ( min : UInt64 , max : UInt64 , closed ! : Bool = false ) : Stream < UInt64 > {  return Stream < UInt64 > ( RangeRandomUInt64Iterator < SecureRandom > ( this , min , max , closed ) ) NL }","func_name":"randomUInt64","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func randomInt32 ( min : Int32 , max : Int32 , closed ! : Bool = false ) : Stream < Int32 > {  return Stream < Int32 > ( RangeRandomInt32Iterator < SecureRandom > ( this , min , max , closed ) ) NL }","func_name":"randomInt32","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func randomUInt32 ( min : UInt32 , max : UInt32 , closed ! : Bool = false ) : Stream < UInt32 > {  return Stream < UInt32 > ( RangeRandomUInt32Iterator < SecureRandom > ( this , min , max , closed ) ) NL }","func_name":"randomUInt32","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func nextUInt8s ( array : Array < UInt8 > ) : Array < UInt8 > {  return this . nextBytes ( Int32 ( array . size ) ) NL }","func_name":"nextUInt8s","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  return this NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int32 > {  rand . nextInt32 ( min , max , closed : closed ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt32 > {  rand . nextUInt32 ( min , max , closed : closed ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int64 > {  rand . nextInt64 ( min , max , closed : closed ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt64 > {  rand . nextUInt64 ( min , max , closed : closed ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Bool > {  rand . nextBool ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int8 > {  rand . nextInt8 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt8 > {  rand . nextUInt8 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int8 > {  rand . nextInt8 ( upper ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt8 > {  rand . nextUInt8 ( upper ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Array < UInt8 > > {  rand . nextUInt8s ( Array < UInt8 > ( size , item : 0 ) ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int16 > {  rand . nextInt16 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt16 > {  rand . nextUInt16 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int16 > {  rand . nextInt16 ( upper ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt16 > {  rand . nextUInt16 ( upper ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int32 > {  rand . nextInt32 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt32 > {  rand . nextUInt32 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int32 > {  rand . nextInt32 ( upper ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt32 > {  rand . nextUInt32 ( upper ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int64 > {  rand . nextInt64 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt64 > {  rand . nextUInt64 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Int64 > {  rand . nextInt64 ( upper ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < UInt64 > {  rand . nextUInt64 ( upper ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Float16 > {  rand . nextFloat16 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Float32 > {  rand . nextFloat32 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Float64 > {  rand . nextFloat64 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Float16 > {  rand . nextGaussianFloat16 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Float32 > {  rand . nextGaussianFloat32 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomStream.cj","path":"fountain/src/random/RandomStream.cj","code_tokens":"public func next ( ) : Option < Float64 > {  rand . nextGaussianFloat64 ( ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomAscii ( count : Int64 ) {   var builder = StringBuilder ( ) NL  var i = 0 NL while ( i < count ) {  builder . append ( Char ( rand . nextUInt32 ( 128 ) ) ) NL i ++ NL } NL return builder . toString ( ) NL }","func_name":"randomAscii","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomAscii ( min : Int64 , max : Int64 ) {  randomAscii ( rand . nextInt64 ( min , max , closed : true ) ) NL }","func_name":"randomAscii","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func random ( count : Int64 , source : String ) {   var builder = StringBuilder ( ) NL  var i = 0 NL while ( i < count ) {  builder . append ( source . get ( rand . nextInt64 ( source . size ) ) . getOrThrow ( ) ) NL i ++ NL } NL return builder . toString ( ) NL }","func_name":"random","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func random ( min : Int64 , max : Int64 , source : String ) {  random ( rand . nextInt64 ( min , max , closed : true ) , source ) NL }","func_name":"random","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomLowerLetters ( count : Int64 ) {  random ( count , LOWER_LETTERS ) NL }","func_name":"randomLowerLetters","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomLowerLetters ( min : Int64 , max : Int64 ) {  randomLowerLetters ( rand . nextInt64 ( min , max ) ) NL }","func_name":"randomLowerLetters","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomUpperLetters ( count : Int64 ) {  random ( count , UPPER_LETTERS ) NL }","func_name":"randomUpperLetters","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomUpperLetters ( min : Int64 , max : Int64 ) {  randomUpperLetters ( rand . nextInt64 ( min , max ) ) NL }","func_name":"randomUpperLetters","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomAllLetters ( count : Int64 ) {  random ( count , ALL_LETTERS ) NL }","func_name":"randomAllLetters","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomAllLetters ( min : Int64 , max : Int64 ) {  randomLowerLetters ( rand . nextInt64 ( min , max ) ) NL }","func_name":"randomAllLetters","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomNumbers ( count : Int64 ) {  random ( count , NUMBERS ) NL }","func_name":"randomNumbers","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomNumbers ( min : Int64 , max : Int64 ) {  randomNumbers ( rand . nextInt64 ( min , max ) ) NL }","func_name":"randomNumbers","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomLowerLettersNumbers ( count : Int64 ) {  random ( count , LOWER_LETTERS_AND_NUMBERS ) NL }","func_name":"randomLowerLettersNumbers","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomLowerLettersNumbers ( min : Int64 , max : Int64 ) {  randomLowerLettersNumbers ( rand . nextInt64 ( min , max ) ) NL }","func_name":"randomLowerLettersNumbers","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomUpperLettersNumbers ( count : Int64 ) {  random ( count , LOWER_LETTERS_AND_NUMBERS ) NL }","func_name":"randomUpperLettersNumbers","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomUpperLettersNumbers ( min : Int64 , max : Int64 ) {  randomLowerLettersNumbers ( rand . nextInt64 ( min , max ) ) NL }","func_name":"randomUpperLettersNumbers","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomLettersNumbers ( count : Int64 ) {  random ( count , ALL_LETTERS_AND_NUMBERS ) NL }","func_name":"randomLettersNumbers","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomLettersNumbers ( min : Int64 , max : Int64 ) {  randomLowerLettersNumbers ( rand . nextInt64 ( min , max ) ) NL }","func_name":"randomLettersNumbers","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomPrintableAsciis ( count : Int64 ) {  random ( count , ALL_PRINTABLE_ASCIIS ) NL }","func_name":"randomPrintableAsciis","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomPrintableAsciis ( min : Int64 , max : Int64 ) {  randomPrintableAsciis ( rand . nextInt64 ( min , max ) ) NL }","func_name":"randomPrintableAsciis","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomAllChars ( count : Int64 ) {   var builder = StringBuilder ( ) NL  var i = 0 NL while ( i < count ) {   let tuple = ALL_CHARS [ rand . nextInt64 ( 2 ) ] NL builder . append ( Char ( rand . nextUInt32 ( tuple [ 0 ] , tuple [ 1 ] , closed : true ) ) ) NL i ++ NL } NL return builder . toString ( ) NL }","func_name":"randomAllChars","docstring":""}
{"repo":"fountain","file":"RandomString.cj","path":"fountain/src/random/RandomString.cj","code_tokens":"public func randomAllChars ( min : Int64 , max : Int64 ) {  randomAllChars ( rand . nextInt64 ( min , max ) ) NL }","func_name":"randomAllChars","docstring":""}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt64 ( min : Int64 , max : Int64 , closed ! : Bool ) : Int64","func_name":"nextInt64","docstring":"/*\n     * 获取一个 Int64 类型的随机数，获取失败会抛异常\n     * 返回值 Int64 - 一个 Int64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt64 ( min : UInt64 , max : UInt64 , closed ! : Bool ) : UInt64","func_name":"nextUInt64","docstring":"/*\n     * 获取一个 UInt64 类型的随机数，获取失败会抛异常\n     * 返回值 UInt64 - 一个 UInt64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt32 ( min : Int32 , max : Int32 , closed ! : Bool ) : Int32","func_name":"nextInt32","docstring":"/*\n     * 获取一个 Int32 类型的随机数，获取失败会抛异常\n     * 返回值 Int32 - 一个 Int32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt32 ( min : UInt32 , max : UInt32 , closed ! : Bool ) : UInt32","func_name":"nextUInt32","docstring":"/*\n     * 获取一个 UInt32 类型的随机数，获取失败会抛异常\n     * 返回值 UInt32 - 一个 UInt32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"public func nextInt64 ( min : Int64 , max : Int64 , closed ! : Bool = false ) : Int64 {  return Int64 ( floor ( nextFloat64 ( ) * ( Float64 ( max ) - Float64 ( min ) + if ( closed ) {  1.0 NL } else {  0.0 NL } ) + Float64 ( min ) ) ) NL }","func_name":"nextInt64","docstring":"/*\n     * 获取一个 Int64 类型的随机数，获取失败会抛异常\n     * 返回值 Int64 - 一个 Int64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"public func nextUInt64 ( min : UInt64 , max : UInt64 , closed ! : Bool = false ) : UInt64 {  return UInt64 ( floor ( nextFloat64 ( ) * ( Float64 ( max ) - Float64 ( min ) + if ( closed ) {  1.0 NL } else {  0.0 NL } ) + Float64 ( min ) ) ) NL }","func_name":"nextUInt64","docstring":"/*\n     * 获取一个 UInt64 类型的随机数，获取失败会抛异常\n     * 返回值 UInt64 - 一个 UInt64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"public func nextInt32 ( min : Int32 , max : Int32 , closed ! : Bool = false ) : Int32 {  return Int32 ( floor ( nextFloat32 ( ) * ( Float32 ( max ) - Float32 ( min ) + if ( closed ) {  1.0 NL } else {  0.0 NL } ) + Float32 ( min ) ) ) NL }","func_name":"nextInt32","docstring":"/*\n     * 获取一个 Int32 类型的随机数，获取失败会抛异常\n     * 返回值 Int32 - 一个 Int32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"public func nextUInt32 ( min : UInt32 , max : UInt32 , closed ! : Bool = false ) : UInt32 {  return UInt32 ( floor ( nextFloat32 ( ) * ( Float32 ( max ) - Float32 ( min ) + if ( closed ) {  1.0 NL } else {  0.0 NL } ) + Float32 ( min ) ) ) NL }","func_name":"nextUInt32","docstring":"/*\n     * 获取一个 UInt32 类型的随机数，获取失败会抛异常\n     * 返回值 UInt32 - 一个 UInt32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"public func nextInt64 ( min : Int64 , max : Int64 , closed ! : Bool = false ) : Int64 {  return Int64 ( floor ( nextFloat64 ( ) * ( Float64 ( max ) - Float64 ( min ) + if ( closed ) {  1.0 NL } else {  0.0 NL } ) + Float64 ( min ) ) ) NL }","func_name":"nextInt64","docstring":"/*\n     * 获取一个 Int64 类型的随机数，获取失败会抛异常\n     * 返回值 Int64 - 一个 Int64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"public func nextUInt64 ( min : UInt64 , max : UInt64 , closed ! : Bool = false ) : UInt64 {  return UInt64 ( floor ( nextFloat64 ( ) * ( Float64 ( max ) - Float64 ( min ) + if ( closed ) {  1.0 NL } else {  0.0 NL } ) + Float64 ( min ) ) ) NL }","func_name":"nextUInt64","docstring":"/*\n     * 获取一个 UInt64 类型的随机数，获取失败会抛异常\n     * 返回值 UInt64 - 一个 UInt64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"public func nextInt32 ( min : Int32 , max : Int32 , closed ! : Bool = false ) : Int32 {  return Int32 ( floor ( nextFloat32 ( ) * ( Float32 ( max ) - Float32 ( min ) + if ( closed ) {  1.0 NL } else {  0.0 NL } ) + Float32 ( min ) ) ) NL }","func_name":"nextInt32","docstring":"/*\n     * 获取一个 Int32 类型的随机数，获取失败会抛异常\n     * 返回值 Int32 - 一个 Int32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"public func nextUInt32 ( min : UInt32 , max : UInt32 , closed ! : Bool = false ) : UInt32 {  return UInt32 ( floor ( nextFloat32 ( ) * ( Float32 ( max ) - Float32 ( min ) + if ( closed ) {  1.0 NL } else {  0.0 NL } ) + Float32 ( min ) ) ) NL }","func_name":"nextUInt32","docstring":"/*\n     * 获取一个 UInt32 类型的随机数，获取失败会抛异常\n     * 返回值 UInt32 - 一个 UInt32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt8s ( array : Array < UInt8 > ) : Array < UInt8 >","func_name":"nextUInt8s","docstring":"/*\n     * 生成随机数替换入参数组中的每个元素\n     * 参数类型 array - 传入一个数组\n     * 返回值 Array<UInt8> - 返回替换后的 Array\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextBytes ( length : Int32 ) : Array < Byte >","func_name":"nextBytes","docstring":"/*\n     * 获取一个指定长度的随机数字节数组\n     * 参数 length - 要生成的随机字节数的数量， length <= 0 会抛出参数非法异常\n     * 返回值 Array<Byte> - 一个随机数字节数组\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextBool ( ) : Bool","func_name":"nextBool","docstring":"/*\n     * 获取一个布尔类型的随机数，获取失败会抛异常\n     * 返回值 Bool - 一个布尔类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt8 ( ) : UInt8","func_name":"nextUInt8","docstring":"/*\n     * 获取一个 UInt8 类型的随机数，获取失败会抛异常\n     * 返回值 UInt8 - 一个 UInt8 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt16 ( ) : UInt16","func_name":"nextUInt16","docstring":"/*\n     * 获取一个 UInt16 类型的随机数，获取失败会抛异常\n     * 返回值 UInt16 - 一个 UInt16 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt32 ( ) : UInt32","func_name":"nextUInt32","docstring":"/*\n     * 获取一个 UInt32 类型的随机数，获取失败会抛异常\n     * 返回值 UInt32 - 一个 UInt32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt64 ( ) : UInt64","func_name":"nextUInt64","docstring":"/*\n     * 获取一个 UInt64 类型的随机数，获取失败会抛异常\n     * 返回值 UInt64 - 一个 UInt64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt8 ( ) : Int8","func_name":"nextInt8","docstring":"/*\n     * 获取一个 Int8 类型的随机数，获取失败会抛异常\n     * 返回值 Int8 - 一个 Int8 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt16 ( ) : Int16","func_name":"nextInt16","docstring":"/*\n     * 获取一个 Int16 类型的随机数，获取失败会抛异常\n     * 返回值 Int16 - 一个 Int16 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt32 ( ) : Int32","func_name":"nextInt32","docstring":"/*\n     * 获取一个 Int32 类型的随机数，获取失败会抛异常\n     * 返回值 Int32 - 一个 Int32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt64 ( ) : Int64","func_name":"nextInt64","docstring":"/*\n     * 获取一个 Int64 类型的随机数，获取失败会抛异常\n     * 返回值 Int64 - 一个 Int64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt8 ( max : UInt8 ) : UInt8","func_name":"nextUInt8","docstring":"/*\n     * 获取一个 UInt8 类型的随机数，获取失败会抛异常\n     * 返回值 UInt8 - 一个 UInt8 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt16 ( max : UInt16 ) : UInt16","func_name":"nextUInt16","docstring":"/*\n     * 获取一个 UInt16 类型的随机数，获取失败会抛异常\n     * 返回值 UInt16 - 一个 UInt16 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt32 ( max : UInt32 ) : UInt32","func_name":"nextUInt32","docstring":"/*\n     * 获取一个 UInt32 类型的随机数，获取失败会抛异常\n     * 返回值 UInt32 - 一个 UInt32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextUInt64 ( max : UInt64 ) : UInt64","func_name":"nextUInt64","docstring":"/*\n     * 获取一个 UInt64 类型的随机数，获取失败会抛异常\n     * 返回值 UInt64 - 一个 UInt64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt8 ( max : Int8 ) : Int8","func_name":"nextInt8","docstring":"/*\n     * 获取一个 Int8 类型的随机数，获取失败会抛异常\n     * 返回值 Int8 - 一个 Int8 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt16 ( max : Int16 ) : Int16","func_name":"nextInt16","docstring":"/*\n     * 获取一个 Int16 类型的随机数，获取失败会抛异常\n     * 返回值 Int16 - 一个 Int16 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt32 ( max : Int32 ) : Int32","func_name":"nextInt32","docstring":"/*\n     * 获取一个 Int32 类型的随机数，获取失败会抛异常\n     * 返回值 Int32 - 一个 Int32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextInt64 ( max : Int64 ) : Int64","func_name":"nextInt64","docstring":"/*\n     * 获取一个 Int64 类型的随机数，获取失败会抛异常\n     * 返回值 Int64 - 一个 Int64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextFloat16 ( ) : Float16","func_name":"nextFloat16","docstring":"/*\n     * 获取一个 Float16 类型的随机数，范围在 0.0 到 1.0 之间，获取失败会抛异常\n     * 返回值 Float16 - 一个 Float16 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextFloat32 ( ) : Float32","func_name":"nextFloat32","docstring":"/*\n     * 获取一个 Float32 类型的随机数，范围在 0.0 到 1.0 之间，获取失败会抛异常\n     * 返回值 Float32 - 一个 Float32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextFloat64 ( ) : Float64","func_name":"nextFloat64","docstring":"/*\n     * 获取一个 Float64 类型的随机数，范围在 0.0 到 1.0 之间，获取失败会抛异常\n     * 返回值 Float64 - 一个 Float64 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextGaussianFloat16 ( ) : Float16","func_name":"nextGaussianFloat16","docstring":"/*\n     * 获取一个 Float16 类型且符合均值为 0.0 标准差为 1.0 的高斯分布的随机数，获取失败会抛异\n             常\n     * 返回值 Float16 - 一个 Float16 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextGaussianFloat32 ( ) : Float32","func_name":"nextGaussianFloat32","docstring":"/*\n     * 获取一个 Float32 类型且符合均值为 0.0 标准差为 1.0 的高斯分布的随机数，获取失败会抛异\n             常\n     * 返回值 Float32 - 一个 Float32 类型的随机数\n     */"}
{"repo":"fountain","file":"ExtendRandom.cj","path":"fountain/src/random/ExtendRandom.cj","code_tokens":"func nextGaussianFloat64 ( ) : Float64","func_name":"nextGaussianFloat64","docstring":"/*\n     * 获取一个 Float64 类型且符合均值为 0.0 标准差为 1.0 的高斯分布的随机数，获取失败会抛异\n             常\n     * 返回值 Float64 - 一个 Float64 类型的随机数\n     */"}
{"repo":"fountain","file":"RandomReservoir.cj","path":"fountain/src/random/RandomReservoir.cj","code_tokens":"public func randomReservoir < T > ( count : Int64 , source : Iterable < T > , priv ! : Bool = false ) : ArrayList < T > {   let rand = SecureRandom ( priv : priv ) NL  var result = ArrayList < T > ( ) NL  var c = 0 NL for ( v in source ) {  if ( c < count ) {  result . append ( v ) NL } else {   let r = rand . nextInt64 ( c ) NL if ( r < count ) {  result . set ( r , v ) NL } NL } NL c ++ NL } NL return result NL }","func_name":"randomReservoir","docstring":""}
{"repo":"fountain","file":"FactoryBean.cj","path":"fountain/src/bean/FactoryBean.cj","code_tokens":"func get ( ) : Any","func_name":"get","docstring":""}
{"repo":"fountain","file":"FactoryBean.cj","path":"fountain/src/bean/FactoryBean.cj","code_tokens":"func beanPostConstructor ( ) : ( Any ) -> Unit {  DefaultPostConstruct NL }","func_name":"beanPostConstructor","docstring":""}
{"repo":"fountain","file":"FactoryBean.cj","path":"fountain/src/bean/FactoryBean.cj","code_tokens":"func beanDestroier ( ) : ( Any ) -> Unit {  DefaultDestroier NL }","func_name":"beanDestroier","docstring":""}
{"repo":"fountain","file":"Bean.cj","path":"fountain/src/bean/Bean.cj","code_tokens":"static func new ( ) : Bean","func_name":"new","docstring":""}
{"repo":"fountain","file":"Bean.cj","path":"fountain/src/bean/Bean.cj","code_tokens":"func postConstruct ( ) : Unit {  }","func_name":"postConstruct","docstring":""}
{"repo":"fountain","file":"Bean.cj","path":"fountain/src/bean/Bean.cj","code_tokens":"func destroy ( ) : Unit {  }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"FactoryBeanManager.cj","path":"fountain/src/bean/FactoryBeanManager.cj","code_tokens":"public func getFactory ( ) : FactoryBean {  if ( let Some ( f ) = factory ) {  f NL } else {  synchronized ( mutex ) {  if ( let Some ( f ) = factory ) {  f NL } else {  factory = super . get ( ) as FactoryBean NL factory . getOrThrow ( ) NL } NL } NL } NL }","func_name":"getFactory","docstring":""}
{"repo":"fountain","file":"FactoryBeanManager.cj","path":"fountain/src/bean/FactoryBeanManager.cj","code_tokens":"public open func get ( ) : Any {   let factory = getFactory ( ) NL try {   var o = factory . get ( ) NL if ( ! ( o is Object ) ) {   let o = Box < Any > ( o ) NL postConstruct ( o ) NL o . value NL } else {  postConstruct ( o ) NL o NL } NL } finally {  if ( ! factory . singletonFactory ) {  destroyFactory ( factory ) NL } NL } NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"FactoryBeanManager.cj","path":"fountain/src/bean/FactoryBeanManager.cj","code_tokens":"public func destroyFactory ( factory : FactoryBean ) {  this . factory = None < FactoryBean > NL super . destroy ( factory ) NL }","func_name":"destroyFactory","docstring":""}
{"repo":"fountain","file":"FactoryBeanManager.cj","path":"fountain/src/bean/FactoryBeanManager.cj","code_tokens":"public func destroy ( o : Any ) {  destroier ( o ) NL }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"func DefaultPostConstruct ( o : Any ) {  match ( o ) { case x : Bean => x . postConstruct ( ) NL case x : Box < Any > => ( x as Bean ) . getOrThrow ( ) . postConstruct ( ) NL case _ => throw BeanException ( ) NL } NL }","func_name":"DefaultPostConstruct","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"func DefaultDestroier ( o : Any ) {  match ( o ) { case x : Bean => x . destroy ( ) NL case x : Box < Any > => ( x as Bean ) . getOrThrow ( ) . destroy ( ) NL case _ => throw BeanException ( ) NL } NL }","func_name":"DefaultDestroier","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public open func setCreator ( fn : ( ) -> Any ) : BeanManager {  this . creator = fn NL this NL }","func_name":"setCreator","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public func getCreator ( ) : ( ) -> Any {  creator NL }","func_name":"getCreator","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public func getPostConstruct ( ) : ( Any ) -> Unit {  postConstruct NL }","func_name":"getPostConstruct","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public func getDestroier ( ) : ( Any ) -> Unit {  destroier NL }","func_name":"getDestroier","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public func bean < T > ( ) : BeanManager where T <: Bean {  setPostConstruct { o => ( o as T ) . getOrThrow ( ) . postConstruct ( ) NL } NL setDestroier { o => ( o as T ) . getOrThrow ( ) . destroy ( ) NL } NL setCreator ( T . new ) NL afterBean ( ) NL }","func_name":"bean","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public open func afterBean ( ) : BeanManager {  this NL }","func_name":"afterBean","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public func setPostConstruct ( fn : ( Any ) -> Unit ) : BeanManager {  this . postConstruct = fn NL this NL }","func_name":"setPostConstruct","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public func setDestroier ( fn : ( Any ) -> Unit ) : BeanManager {  this . destroier = fn NL this NL }","func_name":"setDestroier","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public open func destroy ( o : Any ) : Unit {  destroier ( o ) NL }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public open func destroy ( ) : Unit {  }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"BeanManager.cj","path":"fountain/src/bean/BeanManager.cj","code_tokens":"public open func get ( ) : Any {   var o = creator ( ) NL if ( ! ( o is Object ) ) {   let o = Box < Any > ( o ) NL postConstruct ( o ) NL o . value NL } else {  postConstruct ( o ) NL o NL } NL }","func_name":"get","docstring":"//如果creator()返回的是值类型会先用Box<Any>包装一遍再执行postConstruct，返回的也是包装以后的"}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"private func destroy ( ) : Unit {  for ( b in beans . values ( ) ) {  b . destroy ( ) NL } NL }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func setInherited ( inherited : BeanFactory ) : BeanFactory {  this . inherited = inherited NL this NL }","func_name":"setInherited","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func register ( bean : BeanManager ) : BeanFactory {  if ( beans . putIfNonExistent ( bean . name , bean ) . some ) {  throw BeanException ( duplicate bean name: ${bean.name} ) NL } NL this NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func register ( fn : ( ) -> BeanManager ) : BeanFactory {  register ( fn ( ) ) NL this NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func register ( beans : Iterable < BeanManager > ) : BeanFactory {  for ( bean in beans ) {  register ( bean ) NL } NL this NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func register ( fn : ( ) -> Iterable < BeanManager > ) : BeanFactory {  register ( fn ( ) ) NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func register ( fns : Iterable < ( ) -> BeanManager > ) : BeanFactory {  for ( fn in fns ) {  register ( fn ) NL } NL this NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func register ( fns : Iterable < ( ) -> Iterable < BeanManager > > ) : BeanFactory {  for ( fn in fns ) {  register ( fn ) NL } NL this NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"private func toFactoryBeanManager ( name : String , bm : BeanManager ) : Any {   let manager = this . beans . computeIfPresent ( name ) { k , v => if ( v is FactoryBeanManager ) {  return v NL } NL  let manager = match ( bm ) { case x : SingletonBeanManager => SingletonFactoryBeanManager ( name , x . lazy ) NL case _ => FactoryBeanManager ( name ) NL } NL manager . setCreator ( bm . getCreator ( ) ) NL manager . setPostConstruct ( bm . getPostConstruct ( ) ) NL manager . setDestroier ( bm . getDestroier ( ) ) NL manager NL } . getOrThrow ( ) NL manager . get ( ) NL }","func_name":"toFactoryBeanManager","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func get < T > ( name : String ) : T {   var result = if ( let Some ( b ) = beans . get ( name ) ) {  match ( b . get ( ) ) { case x : T => x NL case x : FactoryBean => toFactoryBeanManager ( name , b ) NL case _ => throw TypeCastException ( bean name: ${name} ) NL } NL } else if ( let Some ( f ) = inherited ) {  return f . get < T > ( name ) NL } else {  None < T > NL } NL if ( let Some ( o ) = result as T ) {  o NL } else {  throw BeanException ( bean named as ${name} does not exist ) NL } NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"private func prefix ( prefix : String ) : ( String ) -> Bool {  { name => name . startsWith ( name ) NL } NL }","func_name":"prefix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func getByPrefix < T > ( prefix : String ) : Map < String , T > {  get < T > ( this . prefix ( prefix ) ) NL }","func_name":"getByPrefix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func useByPrefix < T > ( prefix : String , exec : ( T ) -> Unit ) : Unit {  use < T > ( this . prefix ( prefix ) , exec ) NL }","func_name":"useByPrefix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func getFirstByPrefix < T > ( prefix : String ) : ? T {  getFirst < T > ( this . prefix ( prefix ) ) NL }","func_name":"getFirstByPrefix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"private func suffix ( suffix : String ) : ( String ) -> Bool {  { name => name . endsWith ( name ) NL } NL }","func_name":"suffix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func getBySuffix < T > ( suffix : String ) : Map < String , T > {  get < T > ( this . suffix ( suffix ) ) NL }","func_name":"getBySuffix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func useBySuffix < T > ( suffix : String , exec : ( T ) -> Unit ) : Unit {  use < T > ( this . suffix ( suffix ) , exec ) NL }","func_name":"useBySuffix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func getFirstBySuffix < T > ( suffix : String ) : ? T {  getFirst < T > ( this . suffix ( suffix ) ) NL }","func_name":"getFirstBySuffix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"private func wildcard ( pattern : String ) : ( String ) -> Bool {  { name => ^${pattern.replace(\"*\", \".*\")}$ . regex ( ) . matched ( name ) NL } NL }","func_name":"wildcard","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func getWithWildcard < T > ( pattern : String ) : Map < String , T > {  get < T > ( wildcard ( pattern ) ) NL }","func_name":"getWithWildcard","docstring":"//支持通配符*"}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func useWithWildcard < T > ( pattern : String , exec : ( T ) -> Unit ) : Unit {  use < T > ( wildcard ( pattern ) , exec ) NL }","func_name":"useWithWildcard","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func getFirstWithWildcard < T > ( pattern : String ) : ? T {  getFirst < T > ( wildcard ( pattern ) ) NL }","func_name":"getFirstWithWildcard","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"private func alwaysTrue ( ) : ( String ) -> Bool {  { k => true NL } NL }","func_name":"alwaysTrue","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func get < T > ( ) : Map < String , T > {  get < T > ( alwaysTrue ( ) ) NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func use < T > ( exec : ( T ) -> Unit ) : Unit {  use < T > ( alwaysTrue ( ) , exec ) NL }","func_name":"use","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func use < T , R > ( name : String , exec : ( T ) -> ? R ) : ? R {  exec ( get < T > ( name ) ) NL }","func_name":"use","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func getFirst < T > ( ) : ? T {  getFirst < T > { k => true NL } NL }","func_name":"getFirst","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func get < T > ( checker : ( String ) -> Bool ) : Map < String , T > {   let beans = HashMap < String , T > ( ) NL if ( let Some ( i ) = inherited ) {  beans . putAll ( i . get < T > ( checker ) ) NL } NL for ( name in this . beans . keys ( ) where checker ( name ) ) {   let bean = get < T > ( name ) NL if ( bean is T ) {  beans [ name ] = bean NL } else if ( bean is FactoryBean ) {   let o = toFactoryBeanManager ( name , this . beans [ name ] ) NL match ( o ) { case x : T => beans [ name ] = x NL case _ => continue NL } NL } NL } NL beans NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func use < T > ( checker : ( String ) -> Bool , exec : ( T ) -> Unit ) : Unit {  for ( bean in get < T > ( checker ) . values ( ) ) {  exec ( bean ) NL } NL }","func_name":"use","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func use < T > ( checker : ( String ) -> Bool ) : BeanFactoryWrapper {  BeanFactoryWrapper ( this , checker ) NL }","func_name":"use","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func useFirst < T > ( checker : ( String ) -> Bool ) : FirstBeanFactoryWrapper {  FirstBeanFactoryWrapper ( this , checker ) NL }","func_name":"useFirst","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func getFirst < T > ( checker : ( String ) -> Bool ) : ? T {  for ( name in this . beans . keys ( ) where checker ( name ) ) {   let bean = get < T > ( name ) NL if ( bean is T ) {  return bean NL } else if ( bean is FactoryBean ) {   let o = toFactoryBeanManager ( name , this . beans [ name ] ) NL match ( o ) { case x : T => return x NL case _ => continue NL } NL } NL } NL  var result = None < T > NL if ( let Some ( i ) = inherited ) {  result = i . getFirst < T > ( checker ) NL } NL result NL }","func_name":"getFirst","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func useFirst < T , R > ( checker : ( String ) -> Bool , exec : ( T ) -> ? R ) : ? R {  if ( let Some ( f ) = getFirst < T > ( checker ) ) {  exec ( f ) NL } else {  None NL } NL }","func_name":"useFirst","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func useFirstByPrefix < T , R > ( prefix : String , exec : ( T ) -> ? R ) : ? R {  useFirst < T , R > ( this . prefix ( prefix ) , exec ) NL }","func_name":"useFirstByPrefix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func useFirst < T , R > ( exec : ( T ) -> ? R ) : ? R {  useFirst < T , R > ( alwaysTrue ( ) , exec ) NL }","func_name":"useFirst","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func useFirstBySuffix < T , R > ( suffix : String , exec : ( T ) -> ? R ) : ? R {  useFirst < T , R > ( this . suffix ( suffix ) , exec ) NL }","func_name":"useFirstBySuffix","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func useFirstWithWildcard < T , R > ( pattern : String , exec : ( T ) -> ? R ) : ? R {  useFirst < T , R > ( this . wildcard ( pattern ) , exec ) NL }","func_name":"useFirstWithWildcard","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func exec < T > ( exec : ( T ) -> Unit ) : Unit {  factory . use < T > ( checker , exec ) NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"BeanFactory.cj","path":"fountain/src/bean/BeanFactory.cj","code_tokens":"public func exec < T , R > ( exec : ( T ) -> ? R ) : ? R {  factory . useFirst < T , R > ( checker , exec ) NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"SingletonBeanManager.cj","path":"fountain/src/bean/SingletonBeanManager.cj","code_tokens":"public func setCreator ( fn : ( ) -> Any ) : BeanManager {  super . setCreator ( fn ) NL if ( ! lazy ) {  get ( ) NL } NL this NL }","func_name":"setCreator","docstring":""}
{"repo":"fountain","file":"SingletonBeanManager.cj","path":"fountain/src/bean/SingletonBeanManager.cj","code_tokens":"public func destroy ( ) : Unit {  if ( let Some ( v ) = val ) {  destroy ( v ) NL } NL }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"SingletonBeanManager.cj","path":"fountain/src/bean/SingletonBeanManager.cj","code_tokens":"public func get ( ) : Any {  if ( let Some ( v ) = val ) {  v NL } else {  synchronized ( mutex ) {  if ( let Some ( v ) = val ) {  v NL } else {   let v = super . get ( ) NL val = v NL v NL } NL } NL } NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"SingletonFactoryBeanManager.cj","path":"fountain/src/bean/SingletonFactoryBeanManager.cj","code_tokens":"public func afterBean ( ) : BeanManager {  if ( ! lazy ) {  get ( ) NL } NL this NL }","func_name":"afterBean","docstring":""}
{"repo":"fountain","file":"SingletonFactoryBeanManager.cj","path":"fountain/src/bean/SingletonFactoryBeanManager.cj","code_tokens":"public func get ( ) : Any {  if ( let Some ( m ) = manager ) {  m . get ( ) NL } else {  synchronized ( mutex ) {  if ( let Some ( m ) = manager ) {  m . get ( ) NL } else {   let m = SingletonBeanManager ( ${name}_SingletonBean , lazy ) NL  let factory = super . getFactory ( ) NL m . setDestroier ( factory . beanDestroier ( ) ) NL m . setPostConstruct ( factory . beanPostConstructor ( ) ) NL m . setCreator ( factory . get ) NL manager = m NL this . factory = factory NL m . get ( ) NL } NL } NL } NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"SingletonFactoryBeanManager.cj","path":"fountain/src/bean/SingletonFactoryBeanManager.cj","code_tokens":"public func destroy ( ) {  if ( let Some ( m ) = manager ) {  m . destroy ( ) NL } NL if ( let Some ( f ) = factory ) {  super . destroyFactory ( f ) NL } NL }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"BeanCreation.cj","path":"fountain/src/bean/annotation/BeanCreation.cj","code_tokens":"func thrownFn ( token : Token ) {  BeanException ( Unrecognized Token(${token.kind}, ${token.value}) ) NL }","func_name":"thrownFn","docstring":""}
{"repo":"fountain","file":"BeanCreation.cj","path":"fountain/src/bean/annotation/BeanCreation.cj","code_tokens":"func generateTokens ( name : Token , scope : String , lazy : Bool , decl : FuncDecl , input : Tokens ) : Tokens {   let funcName = decl . getIdentifier ( ) NL  let beanName = if ( name . value ==  ) {  decl . getIdentifier ( ) NL } else {  name NL } NL  let isStatic = macro_fragments . isStatic ( decl ) NL  let beanManager = match ( scope ) { case singleton => quote ( SingletonBeanManager ( $name , $lazy ) ) NL case prototype => quote ( BeanManager ( $name ) ) NL case _ => throw BeanException ( unsupported scope ${scope} for BeanFactory ) NL } NL funcBeanHolder ++ NL  let holder = Token ( STRING_LITERAL , bEAn__rEgIstErEd_hOldEr___${funcBeanHolder}____ ) NL input + `nl` + if ( isStatic ) {  `static` NL } else {  `empty_tokens` NL } + quote ( \\n let $holder = App . beanFactory . register { \\n let manager = $beanManager \\n manager . setCreator { $ ( funcName ) ( ) } \\n } \\n ) NL }","func_name":"generateTokens","docstring":""}
{"repo":"fountain","file":"BeanCreation.cj","path":"fountain/src/bean/annotation/BeanCreation.cj","code_tokens":"func generateTokens ( name : Token , scope : String , lazy : Bool , decl : CompositDeclMethod , input : Tokens ) : Tokens {   let typeName = decl . getIdentifier ( ) NL  var generic = extractGeneric ( decl . getGeneric ( ) ) [ 0 ] NL if ( generic . size > 0 ) {  generic = quote ( < $generic > ) NL } NL  let isBean = hasType ( decl . getSuperTypes ( ) , quote ( Bean ) ) || hasType ( decl . getSuperTypes ( ) , quote ( bean . Bean ) ) NL  let isFactory = hasType ( decl . getSuperTypes ( ) , quote ( FactoryBean ) ) || hasType ( decl . getSuperTypes ( ) , quote ( bean . FactoryBean ) ) NL  let funcs = decl . getFuncs ( ) NL  let newFunc = parseFuncDecl ( quote ( public static func new ( ) : $typeName $generic ) ) NL  let publicNoParamInit = parseFuncDecl ( quote ( public init ( ) ) ) NL  let protectedNoParamInit = parseFuncDecl ( quote ( protected init ( ) ) ) NL  let privateNoParamInit = parseFuncDecl ( quote ( private init ( ) ) ) NL  let packageNoParamInit = parseFuncDecl ( quote ( init ( ) ) ) NL  var hasNew = false NL  var hasNonParamInit = false NL for ( f in funcs ) {  if ( isSameFuncDecl ( f , newFunc ) ) {  hasNew = true NL } else if ( isSameFuncDecl ( f , publicNoParamInit ) || isSameFuncDecl ( f , protectedNoParamInit ) || isSameFuncDecl ( f , privateNoParamInit ) || isSameFuncDecl ( f , packageNoParamInit ) ) {  hasNonParamInit = true NL } NL break NL } NL  let beanManager = match ( ( scope , isFactory ) ) { case ( singleton , false ) => quote ( SingletonBeanManager ( $name , $lazy ) ) NL case ( prototype , false ) => quote ( BeanManager ( $name ) ) NL case ( singleton , true ) => quote ( SingletonFactoryBeanManager ( $name , $lazy ) ) NL case ( prototype , true ) => quote ( FactoryBeanManager ( $name ) ) NL case _ => throw BeanException ( unsupported scope ${scope} for BeanFactory ) NL } NL if ( isBean ) {  input + quote ( \\n let _ = App . beanFactory . register { \\n let manager = $beanManager \\n manager . bean < $typeName $generic > ( ) \\n } \\n ) NL } else if ( hasNew ) {  input + quote ( \\n let _ = App . beanFactory . register { \\n let manager = $beanManager \\n manager . setCreator { $typeName $generic . new ( ) } \\n } \\n ) NL } else if ( hasNonParamInit ) {   var tokens = `empty_tokens` NL for ( i in 0 .. input . size - 1 ) {  tokens += input [ i ] NL } NL tokens + `nl` + `rcurl` + `nl` + quote ( \\n let _ = App . beanFactory . register { \\n let manager = $beanManager \\n manager . setCreator { $typeName $generic ( ) } \\n } \\n ) NL } else {  throw BeanException ( current type must be implemented fountain/bean.Bean or be with a public static func new(): Bean or be with a no param init, however it is without any one ) NL } NL }","func_name":"generateTokens","docstring":""}
{"repo":"fountain","file":"MessageConsumer.cj","path":"fountain/src/pubsub/MessageConsumer.cj","code_tokens":"func exec ( event : E , data : D ) : Unit","func_name":"exec","docstring":""}
{"repo":"fountain","file":"PubSub.cj","path":"fountain/src/pubsub/PubSub.cj","code_tokens":"public func sub ( consumer : MessageConsumer < E , D > , duplicateAction ! : DuplicateSubscriberAction = Override ) : Unit {   func dupmsg ( ) {  duplicate event ${consumer.event} subscriber, which name is ${consumer.name} NL } NL  let wrapped = match ( consumer ) { case x : WrappedMessageConsumer < E , D > => x NL case _ => WrappedMessageConsumer < E , D > ( consumer . event , consumer . name , consumer . once , consumer . exec ) NL } NL  let subers = subscribed . computeIfAbsent ( consumer . event ) { e => ConcurrentHashMap < String , WrappedMessageConsumer < E , D > > . create ( ) NL } NL match ( duplicateAction ) { case Override => subers ? . put ( consumer . name , wrapped ) NL ( ) NL case Discard => if ( let Some ( _ ) = subers ? . putIfNonExistent ( consumer . name , wrapped ) ) {  logger . warn ( dupmsg ( ) ) NL } NL case Thrown => if ( let Some ( _ ) = subers ? . putIfNonExistent ( consumer . name , wrapped ) ) {  throw DuplicateSubscriberException ( dupmsg ( ) ) NL } NL } NL }","func_name":"sub","docstring":""}
{"repo":"fountain","file":"PubSub.cj","path":"fountain/src/pubsub/PubSub.cj","code_tokens":"func dupmsg ( ) {  duplicate event ${consumer.event} subscriber, which name is ${consumer.name} NL }","func_name":"dupmsg","docstring":""}
{"repo":"fountain","file":"PubSub.cj","path":"fountain/src/pubsub/PubSub.cj","code_tokens":"public func unsub ( event : E , name : String ) : Unit {  subscribed . get ( event ) ? . remove ( name ) NL }","func_name":"unsub","docstring":""}
{"repo":"fountain","file":"PubSub.cj","path":"fountain/src/pubsub/PubSub.cj","code_tokens":"public func pub ( event : E , data : D ) : Unit {  if ( let Some ( subers ) = subscribed . get ( event ) ) {   let iterator = subers . iterator ( ) NL for ( entry in iterator ) {  try {   let consumer = entry [ 1 ] NL if ( consumer . executable ) {  consumer . exec ( event , data ) NL if ( consumer . once ) {  subers . remove ( entry [ 0 ] ) NL } NL } NL } catch ( e : Exception ) {  logger . error ( fountain/pubsub.PubSub.pub: ${event} ${entry[0]} , e ) NL } NL } NL } NL }","func_name":"pub","docstring":""}
{"repo":"fountain","file":"Observer.cj","path":"fountain/src/pubsub/Observer.cj","code_tokens":"public func register ( name : String , exec : ( D ) -> Unit ) : Unit {  sub ( 0 , name ) { e , d => exec ( d ) NL } NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"Observer.cj","path":"fountain/src/pubsub/Observer.cj","code_tokens":"public func trigger ( data : D ) : Unit {  pub ( 0 , data ) NL }","func_name":"trigger","docstring":""}
{"repo":"fountain","file":"Publisher.cj","path":"fountain/src/pubsub/Publisher.cj","code_tokens":"func pub ( event : E , data : D ) : Unit","func_name":"pub","docstring":""}
{"repo":"fountain","file":"Subscriber.cj","path":"fountain/src/pubsub/Subscriber.cj","code_tokens":"func sub ( event : E , name : String , exec : ( E , D ) -> Unit ) : Unit {  sub ( event , name , Override , exec ) NL }","func_name":"sub","docstring":"//默认的重复订阅行为是覆盖旧的"}
{"repo":"fountain","file":"Subscriber.cj","path":"fountain/src/pubsub/Subscriber.cj","code_tokens":"func sub ( event : E , name : String , duplicateAction : DuplicateSubscriberAction , exec : ( E , D ) -> Unit ) : Unit {  sub ( event , name , false , duplicateAction , exec ) NL }","func_name":"sub","docstring":"//默认的重复订阅行为是覆盖旧的"}
{"repo":"fountain","file":"Subscriber.cj","path":"fountain/src/pubsub/Subscriber.cj","code_tokens":"func sub ( event : E , name : String , once : Bool , duplicateAction : DuplicateSubscriberAction , exec : ( E , D ) -> Unit ) : Unit {  sub ( WrappedMessageConsumer < E , D > ( event , name , once , exec ) , duplicateAction : duplicateAction ) NL }","func_name":"sub","docstring":"//默认的重复订阅行为是覆盖旧的"}
{"repo":"fountain","file":"Subscriber.cj","path":"fountain/src/pubsub/Subscriber.cj","code_tokens":"func sub ( consumer : MessageConsumer < E , D > , duplicateAction ! : DuplicateSubscriberAction ) : Unit","func_name":"sub","docstring":"//默认的重复订阅行为是覆盖旧的"}
{"repo":"fountain","file":"Subscriber.cj","path":"fountain/src/pubsub/Subscriber.cj","code_tokens":"func unsub ( event : E , name : String ) : Unit","func_name":"unsub","docstring":""}
{"repo":"fountain","file":"WrappedMessageConsumer.cj","path":"fountain/src/pubsub/WrappedMessageConsumer.cj","code_tokens":"public func exec ( event : E , data : D ) : Unit {  exec_ ( event , data ) NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"Observerable.cj","path":"fountain/src/pubsub/Observerable.cj","code_tokens":"public func trigger ( data : D ) : Unit {  observer . trigger ( data ) NL }","func_name":"trigger","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"func distance_ ( first : ( Float64 , Float64 ) , second : ( Float64 , Float64 ) ) : Float64 {   let radLat1 = first [ 1 ] * RAD NL  let radLat2 = second [ 1 ] * RAD NL return abs ( 2.0 * EARTH_RADIUS * asin ( sqrt ( ( sin ( ( radLat1 - radLat2 ) / 2.0 ) ** 2.0 ) + cos ( radLat1 ) * cos ( radLat2 ) * ( sin ( ( first [ 0 ] - second [ 0 ] ) * RAD / 2.0 ) ** 2.0 ) ) ) ) NL }","func_name":"distance_","docstring":"//单位是米"}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"public func distance ( first : ( Float64 , Float64 ) , second : ( Float64 , Float64 ) ) : Float64 {  return distance_ ( first , second ) NL }","func_name":"distance","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"func hash_ ( lng : Float64 , lat : Float64 ) : UInt64 {   var minlng = - 180.0 NL  var maxlng = 180.0 NL  var minlat = - 90.0 NL  var maxlat = 90.0 NL  var hash : UInt64 = 0 NL  var i = 0 NL while ( i < 32 ) {   let midlng = ( minlng + maxlng ) / 2.0 NL  let midlat = ( minlat + maxlat ) / 2.0 NL if ( midlng < lng ) {  minlng = midlng NL hash = ( hash << 1 ) | 1 NL } else {  maxlng = midlng NL hash <<= 1 NL } NL if ( midlat < lat ) {  minlat = midlat NL hash = ( hash << 1 ) | 1 NL } else {  maxlat = midlat NL hash <<= 1 NL } NL i ++ NL } NL return hash NL }","func_name":"hash_","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"func hashHex_ ( lng : Float64 , lat : Float64 ) : String {  return hash_ ( lng , lat ) . hex NL }","func_name":"hashHex_","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"public func hash ( lng : Float64 , lat : Float64 ) : UInt64 {  return hash_ ( lng , lat ) NL }","func_name":"hash","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"public func hashHex ( lng : Float64 , lat : Float64 ) : String {  return hashHex_ ( lng , lat ) NL }","func_name":"hashHex","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"public func hash ( coordinate : ( Float64 , Float64 ) ) : UInt64 {  return hash ( coordinate [ 0 ] , coordinate [ 1 ] ) NL }","func_name":"hash","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"public func hashHex ( coordinate : ( Float64 , Float64 ) ) : String {  return hashHex ( coordinate [ 0 ] , coordinate [ 1 ] ) NL }","func_name":"hashHex","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"func dehash_ ( hash : UInt64 ) : ( Float64 , Float64 ) {   var bitmask : UInt64 = 1 << 63 NL  var lng : Float64 = 0.0 NL  var lat : Float64 = 0.0 NL  var minlng : Float64 = - 180.0 NL  var maxlng : Float64 = 180.0 NL  var minlat : Float64 = - 90.0 NL  var maxlat : Float64 = 90.0 NL while ( bitmask != 0 ) {   var h = hash & bitmask NL lng = ( minlng + maxlng ) / 2.0 NL if ( h > 0 ) {  minlng = lng NL } else {  maxlng = lng NL } NL bitmask >>= 1 NL h = hash & bitmask NL lat = ( minlat + maxlat ) / 2.0 NL if ( h > 0 ) {  minlat = lat NL } else {  maxlat = lat NL } NL bitmask >>= 1 NL } NL return ( lng , lat ) NL }","func_name":"dehash_","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"func dehash_ ( hash : String ) : ( Float64 , Float64 ) {  return dehash_ ( UInt64 . fromHex ( hash ) ) NL }","func_name":"dehash_","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"public func dehash ( hash : UInt64 ) : ( Float64 , Float64 ) {  return dehash_ ( hash ) NL }","func_name":"dehash","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"public func dehash ( hash : String ) : ( Float64 , Float64 ) {  return dehash_ ( hash ) NL }","func_name":"dehash","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"public func distance ( other : GEO ) {  return distance_ ( coordinate , other . coordinate ) NL }","func_name":"distance","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"static public func dehash ( hash : String ) : GEO {  return GEO ( dehash_ ( hash ) ) NL }","func_name":"dehash","docstring":""}
{"repo":"fountain","file":"GEO.cj","path":"fountain/src/geo/GEO.cj","code_tokens":"static public func dehash ( hash : UInt64 ) : GEO {  return GEO ( dehash_ ( hash ) ) NL }","func_name":"dehash","docstring":""}
{"repo":"fountain","file":"extract_first_token.cj","path":"fountain/src/macro_fragments/extract_first_token.cj","code_tokens":"public func extractFirstTokenToStringLiteral ( tokens : Tokens , default ! : Token = `empty_string` [ 0 ] ) : Token {  if ( tokens . size == 0 ) {  return default NL } NL match ( tokens [ 0 ] . kind ) { case IDENTIFIER => Token ( STRING_LITERAL , tokens [ 0 ] . value ) NL case STRING_LITERAL => tokens [ 0 ] NL case _ => throw MacroFragmentException ( first attr must be an IDENTIFIER or a STRING_LITERAL ) NL } NL }","func_name":"extractFirstTokenToStringLiteral","docstring":""}
{"repo":"fountain","file":"extract_first_token.cj","path":"fountain/src/macro_fragments/extract_first_token.cj","code_tokens":"public func extractFirstTokenToIdentifier ( tokens : Tokens ) : Token {  match ( tokens [ 0 ] . kind ) { case IDENTIFIER => tokens [ 0 ] NL case STRING_LITERAL => Token ( IDENTIFIER , tokens [ 0 ] . value ) NL case _ => throw MacroFragmentException ( first attr must be an IDENTIFIER or a STRING_LITERAL ) NL } NL }","func_name":"extractFirstTokenToIdentifier","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getModifiers ( ) : Tokens","func_name":"getModifiers","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getAnnotations ( ) : Array < Annotation >","func_name":"getAnnotations","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getKeyword ( ) : Token","func_name":"getKeyword","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getSuperTypes ( ) : Array < Type >","func_name":"getSuperTypes","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getIdentifier ( ) : Token","func_name":"getIdentifier","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getBody ( ) : Array < Decl >","func_name":"getBody","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getGeneric ( ) : ? Generic","func_name":"getGeneric","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getConstructors ( ) : Array < Decl >","func_name":"getConstructors","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getMembers ( ) : Array < Decl >","func_name":"getMembers","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getVars ( ) : Array < VarDecl >","func_name":"getVars","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getProps ( ) : Array < PropDecl >","func_name":"getProps","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getFuncs ( ) : Array < FuncDecl >","func_name":"getFuncs","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"public func getBody ( ) : Array < Decl > {   let constructors = this . getConstructors ( ) NL  let members = this . getMembers ( ) NL Array ( constructors . size + members . size ) { i => if ( i < constructors . size ) {  constructors [ i ] NL } else {  members [ i - constructors . size ] NL } NL } NL }","func_name":"getBody","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"private func extract < T > ( check : ( Decl ) -> Bool , converter : ( Decl ) -> T ) : Array < T > {   var decls = ArrayList < T > ( ) NL for ( d in this . getMembers ( ) where check ( d ) ) {  decls . append ( converter ( d ) ) NL } NL decls . toArray ( ) NL }","func_name":"extract","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"public func getVars ( ) : Array < VarDecl > {  extract < VarDecl > ( { d => d . isVarDecl ( ) NL } ) { d => d . asVarDecl ( ) NL } NL }","func_name":"getVars","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"public func getProps ( ) : Array < PropDecl > {  extract < PropDecl > ( { d => d . isPropDecl ( ) NL } ) { d => d . asPropDecl ( ) NL } NL }","func_name":"getProps","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"public func getFuncs ( ) : Array < FuncDecl > {  extract < FuncDecl > ( { d => d . isFuncDecl ( ) NL } ) { d => d . asFuncDecl ( ) NL } NL }","func_name":"getFuncs","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getConstructors ( ) : Array < Decl > {   let name = this . getIdentifier ( ) . value NL  let list = ArrayList < Decl > ( ) NL for ( decl in this . getBody ( ) where decl . isFuncDecl ( ) ) {   let fnDecl = decl . asFuncDecl ( ) NL  let identifier = fnDecl . getIdentifier ( ) NL match ( ( identifier . kind , identifier . value ) ) { case ( IDENTIFIER , init ) => list . append ( decl ) NL case ( IDENTIFIER , name ) => list . append ( decl ) NL case _ => continue NL } NL } NL list . toArray ( ) NL }","func_name":"getConstructors","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getMembers ( ) : Array < Decl > {   let name = this . getIdentifier ( ) . value NL  let list = ArrayList < Decl > ( ) NL for ( decl in this . getBody ( ) ) {  if ( decl . isFuncDecl ( ) ) {   let fnDecl = decl . asFuncDecl ( ) NL  let identifier = fnDecl . getIdentifier ( ) NL match ( ( identifier . kind , identifier . value ) ) { case ( IDENTIFIER , init ) => continue NL case ( IDENTIFIER , name ) => continue NL case _ => list . append ( decl ) NL } NL } else {  list . append ( decl ) NL } NL } NL list . toArray ( ) NL }","func_name":"getMembers","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getVars ( ) : Array < VarDecl > {   let name = this . getIdentifier ( ) . value NL  let list = ArrayList < VarDecl > ( ) NL for ( decl in this . getBody ( ) where decl . isVarDecl ( ) ) {  list . append ( decl . asVarDecl ( ) ) NL } NL list . toArray ( ) NL }","func_name":"getVars","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getProps ( ) : Array < PropDecl > {   let name = this . getIdentifier ( ) . value NL  let list = ArrayList < PropDecl > ( ) NL for ( decl in this . getBody ( ) where decl . isPropDecl ( ) ) {  list . append ( decl . asPropDecl ( ) ) NL } NL list . toArray ( ) NL }","func_name":"getProps","docstring":""}
{"repo":"fountain","file":"ExtendDecl.cj","path":"fountain/src/macro_fragments/ExtendDecl.cj","code_tokens":"func getFuncs ( ) : Array < FuncDecl > {   let name = this . getIdentifier ( ) . value NL  let list = ArrayList < FuncDecl > ( ) NL for ( decl in this . getBody ( ) where decl . isFuncDecl ( ) ) {   let fnDecl = decl . asFuncDecl ( ) NL  let identifier = fnDecl . getIdentifier ( ) NL match ( ( identifier . kind , identifier . value ) ) { case ( IDENTIFIER , init ) => continue NL case ( IDENTIFIER , name ) => continue NL case _ => list . append ( fnDecl ) NL } NL } NL list . toArray ( ) NL }","func_name":"getFuncs","docstring":""}
{"repo":"fountain","file":"extract_args.cj","path":"fountain/src/macro_fragments/extract_args.cj","code_tokens":"public func extractArgs ( params : FuncParamListMethod ) : Tokens {   let paramArray = params . getParams ( ) NL  var args = `empty_tokens` NL for ( i in 0 .. paramArray . size ) {  if ( i > 0 ) {  args += `comma` NL } NL args += paramArray [ i ] . getIdentifier ( ) NL } NL args NL }","func_name":"extractArgs","docstring":""}
{"repo":"fountain","file":"extract_bool.cj","path":"fountain/src/macro_fragments/extract_bool.cj","code_tokens":"public func extractBoolAttr ( tokens : Tokens , idx : Int64 , thrown : ( Token ) -> Exception ) {   let token = tokens [ idx ] NL match ( ( token . kind , token . value ) ) { case ( BOOL_LITERAL , true ) => true NL case ( BOOL_LITERAL , false ) => false NL case ( kind , val ) => throw thrown ( token ) NL } NL }","func_name":"extractBoolAttr","docstring":""}
{"repo":"fountain","file":"isSameFunc.cj","path":"fountain/src/macro_fragments/isSameFunc.cj","code_tokens":"public func isSameFuncDecl ( source : FuncDecl , target : FuncDecl ) : Bool {   let sourceModifiers = source . getModifiers ( ) NL  let targetModifiers = target . getModifiers ( ) NL  var same : Bool = if ( sourceModifiers . size != targetModifiers . size ) {  return false NL } else if ( sourceModifiers . size == 1 ) {  match ( ( sourceModifiers [ 0 ] . kind , targetModifiers [ 0 ] . kind ) ) { case ( PUBLIC , PUBLIC ) | ( PROTECTED , PROTECTED ) | ( PRIVATE , PRIVATE ) | ( STATIC , STATIC ) => true NL case _ => return false NL } NL } else if ( sourceModifiers . size == 2 ) {  match ( ( sourceModifiers [ 0 ] . kind , sourceModifiers [ 0 ] . kind , targetModifiers [ 1 ] . kind , targetModifiers [ 1 ] . kind ) ) { case ( PUBLIC , STATIC , PUBLIC , STATIC ) | ( STATIC , PUBLIC , STATIC , PUBLIC ) | ( PUBLIC , STATIC , STATIC , PUBLIC ) | ( STATIC , PUBLIC , PUBLIC , STATIC ) | ( PROTECTED , STATIC , PROTECTED , STATIC ) | ( STATIC , PROTECTED , STATIC , PROTECTED ) | ( PROTECTED , STATIC , STATIC , PROTECTED ) | ( STATIC , PROTECTED , PROTECTED , STATIC ) | ( PRIVATE , STATIC , PRIVATE , STATIC ) | ( STATIC , PRIVATE , STATIC , PRIVATE ) | ( PRIVATE , STATIC , STATIC , PRIVATE ) | ( STATIC , PRIVATE , PRIVATE , STATIC ) => true NL case _ => return false NL } NL } else {  return false NL } NL same = if ( ! same || source . getIdentifier ( ) . value != target . getIdentifier ( ) . value ) {  false NL } else {   let sourceParams = source . getParamList ( ) . getParams ( ) NL  let targetParams = target . getParamList ( ) . getParams ( ) NL if ( sourceParams . size != targetParams . size ) {  return false NL } NL for ( i in 0 .. sourceParams . size ) {   let sourceParam = sourceParams [ i ] NL  let targetParam = targetParams [ i ] NL if ( sourceParam . getIdentifier ( ) . value != targetParam . getIdentifier ( ) . value || sourceParam . isNamedParam ( ) != targetParam . isNamedParam ( ) || sourceParam . isMemberParam ( ) != targetParam . isMemberParam ( ) || sourceParam . getType ( ) . toTokens ( ) != targetParam . getType ( ) . toTokens ( ) ) {  return false NL } NL } NL same = match ( ( source . getType ( ) , target . getType ( ) ) ) { case ( Some ( st ) , Some ( tt ) ) => st . toTokens ( ) != tt . toTokens ( ) NL case ( None < Type > , None < Type > ) => true NL case _ => false NL } NL same NL } NL same NL }","func_name":"isSameFuncDecl","docstring":""}
{"repo":"fountain","file":"hasType.cj","path":"fountain/src/macro_fragments/hasType.cj","code_tokens":"public func hasType ( types : Array < Type > , typeTokens : Tokens ) : Bool {  if ( types . isEmpty ( ) ) {  return false NL } NL for ( t in types where t . toTokens ( ) == typeTokens ) {  return true NL } NL return false NL }","func_name":"hasType","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isStatic ( tokens : Tokens ) : Bool {  isStatic ( parseDecl ( tokens ) ) NL }","func_name":"isStatic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isStatic ( decl : Decl ) : Bool {  ( decl . isPropDecl ( ) && isStatic ( decl . asPropDecl ( ) ) ) || ( decl . isFuncDecl ( ) && isStatic ( decl . asFuncDecl ( ) ) ) || ( decl . isVarDecl ( ) && isStatic ( decl . asVarDecl ( ) ) ) NL }","func_name":"isStatic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isStatic ( decl : PropDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isStatic ( modifiers , 0 ) ) || ( size > 1 && isStatic ( modifiers , 1 ) ) || ( size > 2 && isStatic ( modifiers , 2 ) ) || ( size > 3 && isStatic ( modifiers , 3 ) ) || ( size > 4 && isStatic ( modifiers , 4 ) ) NL }","func_name":"isStatic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isStatic ( decl : FuncDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isStatic ( modifiers , 0 ) ) || ( size > 1 && isStatic ( modifiers , 1 ) ) || ( size > 2 && isStatic ( modifiers , 2 ) ) || ( size > 3 && isStatic ( modifiers , 3 ) ) || ( size > 4 && isStatic ( modifiers , 4 ) ) NL }","func_name":"isStatic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isStatic ( decl : VarDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isStatic ( modifiers , 0 ) ) || ( size > 1 && isStatic ( modifiers , 1 ) ) || ( size > 2 && isStatic ( modifiers , 2 ) ) || ( size > 3 && isStatic ( modifiers , 3 ) ) || ( size > 4 && isStatic ( modifiers , 4 ) ) NL }","func_name":"isStatic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"func isStatic ( modifiers : Tokens , index : Int64 ) : Bool {  isModifier ( modifiers , index , STATIC ) NL }","func_name":"isStatic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPublic ( tokens : Tokens ) : Bool {  isPublic ( parseDecl ( tokens ) ) NL }","func_name":"isPublic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPublic ( decl : Decl ) : Bool {  ( decl . isPropDecl ( ) && isPublic ( decl . asPropDecl ( ) ) ) || ( decl . isFuncDecl ( ) && isPublic ( decl . asFuncDecl ( ) ) ) || ( decl . isVarDecl ( ) && isPublic ( decl . asVarDecl ( ) ) ) NL }","func_name":"isPublic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPublic ( decl : PropDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isPublic ( modifiers , 0 ) ) || ( size > 1 && isPublic ( modifiers , 1 ) ) || ( size > 2 && isPublic ( modifiers , 2 ) ) || ( size > 3 && isPublic ( modifiers , 3 ) ) || ( size > 4 && isPublic ( modifiers , 4 ) ) NL }","func_name":"isPublic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPublic ( decl : FuncDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isPublic ( modifiers , 0 ) ) || ( size > 1 && isPublic ( modifiers , 1 ) ) || ( size > 2 && isPublic ( modifiers , 2 ) ) || ( size > 3 && isPublic ( modifiers , 3 ) ) || ( size > 4 && isPublic ( modifiers , 4 ) ) NL }","func_name":"isPublic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPublic ( decl : VarDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isPublic ( modifiers , 0 ) ) || ( size > 1 && isPublic ( modifiers , 1 ) ) || ( size > 2 && isPublic ( modifiers , 2 ) ) || ( size > 3 && isPublic ( modifiers , 3 ) ) || ( size > 4 && isPublic ( modifiers , 4 ) ) NL }","func_name":"isPublic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"func isPublic ( modifiers : Tokens , index : Int64 ) : Bool {  isModifier ( modifiers , index , PUBLIC ) NL }","func_name":"isPublic","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPrivate ( tokens : Tokens ) : Bool {  isPrivate ( parseDecl ( tokens ) ) NL }","func_name":"isPrivate","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPrivate ( decl : Decl ) : Bool {  ( decl . isPropDecl ( ) && isPrivate ( decl . asPropDecl ( ) ) ) || ( decl . isFuncDecl ( ) && isPrivate ( decl . asFuncDecl ( ) ) ) || ( decl . isVarDecl ( ) && isPrivate ( decl . asVarDecl ( ) ) ) NL }","func_name":"isPrivate","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPrivate ( decl : PropDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isPrivate ( modifiers , 0 ) ) || ( size > 1 && isPrivate ( modifiers , 1 ) ) || ( size > 2 && isPrivate ( modifiers , 2 ) ) || ( size > 3 && isPrivate ( modifiers , 3 ) ) || ( size > 4 && isPrivate ( modifiers , 4 ) ) NL }","func_name":"isPrivate","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPrivate ( decl : FuncDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isPrivate ( modifiers , 0 ) ) || ( size > 1 && isPrivate ( modifiers , 1 ) ) || ( size > 2 && isPrivate ( modifiers , 2 ) ) || ( size > 3 && isPrivate ( modifiers , 3 ) ) || ( size > 4 && isPrivate ( modifiers , 4 ) ) NL }","func_name":"isPrivate","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isPrivate ( decl : VarDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isPrivate ( modifiers , 0 ) ) || ( size > 1 && isPrivate ( modifiers , 1 ) ) || ( size > 2 && isPrivate ( modifiers , 2 ) ) || ( size > 3 && isPrivate ( modifiers , 3 ) ) || ( size > 4 && isPrivate ( modifiers , 4 ) ) NL }","func_name":"isPrivate","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"func isPrivate ( modifiers : Tokens , index : Int64 ) : Bool {  isModifier ( modifiers , index , PRIVATE ) NL }","func_name":"isPrivate","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isProtected ( tokens : Tokens ) : Bool {  isProtected ( parseDecl ( tokens ) ) NL }","func_name":"isProtected","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isProtected ( decl : Decl ) : Bool {  ( decl . isPropDecl ( ) && isProtected ( decl . asPropDecl ( ) ) ) || ( decl . isFuncDecl ( ) && isProtected ( decl . asFuncDecl ( ) ) ) || ( decl . isVarDecl ( ) && isProtected ( decl . asVarDecl ( ) ) ) NL }","func_name":"isProtected","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isProtected ( decl : PropDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isProtected ( modifiers , 0 ) ) || ( size > 1 && isProtected ( modifiers , 1 ) ) || ( size > 2 && isProtected ( modifiers , 2 ) ) || ( size > 3 && isProtected ( modifiers , 3 ) ) || ( size > 4 && isProtected ( modifiers , 4 ) ) NL }","func_name":"isProtected","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isProtected ( decl : FuncDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isProtected ( modifiers , 0 ) ) || ( size > 1 && isProtected ( modifiers , 1 ) ) || ( size > 2 && isProtected ( modifiers , 2 ) ) || ( size > 3 && isProtected ( modifiers , 3 ) ) || ( size > 4 && isProtected ( modifiers , 4 ) ) NL }","func_name":"isProtected","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isProtected ( decl : VarDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isProtected ( modifiers , 0 ) ) || ( size > 1 && isProtected ( modifiers , 1 ) ) || ( size > 2 && isProtected ( modifiers , 2 ) ) || ( size > 3 && isProtected ( modifiers , 3 ) ) || ( size > 4 && isProtected ( modifiers , 4 ) ) NL }","func_name":"isProtected","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"func isProtected ( modifiers : Tokens , index : Int64 ) : Bool {  isModifier ( modifiers , index , PROTECTED ) NL }","func_name":"isProtected","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isMut ( tokens : Tokens ) : Bool {  isMut ( parseDecl ( tokens ) ) NL }","func_name":"isMut","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isMut ( decl : Decl ) : Bool {  ( decl . isPropDecl ( ) && isMut ( decl . asPropDecl ( ) ) ) || ( decl . isFuncDecl ( ) && isMut ( decl . asFuncDecl ( ) ) ) || ( decl . isVarDecl ( ) && isMut ( decl . asVarDecl ( ) ) ) NL }","func_name":"isMut","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isMut ( decl : PropDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isMut ( modifiers , 0 ) ) || ( size > 1 && isMut ( modifiers , 1 ) ) || ( size > 2 && isMut ( modifiers , 2 ) ) || ( size > 3 && isMut ( modifiers , 3 ) ) || ( size > 4 && isMut ( modifiers , 4 ) ) NL }","func_name":"isMut","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isMut ( decl : FuncDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isMut ( modifiers , 0 ) ) || ( size > 1 && isMut ( modifiers , 1 ) ) || ( size > 2 && isMut ( modifiers , 2 ) ) || ( size > 3 && isMut ( modifiers , 3 ) ) || ( size > 4 && isMut ( modifiers , 4 ) ) NL }","func_name":"isMut","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isMut ( decl : VarDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isMut ( modifiers , 0 ) ) || ( size > 1 && isMut ( modifiers , 1 ) ) || ( size > 2 && isMut ( modifiers , 2 ) ) || ( size > 3 && isMut ( modifiers , 3 ) ) || ( size > 4 && isMut ( modifiers , 4 ) ) NL }","func_name":"isMut","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"func isMut ( modifiers : Tokens , index : Int64 ) : Bool {  isModifier ( modifiers , index , MUT ) NL }","func_name":"isMut","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOpen ( tokens : Tokens ) : Bool {  isOpen ( parseDecl ( tokens ) ) NL }","func_name":"isOpen","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOpen ( decl : Decl ) : Bool {  ( decl . isPropDecl ( ) && isOpen ( decl . asPropDecl ( ) ) ) || ( decl . isFuncDecl ( ) && isOpen ( decl . asFuncDecl ( ) ) ) || ( decl . isVarDecl ( ) && isOpen ( decl . asVarDecl ( ) ) ) NL }","func_name":"isOpen","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOpen ( decl : PropDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isOpen ( modifiers , 0 ) ) || ( size > 1 && isOpen ( modifiers , 1 ) ) || ( size > 2 && isOpen ( modifiers , 2 ) ) || ( size > 3 && isOpen ( modifiers , 3 ) ) || ( size > 4 && isOpen ( modifiers , 4 ) ) NL }","func_name":"isOpen","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOpen ( decl : FuncDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isOpen ( modifiers , 0 ) ) || ( size > 1 && isOpen ( modifiers , 1 ) ) || ( size > 2 && isOpen ( modifiers , 2 ) ) || ( size > 3 && isOpen ( modifiers , 3 ) ) || ( size > 4 && isOpen ( modifiers , 4 ) ) NL }","func_name":"isOpen","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOpen ( decl : VarDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isOpen ( modifiers , 0 ) ) || ( size > 1 && isOpen ( modifiers , 1 ) ) || ( size > 2 && isOpen ( modifiers , 2 ) ) || ( size > 3 && isOpen ( modifiers , 3 ) ) || ( size > 4 && isOpen ( modifiers , 4 ) ) NL }","func_name":"isOpen","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"func isOpen ( modifiers : Tokens , index : Int64 ) : Bool {  isModifier ( modifiers , index , OPEN ) NL }","func_name":"isOpen","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOverride ( tokens : Tokens ) : Bool {  isOverride ( parseDecl ( tokens ) ) NL }","func_name":"isOverride","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOverride ( decl : Decl ) : Bool {  ( decl . isPropDecl ( ) && isOverride ( decl . asPropDecl ( ) ) ) || ( decl . isFuncDecl ( ) && isOverride ( decl . asFuncDecl ( ) ) ) || ( decl . isVarDecl ( ) && isOverride ( decl . asVarDecl ( ) ) ) NL }","func_name":"isOverride","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOverride ( decl : PropDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isOverride ( modifiers , 0 ) ) || ( size > 1 && isOverride ( modifiers , 1 ) ) || ( size > 2 && isOverride ( modifiers , 2 ) ) || ( size > 3 && isOverride ( modifiers , 3 ) ) || ( size > 4 && isOverride ( modifiers , 4 ) ) NL }","func_name":"isOverride","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOverride ( decl : FuncDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isOverride ( modifiers , 0 ) ) || ( size > 1 && isOverride ( modifiers , 1 ) ) || ( size > 2 && isOverride ( modifiers , 2 ) ) || ( size > 3 && isOverride ( modifiers , 3 ) ) || ( size > 4 && isOverride ( modifiers , 4 ) ) NL }","func_name":"isOverride","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isOverride ( decl : VarDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isOverride ( modifiers , 0 ) ) || ( size > 1 && isOverride ( modifiers , 1 ) ) || ( size > 2 && isOverride ( modifiers , 2 ) ) || ( size > 3 && isOverride ( modifiers , 3 ) ) || ( size > 4 && isOverride ( modifiers , 4 ) ) NL }","func_name":"isOverride","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"func isOverride ( modifiers : Tokens , index : Int64 ) : Bool {  isModifier ( modifiers , index , OVERRIDE ) NL }","func_name":"isOverride","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isRedef ( tokens : Tokens ) : Bool {  isRedef ( parseDecl ( tokens ) ) NL }","func_name":"isRedef","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isRedef ( decl : Decl ) : Bool {  ( decl . isPropDecl ( ) && isRedef ( decl . asPropDecl ( ) ) ) || ( decl . isFuncDecl ( ) && isRedef ( decl . asFuncDecl ( ) ) ) || ( decl . isVarDecl ( ) && isRedef ( decl . asVarDecl ( ) ) ) NL }","func_name":"isRedef","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isRedef ( decl : PropDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isRedef ( modifiers , 0 ) ) || ( size > 1 && isRedef ( modifiers , 1 ) ) || ( size > 2 && isRedef ( modifiers , 2 ) ) || ( size > 3 && isRedef ( modifiers , 3 ) ) || ( size > 4 && isRedef ( modifiers , 4 ) ) NL }","func_name":"isRedef","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isRedef ( decl : FuncDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isRedef ( modifiers , 0 ) ) || ( size > 1 && isRedef ( modifiers , 1 ) ) || ( size > 2 && isRedef ( modifiers , 2 ) ) || ( size > 3 && isRedef ( modifiers , 3 ) ) || ( size > 4 && isRedef ( modifiers , 4 ) ) NL }","func_name":"isRedef","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"public func isRedef ( decl : VarDecl ) {   let modifiers = decl . getModifiers ( ) NL  let size = modifiers . size NL ( size > 0 && isRedef ( modifiers , 0 ) ) || ( size > 1 && isRedef ( modifiers , 1 ) ) || ( size > 2 && isRedef ( modifiers , 2 ) ) || ( size > 3 && isRedef ( modifiers , 3 ) ) || ( size > 4 && isRedef ( modifiers , 4 ) ) NL }","func_name":"isRedef","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"func isRedef ( modifiers : Tokens , index : Int64 ) : Bool {  isModifier ( modifiers , index , REDEF ) NL }","func_name":"isRedef","docstring":""}
{"repo":"fountain","file":"isModifier.cj","path":"fountain/src/macro_fragments/isModifier.cj","code_tokens":"func isModifier ( modifiers : Tokens , index : Int64 , kind : TokenKind ) : Bool {  match ( ( modifiers [ index ] . kind , kind ) ) { case ( PUBLIC , PUBLIC ) | ( PRIVATE , PRIVATE ) | ( PROTECTED , PROTECTED ) | ( STATIC , STATIC ) | ( MUT , MUT ) | ( OPEN , OPEN ) | ( OVERRIDE , OVERRIDE ) | ( REDEF , REDEF ) => true NL case _ => false NL } NL }","func_name":"isModifier","docstring":""}
{"repo":"fountain","file":"ExtendVarDecl.cj","path":"fountain/src/macro_fragments/ExtendVarDecl.cj","code_tokens":"func hasVar ( ) : Bool","func_name":"hasVar","docstring":""}
{"repo":"fountain","file":"ExtendVarDecl.cj","path":"fountain/src/macro_fragments/ExtendVarDecl.cj","code_tokens":"public func hasVar ( ) : Bool {  match ( this . getKeyword ( ) . kind ) { case VAR => true NL case _ => false NL } NL }","func_name":"hasVar","docstring":""}
{"repo":"fountain","file":"TokenEq.cj","path":"fountain/src/macro_fragments/TokenEq.cj","code_tokens":"operator func == ( other : T ) : Bool","func_name":"==","docstring":""}
{"repo":"fountain","file":"TokenEq.cj","path":"fountain/src/macro_fragments/TokenEq.cj","code_tokens":"operator func != ( other : T ) : Bool {  ! ( this == other ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"TokenEq.cj","path":"fountain/src/macro_fragments/TokenEq.cj","code_tokens":"public operator func == ( other : Tokens ) : Bool {  if ( this . size != other . size ) {  false NL } else {  for ( i in 0 .. this . size where this [ i ] != other [ i ] ) {  return false NL } NL } NL true NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"extract_generic.cj","path":"fountain/src/macro_fragments/extract_generic.cj","code_tokens":"public func extractGeneric ( generic : ? Generic ) : ( Tokens , Tokens ) {   var genericParams = `empty_tokens` NL  var genericConstraints = `empty_tokens` NL if ( let Some ( g ) = generic ) {   let gp = g . getTypeParameters ( ) NL  let gc = g . getConstraints ( ) NL for ( i in 0 .. gp . size ) {  if ( i == 0 ) {  genericParams += quote ( < ) NL } else if ( i > 0 ) {  genericParams += `comma` NL } NL genericParams += gp [ i ] NL } NL if ( genericParams . size > 0 ) {  genericParams += quote ( > ) NL } NL for ( i in 0 .. gc . size ) {  if ( i > 0 ) {  genericConstraints += `comma` NL } NL genericConstraints += gc [ i ] . toTokens ( ) NL } NL } NL ( genericParams , genericConstraints ) NL }","func_name":"extractGeneric","docstring":""}
{"repo":"fountain","file":"extract_generic.cj","path":"fountain/src/macro_fragments/extract_generic.cj","code_tokens":"public func extractGenericArgs ( tokens : Tokens ) : Array < Tokens > {   let tokenItr = tokens . iterator ( ) NL for ( token in tokenItr where token . value != < ) {  break NL } NL  let list = ArrayList < Tokens > ( ) NL  var arg = `empty_tokens` NL for ( token in tokenItr ) {  match ( token . value ) { case , => list . append ( arg ) NL arg = `empty_tokens` NL case > => list . append ( arg ) NL case _ => arg = arg + token NL } NL } NL list . toArray ( ) NL }","func_name":"extractGenericArgs","docstring":""}
{"repo":"fountain","file":"rfc.cj","path":"fountain/src/mvc/rfc.cj","code_tokens":"func rfc1123 ( t : Time ) {   let zone = t . zone ( ) NL  let offset = zone [ 1 ] / 3600 NL  let zoneId = if ( offset == 0 ) {  zone [ 0 ] NL } else if ( offset > 0 ) {  if ( offset < 1000 ) {  +0${offset} NL } else {  +${offset} NL } NL } else if ( offset > - 1000 ) {  -0${-offset} NL } else {  +${offset} NL } NL ${t.weekDay().toString().substring(0, 3)}, ${t.day()} ${t.month().toString().substring(0, 3)} ${t.year()} ${t.hour()}:${t.minute()}:${t.second()} ${zoneId} NL }","func_name":"rfc1123","docstring":""}
{"repo":"fountain","file":"rfc.cj","path":"fountain/src/mvc/rfc.cj","code_tokens":"func parseRfc1123 ( date : String ) : Time {   let zoneIdx = date . lastIndexOf (   ) . getOrThrow ( ) NL  let zoneId = date . substring ( zoneIdx + 1 , 2 ) NL  let location = if ( zoneId == GMT ) {  Location ( zoneId , 0 ) NL } else if ( zoneId . startsWith ( + ) ) {  Location (  , Duration . hour ( Int64 . parse ( zoneId . substring ( 1 ) ) ) ) NL } else {  Location (  , Duration . hour ( Int64 . parse ( zoneId ) ) ) NL } NL  var start = 5 NL  var end = date . indexOf (   , start ) . getOrThrow ( ) NL  let day = Int64 . parse ( date . substring ( start , end - start ) . trim ( ) ) NL start = end + 1 NL end = date . indexOf (   , start ) . getOrThrow ( ) NL  let month = match ( date . substring ( start , end - start ) . trim ( ) ) { case Jan => Month . January NL case Feb => Month . February NL case Mar => Month . March NL case Apr => Month . April NL case May => Month . May NL case Jun => Month . June NL case Jul => Month . July NL case Aug => Month . August NL case Sep => Month . September NL case Oct => Month . October NL case Nov => Month . November NL case Dec => Month . December NL case _ => throw UnreachableException ( ) NL } NL start = end + 1 NL end = date . indexOf (   , start ) . getOrThrow ( ) NL  let year = Int64 . parse ( date . substring ( start , end - start ) ) NL start = end + 1 NL end = date . indexOf ( : , start ) . getOrThrow ( ) NL  let hour = Int64 . parse ( date . substring ( start , end - start ) ) NL start = end + 1 NL end = date . indexOf ( : , start ) . getOrThrow ( ) NL  let minute = Int64 . parse ( date . substring ( start , end - start ) ) NL start = end + 1 NL end = date . indexOf (   , start ) . getOrThrow ( ) NL  let second = Int64 . parse ( date . substring ( start , end - start ) ) NL Time ( year , month , day , hour : hour , min : minute , sec : second , loc : location ) NL }","func_name":"parseRfc1123","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getBool ( name : String ) : Option < Bool >","func_name":"getBool","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getUInt8 ( name : String ) : Option < UInt8 >","func_name":"getUInt8","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getInt8 ( name : String ) : Option < Int8 >","func_name":"getInt8","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getInt32 ( name : String ) : Option < Int32 >","func_name":"getInt32","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getUInt32 ( name : String ) : Option < UInt32 >","func_name":"getUInt32","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getInt64 ( name : String ) : Option < Int64 >","func_name":"getInt64","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getUInt64 ( name : String ) : Option < UInt64 >","func_name":"getUInt64","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getFloat64 ( name : String ) : Option < Float64 >","func_name":"getFloat64","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getFloat32 ( name : String ) : Option < Float32 >","func_name":"getFloat32","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func getBytes ( name : String ) : ArrayList < Byte >","func_name":"getBytes","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"func add ( name : String , value : ToString ) : Unit","func_name":"add","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getBool ( name : String ) : Option < Bool > {  match ( get ( name ) ) { case Some ( v ) => Bool . parse ( v ) NL case _ => None < Bool > NL } NL }","func_name":"getBool","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getUInt8 ( name : String ) : Option < UInt8 > {  match ( get ( name ) ) { case Some ( v ) => UInt8 . parse ( v ) NL case _ => None < UInt8 > NL } NL }","func_name":"getUInt8","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getInt8 ( name : String ) : Option < Int8 > {  match ( get ( name ) ) { case Some ( v ) => Int8 . parse ( v ) NL case _ => None < Int8 > NL } NL }","func_name":"getInt8","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getInt32 ( name : String ) : Option < Int32 > {  match ( get ( name ) ) { case Some ( v ) => Int32 . parse ( v ) NL case _ => None < Int32 > NL } NL }","func_name":"getInt32","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getUInt32 ( name : String ) : Option < UInt32 > {  match ( get ( name ) ) { case Some ( v ) => UInt32 . parse ( v ) NL case _ => None < UInt32 > NL } NL }","func_name":"getUInt32","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getInt64 ( name : String ) : Option < Int64 > {  match ( get ( name ) ) { case Some ( v ) => Int64 . parse ( v ) NL case _ => None < Int64 > NL } NL }","func_name":"getInt64","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getUInt64 ( name : String ) : Option < UInt64 > {  match ( get ( name ) ) { case Some ( v ) => UInt64 . parse ( v ) NL case _ => None < UInt64 > NL } NL }","func_name":"getUInt64","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getFloat64 ( name : String ) : Option < Float64 > {  match ( get ( name ) ) { case Some ( v ) => Float64 . parse ( v ) NL case _ => None < Float64 > NL } NL }","func_name":"getFloat64","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getFloat32 ( name : String ) : Option < Float32 > {  match ( get ( name ) ) { case Some ( v ) => Float32 . parse ( v ) NL case _ => None < Float32 > NL } NL }","func_name":"getFloat32","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getBytes ( name : String ) : ArrayList < Byte > {   let list = ArrayList < Byte > ( ) NL for ( val in getAll ( name ) ) {  for ( n in val . split ( , ) ) {  list . append ( Byte . parse ( n . trim ( ) ) ) NL } NL } NL list NL }","func_name":"getBytes","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func add ( name : String , value : ToString ) : Unit {  add ( name , value . toString ( ) ) NL }","func_name":"add","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getBool ( name : String ) : Option < Bool > {  match ( get ( name ) ) { case Some ( v ) => Bool . parse ( v ) NL case _ => None < Bool > NL } NL }","func_name":"getBool","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getUInt8 ( name : String ) : Option < UInt8 > {  match ( get ( name ) ) { case Some ( v ) => UInt8 . parse ( v ) NL case _ => None < UInt8 > NL } NL }","func_name":"getUInt8","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getInt8 ( name : String ) : Option < Int8 > {  match ( get ( name ) ) { case Some ( v ) => Int8 . parse ( v ) NL case _ => None < Int8 > NL } NL }","func_name":"getInt8","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getInt32 ( name : String ) : Option < Int32 > {  match ( get ( name ) ) { case Some ( v ) => Int32 . parse ( v ) NL case _ => None < Int32 > NL } NL }","func_name":"getInt32","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getUInt32 ( name : String ) : Option < UInt32 > {  match ( get ( name ) ) { case Some ( v ) => UInt32 . parse ( v ) NL case _ => None < UInt32 > NL } NL }","func_name":"getUInt32","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getInt64 ( name : String ) : Option < Int64 > {  match ( get ( name ) ) { case Some ( v ) => Int64 . parse ( v ) NL case _ => None < Int64 > NL } NL }","func_name":"getInt64","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getUInt64 ( name : String ) : Option < UInt64 > {  match ( get ( name ) ) { case Some ( v ) => UInt64 . parse ( v ) NL case _ => None < UInt64 > NL } NL }","func_name":"getUInt64","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getFloat64 ( name : String ) : Option < Float64 > {  match ( get ( name ) ) { case Some ( v ) => Float64 . parse ( v ) NL case _ => None < Float64 > NL } NL }","func_name":"getFloat64","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getFloat32 ( name : String ) : Option < Float32 > {  match ( get ( name ) ) { case Some ( v ) => Float32 . parse ( v ) NL case _ => None < Float32 > NL } NL }","func_name":"getFloat32","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func getBytes ( name : String ) : ArrayList < Byte > {   let list = ArrayList < Byte > ( ) NL for ( val in getAll ( name ) ) {  for ( n in val . split ( , ) ) {  list . append ( Byte . parse ( n . trim ( ) ) ) NL } NL } NL list NL }","func_name":"getBytes","docstring":""}
{"repo":"fountain","file":"Extends.cj","path":"fountain/src/mvc/Extends.cj","code_tokens":"public func add ( name : String , value : ToString ) : Unit {  add ( name , value . toString ( ) ) NL }","func_name":"add","docstring":""}
{"repo":"fountain","file":"AccessControlState.cj","path":"fountain/src/mvc/AccessControlState.cj","code_tokens":"public func compare ( other : AccessControlState ) : Ordering {  match ( ( this , other ) ) { case ( IgnoreLogin , IgnoreLogin ) | ( IgnorePrivilege , IgnorePrivilege ) | ( IgnoreNone , IgnoreNone ) => EQ NL case ( IgnoreLogin , _ ) | ( IgnorePrivilege , IgnoreNone ) => LT NL case ( IgnoreNone , _ ) | ( IgnorePrivilege , IgnoreLogin ) => GT NL } NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"AuthController.cj","path":"fountain/src/mvc/AuthController.cj","code_tokens":"public func check ( ctx : HttpContext , state : AccessControlState , roles : Set < String > ) : AccessChecked {  match ( state ) { case IgnoreLogin => Allowed NL case IgnorePrivilege => checkAuthorized ( ctx ) NL case IgnoreNone =>  let checked = checkAuthorized ( ctx ) NL match ( checked ) { case Allowed => checkPrivilege ( ctx , roles ) NL case _ => checked NL } NL } NL }","func_name":"check","docstring":""}
{"repo":"fountain","file":"AuthController.cj","path":"fountain/src/mvc/AuthController.cj","code_tokens":"protected open func checkAuthorized ( ctx : HttpContext ) : AccessChecked","func_name":"checkAuthorized","docstring":""}
{"repo":"fountain","file":"AuthController.cj","path":"fountain/src/mvc/AuthController.cj","code_tokens":"protected func checkPrivilege ( ctx : HttpContext , roles : Set < String > ) : AccessChecked","func_name":"checkPrivilege","docstring":""}
{"repo":"fountain","file":"AuthController.cj","path":"fountain/src/mvc/AuthController.cj","code_tokens":"public func auth ( ctx : HttpContext ) : Unit {   let basicAuth = ctx . basicAuth NL match ( basicAuth ) { case Some ( ba ) => match ( checkAuth ( ba . username , ba . password ) ) { case ( Some ( a ) , _ ) => ctx . authorization = a NL Allowed NL case ( _ , msg ) => Forbidden ( msg ) NL } NL case _ => throw MVCException ( there should be with a request header as 'Authorization: Basic username:password' ) NL } NL }","func_name":"auth","docstring":""}
{"repo":"fountain","file":"AuthController.cj","path":"fountain/src/mvc/AuthController.cj","code_tokens":"protected func checkAuth ( username : String , password : String ) : ( Option < String > , ToString )","func_name":"checkAuth","docstring":""}
{"repo":"fountain","file":"PrivilegeRoles.cj","path":"fountain/src/mvc/PrivilegeRoles.cj","code_tokens":"func addRoles ( roles : Iterable < String > ) {  for ( r in roles ) {  this . roles_ . put ( r ) NL } NL }","func_name":"addRoles","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"static func extractBoundary ( contentType : String ) {  contentType . substring ( multipart/form-data; boundary= . size ) NL }","func_name":"extractBoundary","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"private func createDiskFile ( dir : String , filename : String ) : MultiPartFile < File > {   let path = ${dir}/${filename} NL MultiPartFile < File > ( File ( path , Create ( true ) ) ) NL }","func_name":"createDiskFile","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"private func createMemoryFile ( ) : MultiPartFile < ByteArrayStream > {  MultiPartFile < ByteArrayStream > ( ByteArrayStream ( ) ) NL }","func_name":"createMemoryFile","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func parse ( ) : Unit {   let path = if ( ! inMemory ) {   let part = ${Time.now()}${boundary} NL  let path = if ( uploadDir . endsWith ( / ) ) {  ${uploadDir}${part} NL } else {  ${uploadDir}/${part} NL } NL Directory . createTemp ( path ) NL path NL } else {   NL } NL doParse ( path ) NL }","func_name":"parse","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"private func extractHeaderFromBody ( indexer : BodyIndexer ) {   let headerName = findSlice ( indexer , headerDelim ) NL  let headerValue = findSlice ( indexer , lineDelim ) NL ( headerName , headerValue ) NL }","func_name":"extractHeaderFromBody","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"private func doParse ( path : String ) : Unit {   let indexer = BodyIndexer ( bodyStream , bodyStart , bodyDelimiter , bodyEnd ) NL if ( ! indexer . checkStart ( ) ) {  throw HttpException ( current request body does not match multipart/form-data, it does not starts with the boundary ) NL } NL while ( indexer . notEnd ( ) ) {   let header = extractHeaderFromBody ( indexer ) NL  let contentDisposition = ContentDisposition . parse ( header [ 1 ] ) NL if ( contentDisposition . getFilename ( ) . isEmpty ( ) ) {  indexer . indexOf ( lineDelim , rotate : true ) NL  var partEnd = - 1 NL  let list = ArrayList < Byte > ( ) NL do {  partEnd = indexer . indexOf ( bodyDelimiter ) NL indexer . slice ( list ) NL } while ( partEnd < 0 ) NL  let value = if ( list . isEmpty ( ) ) {   NL } else {  URL . parse ( String . fromUtf8 ( list . toArray ( ) ) ) . path NL } NL  let builder = StringBuilder ( ) NL  var i = 0 NL while ( i < value . size ) {   var ch = value [ i ] NL if ( ch == & ) {  i ++ NL ch = value [ i ] NL if ( ch == # ) {  i ++ NL  let chendopt = value . indexOf ( ; , i ) NL if ( let Some ( chend ) = chendopt ) {   let chstr = value . substring ( i , chend - i ) NL ch = Char ( UInt32 . parse ( chstr ) ) NL builder . append ( ch ) NL i = chend + 1 NL } else {  builder . append ( value . substring ( i ) ) NL break NL } NL } else {  builder . append ( ch ) NL } NL } else {  builder . append ( ch ) NL i ++ NL } NL } NL ctx . getBodyForm ( ) . add ( contentDisposition . getName ( ) , builder . toString ( ) ) NL } else {   let filename = contentDisposition . getFilename ( ) NL ctx . getBodyForm ( ) . add ( contentDisposition . getName ( ) , filename ) NL  let header = extractHeaderFromBody ( indexer ) NL  let tuple : ( OutputStream , Any ) = if ( inMemory ) {   let stream = ByteArrayStream ( ) NL  let file = MultiPartFile < ByteArrayStream > ( stream ) NL ( stream , file ) NL } else {   let stream = File ( path , OpenOption . Create ( true ) ) NL  let file = MultiPartFile < File > ( stream ) NL ( stream , file ) NL } NL ctx . addExtra ( filename , tuple [ 1 ] ) NL  let stream = tuple [ 0 ] NL  var partEnd = - 1 NL do {   let partEnd = indexer . indexOf ( bodyDelimiter ) NL indexer . output ( stream ) NL } while ( partEnd < 0 ) NL } NL } NL }","func_name":"doParse","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"private func findSlice ( indexer : BodyIndexer , delim : Array < Byte > ) : String {   let found = indexer . indexOf ( delim ) NL if ( found > 0 ) {   let slice = indexer . slice ( ) NL String . fromUtf8 ( slice ) . trim ( ) NL } else {  throw HttpException ( current request body does not match multipart/form-data ) NL } NL }","func_name":"findSlice","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"private operator func [ ] ( index : Int64 , goahead : Bool ) : Option < Byte > {  if ( firstOffset < firstLength ) {  if ( goahead ) {  firstOffset ++ NL } NL first [ index ] NL } else if ( secondOffset < secondLength ) {  if ( goahead ) {  secondOffset ++ NL } NL second [ index - firstLength ] NL } else {  None NL } NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func output ( stream : OutputStream ) : Unit {   func innerOutput ( secondLen : Int64 ) {  stream . write ( first . slice ( sliceFrom , firstLength - sliceFrom ) ) NL stream . write ( second . slice ( 0 , secondLen ) ) NL } NL if ( foundOffset < 0 ) {  innerOutput ( secondLength ) NL } else if ( foundOffset <= firstLength ) {  stream . write ( first . slice ( sliceFrom , foundOffset - sliceFrom ) ) NL firstOffset ++ NL } else if ( foundOffset > firstLength ) {  innerOutput ( foundOffset - firstLength ) NL if ( secondOffset < secondLength ) {  secondOffset ++ NL } NL } else if ( foundOffset > 0 ) {  stream . write ( first . slice ( sliceFrom , foundOffset - sliceFrom ) ) NL } NL rotateIfNecessary ( ) NL }","func_name":"output","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func innerOutput ( secondLen : Int64 ) {  stream . write ( first . slice ( sliceFrom , firstLength - sliceFrom ) ) NL stream . write ( second . slice ( 0 , secondLen ) ) NL }","func_name":"innerOutput","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func slice ( ) : Array < Byte > {   func innerSlice ( secondLen : Int64 ) {   let list = ArrayList < Byte > ( ) NL list . appendAll ( first . slice ( sliceFrom , firstLength - sliceFrom ) ) NL list . appendAll ( second . slice ( 0 , secondLen ) ) NL list . toArray ( ) NL } NL  var slc : Array < Byte > = [ ] NL if ( foundOffset < 0 ) {  slc = innerSlice ( secondLength ) NL } else if ( foundOffset <= firstLength ) {  slc = first . slice ( sliceFrom , foundOffset - sliceFrom ) NL firstOffset ++ NL } else if ( foundOffset > firstLength ) {  slc = innerSlice ( foundOffset - firstLength ) NL if ( secondOffset < secondLength ) {  secondOffset ++ NL } NL } else if ( foundOffset > 0 ) {  slc = first . slice ( sliceFrom , foundOffset - sliceFrom ) NL } NL rotateIfNecessary ( ) NL slc NL }","func_name":"slice","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func innerSlice ( secondLen : Int64 ) {   let list = ArrayList < Byte > ( ) NL list . appendAll ( first . slice ( sliceFrom , firstLength - sliceFrom ) ) NL list . appendAll ( second . slice ( 0 , secondLen ) ) NL list . toArray ( ) NL }","func_name":"innerSlice","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func slice ( list : ArrayList < Byte > ) : Unit {   func innerSlice ( secondLen : Int64 ) {   let list = ArrayList < Byte > ( ) NL list . appendAll ( first . slice ( sliceFrom , firstLength - sliceFrom ) ) NL list . appendAll ( second . slice ( 0 , secondLen ) ) NL } NL  var slc : Array < Byte > = [ ] NL if ( foundOffset < 0 ) {  innerSlice ( secondLength ) NL } else if ( foundOffset < firstLength ) {  list . appendAll ( first . slice ( sliceFrom , foundOffset - sliceFrom ) ) NL firstOffset ++ NL } else {  innerSlice ( foundOffset - firstLength ) NL } NL rotateIfNecessary ( ) NL }","func_name":"slice","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func innerSlice ( secondLen : Int64 ) {   let list = ArrayList < Byte > ( ) NL list . appendAll ( first . slice ( sliceFrom , firstLength - sliceFrom ) ) NL list . appendAll ( second . slice ( 0 , secondLen ) ) NL }","func_name":"innerSlice","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"private func rotateIfNecessary ( ) : Unit {   func innerRotate ( secOff : Int64 ) {  first = second . slice ( secOff , secondLength - secOff ) NL firstOffset = 0 NL firstLength = first . size NL  let tuple = createBuffer ( ) NL second = tuple [ 0 ] NL secondLength = tuple [ 1 ] NL secondOffset = 0 NL } NL if ( foundOffset < 0 ) {   var tuple = createBuffer ( ) NL first = tuple [ 0 ] NL firstOffset = 0 NL firstLength = tuple [ 1 ] NL tuple = createBuffer ( ) NL secondOffset = 0 NL secondLength = tuple [ 1 ] NL sliceFrom = 0 NL } else if ( size - foundOffset < bodyDelimiter . size ) {  innerRotate ( foundOffset - firstLength ) NL sliceFrom = 0 NL } else if ( firstOffset > = firstLength ) {  if ( secondLength == 0 ) {  first = EmptyArray < Byte > . instance NL second = EmptyArray < Byte > . instance NL firstOffset = 0 NL firstLength = 0 NL secondOffset = 0 NL secondLength = 0 NL } else {  innerRotate ( secondOffset ) NL } NL foundOffset = 0 NL sliceFrom = 0 NL } else if ( firstLength - firstOffset <= bodyDelimiter . size ) {  first = first . slice ( firstOffset , firstLength - firstOffset ) NL foundOffset = foundOffset - firstOffset NL firstOffset = 0 NL firstLength = first . size NL sliceFrom = 0 NL } else {  sliceFrom = foundOffset + bodyDelimiter . size NL } NL }","func_name":"rotateIfNecessary","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func innerRotate ( secOff : Int64 ) {  first = second . slice ( secOff , secondLength - secOff ) NL firstOffset = 0 NL firstLength = first . size NL  let tuple = createBuffer ( ) NL second = tuple [ 0 ] NL secondLength = tuple [ 1 ] NL secondOffset = 0 NL }","func_name":"innerRotate","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"private func createBuffer ( ) {   let bodyLen = body . length NL  let buffer = if ( bodyLen == 0 ) {  EmptyArray < Byte > . instance NL } else if ( bodyLen < 0 || bodyLen < 4096 ) {  Array < Byte > ( bodyLen , item : 0 ) NL } else {  Array < Byte > ( 2048 , item : 0 ) NL } NL if ( buffer . size > 0 ) {   let len = body . read ( buffer ) NL ( buffer , len ) NL } else {  ( buffer , 0 ) NL } NL }","func_name":"createBuffer","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func checkStart ( ) : Bool {   let start = indexOf ( bodyStart . size , bodyStart , bodyStart . size , 0 ) == 0 NL rotateIfNecessary ( ) NL start NL }","func_name":"checkStart","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func notEnd ( ) : Bool {   let endMark = UInt8 ( UInt32 ( - ) ) NL ! ( this [ 0 , false ] == endMark && this [ 1 , false ] == endMark ) NL }","func_name":"notEnd","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"func indexOf ( sub : Array < Byte > , rotate ! : Bool = false ) : Int64 {  try {  indexOf ( this . size , sub , sub . size , sliceFrom ) NL } finally {  if ( rotate ) {  rotateIfNecessary ( ) NL } NL } NL }","func_name":"indexOf","docstring":""}
{"repo":"fountain","file":"MultiPartFormDataParser.cj","path":"fountain/src/mvc/MultiPartFormDataParser.cj","code_tokens":"private func indexOf ( valueCount : Int64 , sub : Array < Byte > , subCount : Int64 , fromIndex : Int64 ) : Int64 {  if ( valueCount == 0 || valueCount == fromIndex ) {  foundOffset = - 1 NL return foundOffset NL } NL  let first = sub [ 0 ] NL  let max = valueCount - fromIndex - subCount NL  var i = fromIndex NL while ( i <= max ) {  if ( this [ i , true ] . getOrThrow ( ) != first ) {  i ++ NL while ( i <= max && this [ i , true ] . getOrThrow ( ) != first ) {  } NL } NL if ( i <= max ) {   var j = i + 1 NL  let end = j + subCount - 1 NL  var k = 1 NL while ( j < end && this [ j , true ] . getOrThrow ( ) == sub [ k ] ) {  j ++ NL k ++ NL } NL if ( j == end ) {  foundOffset = i NL return foundOffset NL } NL } else {   var j = i + 1 NL  let end = valueCount NL  var k = 1 NL while ( j < end && this [ j , true ] . getOrThrow ( ) == sub [ i ] ) {  j ++ NL k ++ NL } NL if ( j == end ) {  foundOffset = i NL return - 1 NL } NL } NL i ++ NL } NL foundOffset = - 1 NL return foundOffset NL }","func_name":"indexOf","docstring":""}
{"repo":"fountain","file":"HttpRequestHandler.cj","path":"fountain/src/mvc/HttpRequestHandler.cj","code_tokens":"func setResponseOutput ( output : ( Any , HttpContext ) -> Unit ) {  responseOutput = output NL }","func_name":"setResponseOutput","docstring":""}
{"repo":"fountain","file":"HttpRequestHandler.cj","path":"fountain/src/mvc/HttpRequestHandler.cj","code_tokens":"protected func execute ( context : HttpContext ) : Any {  executor ( context ) NL }","func_name":"execute","docstring":""}
{"repo":"fountain","file":"HttpRequestHandler.cj","path":"fountain/src/mvc/HttpRequestHandler.cj","code_tokens":"static public func builder ( path ! : String , executor ! : ( HttpContext ) -> Any ) {  HttpRequestHandlerBuilder ( path : path , executor : executor ) NL }","func_name":"builder","docstring":""}
{"repo":"fountain","file":"HttpRequestHandler.cj","path":"fountain/src/mvc/HttpRequestHandler.cj","code_tokens":"protected open func canRead ( ctx : HttpContext ) {  if ( consumesRegex . matches ( ctx . contentType ) . none ) {  throw MVCException ( status : HttpStatus . UNSUPPORTED_MEDIA_TYPE ) NL } NL }","func_name":"canRead","docstring":""}
{"repo":"fountain","file":"HttpRequestHandler.cj","path":"fountain/src/mvc/HttpRequestHandler.cj","code_tokens":"protected open func canWrite ( ctx : HttpContext ) {  }","func_name":"canWrite","docstring":""}
{"repo":"fountain","file":"HttpRequestHandler.cj","path":"fountain/src/mvc/HttpRequestHandler.cj","code_tokens":"protected open func parseBody ( ctx : HttpContext ) : Unit {   let contentType = ctx . contentType NL try {  if ( formurlRegex . matches ( contentType ) . none ) {   let body = ctx . request . readToEnd ( ) NL  let url = ?${String.fromUtf8(body)} NL ctx . body = URL . parse ( url ) . query ( ) NL } else if ( jsonRegex . matches ( contentType ) . none ) {   let bytes = ctx . request . readToEnd ( ) NL  let json = String . fromUtf8 ( bytes ) NL ctx . body = JsonValue . fromStr ( json ) NL } else {  throw MVCException ( status : HttpStatus . UNSUPPORTED_MEDIA_TYPE ) NL } NL } catch ( e : Exception ) {  throw MVCException ( request body requires ${consumes}, current request Content-Type is ${contentType}, but the body does not match , e , status : HttpStatus . UNSUPPORTED_MEDIA_TYPE ) NL } NL }","func_name":"parseBody","docstring":""}
{"repo":"fountain","file":"CommonHttpMultiPartRequestHandler.cj","path":"fountain/src/mvc/CommonHttpMultiPartRequestHandler.cj","code_tokens":"protected func canRead ( ctx : HttpContext ) : Unit {  if ( let Some ( fn ) = readable ) {  fn ( ctx ) NL } else {  super . canRead ( ctx ) NL } NL }","func_name":"canRead","docstring":""}
{"repo":"fountain","file":"CommonHttpMultiPartRequestHandler.cj","path":"fountain/src/mvc/CommonHttpMultiPartRequestHandler.cj","code_tokens":"protected func canWrite ( ctx : HttpContext ) : Unit {  if ( let Some ( fn ) = writable ) {  fn ( ctx ) NL } else {  super . canWrite ( ctx ) NL } NL }","func_name":"canWrite","docstring":""}
{"repo":"fountain","file":"CommonHttpMultiPartRequestHandler.cj","path":"fountain/src/mvc/CommonHttpMultiPartRequestHandler.cj","code_tokens":"protected func parseBody ( ctx : HttpContext ) : Unit {  if ( let Some ( fn ) = bodyParser ) {  fn ( ctx ) NL } else {  super . parseBody ( ctx ) NL } NL }","func_name":"parseBody","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func setMethod ( method : RequestMethod ) : HttpRequestHandlerBuilder {  this . method = method NL this NL }","func_name":"setMethod","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func setAccessControlState ( state : AccessControlState ) : HttpRequestHandlerBuilder {  this . accessControlState = state NL this NL }","func_name":"setAccessControlState","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func setConsumes ( consumes : Collection < String > ) : HttpRequestHandlerBuilder {  this . consumes = consumes . toArray ( ) NL this NL }","func_name":"setConsumes","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func setProduces ( produces : String ) : HttpRequestHandlerBuilder {  this . produces = produces NL this NL }","func_name":"setProduces","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func setResponseOutput ( output : ( Any , HttpContext ) -> Unit ) : HttpRequestHandlerBuilder {  this . responseOutput = output NL this NL }","func_name":"setResponseOutput","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func setUploadDir ( dir : String ) : HttpRequestHandlerBuilder {  this . uploadDir = dir NL this . uploader = true NL this NL }","func_name":"setUploadDir","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func setUploadTmpFile ( tmp : Bool ) : HttpRequestHandlerBuilder {  this . uploadTmpFile = tmp NL this . uploader = true NL this NL }","func_name":"setUploadTmpFile","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func setUploader ( ) : HttpRequestHandlerBuilder {  this . uploader = true NL this NL }","func_name":"setUploader","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func setUploadInMemory ( inMemory : Bool ) : HttpRequestHandlerBuilder {  this . uploadInMemory = inMemory NL this . uploader = true NL this NL }","func_name":"setUploadInMemory","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"public func build ( ) : HttpRequestHandler {  if ( uploader ) {  buildCommon ( ) NL } else {  buildUpload ( ) NL } NL }","func_name":"build","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"private func buildCommon ( ) : HttpRequestHandler {  HttpRequestHandler ( path : path , method : method , accessControlState : accessControlState , consumes : consumes , produces : produces , responseOutput : responseOutput , executor : executor ) NL }","func_name":"buildCommon","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerBuilder.cj","path":"fountain/src/mvc/HttpRequestHandlerBuilder.cj","code_tokens":"private func buildUpload ( ) : HttpRequestHandler {  HttpMultiPartRequestHandler ( path : path , method : method , accessControlState : accessControlState , produces : produces , responseOutput : responseOutput , executor : executor , uploadDir : uploadDir , inMemory : uploadInMemory ) NL }","func_name":"buildUpload","docstring":""}
{"repo":"fountain","file":"LogGenerator.cj","path":"fountain/src/mvc/LogGenerator.cj","code_tokens":"func generate ( ctx : HttpContext , result : Any ) : String {   let resultTxt = ( result as ToString ??  ) . toString ( ) NL ${ctx.request.method} ${ctx.path}?${ctx.queryString}|${resultTxt};${Time.now() - startTime} NL }","func_name":"generate","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"func defaultPrivilegeInitializer ( ) : ( ( RequestMethod , String , Iterable < String > ) -> Unit ) -> Unit {  { fn => ( ) NL } NL }","func_name":"defaultPrivilegeInitializer","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"func defaultAccessChecker ( ) : ( HttpContext , AccessControlState , Set < String > ) -> AccessChecked {  { ctx : HttpContext , state : AccessControlState , roles : Set < String > => Allowed NL } NL }","func_name":"defaultAccessChecker","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"static public func byConfig ( ) {   let cfg = App . config NL HttpLauncher ( port : UInt16 ( cfg . getIntConf ( HTTP_SERVER_PORT , Int64 ( DEFAULT_PORT ) ) ) , readHeaderTimeout : Duration . second ( cfg . getIntConf ( HTTP_SERVER_READ_HEADER_TIMEOUT , DEFAULT_TIMEOUT_DURATION . seconds ( ) ) ) , readTimeout : Duration . second ( cfg . getIntConf ( HTTP_SERVER_READ_TIMEOUT , DEFAULT_TIMEOUT_DURATION . seconds ( ) ) ) , writeTimeout : Duration . second ( cfg . getIntConf ( HTTP_SERVER_WRITE_TIMEOUT , DEFAULT_TIMEOUT_DURATION . seconds ( ) ) ) , httpKeepAliveTimeout : Duration . second ( cfg . getIntConf ( HTTP_SERVER_KEEPALIVE_TIMEOUT , DEFAULT_TIMEOUT_DURATION . seconds ( ) ) ) , maxHeaderSize : cfg . getIntConf ( HTTP_SERVER_MAX_HEADER_SIZE , DEFAULT_MAX_HEADER_SIZE ) , maxBodySize : cfg . getIntConf ( HTTP_SERVER_MAX_HEADER_SIZE , DEFAULT_MAX_BODY_SIZE ) , timeout : Duration . second ( cfg . getIntConf ( HTTP_SERVER_TIMEOUT , DEFAULT_TIMEOUT_DURATION . seconds ( ) ) ) , timeoutMsg : cfg . getConf ( HTTP_SERVER_TIMEOUT_MSG , DEFAULT_TIMEOUT_MSG ) ) NL }","func_name":"byConfig","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setPort ( port : UInt16 ) : HttpLauncher {  this . port = port NL this NL }","func_name":"setPort","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setReadHeaderTimeout ( readHeaderTimeout : Duration ) : HttpLauncher {  this . readHeaderTimeout = readHeaderTimeout NL this NL }","func_name":"setReadHeaderTimeout","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setReadTimeout ( readTimeout : Duration ) : HttpLauncher {  this . readTimeout = readTimeout NL this NL }","func_name":"setReadTimeout","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setHttpKeepAliveTimeout ( httpKeepAliveTimeout : Duration ) : HttpLauncher {  this . httpKeepAliveTimeout = httpKeepAliveTimeout NL this NL }","func_name":"setHttpKeepAliveTimeout","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setTlsConfig ( tlsConfig : TlsServerConfig ) : HttpLauncher {  this . tlsConfig = tlsConfig NL this NL }","func_name":"setTlsConfig","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setResponseOutput ( responseOutput : ( Any , HttpContext ) -> Unit ) : HttpLauncher {  this . responseOutput = responseOutput NL this NL }","func_name":"setResponseOutput","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setMaxHeaderSize ( maxHeaderSize : Int64 ) : HttpLauncher {  this . maxHeaderSize = maxHeaderSize NL this NL }","func_name":"setMaxHeaderSize","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setMaxBodySize ( maxBodySize : Int64 ) : HttpLauncher {  this . maxBodySize = maxBodySize NL this NL }","func_name":"setMaxBodySize","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setPrivilegeInitializer ( initializer : ( ( RequestMethod , String , Iterable < String > ) -> Unit ) -> Unit ) : HttpLauncher {  this . privilegeInitializer = initializer NL this NL }","func_name":"setPrivilegeInitializer","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setAccessChecker ( accessChecker : ( HttpContext , AccessControlState , Set < String > ) -> AccessChecked ) : HttpLauncher {  this . accessChecker = accessChecker NL this NL }","func_name":"setAccessChecker","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setLogGenerator ( logGenerator : LogGenerator ) : HttpLauncher {  this . logGenerator = logGenerator NL this NL }","func_name":"setLogGenerator","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setTimeout ( timeout : Duration ) : HttpLauncher {  this . timeout = timeout NL this NL }","func_name":"setTimeout","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func setTimeoutMsg ( msg : String ) : HttpLauncher {  this . timeoutMsg = msg NL this NL }","func_name":"setTimeoutMsg","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func install ( path ! : String , method ! : RequestMethod , accessControlState ! : AccessControlState = IgnoreNone , consumes ! : Array < String > = [ application/x-www-formurlencoded ] , produces ! : String = application/json , executor ! : ( HttpContext ) -> Any , responseOutput ! : Option < ( Any , HttpContext ) -> Unit > = None < ( Any , HttpContext ) -> Unit > ) : HttpLauncher {  install ( HttpRequestHandler ( path : path , method : method , accessControlState : accessControlState , consumes : consumes , produces : produces , executor : executor , responseOutput : responseOutput ) ) NL }","func_name":"install","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func install ( handler : HttpRequestHandler ) : HttpLauncher {  handlers . append ( handler ) NL this NL }","func_name":"install","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func install ( handlers : Iterable < HttpRequestHandler > ) : HttpLauncher {  this . handlers . appendAll ( handlers ) NL this NL }","func_name":"install","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func install ( factory : BeanFactory ) : HttpLauncher {  factory . use < HttpRequestHandler > { hd => install ( hd ) NL } NL this NL }","func_name":"install","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"private func doExecute ( handler : HttpRequestHandler , ctx : HttpContext ) {   let content = handler . execute ( ctx ) NL HttpResult ( HttpStatus . OK , content : content ) NL }","func_name":"doExecute","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"private func makeFuncHandler ( ) {   let handler = FuncHandler { rws : ResponseWriteStream , req : Request =>  let ctx = HttpContext ( req , rws ) NL  let loggen = logGenerator . start NL  let result : HttpResult = try {   let path = ctx . path NL  let handlerOpt = HttpContext . pathPattern . data < HashMap < String , HttpRequestHandler > > ( path ) NL match ( handlerOpt ) { case Some ( handlerMap ) =>  let method = req . method NL match ( handlerMap . get ( method . toString ( ) ) ) { case Some ( handler ) => ctx . handler = handler NL handler . canRead ( ctx ) NL handler . canWrite ( ctx ) NL handler . parseBody ( ctx ) NL  let accessControlState = handler . accessControlState NL if ( let IgnoreLogin = accessControlState ) {  doExecute ( handler , ctx ) NL } else {  match ( accessChecker ( ctx , accessControlState , handler . roles ) ) { case Forbidden ( r ) => HttpResult ( HttpStatus . FORBIDDEN , content : r ) NL case _ => doExecute ( handler , ctx ) NL } NL } NL case _ where method == RequestMethod . OPTIONS => ctx . setResponseHeader ( Server , fountain powered by Cangjie ) NL ctx . setResponseHeader ( Date , rfc1123 ( Time . now ( ) ) ) NL ctx . setResponseHeader ( Content-Length , 0 ) NL  let keys = handlerMap . keys ( ) NL ctx . setResponseHeader ( Allow , StringJoiner . join < String > ( keys , delimiter : ,  ) ) NL ctx . setResponseHeader ( X-Frame-Options , SAMEOPTION ) NL HttpResult ( HttpStatus . OK , content : ( ) ) NL case _ => HttpResult ( HttpStatus . METHOD_NOT_ALLOWED ) NL } NL case _ => HttpResult ( HttpStatus . NOT_FOUND ) NL } NL } catch ( ex : MVCException ) {  match ( ex . status ) { case Some ( status ) => HttpResult ( status , exception : ex ) NL case _ => HttpResult ( HttpStatus . INTERNAL_SERVER_ERROR , exception : ex ) NL } NL } catch ( ex : Exception ) {  HttpResult ( HttpStatus . INTERNAL_SERVER_ERROR , exception : ex ) NL } NL match ( result . exception ) { case Some ( ex ) => logger . error ( loggen . generate ( ctx , result . content ) , ex ) NL case _ => logger . info ( loggen . generate ( ctx , result . content ) ) NL } NL try {  ctx . statusCode ( result . status ) NL ctx . writeResponse ( result . content ) NL } catch ( ex : Exception ) {  logger . error ( loggen . generate ( ctx , ( ) ) , ex ) NL } finally {  match ( ctx . handler ) { case hd : HttpMultiPartRequestHandler => hd . removeIfTmp ( ctx ) NL case _ => ( ) NL } NL } NL } NL handler NL if ( timeout . nanoseconds ( ) > 0 ) {  timeoutHandler ( handler , timeout , timeoutMsg ) NL } else {  handler NL } NL }","func_name":"makeFuncHandler","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"private func compilePaths ( ) {   let pathPattern = HttpContext . pathPattern NL for ( hd in handlers ) {   let map = pathPattern . compileIfAbsent < HashMap < String , HttpRequestHandler > > ( hd . path ) { HashMap < String , HttpRequestHandler > ( ) NL } . getOrThrow ( ) NL if ( let ( Some ( ro ) , None < ( Any , HttpContext ) -> Unit > ) = ( responseOutput , hd . respOutput ) ) {  hd . setResponseOutput ( ro ) NL } NL  let method = hd . method . toString ( ) NL if ( ! map . contains ( method ) ) {  map [ method ] = hd NL } else {  throw IllegalAccessException ( duplicate patterns for the same path pattern and RequestMethod, ${method} ${hd.path} ) NL } NL } NL privilegeInitializer { method : RequestMethod , path : String , roles : Iterable < String > => pathPattern . data < HashMap < String , HttpRequestHandler > > ( path ) . getOrThrow ( ) [ method . toString ( ) ] . addRoles ( roles ) NL } NL }","func_name":"compilePaths","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"private func createServer ( ) {   let hd = makeFuncHandler ( ) NL  let server = if ( let Some ( cfg ) = tlsConfig ) {  Server ( hd , cfg ) NL } else {  Server ( hd ) NL } NL server . port = port NL server . logger = logger NL server . readHeaderTimeout = readHeaderTimeout NL server . readTimeout = readTimeout NL server . writeTimeout = writeTimeout NL server . httpKeepAliveTimeout = httpKeepAliveTimeout NL server . maxBodySize = maxBodySize NL server . maxHeaderSize = if ( maxHeaderSize < 1 << 25 ) {  maxHeaderSize NL } else {  1 << 25 NL } NL server NL }","func_name":"createServer","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func launch ( ) {  compilePaths ( ) NL  let server = createServer ( ) NL server . listenAndServe ( ) NL }","func_name":"launch","docstring":""}
{"repo":"fountain","file":"HttpStartup.cj","path":"fountain/src/mvc/HttpStartup.cj","code_tokens":"public func startup ( handlers : Collection < HttpRequestHandler > , port ! : UInt16 = DEFAULT_PORT , readHeaderTimeout ! : Duration = DEFAULT_TIMEOUT_DURATION , readTimeout ! : Duration = DEFAULT_TIMEOUT_DURATION , writeTimeout ! : Duration = DEFAULT_TIMEOUT_DURATION , httpKeepAliveTimeout ! : Duration = DEFAULT_KEEPALIVE_TIMEOUT_DURATION , tlsConfig ! : Option < TlsServerConfig > = None < TlsServerConfig > , responseOutput ! : Option < ( Any , HttpContext ) -> Unit > = None < ( Any , HttpContext ) -> Unit > , maxHeaderSize ! : Int64 = DEFAULT_MAX_HEADER_SIZE , maxBodySize ! : Int64 = DEFAULT_MAX_BODY_SIZE , privilegeInitializer ! : ( ( RequestMethod , String , Iterable < String > ) -> Unit ) -> Unit = defaultPrivilegeInitializer ( ) , accessChecker ! : ( HttpContext , AccessControlState , Set < String > ) -> AccessChecked = defaultAccessChecker ( ) , logGenerator ! : LogGenerator = DefaultLogGenerator ( ) , timeout ! : Duration = DEFAULT_TIMEOUT_DURATION , timeoutMsg ! : String = DEFAULT_TIMEOUT_MSG ) {  HttpLauncher ( port : port , readHeaderTimeout : readHeaderTimeout , readTimeout : readTimeout , writeTimeout : writeTimeout , httpKeepAliveTimeout : httpKeepAliveTimeout , tlsConfig : tlsConfig , responseOutput : responseOutput , maxHeaderSize : maxHeaderSize , maxBodySize : maxBodySize , privilegeInitializer : privilegeInitializer , accessChecker : accessChecker , logGenerator : logGenerator , timeout : timeout , timeoutMsg : timeoutMsg ) . install ( handlers ) . launch ( ) NL }","func_name":"startup","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"public func isEmpty ( ) : Bool {  length == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"func setType ( `type` : String ) : Unit {  contentDisposition . setType ( ContentDispositionType . tryParse ( `type` ) . getOrThrow ( ) ) NL }","func_name":"setType","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"public func getType ( ) : ContentDispositionType {  contentDisposition . getType ( ) NL }","func_name":"getType","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"func setName ( name : String ) : Unit {  contentDisposition . setName ( name ) NL }","func_name":"setName","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"func setFilename ( filename : String ) : Unit {  contentDisposition . setFilename ( filename ) NL }","func_name":"setFilename","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"func setSize ( size : Int64 ) : Unit {  contentDisposition . setSize ( size ) NL }","func_name":"setSize","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {  try {  content . read ( buffer ) NL } finally {  if ( content . length == 0 ) {  close ( ) NL } NL } NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"public func copyTo ( output : OutputStream ) : Unit {  try {  match ( content ) { case input : ByteArrayStream => input . copyTo ( output ) NL case file : File => file . copyTo ( output ) NL case _ =>  let buffer = Array < Byte > ( 4096 , item : 0 ) NL while ( true ) {   let len = content . read ( buffer ) NL if ( len > 0 ) {  output . write ( buffer . slice ( 0 , len ) ) NL } else {  return NL } NL } NL } NL } finally {  close ( ) NL } NL }","func_name":"copyTo","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"public func readToEnd ( ) : Array < Byte > {  try {  match ( content ) { case input : ByteArrayStream => input . readToEnd ( ) NL case file : File => file . readToEnd ( ) NL case _ =>  let buffer = ByteArrayStream ( ) NL copyTo ( buffer ) NL buffer . readToEnd ( ) NL } NL } finally {  close ( ) NL } NL }","func_name":"readToEnd","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"public func isClosed ( ) : Bool {  ( content as Resource ) ? . isClosed ( ) ?? false NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"MultiPartFile.cj","path":"fountain/src/mvc/MultiPartFile.cj","code_tokens":"public func close ( ) : Unit {  ( content as Resource ) ? . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"MVCApp.cj","path":"fountain/src/mvc/MVCApp.cj","code_tokens":"static public func startup ( configPathPrefix : String , startfn : ( ) -> Unit ) {  App . startup ( configPathPrefix , startfn ) NL launcher_ = HttpLauncher . byConfig ( ) NL launcher_ . getOrThrow ( ) NL }","func_name":"startup","docstring":""}
{"repo":"fountain","file":"MVCApp.cj","path":"fountain/src/mvc/MVCApp.cj","code_tokens":"static public func startup ( configPathPrefix : String ) {  startup ( configPathPrefix ) { } NL }","func_name":"startup","docstring":""}
{"repo":"fountain","file":"MVCApp.cj","path":"fountain/src/mvc/MVCApp.cj","code_tokens":"static public func startup ( startfn : ( ) -> Unit ) {  startup (  , startfn ) NL }","func_name":"startup","docstring":""}
{"repo":"fountain","file":"MVCApp.cj","path":"fountain/src/mvc/MVCApp.cj","code_tokens":"static public func addHandler ( handler : HttpRequestHandler ) {  requestHandles . append ( handler ) NL }","func_name":"addHandler","docstring":""}
{"repo":"fountain","file":"MVCApp.cj","path":"fountain/src/mvc/MVCApp.cj","code_tokens":"static public func launch ( ) {   let launcher = MVCApp . launcher NL for ( handler in requestHandles ) {  launcher . install ( handler ) NL } NL launcher . launch ( ) NL }","func_name":"launch","docstring":""}
{"repo":"fountain","file":"CommonHttpRequestHandler.cj","path":"fountain/src/mvc/CommonHttpRequestHandler.cj","code_tokens":"protected func canRead ( ctx : HttpContext ) : Unit {  if ( let Some ( fn ) = readable ) {  fn ( ctx ) NL } else {  super . canRead ( ctx ) NL } NL }","func_name":"canRead","docstring":""}
{"repo":"fountain","file":"CommonHttpRequestHandler.cj","path":"fountain/src/mvc/CommonHttpRequestHandler.cj","code_tokens":"protected func canWrite ( ctx : HttpContext ) : Unit {  if ( let Some ( fn ) = writable ) {  fn ( ctx ) NL } else {  super . canWrite ( ctx ) NL } NL }","func_name":"canWrite","docstring":""}
{"repo":"fountain","file":"CommonHttpRequestHandler.cj","path":"fountain/src/mvc/CommonHttpRequestHandler.cj","code_tokens":"protected func parseBody ( ctx : HttpContext ) : Unit {  if ( let Some ( fn ) = bodyParser ) {  fn ( ctx ) NL } else {  super . parseBody ( ctx ) NL } NL }","func_name":"parseBody","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setMethod ( method : RequestMethod ) : HttpRequestHandlerFactoryTemplate {  this . method = method NL this NL }","func_name":"setMethod","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setAccessControlState ( state : AccessControlState ) : HttpRequestHandlerFactoryTemplate {  this . accessControlState = state NL this NL }","func_name":"setAccessControlState","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setConsumes ( consumes : Array < String > ) {  this . consumes = consumes NL this NL }","func_name":"setConsumes","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setConsumes ( consumes : String ) {  this . setConsumes ( [ consumes ] ) NL }","func_name":"setConsumes","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setProduces ( produces : String ) {  this . produces = produces NL this NL }","func_name":"setProduces","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setResponseOutput ( responseOutput : ( Any , HttpContext ) -> Unit ) {  this . responseOutput = responseOutput NL this NL }","func_name":"setResponseOutput","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setReadable ( readable : ( HttpContext ) -> Unit ) {  this . readable = readable NL this NL }","func_name":"setReadable","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setWritable ( writable : ( HttpContext ) -> Unit ) {  this . writable = writable NL this NL }","func_name":"setWritable","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setBodyParser ( bodyParser : ( HttpContext ) -> Unit ) {  this . bodyParser = bodyParser NL this NL }","func_name":"setBodyParser","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setUploadDir ( uploadDir : String ) {  this . uploadDir = uploadDir NL this NL }","func_name":"setUploadDir","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func setInMemory ( inMemory : Bool ) {  this . inMemory = inMemory NL this NL }","func_name":"setInMemory","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func make ( path : String , executor : ( HttpContext ) -> Any , consumes ! : Array < String > = this . consumes , produces ! : String = this . produces ) {  CommonHttpRequestHandler ( path : path , method : method , accessControlState : accessControlState , consumes : consumes , produces : produces , executor : executor , responseOutput : responseOutput , readable : readable , writable : writable , bodyParser : bodyParser ) NL }","func_name":"make","docstring":""}
{"repo":"fountain","file":"HttpRequestHandlerFactoryTemplate.cj","path":"fountain/src/mvc/HttpRequestHandlerFactoryTemplate.cj","code_tokens":"public func makeMultiPart ( path : String , executor : ( HttpContext ) -> Any , consumes ! : Array < String > = this . consumes , produces ! : String = this . produces ) {  CommonMultiPartRequestHandler ( path : path , method : method , accessControlState : accessControlState , produces : produces , executor : executor , responseOutput : responseOutput , readable : readable , writable : writable , bodyParser : bodyParser , uploadDir : uploadDir , inMemory : inMemory ) NL }","func_name":"makeMultiPart","docstring":""}
{"repo":"fountain","file":"ContentDispositionType.cj","path":"fountain/src/mvc/ContentDispositionType.cj","code_tokens":"public func toString ( ) : String {  match ( this ) { case attachment => attachment NL case formData => form-data NL case inline => inline NL case none =>  NL } NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"ContentDispositionType.cj","path":"fountain/src/mvc/ContentDispositionType.cj","code_tokens":"public func hashCode ( ) : Int64 {  toString ( ) . hashCode ( ) NL }","func_name":"hashCode","docstring":""}
{"repo":"fountain","file":"ContentDispositionType.cj","path":"fountain/src/mvc/ContentDispositionType.cj","code_tokens":"public operator func == ( other : ContentDispositionType ) {  match ( ( this , other ) ) { case ( attachment , attachment ) | ( formData , formData ) | ( inline , inline ) | ( none , none ) => true NL case _ => false NL } NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"ContentDispositionType.cj","path":"fountain/src/mvc/ContentDispositionType.cj","code_tokens":"public operator func != ( other : ContentDispositionType ) {  ! ( this == other ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"ContentDispositionType.cj","path":"fountain/src/mvc/ContentDispositionType.cj","code_tokens":"static public func tryParse ( value : String ) : Option < ContentDispositionType > {  match ( value ) { case attachment => attachment NL case formData | form-data => formData NL case inline => inline NL case none |  | None | NONE => none NL case _ => None < ContentDispositionType > NL } NL }","func_name":"tryParse","docstring":""}
{"repo":"fountain","file":"ContentDispositionType.cj","path":"fountain/src/mvc/ContentDispositionType.cj","code_tokens":"static public func parse ( value : String ) : ContentDispositionType {  match ( tryParse ( value ) ) { case Some ( v ) => v NL case _ => throw IllegalArgumentException ( argument must be one of \\\"attachment\\\" \\\"formData\\\" \\\"form-data\\\" \\\"inline\\\" \\\"none\\\" \\\"None\\\" \\\"NONE\\\" \\\"\\\", but it is \\\"${value}\\\" ) NL } NL }","func_name":"parse","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func name ( value : String ) : ContentDispositionBuilder {  cd . setName ( value ) NL this NL }","func_name":"name","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func filename ( value : String ) : ContentDispositionBuilder {  cd . setFilename ( value ) NL this NL }","func_name":"filename","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func size ( value : Int64 ) : ContentDispositionBuilder {  cd . setSize ( value ) NL this NL }","func_name":"size","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func creationDate ( value : Time ) : ContentDispositionBuilder {  cd . setCreationDate ( value ) NL this NL }","func_name":"creationDate","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func creationDate ( value : String ) : ContentDispositionBuilder {  cd . setCreationDate ( value ) NL this NL }","func_name":"creationDate","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func modificationDate ( value : String ) : ContentDispositionBuilder {  cd . setModificationDate ( value ) NL this NL }","func_name":"modificationDate","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func readDate ( value : String ) : ContentDispositionBuilder {  cd . setReadDate ( value ) NL this NL }","func_name":"readDate","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func modificationDate ( value : Time ) : ContentDispositionBuilder {  cd . setModificationDate ( value ) NL this NL }","func_name":"modificationDate","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func readDate ( value : Time ) : ContentDispositionBuilder {  cd . setReadDate ( value ) NL this NL }","func_name":"readDate","docstring":""}
{"repo":"fountain","file":"ContentDispositionBuilder.cj","path":"fountain/src/mvc/ContentDispositionBuilder.cj","code_tokens":"public func build ( ) : HttpContext {  ctx . setContentDisposition ( cd ) NL ctx NL }","func_name":"build","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func getType ( ) {  return this . `type` NL }","func_name":"getType","docstring":"/**\n       \t * Return the disposition type.\n       \t * @see #isAttachment()\n       \t * @see #isFormData()\n       \t * @see #isInline()\n       \t */"}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setType ( `type` : ContentDispositionType ) : ContentDisposition {  this . `type` = `type` NL this NL }","func_name":"setType","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func getName ( ) {  return this . name NL }","func_name":"getName","docstring":"/**\n       \t * Return the value of the {@literal name} parameter, or {@code null} if not defined.\n       \t */"}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setName ( name : String ) : ContentDisposition {  this . name = name NL this NL }","func_name":"setName","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func getFilename ( ) {  return this . filename NL }","func_name":"getFilename","docstring":"/**\n       \t * Return the value of the {@literal filename} parameter, possibly decoded\n       \t * from BASE64 encoding based on RFC 2047, or of the {@literal filename*}\n       \t * parameter, possibly decoded as defined in the RFC 5987.\n       \t */"}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setFilename ( filename : String ) : ContentDisposition {  this . filename = filename NL this NL }","func_name":"setFilename","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func getSize ( ) {  return this . size NL }","func_name":"getSize","docstring":"/**\n       \t * Return the value of the {@literal size} parameter, or {@code null} if not defined.\n       \t * <a href=\"https://tools.ietf.org/html/rfc6266#appendix-B\">RFC 6266, Appendix B</a>,\n       \t * to be removed in a future release.\n       \t */"}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setSize ( size : Int64 ) : ContentDisposition {  this . size = size NL this NL }","func_name":"setSize","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func getCreationDate ( ) {  this . creationDate NL }","func_name":"getCreationDate","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setCreationDate ( creationDate : Time ) {  this . creationDate = creationDate NL }","func_name":"setCreationDate","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setCreationDate ( creationDate : String ) {  this . creationDate = parseRfc1123 ( creationDate ) NL }","func_name":"setCreationDate","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setModificationDate ( modificationDate : String ) {  this . modificationDate = parseRfc1123 ( modificationDate ) NL }","func_name":"setModificationDate","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setReadDate ( readDate : String ) {  this . readDate = parseRfc1123 ( readDate ) NL }","func_name":"setReadDate","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func getModificationDate ( ) {  this . modificationDate NL }","func_name":"getModificationDate","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setModificationDate ( modificationDate : Time ) {  this . modificationDate = modificationDate NL }","func_name":"setModificationDate","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func getReadDate ( ) {  this . readDate NL }","func_name":"getReadDate","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func setReadDate ( readDate : Time ) {  this . readDate = readDate NL }","func_name":"setReadDate","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public operator func == ( other : Any ) {  match ( other ) { case otherCd : ContentDisposition => this == otherCd NL case _ => false NL } NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public operator func != ( other : Any ) {  ! ( this == other ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public operator func == ( other : ContentDisposition ) {  this . `type` == other . `type` && this . name == other . name && this . filename == other . filename && this . size == other . size && this . creationDate == other . creationDate && this . modificationDate == other . modificationDate && this . readDate == other . readDate NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public operator func != ( other : ContentDisposition ) {  ! ( this == other ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func hashCode ( ) : Int64 {   func dateHash ( date : Option < Time > ) {  match ( date ) { case Some ( d ) => d . toString ( ) . hashCode ( ) NL case _ => 0 NL } NL } NL if ( hash == 0 ) {  hash = HashBuilder ( ) . append ( this . `type` ) . append ( this . name ) . append ( this . filename ) . append ( this . size ) . append ( dateHash ( this . creationDate ) ) . append ( dateHash ( this . modificationDate ) ) . append ( dateHash ( this . readDate ) ) . finish ( ) NL } NL hash NL }","func_name":"hashCode","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"func dateHash ( date : Option < Time > ) {  match ( date ) { case Some ( d ) => d . toString ( ) . hashCode ( ) NL case _ => 0 NL } NL }","func_name":"dateHash","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"public func toString ( ) : String {   let builder = StringBuilder ( ) NL if ( this . `type` != none ) {  builder . append ( this . `type` ) NL } NL if ( this . name !=  ) {  builder . append ( #\"; name=\"\"# ) NL builder . append ( this . name ) . append ( \\\" ) NL } NL if ( this . filename !=  ) {  builder . append ( ; filename*= ) NL builder . append ( encodeFilename ( this . filename ) ) NL } NL if ( this . size > 0 ) {  builder . append ( ; size= ) NL builder . append ( this . size ) NL } NL if ( let Some ( d ) = creationDate ) {  builder . append ( ; creation-date=\\\" ) NL builder . append ( rfc1123 ( d ) ) NL builder . append ( \\\" ) NL } NL if ( let Some ( d ) = modificationDate ) {  builder . append ( ; modification-date=\\\" ) NL builder . append ( rfc1123 ( d ) ) NL builder . append ( \\\" ) NL } NL if ( let Some ( d ) = readDate ) {  builder . append ( ; read-date=\\\" ) NL builder . append ( rfc1123 ( d ) ) NL builder . append ( \\\" ) NL } NL return builder . toString ( ) NL }","func_name":"toString","docstring":"/**\n       \t * Return the header value for this content disposition as defined in RFC 6266.\n       \t * @see #parse(String)\n       \t */"}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"static public func parse ( contentDisposition : String ) : ContentDisposition {   let parts = tokenize ( contentDisposition ) NL  let `type` = ContentDispositionType . parse ( parts [ 0 ] ) NL  var name =  NL  var filename =  NL  var size = - 1 NL  var creationDate = None < Time > NL  var modificationDate = None < Time > NL  var readDate = None < Time > NL for ( i in 1 .. parts . size ) {   let part = parts [ i ] NL  let eqIndex = part . indexOf ( = ) ?? - 1 NL if ( eqIndex != - 1 ) {   let attribute = part . substring ( 0 , eqIndex ) NL  let value = if ( part . indexOf ( \\\" , eqIndex + 1 ) . some && part . endsWith ( \\\" ) ) {  part . substring ( eqIndex + 2 , part . size - 1 ) NL } else {  part . substring ( eqIndex + 1 ) NL } NL if ( attribute . equals ( name ) ) {  name = value NL } else if ( attribute . equals ( filename* ) ) {   let idx1 = value . indexOf ( ' ) ?? - 1 NL  let idx2 = value . indexOf ( ' , idx1 + 1 ) ?? - 1 NL if ( idx1 != - 1 && idx2 != - 1 ) {  filename = decodeFilename ( value . substring ( idx2 + 1 ) ) NL } else {  filename = decodeFilename ( value ) NL } NL } else if ( attribute == filename && ( filename ==  ) ) {  if ( value . startsWith ( =? ) ) {   let matched = BASE64_ENCODED_PATTERN . matcher ( value ) . find ( 0 ) NL match ( matched ) { case Some ( m ) =>  let match1 = m . matchStr ( 1 ) NL  let match2 = m . matchStr ( 2 ) NL filename = String . fromUtf8 ( base64 . fromBase64String ( match2 ) ?? [ ] ) NL case _ => filename = value NL } NL } else {  filename = value NL } NL } else if ( attribute . equals ( size ) ) {  size = Int64 . parse ( value ) NL } else if ( attribute . equals ( creation-date ) ) {  try {  creationDate = parseRfc1123 ( value ) NL } catch ( _ ) {  } NL } else if ( attribute . equals ( modification-date ) ) {  try {  modificationDate = parseRfc1123 ( value ) NL } catch ( _ ) {  } NL } else if ( attribute . equals ( read-date ) ) {  try {  readDate = parseRfc1123 ( value ) NL } catch ( _ ) {  } NL } NL } else {  throw IllegalArgumentException ( Invalid content disposition format ) NL } NL } NL return ContentDisposition ( `type` : `type` , name : name , filename : filename , size : size , creationDate : creationDate , modificationDate : modificationDate , readDate : readDate ) NL }","func_name":"parse","docstring":"/**\n       \t * Parse a {@literal Content-Disposition} header value as defined in RFC 2183.\n       \t * @param contentDisposition the {@literal Content-Disposition} header value\n       \t * @return the parsed content disposition\n       \t * @see #toString()\n       \t */"}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"static private func tokenize ( headerValue : String ) : ArrayList < String > {   var index = headerValue . indexOf ( ; ) ?? - 1 NL  let `type` = ( if ( index > = 0 ) {  headerValue . substring ( 0 , index ) NL } else {  headerValue NL } ) . trim ( ) NL if ( `type` . isEmpty ( ) ) {  throw IllegalArgumentException ( Content-Disposition header must not be empty ) NL } NL  let parts = ArrayList < String > ( ) NL parts . append ( `type` . toString ( ) ) NL if ( index > = 0 ) {  do {   var nextIndex = index + 1 NL  var quoted = false NL  var escaped = false NL while ( nextIndex < headerValue . size ) {   let ch = headerValue . charAt ( nextIndex ) NL if ( ch == ; ) {  if ( ! quoted ) {  break NL } NL } else if ( ! escaped && ch == \\\" ) {  quoted = ! quoted NL } NL escaped = ( ! escaped && ch == \\\\ ) NL nextIndex ++ NL } NL  let part = headerValue . substring ( index + 1 , nextIndex ) . trim ( ) NL if ( ! part . isEmpty ( ) ) {  parts . append ( part ) NL } NL index = nextIndex NL } while ( index < headerValue . size ) NL } NL parts NL }","func_name":"tokenize","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"static private func decodeFilename ( filename : String ) : String {   let value = filename . toUtf8Array ( ) NL  let baos = ByteListOutputStream ( ) NL  var index = 0 NL while ( index < value . size ) {   let b = value [ index ] NL if ( isRFC5987AttrChar ( b ) ) {  baos . write ( b ) NL index ++ NL } else if ( UInt32 ( b ) == UInt32 ( % ) && index < value . size - 2 ) {   let array = [ Char ( value [ index + 1 ] ) , Char ( value [ index + 2 ] ) ] NL try {   let byte = UInt8 . fromHex ( String ( array ) ) NL baos . write ( byte ) NL } catch ( ex : Exception ) {  throw IllegalArgException ( INVALID_HEADER_FIELD_PARAMETER_FORMAT , ex ) NL } NL index += 3 NL } else {  throw IllegalArgException ( INVALID_HEADER_FIELD_PARAMETER_FORMAT ) NL } NL } NL return baos . toString ( ) NL }","func_name":"decodeFilename","docstring":"/**\n       \t * Decode the given header field param as described in RFC 5987.\n       \t * <p>Only the US-ASCII, UTF-8 and ISO-8859-1 charsets are supported.\n       \t * @param filename the filename\n       \t * @param charset the charset for the filename\n       \t * @return the encoded header field param\n       \t * @see <a href=\"https://tools.ietf.org/html/rfc5987\">RFC 5987</a>\n       \t */"}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"static private func isRFC5987AttrChar ( c : Byte ) : Bool {  return ( UInt32 ( c ) > = UInt32 ( 0 ) && UInt32 ( c ) <= UInt32 ( 9 ) ) || ( UInt32 ( c ) > = UInt32 ( a ) && UInt32 ( c ) <= UInt32 ( z ) ) || ( UInt32 ( c ) > = UInt32 ( A ) && UInt32 ( c ) <= UInt32 ( Z ) ) || UInt32 ( c ) == UInt32 ( ! ) || UInt32 ( c ) == UInt32 ( # ) || UInt32 ( c ) == UInt32 ( $ ) || UInt32 ( c ) == UInt32 ( & ) || UInt32 ( c ) == UInt32 ( + ) || UInt32 ( c ) == UInt32 ( - ) || UInt32 ( c ) == UInt32 ( . ) || UInt32 ( c ) == UInt32 ( ^ ) || UInt32 ( c ) == UInt32 ( _ ) || UInt32 ( c ) == UInt32 ( ` ) || UInt32 ( c ) == UInt32 ( | ) || UInt32 ( c ) == UInt32 ( ~ ) NL }","func_name":"isRFC5987AttrChar","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"static private func escapeQuotationsInFilename ( filename : String ) : String {  if ( ( filename . indexOf ( \\\" ) ?? - 1 ) == - 1 && ( filename . indexOf ( \\\\ ) ?? - 1 ) == - 1 ) {  return filename NL } NL  var escaped = false NL  let builder = StringBuilder ( ) NL for ( i in 0 .. filename . size ) {   let c = filename . charAt ( i ) NL if ( ! escaped && c == \\\" ) {  builder . append ( \\\\\\\" ) NL } else {  builder . append ( c ) NL } NL escaped = ( ! escaped && c == \\\\ ) NL } NL if ( escaped ) {  builder . remove ( builder . size - 1 ) NL } NL return builder . toString ( ) NL }","func_name":"escapeQuotationsInFilename","docstring":""}
{"repo":"fountain","file":"ContentDisposition.cj","path":"fountain/src/mvc/ContentDisposition.cj","code_tokens":"static private func encodeFilename ( input : String ) : String {   let source = input . toUtf8Array ( ) NL  let len = source . size NL  let builder = StringBuilder ( ) NL builder . append ( UTF-8 ) NL builder . append ( '' ) NL for ( b in source ) {  if ( isRFC5987AttrChar ( b ) ) {  builder . append ( Char ( b ) ) NL } else {  builder . append ( % ) . append ( b . hex ) NL } NL } NL return builder . toString ( ) NL }","func_name":"encodeFilename","docstring":"/**\n       \t * Encode the given header field param as describe in RFC 5987.\n       \t * @param input the header field param\n       \t * @param charset the charset of the header field param string,\n       \t * only the US-ASCII, UTF-8 and ISO-8859-1 charsets are supported\n       \t * @return the encoded header field param\n       \t * @see <a href=\"https://tools.ietf.org/html/rfc5987\">RFC 5987</a>\n       \t */"}
{"repo":"fountain","file":"HttpMultiPartRequestHandler.cj","path":"fountain/src/mvc/HttpMultiPartRequestHandler.cj","code_tokens":"private func close ( file : MultiPartFile < File > ) {   let dir = file . directory NL if ( ! file . isClosed ( ) ) {  file . close ( ) NL } NL dir NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"HttpMultiPartRequestHandler.cj","path":"fountain/src/mvc/HttpMultiPartRequestHandler.cj","code_tokens":"func removeIfTmp ( ctx : HttpContext ) {  if ( ! inMemory ) {   var dir = None < Path > NL for ( tuple in ctx . extraIterator ( ) ) {  match ( tuple [ 1 ] ) { case file : MultiPartFile < File > => dir = close ( file ) NL case files : Collection < MultiPartFile < File > > => for ( file in files ) {  dir = close ( file ) NL } NL case _ => ( ) NL } NL } NL if ( let Some ( d ) = dir ) {  Directory . delete ( d , recursive : true ) NL } NL } NL }","func_name":"removeIfTmp","docstring":""}
{"repo":"fountain","file":"HttpMultiPartRequestHandler.cj","path":"fountain/src/mvc/HttpMultiPartRequestHandler.cj","code_tokens":"protected open func parseBody ( ctx : HttpContext ) : Unit {  if ( formDataContentTypeRegex . matches ( ctx . contentType ) . some ) {  MultiPartFormDataParser ( ctx , uploadDir , inMemory ) . parse ( ) NL } else {  throw MVCException ( ${ctx.contentType} is not be supported ) NL } NL }","func_name":"parseBody","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"func getBodyForm ( ) : Form {  match ( body ) { case form : Form => form NL case _ => body = Form ( ) NL ( body . getOrThrow ( ) as Form ) . getOrThrow ( ) NL } NL }","func_name":"getBodyForm","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func setExtra ( name : String , value : Any ) : Unit {  extras [ name ] = value NL }","func_name":"setExtra","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func addExtra ( name : String , value : Any ) : Unit {  match ( extras . get ( name ) ) { case Some ( list ) where list is ArrayList < Any > => ( list as ArrayList < Any > ) . getOrThrow ( ) . append ( value ) NL case Some ( list ) => extras [ name ] = ArrayList < Any > ( [ value ] ) NL case _ => extras [ name ] = ArrayList < Any > ( [ value ] ) NL } NL }","func_name":"addExtra","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getExtra < T > ( name : String ) : Option < T > {  match ( extras . get ( name ) ) { case Some ( x ) where x is T => x as T NL case _ => None < T > NL } NL }","func_name":"getExtra","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getMultiPartFile < T > ( name : String ) : Option < MultiPartFile < T > > where T <: InputStream & OutputStream {  getExtra < MultiPartFile < T > > ( name ) NL }","func_name":"getMultiPartFile","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func extraIterator ( ) : Iterator < ( String , Any ) > {  extras . iterator ( ) NL }","func_name":"extraIterator","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getFormStringValue ( key : String ) : Option < String > {  match ( queryForm . get ( key ) ) { case Some ( x ) where x is String => x as String NL case _ => bodyForm ? . get ( key ) ?? None < String > NL } NL }","func_name":"getFormStringValue","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getFormValue < P > ( key : String ) : Option < P > where P <: Parsable < P > {  getFormValue < P > ( key , P . parse ) NL }","func_name":"getFormValue","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getFormValue < V > ( key : String , parser : ( String ) -> V ) : Option < V > {  match ( getFormStringValue ( key ) ) { case Some ( v ) => parser ( v ) NL case _ => None < V > NL } NL }","func_name":"getFormValue","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getFormValues < P > ( key : String , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < P > where P <: Parsable < P > {  getFormValues < P > ( key , P . parse , delimiter : delimiter , removeEmpty : removeEmpty ) NL }","func_name":"getFormValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getFormValues < V > ( key : String , parser : ( String ) -> V , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < V > {   let value = getFormStringValue ( key ) NL  let list = ArrayList < V > ( ) NL match ( value ) { case Some ( v ) => for ( i in v . split ( delimiter , removeEmpty : removeEmpty ) ) {  list . append ( parser ( i ) ) NL } NL case _ => ( ) NL } NL list . toArray ( ) NL }","func_name":"getFormValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getAllFormStringValues ( key : String ) : Array < String > {   let list = queryForm . getAll ( key ) NL list . appendAll ( bodyForm ? . getAll ( key ) ?? [ ] ) NL list . toArray ( ) NL }","func_name":"getAllFormStringValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getAllFormValues < P > ( key : String ) : Array < P > where P <: Parsable < P > {   let list = queryForm . getAll ( key ) NL  let result = ArrayList < P > ( ) NL for ( v in list ) {  result . append ( P . parse ( v ) ) NL } NL result . toArray ( ) NL }","func_name":"getAllFormValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getPathVariable < P > ( name : String ) : Option < P > where P <: Parsable < P > {  getPathVariable < P > ( name , P . parse ) NL }","func_name":"getPathVariable","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getPathVariable < V > ( name : String , converter : ( String ) -> V ) : Option < V > {  match ( pathVars . get ( name ) ) { case Some ( v ) => converter ( v ) NL case _ => None < V > NL } NL }","func_name":"getPathVariable","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getStringPathVariable ( name : String ) : Option < String > {  pathVars . get ( name ) NL }","func_name":"getStringPathVariable","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getStringPathVariables ( name : String , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < String > {  getString ( { => pathVars . get ( name ) NL } , delimiter , removeEmpty ) NL }","func_name":"getStringPathVariables","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getPathVariables < P > ( name : String , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < P > where P <: Parsable < P > {  getPathVariables < P > ( name , P . parse , delimiter : delimiter , removeEmpty : removeEmpty ) NL }","func_name":"getPathVariables","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func getPathVariables < V > ( name : String , converter : ( String ) -> V , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < V > {  getValues < V > ( { => getStringPathVariables ( name , delimiter : delimiter , removeEmpty : removeEmpty ) NL } , converter ) NL }","func_name":"getPathVariables","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"private func getValues < V > ( getter : ( ) -> Array < String > , converter : ( String ) -> V ) {   let arr = getter ( ) NL Array < V > ( arr . size ) { i => converter ( arr [ i ] ) NL } NL }","func_name":"getValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"private func getString ( getter : ( ) -> ? String , delimiter : String , removeEmpty : Bool ) : Array < String > {  match ( getter ( ) ) { case Some ( v ) => v . split ( delimiter , removeEmpty : removeEmpty ) NL case _ => [ ] NL } NL }","func_name":"getString","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func requestStringHeaderValue ( name : String ) : Option < String > {  request . header . get ( HeaderDfaUtil . canonicalHeaderKey ( name ) ) NL }","func_name":"requestStringHeaderValue","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func requestHeaderValue < P > ( name : String ) : Option < P > where P <: Parsable < P > {   let val = requestStringHeaderValue ( name ) NL match ( val ) { case Some ( v ) => P . parse ( v ) NL case _ => None < P > NL } NL }","func_name":"requestHeaderValue","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func requestHeaderValue < V > ( name : String , parser : ( String ) -> V ) : Option < V > {   let val = requestStringHeaderValue ( name ) NL match ( val ) { case Some ( v ) => parser ( v ) NL case _ => None < V > NL } NL }","func_name":"requestHeaderValue","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func requestStringHeaderValues ( name : String , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < String > {  getString ( { => requestStringHeaderValue ( name ) NL } , delimiter , removeEmpty ) NL }","func_name":"requestStringHeaderValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func requestHeaderValues < P > ( name : String , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < P > where P <: Parsable < P > {  requestHeaderValues < P > ( name , P . parse , delimiter : delimiter , removeEmpty : removeEmpty ) NL }","func_name":"requestHeaderValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func requestHeaderValues < V > ( name : String , converter : ( String ) -> V , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < V > {  getValues < V > ( { => requestStringHeaderValues ( name , delimiter : delimiter , removeEmpty : removeEmpty ) NL } , converter ) NL }","func_name":"requestHeaderValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"private func setHeader < T > ( header : Header , name : String , value : T ) : Unit where T <: ToString {  header . set ( HeaderDfaUtil . canonicalHeaderKey ( name ) , value . toString ( ) ) NL }","func_name":"setHeader","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"private func addHeader < T > ( header : Header , name : String , value : T ) : Unit where T <: ToString {  header . add ( HeaderDfaUtil . canonicalHeaderKey ( name ) , value . toString ( ) ) NL }","func_name":"addHeader","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func setRequestHeader < T > ( name : String , value : T ) : Unit where T <: ToString {  setHeader < T > ( request . header , name , value ) NL }","func_name":"setRequestHeader","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func addRequestHeader < T > ( name : String , value : T ) : Unit where T <: ToString {  addHeader < T > ( request . header , name , value ) NL }","func_name":"addRequestHeader","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func cookie ( name : String ) : Option < Cookie > {  request . cookie ( name ) NL }","func_name":"cookie","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func cookieStringValue ( name : String ) : ? String {  cookie ( name ) ? . value NL }","func_name":"cookieStringValue","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func cookieValue < P > ( name : String ) : ? P where P <: Parsable < P > {  cookieValue < P > ( name , P . parse ) NL }","func_name":"cookieValue","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func cookieValue < V > ( name : String , parser : ( String ) -> V ) : ? V {  match ( cookieStringValue ( name ) ) { case Some ( v ) => parser ( v ) NL case _ => None NL } NL }","func_name":"cookieValue","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func cookieStringValues ( name : String , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < String > {  cookie ( name ) ? . value . split ( delimiter , removeEmpty : removeEmpty ) ?? [ ] NL }","func_name":"cookieStringValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func cookieValues < P > ( name : String , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < P > where P <: Parsable < P > {  cookieValues < P > ( name , P . parse , delimiter : delimiter , removeEmpty : removeEmpty ) NL }","func_name":"cookieValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func cookieValues < V > ( name : String , parser : ( String ) -> V , delimiter ! : String = , , removeEmpty ! : Bool = false ) : Array < V > {  getValues < V > ( { => cookieStringValues ( name , delimiter : delimiter , removeEmpty : removeEmpty ) NL } , parser ) NL }","func_name":"cookieValues","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func cookies ( ) : Array < Cookie > {  request . cookies ( ) NL }","func_name":"cookies","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func setCookie ( cookie : Cookie ) : Unit {  http . setCookie ( response , cookie ) NL }","func_name":"setCookie","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func setCookie ( name : String , value : String , path ! : String =  , domain ! : String =  , expires ! : Time = Time . onetime , rawExpires ! : String =  , maxAge ! : Int64 = 0 , secure ! : Bool = false , httpOnly ! : Bool = false , sameSite ! : SameSite = SameSite . Default , raw ! : String =  , unparsed ! : Array < String > = Array < String > ( ) ) : Unit {  setCookie ( Cookie ( name , value , path : path , domain : domain , expires : expires , rawExpires : rawExpires , maxAge : maxAge , secure : secure , httpOnly : httpOnly , sameSite : sameSite , raw : raw , unparsed : unparsed ) ) NL }","func_name":"setCookie","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func setResponseAuthorization ( auth : BasicAuth ) : Unit {  setResponseHeader < BasicAuth > ( Authorization , auth ) NL }","func_name":"setResponseAuthorization","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func setResponseHeader < T > ( name : String , value : T ) : Unit where T <: ToString {  setHeader < T > ( response . header ( ) , name , value ) NL }","func_name":"setResponseHeader","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func addResponseHeader < T > ( name : String , value : T ) : Unit where T <: ToString {  addHeader < T > ( response . header ( ) , name , value ) NL }","func_name":"addResponseHeader","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func redirect ( url : String , code ! : HttpStatus = HttpStatus . MOVED_TEMPORARILY ) {  http . redirect ( this . response , this . request , url , code . value ) NL }","func_name":"redirect","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func statusCode ( code : HttpStatus ) {  response . writeStatusCode ( code . value ) NL }","func_name":"statusCode","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"func setContentDisposition ( cd : ContentDisposition ) : Unit {  setResponseHeader < String > ( Content-Disposition , cd . toString ( ) ) NL }","func_name":"setContentDisposition","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func flush ( ) : Unit {  response . flush ( ) NL }","func_name":"flush","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func write ( bytes : Array < Byte > ) : Unit {  writeResponse ( bytes ) NL }","func_name":"write","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func writeResponse ( bytes : Array < Byte > ) : Unit {  response . write ( bytes ) NL }","func_name":"writeResponse","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"public func writeResponse ( value : Any ) : Unit {  transfer ( handler , value ) NL }","func_name":"writeResponse","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"private func doTransfer ( hd : HttpRequestHandler , value : ToString ) : Array < Byte > {  value . toString ( ) . toUtf8Array ( ) NL }","func_name":"doTransfer","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"private func doTransfer ( hd : HttpRequestHandler , value : ToJson ) : Array < Byte > {  match ( hd . produces ) { case application/json | plain/text =>  let json : ToString = value . toJson ( ) NL doTransfer ( hd , json ) NL case _ => throw IllegalAccessException ( response data type requires ${hd.produces} ) NL } NL }","func_name":"doTransfer","docstring":""}
{"repo":"fountain","file":"HttpContext.cj","path":"fountain/src/mvc/HttpContext.cj","code_tokens":"private func transfer ( handler : HttpRequestHandler , value : Any ) : Unit {   let array : Array < Byte > = match ( handler . respOutput ) { case Some ( trans ) => return trans ( value , this ) NL case _ => match ( value ) { case v : ToJson => doTransfer ( handler , v ) NL case v : Array < Byte > => v NL case v : Unit => [ ] NL case v : InputStream => while ( true ) {   var buf = Array < Byte > ( 4096 , item : 0 ) NL  let read = v . read ( buf ) NL if ( read == 0 ) {  break NL } else if ( read < 4096 ) {  buf = buf . slice ( 0 , read ) NL this . writeResponse ( buf ) NL break NL } else {  this . writeResponse ( buf ) NL } NL } NL return NL case v : ToString where ! ( value is Option < Any > ) => doTransfer ( handler , v ) NL case opt : Option < Any > => match ( opt ) { case Some ( v ) => return transfer ( handler , v ) NL case _ => return ( ) NL } NL case _ => throw IllegalAccessException ( ) NL } NL } NL this . contentType = handler . produces NL this . writeResponse ( array ) NL return NL }","func_name":"transfer","docstring":""}
{"repo":"fountain","file":"RequestMapping.cj","path":"fountain/src/mvc/annotation/RequestMapping.cj","code_tokens":"func RequestMapping ( attr : Tokens , methodTokens : Tokens , input : Tokens ) : Tokens {   let path = attr [ 0 ] NL  let argSources = HashMap < String , String > ( ) NL  var consumes = `empty_tokens` NL  var produces = `empty_string` [ 0 ] NL  var i = 1 NL while ( i < attr . size ) {   var token = attr [ i ] NL if ( token . value == consumes ) {  i ++ NL token = attr [ i ] NL match ( token . kind ) { case LSQUARE => i ++ NL  var c = 0 NL consumes += `lsquare` NL while ( i < attr . size ) {  token = attr [ i ] NL match ( token . kind ) { case STRING_LITERAL => if ( c == 0 ) {  consumes += `comma` NL } NL consumes += token NL case RSQUARE => break NL case _ => throw MVCException ( unrecognized token for consumes: ${token.value} ) NL } NL c ++ NL i ++ NL } NL consumes += `rsquare` NL case STRING_LITERAL => consumes = quote ( [ $token ] ) NL case _ => throw MVCException ( unrecognized token for consumes: ${token.value} ) NL } NL } else if ( token . value == produces ) {  i ++ NL produces = attr [ i ] NL } else {   let argName = token . value NL i += 2 NL argSources [ argName ] = token . value NL } NL i ++ NL } NL  let decl = parseFuncDecl ( input ) NL  let funcName = decl . getIdentifier ( ) NL  let modifiers = decl . getModifiers ( ) NL  let params = decl . getParamList ( ) . getParams ( ) NL  let args = Array < Tokens > ( params . size ) { i =>  let param = params [ i ] NL  let paramName = param . getIdentifier ( ) NL  let paramType = param . getType ( ) NL  var paramTypeTokens = paramType . toTokens ( ) NL  let isArray = paramTypeTokens [ 0 ] . value == Array NL if ( isArray ) {  paramTypeTokens = quote ( paramTypeTokens [ 1 ] ) NL } NL  let isOption = paramType . isOptionType ( ) NL match ( argSources [ paramName . value ] ) { case Header => if ( isArray ) {  if ( paramTypeTokens [ 0 ] . value == String ) {  quote ( $paramName : ctx . requestStringHeaderValues ( $paramName , removeEmpty : true ) ) NL } else {  quote ( $paramName : ctx . requestHeaderValues < $paramTypeTokens > ( $paramName , removeEmpty : true ) ) NL } NL } else if ( paramTypeTokens [ 0 ] . value == String && isOption ) {  quote ( $paramName : ctx . requestStringHeaderValue ( $paramName ) ) NL } else if ( paramTypeTokens [ 0 ] . value == String ) {  quote ( $paramName : ctx . requestStringHeaderValue ( $paramName ) . getOrThrow ( ) ) NL } else if ( isOption ) {  quote ( $paramName : ctx . requestHeaderValue < $paramTypeTokens > ( $paramName ) ) NL } else {  quote ( $paramName : ctx . requestHeaderValue < $paramTypeTokens > ( $paramName ) . getOrThrow ( ) ) NL } NL case Body => quote ( \\n $paramName : Serializable < $paramTypeTokens > . deserialize ( DataModel . fromJson ( ctx . jsonBody . getOrThrow ( ) ) ) ) NL case Cookie => if ( isArray ) {  if ( paramTypeTokens [ 0 ] . value == String ) {  quote ( $paramName : ctx . cookieStringValues ( $paramName , removeEmpty : true ) ) NL } else {  quote ( $paramName : ctx . cookieValues < $paramTypeTokens > ( $paramName , removeEmpty : true ) ) NL } NL } else if ( paramTypeTokens [ 0 ] . value == String && isOption ) {  quote ( $paramName : ctx . cookieStringValue ( $paramName ) ) NL } else if ( paramTypeTokens [ 0 ] . value == String ) {  quote ( $paramName : ctx . cookieStringValue ( $paramName ) . getOrThrow ( ) ) NL } else if ( isOption ) {  quote ( $paramName : ctx . cookieValue < $paramTypeTokens > ( $paramName ) ) NL } else {  quote ( $paramName : ctx . cookieValue < $paramTypeTokens > ( $paramName ) . getOrThrow ( ) ) NL } NL case Form => if ( isArray ) {  if ( paramTypeTokens [ 0 ] . value == String ) {  quote ( $paramName : ctx . getAllFormStringValues ( $paramName , removeEmpty : true ) ) NL } else {  quote ( $paramName : ctx . getAllFormValues < $paramTypeTokens > ( $paramName , removeEmpty : true ) ) NL } NL } else if ( paramTypeTokens [ 0 ] . value == String && isOption ) {  quote ( $paramName : ctx . getFormStringValue ( $paramName ) ) NL } else if ( paramTypeTokens [ 0 ] . value == String ) {  quote ( $paramName : ctx . getFormStringValue ( $paramName ) . getOrThrow ( ) ) NL } else if ( isOption ) {  quote ( $paramName : ctx . getFormValue < $paramTypeTokens > ( $paramName ) ) NL } else {  quote ( $paramName : ctx . getFormValue < $paramTypeTokens > ( $paramName ) . getOrThrow ( ) ) NL } NL case _ => throw MVCException ( unreognized param value source: ${paramName.value} ) NL } NL } NL  var argTokens = args [ 0 ] NL for ( i in 1 .. args . size ) {  argTokens += `comma` + args [ i ] NL } NL handlerCount ++ NL  let handlerToken = Token ( STRING_LITERAL , rEgIstEr__hAndlEr___${handlerCount}____ ) NL input + `nl` + if ( consumes . size == 0 && produces . value ==  ) {  quote ( \\n let $handlerToken = { => \\n let handler = MVCApp . handlerTemplate . make ( path ) { ctx => \\n $funcName ( $argTokens ) \\n } \\n MVCApp . addHandler ( handler ) \\n } ( ) \\n ) NL } else if ( consumes . size == 0 && produces . value !=  ) {  quote ( \\n let $handlerToken = { => \\n let handler = MVCApp . handlerTemplate . make ( path , { ctx => \\n $funcName ( $argTokens ) \\n } , produces : $produces ) \\n MVCApp . addHandler ( handler ) \\n } ( ) \\n ) NL } else if ( consumes . size > 0 && produces . value ==  ) {  if ( consumes [ 0 ] . value . startsWith ( multipart/form-data ) ) {  quote ( \\n let $handlerToken = { => \\n let handler = MVCApp . handlerTemplate . makeMultiPart ( path , { ctx => \\n $funcName ( $argTokens ) \\n } ) \\n MVCApp . addHandler ( handler ) \\n } ( ) \\n ) NL } else {  quote ( \\n let $handlerToken = { => \\n let handler = MVCApp . handlerTemplate . makeMultiPart ( path , { ctx => \\n $funcName ( $argTokens ) \\n } , consumes : $consumes ) \\n MVCApp . addHandler ( handler ) \\n } ( ) \\n ) NL } NL } else if ( consumes . size > 0 && produces . value !=  ) {  if ( consumes [ 0 ] . value . startsWith ( multipart/form-data ) ) {  quote ( \\n let $handlerToken = { => \\n let handler = MVCApp . handlerTemplate . makeMultiPart ( path , { ctx => \\n $funcName ( $argTokens ) \\n } , produces : $produces ) \\n MVCApp . addHandler ( handler ) \\n } ( ) \\n ) NL } else {  quote ( \\n let $handlerToken = { => \\n let handler = MVCApp . handlerTemplate . makeMultiPart ( path , { ctx => \\n $funcName ( $argTokens ) \\n } , consumes : consumes , produces : produces ) \\n MVCApp . addHandler ( handler ) \\n } ( ) \\n ) NL } NL } else {  throw MVCException ( unreachable ) NL } NL }","func_name":"RequestMapping","docstring":"//目前函数参数只支持基本类型、字符串和基本类型数据、字符串数组，以及它们的Option包装"}
{"repo":"fountain","file":"HttpStatus.cj","path":"fountain/src/mvc/constant/HttpStatus.cj","code_tokens":"public func toString ( ) : String {  return ${this.value} ${this.reasonPhrase} NL }","func_name":"toString","docstring":"/**\n       \t * Return a string representation of this status code.\n       \t */"}
{"repo":"fountain","file":"HttpStatus.cj","path":"fountain/src/mvc/constant/HttpStatus.cj","code_tokens":"static public func valueOf ( statusCode : Int64 ) : HttpStatus {   let status = resolve ( statusCode ) NL match ( status ) { case Some ( s ) => s NL case _ => throw IllegalArgumentException ( No matching constant for [${statusCode}] ) NL } NL }","func_name":"valueOf","docstring":"/**\n       \t * Return the {@code HttpStatus} enum constant with the specified numeric value.\n       \t * @param statusCode the numeric value of the enum to be returned\n       \t * @return the enum constant with the specified numeric value\n       \t * @throws IllegalArgumentException if this enum has no constant for the specified numeric value\n       \t */"}
{"repo":"fountain","file":"HttpStatus.cj","path":"fountain/src/mvc/constant/HttpStatus.cj","code_tokens":"static public func resolve ( statusCode : Int64 ) : Option < HttpStatus > {  for ( status in VALUES ) {  if ( status . value == statusCode ) {  return status NL } NL } NL return None < HttpStatus > NL }","func_name":"resolve","docstring":"/**\n       \t * Resolve the given status code to an {@code HttpStatus}, if possible.\n       \t * @param statusCode the HTTP status code (potentially non-standard)\n       \t * @return the corresponding {@code HttpStatus}, or {@code null} if not found\n       \t */"}
{"repo":"fountain","file":"Series.cj","path":"fountain/src/mvc/constant/Series.cj","code_tokens":"public operator func == ( series : Series ) {  this . value == series . value NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"Series.cj","path":"fountain/src/mvc/constant/Series.cj","code_tokens":"public operator func != ( series : Series ) {  ! ( this == series ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"Series.cj","path":"fountain/src/mvc/constant/Series.cj","code_tokens":"static public func valueOf ( status : HttpStatus ) : Series {  return status . series NL }","func_name":"valueOf","docstring":"/**\n       \t\t * Return the {@code Series} enum constant for the supplied {@code HttpStatus}.\n       \t\t * @param status a standard HTTP status enum constant\n       \t\t * @return the {@code Series} enum constant for the supplied {@code HttpStatus}\n       \t\t * @deprecated as of 5.3, in favor of invoking {@link HttpStatus#series} directly\n       \t\t */"}
{"repo":"fountain","file":"Series.cj","path":"fountain/src/mvc/constant/Series.cj","code_tokens":"static public func valueOf ( statusCode : Int64 ) : Series {   let series = resolve ( statusCode ) NL match ( series ) { case Some ( s ) => s NL case _ => throw IllegalArgumentException ( No matching constant for [${statusCode}] ) NL } NL }","func_name":"valueOf","docstring":"/**\n       \t\t * Return the {@code Series} enum constant for the supplied {@code HttpStatus}.\n       \t\t * @param status a standard HTTP status enum constant\n       \t\t * @return the {@code Series} enum constant for the supplied {@code HttpStatus}\n       \t\t * @deprecated as of 5.3, in favor of invoking {@link HttpStatus#series} directly\n       \t\t */"}
{"repo":"fountain","file":"Series.cj","path":"fountain/src/mvc/constant/Series.cj","code_tokens":"static public func resolve ( statusCode : Int64 ) : Option < Series > {   let seriesCode = statusCode / 100 NL for ( series in values ) {  if ( series . value == seriesCode ) {  return series NL } NL } NL return None < Series > NL }","func_name":"resolve","docstring":"/**\n       \t\t * Resolve the given status code to an {@code HttpStatus.Series}, if possible.\n       \t\t * @param statusCode the HTTP status code (potentially non-standard)\n       \t\t * @return the corresponding {@code Series}, or {@code null} if not found\n       \t\t * @since 5.1.3\n       \t\t */"}
{"repo":"fountain","file":"GroupedMapListQueryMappers.cj","path":"fountain/src/orm/GroupedMapListQueryMappers.cj","code_tokens":"public func map ( result : QueryResult , next ! : Bool = false ) : Option < O > {  if ( new ) {  return GroupedMapListQueryMappers < O , K , V > ( mappers : mappers , creator : creator , grouped : grouped , new : false ) . map ( result , next : next ) NL } NL  var groupKey =  NL  let val = if ( next ) {   var o = creator ( ) NL if ( result . next ( ) ) {  groupKey = populate ( result , o ) NL o NL } else {  None < O > NL } NL } else {   var o = creator ( ) NL groupKey = populate ( result , o ) NL o NL } NL match ( val ) { case Some ( v ) => groupedKeys . append ( groupKey ) NL  let groupedObj = groupedMap . putIfAbsent ( groupKey , v ) . get ( ) NL for ( ( km , vm , extractor ) in grouped ) {   let gk = match ( km . map ( result ) ) { case Some ( gk ) => gk NL case _ => continue NL } NL  let gv = match ( vm . map ( result ) ) { case Some ( gv ) => gv NL case _ => continue NL } NL  let map = extractor ( groupedObj ) NL  let listopt = map . get ( gk ) NL  let list = listopt ?? ArrayList < V > ( ) NL list . append ( gv ) NL if ( listopt . none ) {  map . put ( gk , list ) NL } NL } NL groupedObj NL case _ => None < O > NL } NL }","func_name":"map","docstring":""}
{"repo":"fountain","file":"GroupedMapListQueryMappers.cj","path":"fountain/src/orm/GroupedMapListQueryMappers.cj","code_tokens":"protected func populate ( result : QueryResult , o : O ) : String {  populateAndMakeGroupKey ( result , o ) NL }","func_name":"populate","docstring":""}
{"repo":"fountain","file":"GroupedMapListQueryMappers.cj","path":"fountain/src/orm/GroupedMapListQueryMappers.cj","code_tokens":"public func list ( result : QueryResult ) : ArrayList < O > {  groupedList ( result , groupedKeys , groupedMap ) NL }","func_name":"list","docstring":""}
{"repo":"fountain","file":"SqlArgsIterator.cj","path":"fountain/src/orm/SqlArgsIterator.cj","code_tokens":"public func next ( ) : Option < ( DataType , Option < Any > ) > {  match ( itr . next ( ) ) { case Some ( arg ) => return ( arg . argType , arg . value ) NL case _ => return None < ( DataType , Option < Any > ) > NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"QueryResultIterator.cj","path":"fountain/src/orm/QueryResultIterator.cj","code_tokens":"public func next ( ) : ? T {  mappers . map ( result , next : true ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"QueryResultIterator.cj","path":"fountain/src/orm/QueryResultIterator.cj","code_tokens":"public func stream ( ) : Stream < T > {  Stream < T > ( this ) NL }","func_name":"stream","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"static public func byConfig ( driver : Driver ) {   let cfg = App . config NL DatabasePool ( url : cfg . getConf ( DATABASE_POOL_URL ) . getOrThrow ( ) , driver : driver , initSize : cfg . getIntConf ( DATABASE_POOL_INIT_SIZE ) . getOrThrow ( ) , minSize : cfg . getIntConf ( DATABASE_POOL_MIN_SIZE ) . getOrThrow ( ) , maxSize : cfg . getIntConf ( DATABASE_POOL_MAX_SIZE ) . getOrThrow ( ) , checkPeriod : cfg . getIntConf ( DATABASE_POOL_CHECK_PERIOD ) . getOrThrow ( ) , creationRetries : cfg . getIntConf ( DATABASE_POOL_CREATION_RETRIES ) . getOrThrow ( ) , checkSql : cfg . getConf ( DATABASE_POOL_CHECK_SQL ) . getOrThrow ( ) ) NL }","func_name":"byConfig","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"public func isClosed ( ) : Bool {   let poolClosed = pool . isClosed ( ) NL  let dbClosed = database . isClosed ( ) NL if ( poolClosed && ! dbClosed ) {  database . close ( ) NL } else if ( ! poolClosed && dbClosed ) {  pool . close ( ) NL } NL poolClosed || dbClosed NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"public func close ( ) : Unit {  if ( ! isClosed ( ) ) {  pool . close ( ) NL database . close ( ) NL } NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"public func getConnection ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Option < Connection > {  if ( isClosed ( ) ) {  return None < Connection > NL } NL pool . getObject ( timeout : timeout ) ? . activate ( pool . returnObject ) NL }","func_name":"getConnection","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"public func isClosed ( ) : Bool {  ! assigned NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"public func close ( ) : Unit {  assigned = false NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is returning ) NL } NL returnFn ( this ) NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is returned ) NL } NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"func activate ( returnFn : ( PooledConnection ) -> Unit ) : Connection {  assigned = true NL this . returnFn = returnFn NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is assigned ) NL } NL this NL }","func_name":"activate","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"func isDestroied ( ) : Bool {  connection . isClosed ( ) NL }","func_name":"isDestroied","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"func destroy ( ) : Unit {  if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is closing ) NL } NL if ( ! ( assigned || connection . isClosed ( ) ) ) {  connection . close ( ) NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is closed ) NL } NL } else if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} cannot close ) NL } NL }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"public func prepareStmt ( sql : String ) : Statement {  if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is preparing a statement ) NL } NL  let stmt = connection . prepareStmt ( sql ) NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} a statement is prepared ) NL } NL stmt NL }","func_name":"prepareStmt","docstring":"/*\n     * 通过传入的 sql 语句，返回一个预执行的 Statement 对象实例\n     * 参数 sql - 预执行的 sql 语句\n     * 返回值 Statement - 一个可以执行 sql 语句的实例对象\n     */"}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"public func beginTx ( ) : Unit {  if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} a transaction is beginning ) NL } NL connection . beginTx ( ) NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} a transaction began ) NL } NL }","func_name":"beginTx","docstring":"/*\n       接口 Statement ，sql 语句预执行接口，它绑定了一个 Connection , 继承该接口的 class、interface、\n       struct 也需要遵守该接口中函数的入参及返回值定义。\n     * 开始事务\n     */"}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"public func commit ( ) : Unit {  if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is committing ) NL } NL connection . commit ( ) NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is committed ) NL } NL }","func_name":"commit","docstring":"/*\n     * 提交事务，会结束当前事务\n     */"}
{"repo":"fountain","file":"DatabasePool.cj","path":"fountain/src/orm/DatabasePool.cj","code_tokens":"public func rollback ( ) : Unit {  if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is rollbacking ) NL } NL connection . rollback ( ) NL if ( logger . debugEnabled ) {  logger . debug ( database Connection ${serial} is rollbacked ) NL } NL }","func_name":"rollback","docstring":"/*\n     * 回滚事务，会结束当前事务\n     */"}
{"repo":"fountain","file":"GroupedArrayListQueryMappers.cj","path":"fountain/src/orm/GroupedArrayListQueryMappers.cj","code_tokens":"static protected func create ( mappers ! : Array < QueryMapper < O > > , creator ! : ( ) -> O , grouped ! : Array < ( QueryMappers < G > , ( O ) -> ArrayList < G > ) > , new ! : Bool = false ) : GroupedArrayListQueryMappers < O , G > {  GroupedArrayListQueryMappers < O , G > ( mappers : mappers , creator : creator , grouped : grouped , new : new ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"protected open func populate ( result : QueryResult , o : O ) : String {  for ( mapper in mappers ) {  mapper . populate < Any > ( result , o ) NL } NL  NL }","func_name":"populate","docstring":""}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"protected func populateAndMakeGroupKey ( result : QueryResult , o : O ) : String {   let builder = StringBuilder ( ) NL for ( mapper in mappers ) {   let val = mapper . populate < Any > ( result , o ) NL match ( val ) { case Some ( v ) where v is ToString => builder . append ( ( v as ToString ) . getOrThrow ( ) . toString ( ) ) NL case Some ( v ) => builder . append ( [{<_>}] ) NL case _ => builder . append ( null ) NL } NL builder . append ( \\0 ) NL } NL builder . toString ( ) NL }","func_name":"populateAndMakeGroupKey","docstring":""}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"public func map ( result : ExecuteResult , next ! : Bool = false ) : Option < O > {  map ( result . query , next : next ) NL }","func_name":"map","docstring":"//映射单个对象"}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"public open func map ( result : QueryResult , next ! : Bool = false ) : Option < O > {  if ( next ) {   var o = creator ( ) NL if ( result . next ( ) ) {  populate ( result , o ) NL o NL } else {  None < O > NL } NL } else {   var o = creator ( ) NL populate ( result , o ) NL o NL } NL }","func_name":"map","docstring":"//映射单个对象"}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"public func list ( result : ExecuteResult ) : ArrayList < O > {  list ( result . query ) NL }","func_name":"list","docstring":"//映射全部结果集"}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"public open func list ( result : QueryResult ) : ArrayList < O > {   let list = ArrayList < O > ( ) NL while ( result . next ( ) ) {   let val = map ( result ) NL list . append ( val . getOrThrow ( ) ) NL } NL list NL }","func_name":"list","docstring":"//映射全部结果集"}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"public open func stream ( result : QueryResult ) : Stream < O > {  QueryResultIterator < O > ( result , this ) . stream ( ) NL }","func_name":"stream","docstring":""}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"public func one ( result : QueryResult ) : Option < O > {   let list = this . list ( result ) NL if ( list . isEmpty ( ) ) {  None < O > NL } else if ( list . size > 1 ) {  throw OverSizeException ( expected one but ${list.size} ) NL } else {  list [ 0 ] NL } NL }","func_name":"one","docstring":""}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"public func one ( result : ExecuteResult ) : Option < O > {  one ( result . query ) NL }","func_name":"one","docstring":""}
{"repo":"fountain","file":"QueryMappers.cj","path":"fountain/src/orm/QueryMappers.cj","code_tokens":"protected func groupedList ( result : QueryResult , groupedKeys : ArrayList < String > , groupedMap : HashMap < String , O > ) : ArrayList < O > {  this . list ( result ) NL  let list = ArrayList < O > ( ) NL for ( key in groupedKeys ) {  match ( groupedMap . get ( key ) ) { case Some ( o ) => list . append ( o ) NL case _ => continue NL } NL } NL return list NL }","func_name":"groupedList","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"static private func getConnection ( timeout : UInt64 ) {  ORM . connection ( timeout : timeout ) NL }","func_name":"getConnection","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func isClosed ( ) : Bool {  connection . isClosed ( ) NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func close ( ) : Unit {  connection . close ( ) NL connection = NoneConnection . instance NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func begin ( ) {  connection . beginTx ( ) NL }","func_name":"begin","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func commit ( ) {  connection . commit ( ) NL }","func_name":"commit","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func rollback ( ) {  connection . rollback ( ) NL }","func_name":"rollback","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func withTx ( tx ! : Bool = true ) : SqlExecutor {  withTx_ = tx NL this NL }","func_name":"withTx","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func first < T > ( mapper : QueryMapper < T > ) : Option < T > {  execute < Option < T > > { mapper . get < T > ( query , true ) NL } NL }","func_name":"first","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func list < T > ( mapper : QueryMapper < T > ) : ArrayList < Option < T > > {  execute < ArrayList < Option < T > > > { mapper . list < T > ( query ) NL } NL }","func_name":"list","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func first < T > ( mappers : QueryMappers < T > ) : Option < T > {  execute < Option < T > > { mappers . map ( query , next : true ) NL } NL }","func_name":"first","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func list < T > ( mappers : QueryMappers < T > ) : ArrayList < T > {  execute < ArrayList < T > > { mappers . list ( query ) NL } NL }","func_name":"list","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func stream < T > ( mappers : QueryMappers < T > ) : Stream < T > {  execute < Stream < T > > { mappers . stream ( query ) NL } NL }","func_name":"stream","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func one < T > ( mappers : QueryMappers < T > ) : Option < T > {  execute < Option < T > > { mappers . one ( query ) NL } NL }","func_name":"one","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func setSql ( sql : String ) : SqlExecutor {  this . sql = sql NL this NL }","func_name":"setSql","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func setArgs ( args : Iterable < ( DataType , Option < Any > ) > ) : SqlExecutor {  this . args = SqlArgs ( ) NL for ( arg in args ) {  this . args . append ( arg [ 0 ] , arg [ 1 ] ) NL } NL this NL }","func_name":"setArgs","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func generateSql ( generator : ( SqlArgs ) -> String ) : SqlExecutor {  args = SqlArgs ( ) NL sql = generator ( args ) NL this NL }","func_name":"generateSql","docstring":""}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"private func execute < T > ( executor : ( ) -> T ) : T {  try {  if ( withTx_ ) {  return executor ( ) NL } NL try (  let exe = this ) {  return executor ( ) NL } NL throw UnreachableException ( ) NL } finally {  args = SqlArgs . empty NL } NL }","func_name":"execute","docstring":"//executor返回元组的第二个值，如果是true就执行commit，否则执行rollback"}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"private func execute < T > ( extract : ( UpdateResult ) -> T ) : T {  execute < T > {  let result = statement . execute ( ) . update NL extract ( result ) NL } NL }","func_name":"execute","docstring":"//executor返回元组的第二个值，如果是true就执行commit，否则执行rollback"}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func execute < T > ( executor : ( SqlExecutor ) -> T ) : T {  execute < T > { exec : SqlExecutor => ( executor ( exec ) , true ) NL } NL }","func_name":"execute","docstring":"//executor返回元组的第二个值，如果是true就执行commit，否则执行rollback"}
{"repo":"fountain","file":"SqlExecutor.cj","path":"fountain/src/orm/SqlExecutor.cj","code_tokens":"public func execute < T > ( executor : ( SqlExecutor ) -> ( T , Bool ) ) : T {  if ( withTx_ ) {  withTx ( tx : false ) NL execute < T > { withTx ( tx : true ) NL try {  begin ( ) NL  let result = executor ( this ) NL if ( result [ 1 ] ) {  commit ( ) NL result [ 0 ] NL } else {  throw ORMException ( ) NL } NL } catch ( e1 : Exception ) {  try {  rollback ( ) NL } catch ( e2 : Exception ) {   let e = ORMException ( e2 ) NL e . addSuppressed ( e1 ) NL throw e NL } NL if ( e1 is ORMException ) {  throw e1 NL } NL throw ORMException ( e1 ) NL } NL } NL } else {  execute < T > { executor ( this ) [ 0 ] NL } NL } NL }","func_name":"execute","docstring":"//executor返回元组的第二个值，如果是true就执行commit，否则执行rollback"}
{"repo":"fountain","file":"ORM.cj","path":"fountain/src/orm/ORM.cj","code_tokens":"static public func byConfig ( driver : Driver ) {  if ( let None < ORM > = instance ) {  ORM ( DatabasePool . byConfig ( driver ) ) NL } else {  throw ORMException ( ORM has been instantiated ) NL } NL }","func_name":"byConfig","docstring":""}
{"repo":"fountain","file":"ORM.cj","path":"fountain/src/orm/ORM.cj","code_tokens":"public func isClosed ( ) : Bool {  connGetter . isClosed ( ) NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"ORM.cj","path":"fountain/src/orm/ORM.cj","code_tokens":"public func close ( ) : Unit {  if ( ! isClosed ( ) ) {  connGetter . close ( ) NL } NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"ORM.cj","path":"fountain/src/orm/ORM.cj","code_tokens":"static public func connection ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Connection {  match ( instance . getOrThrow ( ) . connGetter . getConnection ( timeout : timeout ) ) { case Some ( c ) => c NL case _ => throw PoolException ( to obtain a database connection failed ) NL } NL }","func_name":"connection","docstring":""}
{"repo":"fountain","file":"ORM.cj","path":"fountain/src/orm/ORM.cj","code_tokens":"static func argsToString ( args : Iterable < ( DataType , Option < Any > ) > ) : String {   let builder = StringBuilder ( ) NL for ( arg in args ) {  match ( arg ) { case ( stream , _ ) => builder . append ( type: < ) . append ( stream . toString ( ) ) . append ( > ) NL case ( d , v ) where v is ToString => builder . append ( type: < ) . append ( d . toString ( ) ) . append ( >, value: ) . append ( ( v as ToString ) . getOrThrow ( ) . toString ( ) ) NL case _ => throw UnreachableException ( ) NL } NL } NL builder . toString ( ) NL }","func_name":"argsToString","docstring":""}
{"repo":"fountain","file":"ORM.cj","path":"fountain/src/orm/ORM.cj","code_tokens":"static public func execute ( sql : String , args ! : Iterable < ( DataType , Option < Any > ) > = [ ] , timeout ! : UInt64 = INFINITE_TIMEOUT ) : ExecuteResult {  if ( logger . debugEnabled ) {  logger . debug ( executing a sql: ${sql}, args: ${argsToString(args)} ) NL } NL try (  let conn = connection ( timeout : timeout ) ) {   let stmt = conn . prepareStmt ( sql ) NL  var i = 0 NL for ( arg in args ) {   let sqlarg = SqlArg ( i , arg [ 0 ] , arg [ 1 ] ) NL sqlarg . setArg ( stmt ) NL i ++ NL } NL return stmt . execute ( ) NL } NL throw UnreachableException ( ) NL }","func_name":"execute","docstring":""}
{"repo":"fountain","file":"ORM.cj","path":"fountain/src/orm/ORM.cj","code_tokens":"static public func executor ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : SqlExecutor {  SqlExecutor ( timeout ) NL }","func_name":"executor","docstring":""}
{"repo":"fountain","file":"DataType.cj","path":"fountain/src/orm/DataType.cj","code_tokens":"public func toString ( ) : String {  match ( this ) { case bool => bool NL case int8 => int8 NL case uint8 => uint8 NL case int16 => int16 NL case uint16 => uint16 NL case int32 => int32 NL case uint32 => uint32 NL case int64 => int64 NL case uint64 => uint64 NL case float16 => float16 NL case float32 => float32 NL case float64 => float64 NL case string => string NL case time => time NL case char => char NL case bytes => bytes NL case stream => stream NL } NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"QueryMapper.cj","path":"fountain/src/orm/QueryMapper.cj","code_tokens":"public func list < T > ( result : ExecuteResult ) : ArrayList < Option < T > > {  list < T > ( result . query ) NL }","func_name":"list","docstring":"//获取单列的全部数据列表"}
{"repo":"fountain","file":"QueryMapper.cj","path":"fountain/src/orm/QueryMapper.cj","code_tokens":"public func list < T > ( result : QueryResult ) : ArrayList < Option < T > > {   let list = ArrayList < Option < T > > ( ) NL while ( result . next ( ) ) {  list . append ( get < T > ( result ) ) NL } NL return list NL }","func_name":"list","docstring":"//获取单列的全部数据列表"}
{"repo":"fountain","file":"QueryMapper.cj","path":"fountain/src/orm/QueryMapper.cj","code_tokens":"public func get < T > ( result : ExecuteResult ) : Option < T > {  get < T > ( result . query ) NL }","func_name":"get","docstring":"//获取单列的单行的数据"}
{"repo":"fountain","file":"QueryMapper.cj","path":"fountain/src/orm/QueryMapper.cj","code_tokens":"public func get < T > ( result : ExecuteResult , next : Bool ) : Option < T > {  get < T > ( result . query , next ) NL }","func_name":"get","docstring":"//获取单列的单行的数据"}
{"repo":"fountain","file":"QueryMapper.cj","path":"fountain/src/orm/QueryMapper.cj","code_tokens":"public func get < T > ( result : QueryResult , next : Bool ) : Option < T > {  if ( next ) {  if ( result . next ( ) ) {  get < T > ( result ) NL } else {  None < T > NL } NL } else {  get < T > ( result ) NL } NL }","func_name":"get","docstring":"//获取单列的单行的数据"}
{"repo":"fountain","file":"QueryMapper.cj","path":"fountain/src/orm/QueryMapper.cj","code_tokens":"func get < T > ( result : QueryResult ) : Option < T > {  match ( dataType ) { case bool => extract < T , Bool > ( result . getBool ( index ) ) NL case int8 => extract < T , Int8 > ( result . getInt8 ( index ) ) NL case uint8 => extract < T , UInt8 > ( result . getUInt8 ( index ) ) NL case int16 => extract < T , Int16 > ( result . getInt16 ( index ) ) NL case uint16 => extract < T , UInt16 > ( result . getUInt16 ( index ) ) NL case int32 => extract < T , Int32 > ( result . getInt32 ( index ) ) NL case uint32 => extract < T , UInt32 > ( result . getUInt32 ( index ) ) NL case int64 => extract < T , Int64 > ( result . getInt64 ( index ) ) NL case uint64 => extract < T , UInt64 > ( result . getUInt64 ( index ) ) NL case float16 => extract < T , Float16 > ( result . getFloat16 ( index ) ) NL case float32 => extract < T , Float32 > ( result . getFloat32 ( index ) ) NL case float64 => extract < T , Float64 > ( result . getFloat64 ( index ) ) NL case string => extract < T , String > ( result . getString ( index ) ) NL case time => extract < T , Time > ( result . getTime ( index ) ) NL case char => extract < T , Char > ( result . getChar ( index ) ) NL case bytes => extract < T , Array < Byte > > ( result . getBytes ( index ) ) NL case stream => extract < T , InputStream > ( result . getStream ( index ) ) NL } NL }","func_name":"get","docstring":"//获取单列的单行的数据"}
{"repo":"fountain","file":"QueryMapper.cj","path":"fountain/src/orm/QueryMapper.cj","code_tokens":"private func extract < T , R > ( value : Option < R > ) : Option < T > {  match ( value ) { case Some ( r ) where r is T => r as T NL case Some ( r ) where ! ( r is T ) => throw TypeCastException ( ) NL case _ => None < T > NL } NL }","func_name":"extract","docstring":""}
{"repo":"fountain","file":"QueryMapper.cj","path":"fountain/src/orm/QueryMapper.cj","code_tokens":"public func populate < T > ( result : QueryResult , o : O ) : Option < Any > {   let val = extract < Any , T > ( get < T > ( result ) ) NL putter ( o , val ) NL val NL }","func_name":"populate","docstring":""}
{"repo":"fountain","file":"LoopChooser.cj","path":"fountain/src/orm/LoopChooser.cj","code_tokens":"public func choose ( check : ( T , Int64 , Int64 ) -> Bool , dataType : DataType , condition : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : LoopChooser < T > {  makeCondition ( check , dataType , condition , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"choose","docstring":""}
{"repo":"fountain","file":"LoopChooser.cj","path":"fountain/src/orm/LoopChooser.cj","code_tokens":"public func choose ( check : ( T , Int64 , Int64 ) -> Bool , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : LoopChooser < T > {  makeCondition ( check , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"choose","docstring":""}
{"repo":"fountain","file":"LoopChooser.cj","path":"fountain/src/orm/LoopChooser.cj","code_tokens":"public func choose ( check : ( T , Int64 , Int64 ) -> Bool , text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : LoopChooser < T > {  makeCondition ( check , text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"choose","docstring":""}
{"repo":"fountain","file":"LoopChooser.cj","path":"fountain/src/orm/LoopChooser.cj","code_tokens":"func execute ( current : T , index : Int64 , size : Int64 ) : Unit {  for ( exec in executors ) {  exec ( current , index , size ) NL if ( ! noMet ) {  break NL } NL } NL }","func_name":"execute","docstring":""}
{"repo":"fountain","file":"SqlArg.cj","path":"fountain/src/orm/SqlArg.cj","code_tokens":"static private func confirmDataType ( value : ? Any ) : DataType {  match ( value ) { case _ : ? Bool => bool NL case _ : ? Int8 => int8 NL case _ : ? UInt8 => uint8 NL case _ : ? Int16 => int16 NL case _ : ? UInt16 => uint16 NL case _ : ? Int32 => int32 NL case _ : ? UInt32 => uint32 NL case _ : ? Int64 => int64 NL case _ : ? UInt64 => uint64 NL case _ : ? Float16 => float16 NL case _ : ? Float32 => float32 NL case _ : ? Float64 => float64 NL case _ : ? String => string NL case _ : ? Time => time NL case _ : ? Char => char NL case _ : ? Array < Byte > => bytes NL case _ : ? InputStream => stream NL case _ => throw ORMException ( unrecognized data type ) NL } NL }","func_name":"confirmDataType","docstring":""}
{"repo":"fountain","file":"SqlArg.cj","path":"fountain/src/orm/SqlArg.cj","code_tokens":"static public func create < T > ( index : Int64 , argType : DataType , value : Option < T > ) {   let val : Option < Any > = convert < T , Any > ( value ) NL SqlArg ( index , argType , val ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SqlArg.cj","path":"fountain/src/orm/SqlArg.cj","code_tokens":"static private func convert < T , R > ( value : Option < T > ) : Option < R > {  Options < T , R > . convertOrThrow ( value ) NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"SqlArg.cj","path":"fountain/src/orm/SqlArg.cj","code_tokens":"public func setArg ( stmt : Statement ) {  match ( argType ) { case bool => stmt . setBool ( index , convert < Any , Bool > ( value ) ) NL case int8 => stmt . setInt8 ( index , convert < Any , Int8 > ( value ) ) NL case uint8 => stmt . setUInt8 ( index , convert < Any , UInt8 > ( value ) ) NL case int16 => stmt . setInt16 ( index , convert < Any , Int16 > ( value ) ) NL case uint16 => stmt . setUInt16 ( index , convert < Any , UInt16 > ( value ) ) NL case int32 => stmt . setInt32 ( index , convert < Any , Int32 > ( value ) ) NL case uint32 => stmt . setUInt32 ( index , convert < Any , UInt32 > ( value ) ) NL case int64 => stmt . setInt64 ( index , convert < Any , Int64 > ( value ) ) NL case uint64 => stmt . setUInt64 ( index , convert < Any , UInt64 > ( value ) ) NL case float16 => stmt . setFloat16 ( index , convert < Any , Float16 > ( value ) ) NL case float32 => stmt . setFloat32 ( index , convert < Any , Float32 > ( value ) ) NL case float64 => stmt . setFloat64 ( index , convert < Any , Float64 > ( value ) ) NL case string => stmt . setString ( index , convert < Any , String > ( value ) ) NL case time => stmt . setTime ( index , convert < Any , Time > ( value ) ) NL case char => stmt . setChar ( index , convert < Any , Char > ( value ) ) NL case bytes => stmt . setBytes ( index , convert < Any , Array < Byte > > ( value ) ) NL case stream => stmt . setStream ( index , convert < Any , InputStream > ( value ) ) NL } NL }","func_name":"setArg","docstring":""}
{"repo":"fountain","file":"GroupedSetQueryMappers.cj","path":"fountain/src/orm/GroupedSetQueryMappers.cj","code_tokens":"protected func putToCollection ( set : Set < G > , v : G ) : Unit {  set . put ( v ) NL }","func_name":"putToCollection","docstring":""}
{"repo":"fountain","file":"GroupedSetQueryMappers.cj","path":"fountain/src/orm/GroupedSetQueryMappers.cj","code_tokens":"static protected func create ( mappers ! : Array < QueryMapper < O > > , creator ! : ( ) -> O , grouped ! : Array < ( QueryMappers < G > , ( O ) -> Set < G > ) > , new ! : Bool = false ) : GroupedSetQueryMappers < O , G > {  GroupedSetQueryMappers < O , G > ( mappers : mappers , creator : creator , grouped : grouped , new : new ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConnectionGetter.cj","path":"fountain/src/orm/ConnectionGetter.cj","code_tokens":"func getConnection ( timeout ! : UInt64 ) : Option < Connection >","func_name":"getConnection","docstring":""}
{"repo":"fountain","file":"ConnectionGetter.cj","path":"fountain/src/orm/ConnectionGetter.cj","code_tokens":"public func getConnection ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Option < Connection > {  database . ping ( ) NL database . connect ( ) NL }","func_name":"getConnection","docstring":""}
{"repo":"fountain","file":"ConnectionGetter.cj","path":"fountain/src/orm/ConnectionGetter.cj","code_tokens":"public func isClosed ( ) : Bool {  false NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"ConnectionGetter.cj","path":"fountain/src/orm/ConnectionGetter.cj","code_tokens":"public func close ( ) : Unit {  }","func_name":"close","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"func setArgs ( stmt : Statement ) {  for ( arg in args ) {  arg . setArg ( stmt ) NL } NL }","func_name":"setArgs","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"func append ( dataType : DataType , value : Option < Any > ) {  args . append ( SqlArg ( args . size , dataType , value ) ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"func append ( value : ? Any ) {  args . append ( SqlArg ( args . size , value ) ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func iterator ( ) : Iterator < ( DataType , Option < Any > ) > {  SqlArgsIterator ( args . iterator ( ) ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func meeter ( prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  ) : Meeter {  Meeter ( this , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead ) NL }","func_name":"meeter","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func chooser ( prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  ) : Chooser {  Chooser ( this , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead ) NL }","func_name":"chooser","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func meet ( check : Bool , dataType : DataType , condition : String , value : Any , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : String {  meeter ( prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead ) . meet ( check , dataType , condition , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) . end NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func meet ( check : Bool , condition : String , value : Any , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : String {  meeter ( prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead ) . meet ( check , condition , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) . end NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func meet ( check : Bool , text : String , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : String {  meeter ( prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead ) . meet ( check , text , delimiter : delimiter , delimiterPosition : delimiterPosition ) . end NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func appendArg ( dataType : DataType , condition : String , value : Any , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  meet ( true , dataType , condition , value , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimTail , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"appendArg","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func appendArg ( condition : String , value : Any , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  meet ( true , condition , value , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimTail , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"appendArg","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func appendArg ( dataType : DataType , value : Any , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  appendArg ( dataType ,  , value , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimTail , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"appendArg","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func appendArg ( value : Any , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  meet ( true ,  , value , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimTail , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"appendArg","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func appendArg ( dataType : DataType , text : String , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  meet ( true , text , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimTail , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"appendArg","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func loop < T > ( iterable : Iterable < T > , prefix ! : String =  , delimiter ! : String =  , suffix ! : String =  ) : Loop < T > {  Loop < T > ( this , iterable , prefix : prefix , delimiter : delimiter , suffix : suffix ) NL }","func_name":"loop","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func trim ( trimmed : String , fn : ( ) -> String ) : String {  trim ( trimmed , trimmed , fn ) NL }","func_name":"trim","docstring":"//构造动态sql的条件，相当于mybatis的<iterate标签"}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func trimPrefix ( trimmed : String , fn : ( ) -> String ) : String {  doTrim ( ^\\\\s*(${trimmed}) , fn ) NL }","func_name":"trimPrefix","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func trimSuffix ( trimmed : String , fn : ( ) -> String ) : String {  doTrim ( (${trimmed})\\\\s*$ , fn ) NL }","func_name":"trimSuffix","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"public func trim ( prefix : String , suffix : String , fn : ( ) -> String ) : String {  doTrim ( prefix , suffix , fn ( ) ) NL }","func_name":"trim","docstring":"//构造动态sql的条件，相当于mybatis的<iterate标签"}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"func doTrim ( prefix : String , suffix : String , partial : String ) : String {  doTrim ( ^\\\\s*(${prefix})|(${suffix})\\\\s*$ , partial ) NL }","func_name":"doTrim","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"private func doTrim ( trimRegex : String , fn : ( ) -> String ) : String {  doTrim ( trimRegex , fn ( ) ) NL }","func_name":"doTrim","docstring":""}
{"repo":"fountain","file":"SqlArgs.cj","path":"fountain/src/orm/SqlArgs.cj","code_tokens":"private func doTrim ( trimRegex : String , partial : String ) : String {  trimRegex . regex ( ) . matcher ( partial ) . replaceAll (   ) NL }","func_name":"doTrim","docstring":""}
{"repo":"fountain","file":"Chooser.cj","path":"fountain/src/orm/Chooser.cj","code_tokens":"public func choose ( check : ( ) -> Bool , dataType : DataType , condition : String , value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Chooser {  if ( noMet && check ( ) ) {  noMet = false NL appendArg ( dataType , condition , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL this NL }","func_name":"choose","docstring":""}
{"repo":"fountain","file":"Chooser.cj","path":"fountain/src/orm/Chooser.cj","code_tokens":"public func choose ( check : ( ) -> Bool , condition : String , value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Chooser {  if ( noMet && check ( ) ) {  noMet = false NL appendArg ( condition , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL this NL }","func_name":"choose","docstring":""}
{"repo":"fountain","file":"Chooser.cj","path":"fountain/src/orm/Chooser.cj","code_tokens":"public func choose ( check : ( ) -> Bool , text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Chooser {  if ( noMet && check ( ) ) {  noMet = false NL appendText ( text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL this NL }","func_name":"choose","docstring":""}
{"repo":"fountain","file":"GroupedQueryMappers.cj","path":"fountain/src/orm/GroupedQueryMappers.cj","code_tokens":"static protected func create ( mappers ! : Array < QueryMapper < O > > , creator ! : ( ) -> O , grouped ! : Array < ( QueryMappers < G > , ( O ) -> C ) > , new ! : Bool = false ) : M {  throw UnreachableException ( unimplemented ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"GroupedQueryMappers.cj","path":"fountain/src/orm/GroupedQueryMappers.cj","code_tokens":"public func map ( result : QueryResult , next ! : Bool = false ) : Option < O > {  if ( new ) {  return GroupedQueryMappers < O , G , C , M > . create ( mappers : mappers , creator : creator , grouped : grouped ) . map ( result , next : next ) NL } NL  var groupKey =  NL  let val = if ( next ) {   var o = creator ( ) NL if ( result . next ( ) ) {  groupKey = populate ( result , o ) NL o NL } else {  None < O > NL } NL } else {   var o = creator ( ) NL groupKey = populate ( result , o ) NL o NL } NL match ( val ) { case Some ( v ) => groupedKeys . append ( groupKey ) NL  let groupedObj = groupedMap . putIfAbsent ( groupKey , v ) . get ( ) NL for ( ( gm , extractor ) in grouped ) {   let gv = match ( gm . map ( result ) ) { case Some ( gv ) => gv NL case _ => continue NL } NL putToCollection ( extractor ( groupedObj ) , gv ) NL } NL groupedObj NL case _ => None < O > NL } NL }","func_name":"map","docstring":""}
{"repo":"fountain","file":"GroupedQueryMappers.cj","path":"fountain/src/orm/GroupedQueryMappers.cj","code_tokens":"protected func putToCollection ( c : C , v : G ) : Unit","func_name":"putToCollection","docstring":""}
{"repo":"fountain","file":"GroupedQueryMappers.cj","path":"fountain/src/orm/GroupedQueryMappers.cj","code_tokens":"protected func populate ( result : QueryResult , o : O ) : String {  populateAndMakeGroupKey ( result , o ) NL }","func_name":"populate","docstring":""}
{"repo":"fountain","file":"GroupedQueryMappers.cj","path":"fountain/src/orm/GroupedQueryMappers.cj","code_tokens":"public func list ( result : QueryResult ) : ArrayList < O > {  groupedList ( result , groupedKeys , groupedMap ) NL }","func_name":"list","docstring":""}
{"repo":"fountain","file":"GroupedListQueryMappers.cj","path":"fountain/src/orm/GroupedListQueryMappers.cj","code_tokens":"protected func putToCollection ( list : L , v : G ) : Unit {  list . append ( v ) NL }","func_name":"putToCollection","docstring":""}
{"repo":"fountain","file":"GroupedListQueryMappers.cj","path":"fountain/src/orm/GroupedListQueryMappers.cj","code_tokens":"static protected func create ( mappers ! : Array < QueryMapper < O > > , creator ! : ( ) -> O , grouped ! : Array < ( QueryMappers < G > , ( O ) -> L ) > , new ! : Bool = false ) : GroupedListQueryMappers < O , G , L > {  GroupedListQueryMappers < O , G , L > ( mappers : mappers , creator : creator , grouped : grouped , new : new ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"LoopArg.cj","path":"fountain/src/orm/LoopArg.cj","code_tokens":"public func add ( dataType : DataType , condition : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : LoopArg < T > {  makeCondition ( dataType , condition , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"add","docstring":""}
{"repo":"fountain","file":"LoopArg.cj","path":"fountain/src/orm/LoopArg.cj","code_tokens":"public func add ( text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : LoopArg < T > {  makeCondition ( text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"add","docstring":""}
{"repo":"fountain","file":"Meeter.cj","path":"fountain/src/orm/Meeter.cj","code_tokens":"public func meet ( check : Bool , dataType : DataType , condition : String , value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Meeter {  if ( check ) {  noMet = false NL appendArg ( dataType , condition , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL this NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"Meeter.cj","path":"fountain/src/orm/Meeter.cj","code_tokens":"public func meet ( check : Bool , condition : String , value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Meeter {  if ( check ) {  noMet = false NL appendArg ( condition , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL this NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"Meeter.cj","path":"fountain/src/orm/Meeter.cj","code_tokens":"public func meet ( check : Bool , text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Meeter {  if ( check ) {  noMet = false NL appendText ( text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL this NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"protected func makeCondition ( check : ( T , Int64 , Int64 ) -> Bool , dataType : DataType , condition : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  executors . append { current : T , index : Int64 , size : Int64 => if ( check ( current , index , size ) ) {  noMet = false NL appendArg ( dataType , condition , current , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL } NL current NL }","func_name":"makeCondition","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"protected func makeCondition ( check : ( T , Int64 , Int64 ) -> Bool , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  executors . append { current : T , index : Int64 , size : Int64 => if ( check ( current , index , size ) ) {  noMet = false NL appendArg ( current , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL } NL current NL }","func_name":"makeCondition","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"protected func makeCondition ( check : ( T , Int64 , Int64 ) -> Bool , text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  executors . append { current : T , index : Int64 , size : Int64 => if ( check ( current , index , size ) ) {  noMet = false NL appendText ( text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL } NL current NL }","func_name":"makeCondition","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"protected func makeCondition ( dataType : DataType , condition : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  executors . append { current : T , index : Int64 , size : Int64 => noMet = false NL appendArg ( dataType , condition , current , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL current NL }","func_name":"makeCondition","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"protected func makeCondition ( dataType : DataType , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  makeCondition ( dataType ,  , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"makeCondition","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"protected func makeCondition ( delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  executors . append { current : T , index : Int64 , size : Int64 => noMet = false NL appendArg ( current , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL current NL }","func_name":"makeCondition","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"protected func makeCondition ( text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  executors . append { current : T , index : Int64 , size : Int64 => noMet = false NL appendText ( text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL current NL }","func_name":"makeCondition","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"public func otherwise ( dataType : DataType , condition : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  executors . append { current : T , index : Int64 , size : Int64 => super . otherwise ( dataType , condition , current , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL current NL }","func_name":"otherwise","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"public func otherwise ( dataType : DataType , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  otherwise ( dataType ,  , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"otherwise","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"public func otherwise ( delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  executors . append { current : T , index : Int64 , size : Int64 => super . otherwise ( current , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL current NL }","func_name":"otherwise","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"public func otherwise ( text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  executors . append { current : T , index : Int64 , size : Int64 => super . otherwise ( text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL current NL }","func_name":"otherwise","docstring":""}
{"repo":"fountain","file":"LoopCondition.cj","path":"fountain/src/orm/LoopCondition.cj","code_tokens":"open func execute ( current : T , index : Int64 , size : Int64 ) : Unit {  for ( exec in executors ) {  exec ( current , index , size ) NL } NL }","func_name":"execute","docstring":""}
{"repo":"fountain","file":"NoneConnection.cj","path":"fountain/src/orm/NoneConnection.cj","code_tokens":"public func prepareStmt ( sql : String ) : Statement {  throw IllegalAccessException ( ) NL }","func_name":"prepareStmt","docstring":""}
{"repo":"fountain","file":"NoneConnection.cj","path":"fountain/src/orm/NoneConnection.cj","code_tokens":"public func beginTx ( ) : Unit {  throw IllegalAccessException ( ) NL }","func_name":"beginTx","docstring":""}
{"repo":"fountain","file":"NoneConnection.cj","path":"fountain/src/orm/NoneConnection.cj","code_tokens":"public func commit ( ) : Unit {  throw IllegalAccessException ( ) NL }","func_name":"commit","docstring":""}
{"repo":"fountain","file":"NoneConnection.cj","path":"fountain/src/orm/NoneConnection.cj","code_tokens":"public func rollback ( ) : Unit {  throw IllegalAccessException ( ) NL }","func_name":"rollback","docstring":""}
{"repo":"fountain","file":"NoneConnection.cj","path":"fountain/src/orm/NoneConnection.cj","code_tokens":"public func isClosed ( ) : Bool {  true NL }","func_name":"isClosed","docstring":""}
{"repo":"fountain","file":"NoneConnection.cj","path":"fountain/src/orm/NoneConnection.cj","code_tokens":"public func close ( ) : Unit {  }","func_name":"close","docstring":""}
{"repo":"fountain","file":"LoopMeeter.cj","path":"fountain/src/orm/LoopMeeter.cj","code_tokens":"public func meet ( check : ( T , Int64 , Int64 ) -> Bool , dataType : DataType , condition : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : LoopMeeter < T > {  makeCondition ( check , dataType , condition , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"LoopMeeter.cj","path":"fountain/src/orm/LoopMeeter.cj","code_tokens":"public func meet ( check : ( T , Int64 , Int64 ) -> Bool , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : LoopMeeter < T > {  makeCondition ( check , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"LoopMeeter.cj","path":"fountain/src/orm/LoopMeeter.cj","code_tokens":"public func meet ( check : ( T , Int64 , Int64 ) -> Bool , text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : LoopMeeter < T > {  makeCondition ( check , text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"Condition.cj","path":"fountain/src/orm/Condition.cj","code_tokens":"public open func otherwise ( text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  if ( noMet ) {  appendText ( text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL current NL }","func_name":"otherwise","docstring":""}
{"repo":"fountain","file":"Condition.cj","path":"fountain/src/orm/Condition.cj","code_tokens":"public func otherwise ( dataType : DataType , condition : String , value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  if ( noMet ) {  appendArg ( dataType , condition , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL current NL }","func_name":"otherwise","docstring":""}
{"repo":"fountain","file":"Condition.cj","path":"fountain/src/orm/Condition.cj","code_tokens":"public func otherwise ( condition : String , value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  if ( noMet ) {  appendArg ( condition , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL } NL current NL }","func_name":"otherwise","docstring":""}
{"repo":"fountain","file":"Condition.cj","path":"fountain/src/orm/Condition.cj","code_tokens":"public func otherwise ( value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : C {  otherwise (  , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"otherwise","docstring":""}
{"repo":"fountain","file":"Condition.cj","path":"fountain/src/orm/Condition.cj","code_tokens":"protected func appendArg ( condition : String , value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  args . append ( value ) NL match ( delimiterPosition ) { case Prepend => builder . append (   ) . append ( delimiter ) . append (   ) . append ( condition ) . append (  ?  ) NL case Append => builder . append (   ) . append ( condition ) . append (  ?  ) . append ( delimiter ) . append (   ) NL } NL }","func_name":"appendArg","docstring":""}
{"repo":"fountain","file":"Condition.cj","path":"fountain/src/orm/Condition.cj","code_tokens":"protected func appendArg ( value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  appendArg (  , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"appendArg","docstring":""}
{"repo":"fountain","file":"Condition.cj","path":"fountain/src/orm/Condition.cj","code_tokens":"protected func appendArg ( dataType : DataType , condition : String , value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  args . append ( dataType , value ) NL match ( delimiterPosition ) { case Prepend => builder . append (   ) . append ( delimiter ) . append (   ) . append ( condition ) . append (  ?  ) NL case Append => builder . append (   ) . append ( condition ) . append (  ?  ) . append ( delimiter ) . append (   ) NL } NL }","func_name":"appendArg","docstring":""}
{"repo":"fountain","file":"Condition.cj","path":"fountain/src/orm/Condition.cj","code_tokens":"protected func appendArg ( dataType : DataType , value : Option < Any > , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  appendArg ( dataType ,  , value , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"appendArg","docstring":""}
{"repo":"fountain","file":"Condition.cj","path":"fountain/src/orm/Condition.cj","code_tokens":"protected func appendText ( text : String , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  match ( delimiterPosition ) { case Prepend => builder . append (   ) . append ( delimiter ) . append (   ) . append ( text ) . append (   ) NL case Append => builder . append (   ) . append ( text ) . append (   ) . append ( delimiter ) . append (   ) NL } NL }","func_name":"appendText","docstring":""}
{"repo":"fountain","file":"Loop.cj","path":"fountain/src/orm/Loop.cj","code_tokens":"public func meeter ( prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  ) : LoopMeeter < T > {   let condition = LoopMeeter < T > ( args , this , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead , builder : builder ) NL conditions . append ( condition ) NL condition NL }","func_name":"meeter","docstring":""}
{"repo":"fountain","file":"Loop.cj","path":"fountain/src/orm/Loop.cj","code_tokens":"public func chooser ( prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  ) : LoopChooser < T > {   let condition = LoopChooser < T > ( args , this , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead , builder : builder ) NL conditions . append ( condition ) NL condition NL }","func_name":"chooser","docstring":""}
{"repo":"fountain","file":"Loop.cj","path":"fountain/src/orm/Loop.cj","code_tokens":"public func meet ( check : ( T , Int64 , Int64 ) -> Bool , dataType : DataType , condition : String , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Loop < T > {  meeter ( prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead ) . meet ( check , dataType , condition , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL this NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"Loop.cj","path":"fountain/src/orm/Loop.cj","code_tokens":"public func meet ( check : ( T , Int64 , Int64 ) -> Bool , text : String , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Loop < T > {  meeter ( prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead ) . meet ( check , text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL this NL }","func_name":"meet","docstring":""}
{"repo":"fountain","file":"Loop.cj","path":"fountain/src/orm/Loop.cj","code_tokens":"public func append ( dataType : DataType , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) {  append ( dataType ,  , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimTail , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"Loop.cj","path":"fountain/src/orm/Loop.cj","code_tokens":"public func append ( dataType : DataType , condition : String , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Loop < T > {   let arg = LoopArg < T > ( args , this , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead , builder : builder ) NL arg . add ( dataType , condition , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL conditions . append ( arg ) NL this NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"Loop.cj","path":"fountain/src/orm/Loop.cj","code_tokens":"public func append ( text : String , prefix ! : String =  , suffix ! : String =  , trimHead ! : String =  , trimTail ! : String =  , delimiter ! : String =  , delimiterPosition ! : DelimiterPosition = Append ) : Loop < T > {   let arg = LoopArg < T > ( args , this , prefix : prefix , suffix : suffix , trimHead : trimHead , trimTail : trimHead , builder : builder ) NL arg . add ( text , delimiter : delimiter , delimiterPosition : delimiterPosition ) NL conditions . append ( arg ) NL this NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func setSql ( sql : String ) : RootDAO < T > {  executor . setSql ( sql ) NL this NL }","func_name":"setSql","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func setArgs ( args : Iterable < ( DataType , Option < Any > ) > ) : RootDAO < T > {  executor . setArgs ( args ) NL this NL }","func_name":"setArgs","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func generateSql ( generator : ( SqlArgs ) -> String ) : RootDAO < T > {  executor . generateSql ( generator ) NL this NL }","func_name":"generateSql","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func execute ( executor : ( SqlExecutor ) -> T ) : T {  this . executor . execute < T > ( executor ) NL }","func_name":"execute","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func one ( mappers : QueryMappers < T > ) : Option < T > {  executor . one < T > ( mappers ) NL }","func_name":"one","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func stream ( mappers : QueryMappers < T > ) : Stream < T > {  executor . stream < T > ( mappers ) NL }","func_name":"stream","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func list ( mappers : QueryMappers < T > ) : ArrayList < T > {  executor . list < T > ( mappers ) NL }","func_name":"list","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func first ( mappers : QueryMappers < T > ) : Option < T > {  executor . first < T > ( mappers ) NL }","func_name":"first","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func list ( mapper : QueryMapper < T > ) : ArrayList < Option < T > > {  executor . list < T > ( mapper ) NL }","func_name":"list","docstring":""}
{"repo":"fountain","file":"RootDAO.cj","path":"fountain/src/orm/RootDAO.cj","code_tokens":"func first ( mapper : QueryMapper < T > ) : Option < T > {  executor . first < T > ( mapper ) NL }","func_name":"first","docstring":""}
{"repo":"fountain","file":"Aspects.cj","path":"fountain/src/aspect/Aspects.cj","code_tokens":"static public func register ( aspect : Aspect ) {  register ( aspect . name , aspect . proceed ) NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"Aspects.cj","path":"fountain/src/aspect/Aspects.cj","code_tokens":"static public func register ( factory : BeanFactory ) {  factory . use < Aspect > ( register ) NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"Aspects.cj","path":"fountain/src/aspect/Aspects.cj","code_tokens":"static public func register ( name : String , fn : ( Array < Any > , ( ) -> Any ) -> Any ) : Unit {  if ( aspects . putIfNonExistent ( name , fn ) . some ) {  throw AspectException ( duplicate aspect name: ${name} ) NL } NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"Aspects.cj","path":"fountain/src/aspect/Aspects.cj","code_tokens":"static public func proceed ( name : String , args : Array < Any > , fn : ( ) -> Any ) : Any {  aspects [ name ] ( args , fn ) NL }","func_name":"proceed","docstring":""}
{"repo":"fountain","file":"AspectProceeder.cj","path":"fountain/src/aspect/AspectProceeder.cj","code_tokens":"public func AspectProceeder < T > ( name : String , args : Array < Any > , fn : ( ) -> Any ) : T {   let result = Aspects . proceed ( name , args , fn ) NL match ( result ) { case x : T => x NL case _ => throw TypeCastException ( ) NL } NL }","func_name":"AspectProceeder","docstring":"//本函数不是给开发者用的，是给@PointCut生成切点使用的"}
{"repo":"fountain","file":"Aspect.cj","path":"fountain/src/aspect/Aspect.cj","code_tokens":"func before ( args : Array < Any > ) : Bool {  true NL }","func_name":"before","docstring":""}
{"repo":"fountain","file":"Aspect.cj","path":"fountain/src/aspect/Aspect.cj","code_tokens":"func after ( args : Array < Any > , result : Any ) : Any {  result NL }","func_name":"after","docstring":""}
{"repo":"fountain","file":"Aspect.cj","path":"fountain/src/aspect/Aspect.cj","code_tokens":"func around ( args : Array < Any > , point : ( ) -> Any ) : Any {  point ( ) NL }","func_name":"around","docstring":""}
{"repo":"fountain","file":"Aspect.cj","path":"fountain/src/aspect/Aspect.cj","code_tokens":"func thrown ( e : Exception ) : Exception {  throw e NL }","func_name":"thrown","docstring":""}
{"repo":"fountain","file":"Aspect.cj","path":"fountain/src/aspect/Aspect.cj","code_tokens":"func proceed ( args : Array < Any > , point : ( ) -> Any ) : Any {  try {  if ( before ( args ) ) {   let result = around ( args , point ) NL after ( args , result ) NL } else {  throw AspectException ( ) NL } NL } catch ( e : AspectException ) {  throw e NL } catch ( e : Exception ) {  throw thrown ( e ) NL } NL }","func_name":"proceed","docstring":""}
{"repo":"fountain","file":"AspectCreation.cj","path":"fountain/src/aspect/annotation/AspectCreation.cj","code_tokens":"func generateTokens ( name : Token , decl : CompositDeclMethod , input : Tokens ) : Tokens {  if ( decl . getGeneric ( ) . some ) {  throw AspectException ( an Aspect decleration must not be with generic type ) NL } NL  var proceed = Token ( IDENTIFIER ,  ) NL  var isStatic = false NL  var accessible = false NL for ( member in decl . getBody ( ) where member . isFuncDecl ( ) ) {   let funcDecl = member . asFuncDecl ( ) NL isStatic = macro_fragments . isStatic ( member ) NL accessible = macro_fragments . isPublic ( member ) NL if ( funcDecl . getGeneric ( ) . some ) {  isStatic = false NL accessible = false NL continue NL } NL  let params = funcDecl . getParamList ( ) . getParams ( ) NL if ( params . size != 2 ) {  isStatic = false NL accessible = false NL continue NL } NL  let first = params [ 0 ] . toTokens ( ) NL if ( let ( IDENTIFIER , Array , LT , IDENTIFIER , Any , GT ) = ( first [ 0 ] . kind , first [ 0 ] . value , first [ 1 ] . kind , first [ 2 ] . kind , first [ 2 ] . value , first [ 3 ] . kind ) ) {  } else {  isStatic = false NL accessible = false NL continue NL } NL  let second = params [ 1 ] . toTokens ( ) NL if ( let ( LPAREN , RPAREN , ARROW , IDENTIFIER , Any ) = ( second [ 0 ] . kind , second [ 1 ] . kind , second [ 2 ] . kind , second [ 3 ] . kind , second [ 3 ] . value ) ) {  } else {  isStatic = false NL accessible = false NL continue NL } NL  let returnType = if ( let Some ( rt ) = funcDecl . getType ( ) ) {   let rtTokens = rt . toTokens ( ) NL if ( let ( 1 , IDENTIFIER , Any ) = ( rtTokens . size , rtTokens [ 0 ] . kind , rtTokens [ 0 ] . value ) ) {  `any` NL } else {  isStatic = false NL accessible = false NL continue NL } NL } else {  `any` NL } NL proceed = funcDecl . getIdentifier ( ) NL break NL } NL if ( ! accessible ) {  throw AspectException ( no func is matched in Aspect decleration ${decl.getIdentifier().value} for aspect ${name.value} ) NL } NL input + `nl` + if ( isStatic ) {  if ( proceed . value ==  ) {  quote ( \\n let _ = { => throw AspectException ( proceed func is not found ) } ( ) \\n ) NL } else {  quote ( \\n let _ = { => \\n Aspects . register ( $name , $ ( decl . getIdentifier ( ) ) . $proceed ) \\n } ( ) \\n ) NL } NL } else {  quote ( \\n let _ = { => \\n let aspectInstance = $ ( decl . getIdentifier ( ) ) ( ) \\n var name = $name \\n if ( name ==  && aspectInstance is aspect . Aspect ) { \\n name = aspectInstance . name \\n } \\n if ( name ==  ) { \\n throw AspectException ( name of Aspect is empty ) \\n } \\n if ( aspectInstance is aspect . Aspect ) { \\n Aspects . register ( $name , aspectInstance . proceed ) \\n } else { \\n ) + `nl` + if ( proceed . value ==  ) {  quote ( \\n throw AspectException ( proceed func is not found ) \\n ) NL } else {  quote ( \\n Aspects . register ( $name , aspectInstance . $proceed ) \\n ) NL } + `rcurl` + `nl` + `rcurl` + `lparen` + `rparen` NL } NL }","func_name":"generateTokens","docstring":""}
{"repo":"fountain","file":"PointCut.cj","path":"fountain/src/aspect/annotation/PointCut.cj","code_tokens":"func weaveProp ( attr : Tokens , decl : PropDecl ) : Tokens {   var getAspect = `empty_string` [ 0 ] NL  var setAspect = `empty_string` [ 0 ] NL if ( attr . size > 3 ) {  match ( ( attr [ 0 ] . value , attr [ 3 ] . value ) ) { case ( get , set ) => getAspect = attr [ 2 ] NL setAspect = attr [ 5 ] NL case ( set , get ) => setAspect = attr [ 2 ] NL setAspect = attr [ 5 ] NL case _ => throw AspectException ( attr . toString ( ) ) NL } NL } else {  match ( attr [ 0 ] . value ) { case get => getAspect = attr [ 2 ] NL case set => setAspect = attr [ 2 ] NL case getset | setget => getAspect = attr [ 2 ] NL setAspect = attr [ 2 ] NL case _ => throw AspectException ( attr . toString ( ) ) NL } NL } NL  let getDecl = if ( getAspect . value !=  ) {   let getFunc = decl . getGetter ( ) . getOrThrow ( ) NL quote ( \\n get ( ) { \\n func fn___ ( ) { \\n $ ( getFunc . getBody ( ) ) \\n } \\n AspectProceeder < $ ( decl . getType ( ) ) > ( $getAspect , [ ] ) { \\n fn___ ( [ ] ) \\n } \\n } \\n ) NL } else {  decl . getGetter ( ) . getOrThrow ( ) . toTokens ( ) NL } NL  let setDecl = if ( let Some ( s ) = decl . getSetter ( ) ) {  if ( setAspect . value !=  ) {  quote ( \\n set ( $ ( s . getParamList ( ) . toTokens ( ) ) ) { \\n fn___ ( ) : Unit { \\n $ ( s . getBody ( ) ) \\n ( ) \\n } \\n let valarg = [ s . getParamList ( ) . toTokens ( ) [ 0 ] ] \\n AspectProceeder < Unit > ( $getAspect , valarg ) { \\n fn___ ( valarg ) \\n } \\n } \\n ) NL } else {  s . toTokens ( ) NL } NL } else {  `empty_tokens` NL } NL  let varlet = if ( decl . hasVar ( ) ) {  `var` NL } else {  `let` NL } NL quote ( \\n $ ( decl . getModifiers ( ) ) prop $varlet $ ( decl . getIdentifier ( ) ) : $ ( decl . getType ( ) . toTokens ( ) ) { \\n $getDecl \\n $setDecl \\n } \\n ) NL }","func_name":"weaveProp","docstring":""}
{"repo":"fountain","file":"PointCut.cj","path":"fountain/src/aspect/annotation/PointCut.cj","code_tokens":"func weaveFunc ( attr : Tokens , decl : FuncDecl ) : Tokens {  if ( attr . size > 1 ) {  throw AspectException ( too many attrs for Pointcut ) NL } NL  let name = extractFirstTokenToStringLiteral ( attr ) NL  let params = decl . getParamList ( ) NL  var returnType = match ( decl . getType ( ) ) { case Some ( t ) => t . toTokens ( ) NL case _ => `empty_tokens` NL } NL  let genericReturnType = if ( returnType . size > 0 ) {   let rtype = returnType NL returnType = `colon` + rtype NL quote ( < $rtype > ) NL } else {  `empty_tokens` NL } NL  var args = extractArgs ( params ) NL  let generic = extractGeneric ( decl . getGeneric ( ) ) NL  var genericParams = generic [ 0 ] NL  var genericConstraints = generic [ 1 ] NL quote ( \\n $ ( decl . getModifiers ( ) ) func $ ( decl . getIdentifier ( ) ) $genericParams $params $returnType $genericConstraints { \\n func $ ( decl . getIdentifier ( ) ) $genericParams $params $returnType $genericConstraints { \\n $ ( decl . getBody ( ) ) \\n } \\n AspectProceeder $genericReturnType ( $name , $args ) { \\n $ ( decl . getIdentifier ( ) ) $genericParams ( $args ) \\n } \\n } \\n ) NL }","func_name":"weaveFunc","docstring":""}
{"repo":"fountain","file":"RangeIterator.cj","path":"fountain/src/stream/RangeIterator.cj","code_tokens":"public func next ( ) : Option < T > {  if ( finished ) {  return None < T > NL } NL while ( true ) {  match ( currentRange ) { case Some ( r ) =>  let v = itr . next ( ) NL if ( let None < T > = v ) {  finished = true NL return v NL } NL current ++ NL if ( current - 1 == r ) {  currentRange = rangeIterator . next ( ) NL return v NL } NL case _ => finished = true NL return None < T > NL } NL } NL None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"GreaterStream.cj","path":"fountain/src/stream/GreaterStream.cj","code_tokens":"func max ( ) : Option < T >","func_name":"max","docstring":""}
{"repo":"fountain","file":"GreaterStream.cj","path":"fountain/src/stream/GreaterStream.cj","code_tokens":"public func max ( ) : Option < T > {  max { v , s => if ( v > s ) {  GT NL } else {  LT NL } NL } NL }","func_name":"max","docstring":""}
{"repo":"fountain","file":"SkipIterator.cj","path":"fountain/src/stream/SkipIterator.cj","code_tokens":"public func next ( ) : Option < T > {  if ( skipped ) {  return itr . next ( ) NL } NL  var val = None < T > NL do {  val = itr . next ( ) NL current ++ NL } while ( current < skip && val . some ) NL skipped = true NL if ( val . none ) {  if ( toThrowIfOutOfBounds ) {  throw IndexOutOfBoundsException ( ) NL } else {  return val NL } NL } NL for ( i in itr ) {  return i NL } NL None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"DistinctStream.cj","path":"fountain/src/stream/DistinctStream.cj","code_tokens":"func distinct ( ) : Stream < T >","func_name":"distinct","docstring":""}
{"repo":"fountain","file":"DistinctStream.cj","path":"fountain/src/stream/DistinctStream.cj","code_tokens":"public func distinct ( ) : Stream < T > {  itr = DistinctIterator < T > ( itr ) NL return this NL }","func_name":"distinct","docstring":""}
{"repo":"fountain","file":"PeekIterator.cj","path":"fountain/src/stream/PeekIterator.cj","code_tokens":"public func next ( ) : Option < T > {  for ( i in itr ) {  consumer ( i ) NL return i NL } NL None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"FlatMapperIterator.cj","path":"fountain/src/stream/FlatMapperIterator.cj","code_tokens":"public func next ( ) : Option < R > {  while ( true ) {  if ( let Some ( c ) = current ) {  for ( r in c ) {  return r NL } NL } NL  var notToBeContinued = true NL for ( i in itr ) {  current = fn ( i ) . iterator ( ) NL notToBeContinued = false NL break NL } NL if ( notToBeContinued ) {  return None < R > NL } NL } NL return None < R > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"FlatIterableIterator.cj","path":"fountain/src/stream/FlatIterableIterator.cj","code_tokens":"public func next ( ) : Option < T > {  if ( let Some ( c ) = current ) {  for ( i in c ) {  return i NL } NL } NL for ( i in itr ) {  current = i . iterator ( ) NL return next ( ) NL } NL return None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ReversedIterator.cj","path":"fountain/src/stream/ReversedIterator.cj","code_tokens":"public func next ( ) : Option < T > {  if ( ! reversed ) {  for ( v in itr ) {  elements . append ( v ) NL } NL index = elements . size NL reversed = true NL } NL if ( index > 0 ) {  index -- NL return elements [ index ] NL } NL None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"func parallelEach ( fn : ( T ) -> Unit ) : Unit","func_name":"parallelEach","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"func parallelCollect ( initial : Any , aggregator : ( T , Any ) -> Any ) : Unit","func_name":"parallelCollect","docstring":"//接口不支持定义泛型函数，只能用Any代替"}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"func parallel ( ) : Stream < Future < Option < T > > >","func_name":"parallel","docstring":"//all operations are parallel before the invocation of this func and sequencial after"}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"func parallelNone ( predicate : ( T ) -> Bool , timeout ! : UInt64 ) : Bool","func_name":"parallelNone","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"func parallelAll ( predicate : ( T ) -> Bool , timeout ! : UInt64 ) : Bool","func_name":"parallelAll","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"func parallelAll ( timeout ! : UInt64 ) : Unit","func_name":"parallelAll","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"func parallelAny ( predicate : ( T ) -> Bool , timeout ! : UInt64 ) : Bool","func_name":"parallelAny","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"func parallelAny ( timeout ! : UInt64 ) : Unit","func_name":"parallelAny","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"public func parallelEach ( fn : ( T ) -> Unit ) : Unit {   let itr = this . map < Unit > ( fn ) . parallel ( ) NL for ( n in itr ) {  } NL }","func_name":"parallelEach","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"public func parallelCollect ( initial : Any , aggregator : ( T , Any ) -> Any ) : Unit {   let box = AtomicReference < Box < Any > > ( Box < Any > ( initial ) ) NL parallelEach { t =>  let r = aggregator ( t , box . load ( ) . value ) NL box . load ( ) . value = r NL } NL }","func_name":"parallelCollect","docstring":"//接口不支持定义泛型函数，只能用Any代替"}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"public func parallel ( ) : Stream < Future < Option < T > > > {  Stream < Future < Option < T > > > ( ParallelismIterator < T > ( itr ) ) NL }","func_name":"parallel","docstring":"//all operations are parallel before the invocation of this func and sequencial after"}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"public func parallelNone ( predicate : ( T ) -> Bool , timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {   let result = AtomicBool ( false ) NL  let monitor = Monitor ( ) NL filter { v =>  let r = predicate ( v ) NL if ( r ) {  result . store ( true ) NL synchronized ( monitor ) {  monitor . notifyAll ( ) NL } NL } NL r NL } . parallel ( ) . each { v => ( ) NL } NL synchronized ( monitor ) {  monitor . wait ( timeout : timeout ) NL } NL return ! result . load ( ) NL }","func_name":"parallelNone","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"public func parallelAll ( predicate : ( T ) -> Bool , timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {  ! this . parallelNone ( { v => ! predicate ( v ) NL } , timeout : timeout ) NL }","func_name":"parallelAll","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"public func parallelAll ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Unit {  parallelAll ( { v => true NL } , timeout : timeout ) NL }","func_name":"parallelAll","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"public func parallelAny ( predicate : ( T ) -> Bool , timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {   let result = AtomicBool ( false ) NL  let monitor = Monitor ( ) NL filter { v =>  let r = predicate ( v ) NL if ( r ) {  result . store ( r ) NL synchronized ( monitor ) {  monitor . notifyAll ( ) NL } NL } NL r NL } . parallel ( ) . each { v => ( ) NL } NL synchronized ( monitor ) {  monitor . wait ( timeout : timeout ) NL } NL }","func_name":"parallelAny","docstring":""}
{"repo":"fountain","file":"ParallelStream.cj","path":"fountain/src/stream/ParallelStream.cj","code_tokens":"public func parallelAny ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Unit {  parallelAny ( { v => true NL } , timeout : timeout ) NL }","func_name":"parallelAny","docstring":""}
{"repo":"fountain","file":"NumberStream.cj","path":"fountain/src/stream/NumberStream.cj","code_tokens":"func add ( i : T ) : Stream < T >","func_name":"add","docstring":"//对每个元素v执行v + i"}
{"repo":"fountain","file":"NumberStream.cj","path":"fountain/src/stream/NumberStream.cj","code_tokens":"func sub ( i : T ) : Stream < T >","func_name":"sub","docstring":"//对每个元素v执行v - i"}
{"repo":"fountain","file":"NumberStream.cj","path":"fountain/src/stream/NumberStream.cj","code_tokens":"func mul ( i : T ) : Stream < T >","func_name":"mul","docstring":"//对每个元素v执行v * i"}
{"repo":"fountain","file":"NumberStream.cj","path":"fountain/src/stream/NumberStream.cj","code_tokens":"func div ( i : T ) : Stream < T >","func_name":"div","docstring":"//对每个元素v执行v / i"}
{"repo":"fountain","file":"NumberStream.cj","path":"fountain/src/stream/NumberStream.cj","code_tokens":"public func add ( i : T ) : Stream < T > {  this . map { v => v + i NL } NL }","func_name":"add","docstring":"//对每个元素v执行v + i"}
{"repo":"fountain","file":"NumberStream.cj","path":"fountain/src/stream/NumberStream.cj","code_tokens":"public func sub ( i : T ) : Stream < T > {  this . map { v => v - i NL } NL }","func_name":"sub","docstring":"//对每个元素v执行v - i"}
{"repo":"fountain","file":"NumberStream.cj","path":"fountain/src/stream/NumberStream.cj","code_tokens":"public func mul ( i : T ) : Stream < T > {  this . map { v => v * i NL } NL }","func_name":"mul","docstring":"//对每个元素v执行v * i"}
{"repo":"fountain","file":"NumberStream.cj","path":"fountain/src/stream/NumberStream.cj","code_tokens":"public func div ( i : T ) : Stream < T > {  this . map { v => v / i NL } NL }","func_name":"div","docstring":"//对每个元素v执行v / i"}
{"repo":"fountain","file":"MapperIterator.cj","path":"fountain/src/stream/MapperIterator.cj","code_tokens":"public func next ( ) : Option < R > {  for ( i in itr ) {  return fn ( i ) NL } NL return None < R > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"DistinctIterator.cj","path":"fountain/src/stream/DistinctIterator.cj","code_tokens":"public func next ( ) : Option < T > {  for ( i in itr ) {  if ( ! set . contains ( i ) ) {  set . put ( i ) NL return i NL } NL } NL return None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"static public func create ( input : InputStream , bufsize ! : Int64 = 4096 ) : Stream < Array < Byte > > {  Stream < Array < Byte > > ( InputStreamIterator ( input , bufsize ) ) NL }","func_name":"create","docstring":"//用InputStream创建一个流"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func next ( ) : Option < T > {  itr . next ( ) NL }","func_name":"next","docstring":"//返回下一个元素"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func isEmpty ( ) : Bool {  next ( ) . none NL }","func_name":"isEmpty","docstring":"//判定当前流是否还有元素，如果没有元素了会返回true，当然调用本方法会迭代过去一个元素"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"static public func concat ( iterables : Iterable < Iterable < T > > ) : Stream < T > {  return Stream < T > ( FlatIterableIterator ( iterables ) ) NL }","func_name":"concat","docstring":"//返回迭代器展开构造成一个流"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func count ( ) : Int64 {   var c = 0 NL for ( i in this ) {  c ++ NL } NL return c NL }","func_name":"count","docstring":"//迭代一遍流返回元素数量"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func min ( fn : ( T , T ) -> Ordering ) : Option < T > {  return reduce < T > ( { v , s => fn ( v , s ) . lt NL } , { v , opt => v NL } ) NL }","func_name":"min","docstring":"//求流内最小值，该值作为fn第一个参数，对其它所有值都返回LT"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func min ( comparator : Comparator < T > ) : Option < T > {  min ( comparator . comparator ) NL }","func_name":"min","docstring":"//求流内最小值，该值作为fn第一个参数，对其它所有值都返回LT"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func max ( fn : ( T , T ) -> Ordering ) : Option < T > {  return reduce < T > ( { v , s => fn ( v , s ) . gt NL } , { v , opt => v NL } ) NL }","func_name":"max","docstring":"//求流内最小值，该值作为fn第一个参数，对其它所有值都返回GT"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func max ( comparator : Comparator < T > ) : Option < T > {  max ( comparator . comparator ) NL }","func_name":"max","docstring":"//求流内最小值，该值作为fn第一个参数，对其它所有值都返回GT"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func each ( fn : ( T ) -> Unit ) : Unit {  for ( o in this ) {  fn ( o ) NL } NL }","func_name":"each","docstring":"//迭代一遍流，每个元素传入fn，这是流结束函数之一"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func reduce < R > ( initial : ( ) -> R , checker : ( T , R ) -> Bool , aggregator : ( T , R ) -> R ) : R {  return reduce < R > ( initial ( ) , checker , aggregator ) NL }","func_name":"reduce","docstring":"/* initial 创建一个初始值，每一个checker是true的元素跟上一个元素的聚合结果一起传入aggregator返回聚合值，\n       如果当前是第一个元素则传入当前值跟初始值*/"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func reduce < R > ( initial : R , checker : ( T , R ) -> Bool , aggregator : ( T , R ) -> R ) : R {   let r = Box < R > ( initial ) NL each { v => if ( checker ( v , r . value ) ) {  r . value = aggregator ( v , r . value ) NL } NL } NL return r . value NL }","func_name":"reduce","docstring":"/* initial 创建一个初始值，每一个checker是true的元素跟上一个元素的聚合结果一起传入aggregator返回聚合值，\n       如果当前是第一个元素则传入当前值跟初始值*/"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func reduce < R > ( initial : ( ) -> R , aggregator : ( T , R ) -> R ) : R {  return reduce < R > ( initial ( ) , aggregator ) NL }","func_name":"reduce","docstring":"/* initial 创建一个初始值，每一个checker是true的元素跟上一个元素的聚合结果一起传入aggregator返回聚合值，\n       如果当前是第一个元素则传入当前值跟初始值*/"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func reduce < R > ( initial : R , aggregator : ( T , R ) -> R ) : R {   let r = Box < R > ( initial ) NL each { v => r . value = aggregator ( v , r . value ) NL } NL return r . value NL }","func_name":"reduce","docstring":"/* initial 创建一个初始值，每一个checker是true的元素跟上一个元素的聚合结果一起传入aggregator返回聚合值，\n       如果当前是第一个元素则传入当前值跟初始值*/"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func reduce < R > ( checker : ( T , R ) -> Bool , aggregator : ( T , Option < R > ) -> R ) : Option < R > {   let r = Box < Option < R > > ( None < R > ) NL each { v => match ( r . value ) { case Some ( s ) where checker ( v , s ) => r . value = aggregator ( v , Some ( s ) ) NL case Some ( _ ) => ( ) NL case None => r . value = aggregator ( v , None < R > ) NL } NL } NL return r . value NL }","func_name":"reduce","docstring":"/* initial 创建一个初始值，每一个checker是true的元素跟上一个元素的聚合结果一起传入aggregator返回聚合值，\n       如果当前是第一个元素则传入当前值跟初始值*/"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func reduce < R > ( aggregator : ( T , Option < R > ) -> R ) : Option < R > {   let r = Box < Option < R > > ( None < R > ) NL each { v => r . value = match ( r . value ) { case Some ( s ) => aggregator ( v , Some ( s ) ) NL case None => aggregator ( v , None < R > ) NL } NL } NL return r . value NL }","func_name":"reduce","docstring":"/* initial 创建一个初始值，每一个checker是true的元素跟上一个元素的聚合结果一起传入aggregator返回聚合值，\n       如果当前是第一个元素则传入当前值跟初始值*/"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func collect < R > ( initial : ( ) -> R , aggregator : ( T , R ) -> R ) : R {  return collect < R > ( initial ( ) , aggregator ) NL }","func_name":"collect","docstring":"//聚合流内每个元素"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func collect < R > ( initial : R , aggregator : ( T , R ) -> R ) : R {   let box = Box < R > ( initial ) NL each { t => box . value = aggregator ( t , box . value ) NL } NL return box . value NL }","func_name":"collect","docstring":"//聚合流内每个元素"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func collectString ( delimiter ! : String =  ) : String {  String . join ( cast < ToString > ( throwIfNotMatch : true ) , delimiter : delimiter ) NL }","func_name":"collectString","docstring":"//把流内各元素连接成一个字符串"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K , V > ( initial : ( ) -> Map < K , ArrayList < V > > , keyMapper : ( T ) -> Option < K > , valueMapper : ( T ) -> Option < V > ) : Map < K , ArrayList < V > > where K <: Equatable < K > {  collect < Map < K , ArrayList < V > > > ( initial ) { t , m => match ( ( keyMapper ( t ) , valueMapper ( t ) ) ) { case ( Some ( k ) , Some ( v ) ) =>  let listOpt : Option < ArrayList < V > > = m . get ( k ) NL match ( listOpt ) { case Some ( l ) => l . append ( v ) NL case _ =>  var l = ArrayList < V > ( ) NL l . append ( v ) NL m . put ( k , l ) NL ( ) NL } NL case _ => ( ) NL } NL return m NL } NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K > ( initial : ( ) -> Map < K , ArrayList < T > > , keyMapper : ( T ) -> Option < K > ) : Map < K , ArrayList < T > > where K <: Equatable < K > {  group < K , T > ( initial , keyMapper ) { t => t as T NL } NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K , V > ( keyMapper : ( T ) -> Option < K > , valueMapper : ( T ) -> Option < V > ) : Map < K , ArrayList < V > > where K <: Hashable & Equatable < K > {  group < K , V > ( { => HashMap < K , ArrayList < V > > ( ) NL } , keyMapper , valueMapper ) NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K > ( keyMapper : ( T ) -> Option < K > ) : Map < K , ArrayList < T > > where K <: Hashable & Equatable < K > {  group < K , T > ( { => HashMap < K , ArrayList < T > > ( ) NL } , keyMapper ) { t => t as T NL } NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K , V > ( initial : ( ) -> Map < K , Set < V > > , setInitial : ( ) -> Set < V > , keyMapper : ( T ) -> Option < K > , valueMapper : ( T ) -> Option < V > ) : Map < K , Set < V > > where K <: Equatable < K > , V <: Equatable < V > {  collect < Map < K , Set < V > > > ( initial ) { t , m => match ( ( keyMapper ( t ) , valueMapper ( t ) ) ) { case ( Some ( k ) , Some ( v ) ) =>  let setOpt = m . get ( k ) NL match ( setOpt ) { case Some ( s ) => s . put ( v ) NL case _ =>  var s = setInitial ( ) NL s . put ( v ) NL m . put ( k , s ) NL ( ) NL } NL case _ => ( ) NL } NL return m NL } NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K , V > ( initial : ( ) -> Map < K , Set < V > > , setInitial : ( ) -> Set < V > , keyMapper : ( T ) -> Option < K > ) : Map < K , Set < V > > where K <: Equatable < K > , V <: Equatable < V > {  group ( initial , setInitial , keyMapper , { t : T => t as V NL } ) NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K , V > ( initial : ( ) -> Map < K , Set < V > > , keyMapper : ( T ) -> Option < K > , valueMapper : ( T ) -> Option < V > ) : Map < K , Set < V > > where K <: Equatable < K > , V <: Hashable & Equatable < V > {  group ( initial , { => HashSet < V > ( ) NL } , keyMapper , valueMapper ) NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K , V > ( initial : ( ) -> Map < K , Set < V > > , keyMapper : ( T ) -> Option < K > ) : Map < K , Set < V > > where K <: Equatable < K > , V <: Hashable & Equatable < V > {  group ( initial , { => HashSet < V > ( ) NL } , keyMapper , { t : T => t as V NL } ) NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K , V > ( keyMapper : ( T ) -> Option < K > , valueMapper : ( T ) -> Option < V > ) : Map < K , Set < V > > where K <: Hashable & Equatable < K > , V <: Hashable & Equatable < V > {  group ( { => HashMap < K , Set < V > > ( ) NL } , { => HashSet < V > ( ) NL } , keyMapper , valueMapper ) NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func group < K , V > ( keyMapper : ( T ) -> Option < K > ) : Map < K , Set < V > > where K <: Hashable & Equatable < K > , V <: Hashable & Equatable < V > {  group ( { => HashMap < K , Set < V > > ( ) NL } , { => HashSet < V > ( ) NL } , keyMapper , { t : T => t as V NL } ) NL }","func_name":"group","docstring":"//将流内按keyMapper的返回值元素分组，"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toMap < K > ( keyMapper : ( T ) -> Option < K > ) : Map < K , T > where K <: Hashable & Equatable < K > {  toMap < K , T > ( { => HashMap < K , T > ( ) NL } , keyMapper , { t => t NL } ) NL }","func_name":"toMap","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toMap < K > ( initial : ( ) -> Map < K , T > , keyMapper : ( T ) -> Option < K > ) : Map < K , T > where K <: Equatable < K > {  toMap < K , T > ( initial , keyMapper , { t => t NL } ) NL }","func_name":"toMap","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toMap < K , V > ( keyMapper : ( T ) -> Option < K > , valueMapper : ( T ) -> Option < V > ) : Map < K , V > where K <: Hashable & Equatable < K > {  toMap ( { => HashMap < K , V > ( ) NL } , keyMapper , valueMapper ) NL }","func_name":"toMap","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toMap < K , V > ( initial : ( ) -> Map < K , V > , keyMapper : ( T ) -> Option < K > , valueMapper : ( T ) -> Option < V > ) : Map < K , V > where K <: Equatable < K > {  collect < Map < K , V > > ( initial ) { t , m => match ( ( keyMapper ( t ) , valueMapper ( t ) ) ) { case ( Some ( k ) , Some ( v ) ) => m . put ( k , v ) NL case _ => None < V > NL } NL return m NL } NL }","func_name":"toMap","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toSet < V > ( initial : ( ) -> Set < V > , mapper : ( T ) -> Option < V > ) : Set < V > where V <: Equatable < V > {  collect < Set < V > > ( initial ) { t , s => if ( let Some ( v ) = mapper ( t ) ) {  s . put ( v ) NL } NL return s NL } NL }","func_name":"toSet","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toSet < V > ( initial : ( ) -> Set < V > ) : Set < V > where V <: Equatable < V > {  toSet < V > ( initial , { t => t as V NL } ) NL }","func_name":"toSet","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toSet < V > ( mapper : ( T ) -> Option < V > ) : Set < V > where V <: Hashable & Equatable < V > {  toSet < V > ( { => HashSet < V > ( ) NL } , mapper ) NL }","func_name":"toSet","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toArrayList < V > ( mapper : ( T ) -> Option < V > ) : ArrayList < V > {  collect < ArrayList < V > > ( { => ArrayList < V > ( ) NL } ) { t , l => if ( let Some ( v ) = mapper ( t ) ) {  l . append ( v ) NL } NL return l NL } NL }","func_name":"toArrayList","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toArrayList ( ) : ArrayList < T > {  collect < ArrayList < T > > ( { => ArrayList < T > ( ) NL } ) { t , l => l . append ( t ) NL return l NL } NL }","func_name":"toArrayList","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toArray < V > ( mapper : ( T ) -> Option < V > ) : Array < V > {  toArrayList < V > ( mapper ) . toArray ( ) NL }","func_name":"toArray","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toArray ( ) : Array < T > {  toArrayList ( ) . toArray ( ) NL }","func_name":"toArray","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func toInputStream ( converter : ( T ) -> Array < Byte > ) : InputStream {  StreamToInputStream < T > ( this , converter ) NL }","func_name":"toInputStream","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func writeTo ( output : OutputStream , convert : ( T ) -> Array < Byte > ) {  for ( v in this ) {  output . write ( convert ( v ) ) NL } NL output . flush ( ) NL }","func_name":"writeTo","docstring":""}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func cast < R > ( throwIfNotMatch ! : Bool = false ) : Stream < R > {  Stream < R > ( IterableConverter < T , R > ( itr , throwIfNotMatch : throwIfNotMatch ) ) NL }","func_name":"cast","docstring":"/* 将流内每个元素转成指定类型并创建新的流，如果无法转成指定类型就按throwOrIgnorIfNotMatch 抛出异常或忽略,\n       throwIfNotMatch：true抛异常，否则忽略*/"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func filter ( fn : ( T ) -> Bool ) : Stream < T > {  itr = FilterIterator < T > ( itr , fn ) NL return this NL }","func_name":"filter","docstring":"//保留fn返回true的元素执行后续，否则丢弃"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func map < R > ( fn : ( T ) -> R ) : Stream < R > {  Stream < R > ( MapperIterator < T , R > ( itr , fn ) ) NL }","func_name":"map","docstring":"//把每个元素映射成指定类型R，不能映射的抛异常"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func mapOption < R > ( fn : ( T ) -> Option < R > ) : Stream < Option < R > > {  Stream < Option < R > > ( MapperOptionIterator < T , R > ( itr , fn ) ) NL }","func_name":"mapOption","docstring":"//把每个元素映射成指定类型Option<R>，不能映射的转成None<Option<R>>"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func flatMap < R > ( fn : ( T ) -> Iterable < R > ) : Stream < R > {  Stream < R > ( FlatMapperIterator < T , R > ( itr , fn ) ) NL }","func_name":"flatMap","docstring":"//每个元素传入fn，返回一批新的迭代器，并展开这些迭代器逐个迭代这些迭代器的每个元素构造一个新的流"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func flatten < R > ( toThrow ! : Bool = false ) : Stream < R > {  flatMap < R > { v => if ( toThrow ) {  ( v as Iterable < R > ) . getOrThrow ( ) NL } else {  ( v as Iterable < R > ) ?? EmptyIterable < R > . instance NL } NL } NL }","func_name":"flatten","docstring":"//每个元素都是一个Iterable，把它们展开成新的Stream"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func first ( ) : Option < T > {  if ( gotFirst ) {  None < T > NL } NL try {  return next ( ) NL } finally {  gotFirst = true NL } NL }","func_name":"first","docstring":"//返回当前流的第一个元素，调用一次以后不论流内还有没有其它元素一律返回None<T>"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func firstToStream ( ) : Stream < T > {  Stream < T > ( first ( ) ) NL }","func_name":"firstToStream","docstring":"//用fist()返回的Option构造新的Stream"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func last ( ) : Option < T > {   var value = None < T > NL for ( v in this ) {  value = v NL } NL value NL }","func_name":"last","docstring":"//返回当前流的最后一个元素"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func lastToStream ( ) : Stream < T > {  Stream < T > ( last ( ) ) NL }","func_name":"lastToStream","docstring":"//用last()返回的Option构造新的Stream"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func at ( index : Int64 ) : Option < T > {  skip ( index ) . first ( ) NL }","func_name":"at","docstring":"//返回当前流指定从0开始数的索引的第index个元素"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func atToStream ( index : Int64 ) : Stream < T > {  Stream < T > ( at ( index ) ) NL }","func_name":"atToStream","docstring":"//用at(index)返回的Option构造新的Stream"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func all ( predicate : ( T ) -> Bool ) : Bool {  ! this . none ( predicate ) NL }","func_name":"all","docstring":"//当前流所有元素逐个调用predicate，都返回true，则本函数返回true"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func none ( predicate : ( T ) -> Bool ) : Bool {  filter ( predicate ) . first ( ) . none NL }","func_name":"none","docstring":"//当前流所有元素逐个调用predicate，都返回false，则本函数返回true"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func any ( predicate : ( T ) -> Bool ) : Bool {  filter ( predicate ) . first ( ) . some NL }","func_name":"any","docstring":"//当前流所有元素逐个调用predicate，有一个返回true，则本函数返回true"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func sort ( comparator : ( T , T ) -> Ordering ) {  itr = SortedIterator ( itr , comparator ) NL return this NL }","func_name":"sort","docstring":"//为流内元素排序"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func sort ( comparator : Comparator < T > ) {  sort ( comparator . comparator ) NL }","func_name":"sort","docstring":"//为流内元素排序"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func reverse ( ) : Stream < T > {  itr = ReversedIterator < T > ( itr ) NL return this NL }","func_name":"reverse","docstring":"//颠倒流内元素顺序"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func peek ( consumer : ( T ) -> Unit ) {  itr = PeekIterator < T > ( itr , consumer ) NL return this NL }","func_name":"peek","docstring":"//流内每个元素调用一遍consumer，conumser执行结果不影响后续，抛异常除外"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func limit ( size : Int64 ) : Stream < T > {  itr = LimitIterator < T > ( itr , size ) NL return this NL }","func_name":"limit","docstring":"//迭代流内前size的元素数"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func skip ( size : Int64 , toThrowIfOutOfBounds ! : Bool = true ) : Stream < T > {  itr = SkipIterator < T > ( itr , size , toThrowIfOutOfBounds ) NL return this NL }","func_name":"skip","docstring":"//丢弃流内前size个元素"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func range ( rang : Range < Int64 > ) : Stream < T > {  itr = RangeIterator < T > ( itr , rang ) NL return this NL }","func_name":"range","docstring":"//截取索引在range范围内的元素，索引从0开始"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func takeWhile ( checker : ( T ) -> Bool ) : Stream < T > {  itr = TakeWhileIterator < T > ( itr , checker ) NL return this NL }","func_name":"takeWhile","docstring":"//迭代流中每个元素直到checker返回false迭代器结束"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func dropWhile ( checker : ( T ) -> Bool ) : Stream < T > {  itr = DropWhileIterator < T > ( itr , checker ) NL return this NL }","func_name":"dropWhile","docstring":"//丢弃迭代器开头checker返回true的元素"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func takeUntil ( checker : ( T ) -> Bool ) : Stream < T > {  return takeWhile { v => ! checker ( v ) NL } NL }","func_name":"takeUntil","docstring":"//迭代流中每个元素直到checker返回true迭代器结束"}
{"repo":"fountain","file":"Stream.cj","path":"fountain/src/stream/Stream.cj","code_tokens":"public func dropUntil ( checker : ( T ) -> Bool ) : Stream < T > {  return dropWhile { v => ! checker ( v ) NL } NL }","func_name":"dropUntil","docstring":"//丢弃迭代器开头checker返回false的元素"}
{"repo":"fountain","file":"TakeWhileIterator.cj","path":"fountain/src/stream/TakeWhileIterator.cj","code_tokens":"public func next ( ) : Option < T > {  if ( ! notFinished ) {  return None < T > NL } NL for ( i in itr where notFinished ) {  if ( checker ( i ) ) {  return i NL } else {  notFinished = false NL break NL } NL } NL None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"func incr ( ) : Stream < T >","func_name":"incr","docstring":"//对每个元素执行+1"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"func decr ( ) : Stream < T >","func_name":"decr","docstring":"//对每个元素执行-1"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"func mod ( i : T ) : Stream < T >","func_name":"mod","docstring":"//对每个元素v执行v % i"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"func and ( i : T ) : Stream < T >","func_name":"and","docstring":"//对每个元素v执行v & i"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"func or ( i : T ) : Stream < T >","func_name":"or","docstring":"//对每个元素v执行v | i"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"func leftShift ( i : T ) : Stream < T >","func_name":"leftShift","docstring":"//对每个元素v执行v << i"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"func rightShift ( i : T ) : Stream < T >","func_name":"rightShift","docstring":"//对每个元素v执行v >> i"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"public func incr ( ) : Stream < T > {  this . add ( ( 1 as T ) . getOrThrow ( ) ) NL }","func_name":"incr","docstring":"//对每个元素执行+1"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"public func decr ( ) : Stream < T > {  this . sub ( ( 1 as T ) . getOrThrow ( ) ) NL }","func_name":"decr","docstring":"//对每个元素执行-1"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"public func mod ( i : T ) : Stream < T > {  this . map { v => v % i NL } NL }","func_name":"mod","docstring":"//对每个元素v执行v % i"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"public func and ( i : T ) : Stream < T > {  this . map { v => v & i NL } NL }","func_name":"and","docstring":"//对每个元素v执行v & i"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"public func or ( i : T ) : Stream < T > {  this . map { v => v | i NL } NL }","func_name":"or","docstring":"//对每个元素v执行v | i"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"public func leftShift ( i : T ) : Stream < T > {  this . map { v => v << i NL } NL }","func_name":"leftShift","docstring":"//对每个元素v执行v << i"}
{"repo":"fountain","file":"IntegerStream.cj","path":"fountain/src/stream/IntegerStream.cj","code_tokens":"public func rightShift ( i : T ) : Stream < T > {  this . map { v => v >> i NL } NL }","func_name":"rightShift","docstring":"//对每个元素v执行v >> i"}
{"repo":"fountain","file":"SortableStream.cj","path":"fountain/src/stream/SortableStream.cj","code_tokens":"func sort ( ) : Stream < T >","func_name":"sort","docstring":""}
{"repo":"fountain","file":"SortableStream.cj","path":"fountain/src/stream/SortableStream.cj","code_tokens":"public func sort ( ) : Stream < T > {  sort ( Comparator . compare < T > ) NL }","func_name":"sort","docstring":""}
{"repo":"fountain","file":"InputStreamIterator.cj","path":"fountain/src/stream/InputStreamIterator.cj","code_tokens":"public func next ( ) : Option < Array < Byte > > {   let buf = Array < Byte > ( bufsize , item : 0 ) NL if ( input . read ( buf ) > 0 ) {  buf NL } else {  None < Array < Byte > > NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"LessStream.cj","path":"fountain/src/stream/LessStream.cj","code_tokens":"func min ( ) : Option < T >","func_name":"min","docstring":""}
{"repo":"fountain","file":"LessStream.cj","path":"fountain/src/stream/LessStream.cj","code_tokens":"public func min ( ) : Option < T > {  min { v , s => if ( v < s ) {  LT NL } else {  GT NL } NL } NL }","func_name":"min","docstring":""}
{"repo":"fountain","file":"WithIndexIterator.cj","path":"fountain/src/stream/WithIndexIterator.cj","code_tokens":"public func next ( ) : Option < IndexedValue < T > > {  for ( value in itr ) {  return IndexedValue < T > ( current . fetchAdd ( 1 ) , value ) NL } NL return None < IndexedValue < T > > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"StreamToInputStream.cj","path":"fountain/src/stream/StreamToInputStream.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {  if ( buf . length == 0 ) {  buf . clear ( ) NL for ( v in stream ) {  buf . write ( converter ( v ) ) NL return buf . read ( buffer ) NL } NL return 0 NL } else {  return buf . read ( buffer ) NL } NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"LimitIterator.cj","path":"fountain/src/stream/LimitIterator.cj","code_tokens":"public func next ( ) : Option < T > {  while ( current < limit ) {  current ++ NL return itr . next ( ) NL } NL None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"MapperOptionIterator.cj","path":"fountain/src/stream/MapperOptionIterator.cj","code_tokens":"public func next ( ) : Option < Option < R > > {  for ( i in itr ) {  return fn ( i ) NL } NL return None < Option < R > > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"DropWhileIterator.cj","path":"fountain/src/stream/DropWhileIterator.cj","code_tokens":"public func next ( ) : Option < T > {  if ( ! dropped ) {  for ( i in itr where checker ( i ) ) {  break NL } NL } NL dropped = true NL for ( i in itr ) {  return i NL } NL None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"AddableStream.cj","path":"fountain/src/stream/AddableStream.cj","code_tokens":"func sum ( ) : Option < T >","func_name":"sum","docstring":""}
{"repo":"fountain","file":"AddableStream.cj","path":"fountain/src/stream/AddableStream.cj","code_tokens":"public func sum ( ) : Option < T > {  return reduce < T > { v , optr => match ( optr ) { case Some ( r ) => v + r NL case _ => v NL } NL } NL }","func_name":"sum","docstring":""}
{"repo":"fountain","file":"ParallelismIterator.cj","path":"fountain/src/stream/ParallelismIterator.cj","code_tokens":"public func next ( ) : Option < Future < Option < T > > > {  if ( finished . load ( ) ) {  None < Future < Option < T > > > NL } NL  let future = spawn {  let opt = itr . next ( ) NL match ( opt ) { case Some ( _ ) => opt NL case _ => finished . store ( true ) NL None < T > NL } NL } NL return future NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"SortedIterator.cj","path":"fountain/src/stream/SortedIterator.cj","code_tokens":"static func create < T > ( itr : Iterator < T > ) : SortedIterator < T > where T <: Comparable < T > {  SortedIterator < T > ( itr , Comparator < T > . compare < T > ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SortedIterator.cj","path":"fountain/src/stream/SortedIterator.cj","code_tokens":"public func next ( ) : Option < T > {  if ( sorted . isEmpty ( ) ) {  sorted . offerAll ( itr ) NL } NL if ( ! sorted . isEmpty ( ) ) {  sorted . poll ( ) NL } else {  None < T > NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"WithIndexStream.cj","path":"fountain/src/stream/WithIndexStream.cj","code_tokens":"func withIndex ( ) : Stream < IndexedValue < T > >","func_name":"withIndex","docstring":""}
{"repo":"fountain","file":"WithIndexStream.cj","path":"fountain/src/stream/WithIndexStream.cj","code_tokens":"public func withIndex ( ) : Stream < IndexedValue < T > > {  Stream < IndexedValue < T > > ( WithIndexIterator < T > ( itr ) ) NL }","func_name":"withIndex","docstring":""}
{"repo":"fountain","file":"FilterIterator.cj","path":"fountain/src/stream/FilterIterator.cj","code_tokens":"public func next ( ) : Option < T > {  for ( i in itr where fn ( i ) ) {  return i NL } NL return None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public operator func == ( key : SkipListKey < K > ) {  this . key == key . key NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public operator func != ( key : SkipListKey < K > ) {  ! ( this == key ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"func set ( val : V ) : Option < V > {  synchronized ( this ) {   let old = this . val_ NL this . val_ = val NL return old NL } NL }","func_name":"set","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func next ( ) : Option < ( K , V ) > {  for ( n in itr ) {  match ( n ) { case e : SkipListEntry < K , V > => return ( e . key , e . val ) NL case _ => throw UnreachableException ( ) NL } NL } NL None NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func next ( ) : Option < ( K , V ) > {  for ( n in itr ) {  match ( n ) { case e : SkipListEntry < K , V > => ( e . key , e . val ) NL case _ => throw UnreachableException ( ) NL } NL } NL None NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func descending ( ) : ConcurrentSkipListSubMap < K , V > {  ConcurrentSkipListSubMap < K , V > ( set . descending ( ) ) NL }","func_name":"descending","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func get ( key : K ) : Option < V > {  match ( set . doFind ( SkipListKey < K > ( key ) ) ) { case n : SkipListValueNode < SkipListEntry < K , V > > => n . value . val NL case n : SkipListValueNode < SkipListKey < K > > => match ( n . value ) { case v : SkipListEntry < K , V > => v . val NL case _ => throw UnreachableException ( ) NL } NL case _ => None NL } NL }","func_name":"get","docstring":"/*\n     * 根据 key 得到 Map 中映射的值\n     * 参数 key - 传递 key，获取 value\n     * 返回值 Option<V> - key 对应的值是用 Option 封装的\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func contains ( key : K ) : Bool {  set . contains ( SkipListKey < K > ( key ) ) NL }","func_name":"contains","docstring":"/*\n     * 判断是否包含指定键的映射\n     * 参数 key - 传递要判断的 key\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  for ( k in keys ) {  if ( ! contains ( k ) ) {  return false NL } NL } NL true NL }","func_name":"containsAll","docstring":"/*\n     * 判断是否包含指定集合键的映射\n     * 参数 keys - 传递待判断的 keys\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func put ( key : K , value : V ) : Option < V > {   let node = set . doPut ( SkipListEntry < K , V > ( key , value ) ) NL if ( let Some ( n ) = node ) {  ConcurrentSkipListMap < K , V > . swap ( n , value ) NL } else {  None NL } NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 Option<V>.None\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  for ( e in elements ) {  put ( e [ 0 ] , e [ 1 ] ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 elements - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func remove ( key : K ) : Option < V > {   let node = set . doRemove ( SkipListKey < K > ( key ) ) NL match ( node ) { case n : SkipListValueNode < SkipListEntry < K , V > > => n . value . val NL case n : SkipListValueNode < SkipListKey < K > > => match ( n ) { case n : SkipListEntry < K , V > => n . val NL case _ => throw UnreachableException ( ) NL } NL case _ => None NL } NL }","func_name":"remove","docstring":"/*\n     * 从此映射中删除指定键的映射（如果存在）\n     * 参数 key - 传入要删除的 key\n     * 返回值 Option<V> - 被移除映射的 V 用 Option 封装\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  for ( k in keys ) {  remove ( k ) NL } NL }","func_name":"removeAll","docstring":"/*\n     * 从此映射中删除指定集合的映射（如果存在）\n     * 参数 keys - 传入要删除的集合\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  for ( e in set ) {  match ( e ) { case kv : SkipListEntry < K , V > where predicate ( kv . key , kv . val ) => remove ( kv . key ) NL case _ => continue NL } NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足条件，则删除对应的键值\n     * 参数 predicate - 传递一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func clear ( ) : Unit {  set . clear ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func clone ( ) : Map < K , V > {  ConcurrentSkipListSubMap < K , V > ( set ) NL }","func_name":"clone","docstring":"/*\n     * 克隆 Map\n     * 返回值 Map<K, V> - 返回一个 Map<K, V>\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  get ( key ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  put ( key , value ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func keys ( ) : Keys < K > {  MapKeys < K , V > ( this ) NL }","func_name":"keys","docstring":"/*\n     * 返回 Map 中所有的 key，并将所有 key 存储在一个 Keys 容器中\n     * 返回值 Keys<K> - 保存所有返回的 key\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func values ( ) : Values < V > {  MapValues < K , V > ( this ) NL }","func_name":"values","docstring":"/*\n     * 返回 Map 中所有的 value，并将所有 value 存储在一个 Values 容器中\n     * 返回值 Values<V> - 保存所有返回的 value\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  set . isEmpty ( ) NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Map 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {  ConcurrentSkipListSubMapIterator < K , V > ( set . iterator ( ) ) NL }","func_name":"iterator","docstring":"/*\n     * 返回 Map 的迭代器\n     * 返回值 Iterator<(K,V)> - Map 的迭代器\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func subMap ( low : K , high : K , lowInclusive ! : Bool = true , highInclusive ! : Bool = false ) : ConcurrentSkipListSubMap < K , V > {  ConcurrentSkipListSubMap < K , V > ( set . subSet ( wrap ( low ) , wrap ( high ) , lowInclusive : lowInclusive , highInclusive : highInclusive ) ) NL }","func_name":"subMap","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func headMap ( end : K , inclusive ! : Bool = false ) : ConcurrentSkipListSubMap < K , V > {  ConcurrentSkipListSubMap < K , V > ( set . headSet ( wrap ( end ) , inclusive : inclusive ) ) NL }","func_name":"headMap","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func tailMap ( start : K , inclusive ! : Bool = true ) : ConcurrentSkipListSubMap < K , V > {  ConcurrentSkipListSubMap < K , V > ( set . tailSet ( wrap ( start ) , inclusive : inclusive ) ) NL }","func_name":"tailMap","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"static public func create < K , V > ( ) : ConcurrentSkipListMap < K , V > where K <: Comparable < K > {  ConcurrentSkipListMap < K , V > ( Comparator . compare < K > ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"static public func create < K , V > ( elements : Iterable < ( K , V ) > ) : ConcurrentSkipListMap < K , V > where K <: Comparable < K > {   let map = create < K , V > ( ) NL map . putAll ( elements ) NL map NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"static public func create ( elements : SortedMap < K , V > ) : ConcurrentSkipListMap < K , V > {  ConcurrentSkipListMap < K , V > ( elements , elements . comparator ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func clear ( ) : Unit {  set . clear ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func putAll ( elements : Iterable < ( K , V ) > ) {  for ( e in elements ) {  put ( e ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 elements - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) {   let itr : Iterable < ( K , V ) > = elements NL putAll ( itr ) NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 elements - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func put ( element : ( K , V ) ) : Option < V > {  put ( element [ 0 ] , element [ 1 ] ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 Option<V>.None\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"private func extractValue ( node : SkipListNode < SkipListKey < K > > ) : Option < V > {  match ( node ) { case n : SkipListValueNode < SkipListEntry < K , V > > => n . value . val NL case n : SkipListValueNode < SkipListKey < K > > => match ( n . value ) { case n : SkipListEntry < K , V > => n . val NL case _ => throw UnreachableException ( ) NL } NL case _ => None < V > NL } NL }","func_name":"extractValue","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"static func swap ( node : SkipListNode < SkipListKey < K > > , val : V ) : Option < V > {  match ( node ) { case x : SkipListValueNode < SkipListEntry < K , V > > => x . value . set ( val ) NL case x : SkipListValueNode < SkipListKey < K > > => match ( x . value ) { case x : SkipListEntry < K , V > => x . set ( val ) NL case _ => throw UnreachableException ( ) NL } NL case _ => None NL } NL }","func_name":"swap","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func put ( key : K , val : V ) : Option < V > {   let node = set . doPut ( SkipListEntry < K , V > ( key , val ) ) NL swap ( node , val ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 Option<V>.None\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func putIfNonExistent ( key : K , val : V ) : Option < V > {   let node = set . doPut ( SkipListEntry < K , V > ( key , val ) ) NL match ( node ) { case x : SkipListValueNode < SkipListEntry < K , V > > => x . value . val NL case x : SkipListValueNode < SkipListKey < K > > => match ( x . value ) { case x : SkipListEntry < K , V > => x . val NL case _ => throw UnreachableException ( ) NL } NL case _ => None NL } NL }","func_name":"putIfNonExistent","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func putIfPresent ( key : K , val : V ) : Option < V > {   let node = set . doFind ( SkipListKey < K > ( key ) ) NL swap ( node , val ) NL }","func_name":"putIfPresent","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func computeIfAbsent ( key : K , fn : ( K ) -> Option < V > ) : Option < V > {  if ( let Some ( v ) = get ( key ) ) {  v NL } else if ( let Some ( v ) = fn ( key ) ) {  putIfNonExistent ( key , v ) NL } else {  None NL } NL }","func_name":"computeIfAbsent","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func computeIfPresent ( key : K , fn : ( K , V ) -> Option < V > ) : Option < V > {   let node = set . doFind ( SkipListKey < K > ( key ) ) NL match ( node ) { case x : SkipListValueNode < SkipListEntry < K , V > > => if ( let Some ( v ) = fn ( key , x . value . val ) ) {  x . value . set ( v ) NL } else {  x . value . val NL } NL case x : SkipListValueNode < SkipListKey < K > > => match ( x . value ) { case x : SkipListEntry < K , V > => if ( let Some ( v ) = fn ( key , x . val ) ) {  x . set ( v ) NL } else {  x . val NL } NL case _ => throw UnreachableException ( ) NL } NL case _ => None NL } NL }","func_name":"computeIfPresent","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func get ( key : K ) : Option < V > {   let node = set . doFind ( SkipListKey < K > ( key ) ) NL extractValue ( node ) NL }","func_name":"get","docstring":"/*\n     * 根据 key 得到 Map 中映射的值\n     * 参数 key - 传递 key，获取 value\n     * 返回值 Option<V> - key 对应的值是用 Option 封装的\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func contains ( key : K ) : Bool {  set . contains ( SkipListKey < K > ( key ) ) NL }","func_name":"contains","docstring":"/*\n     * 判断是否包含指定键的映射\n     * 参数 key - 传递要判断的 key\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  for ( k in keys ) {  if ( ! contains ( k ) ) {  return false NL } NL } NL return true NL }","func_name":"containsAll","docstring":"/*\n     * 判断是否包含指定集合键的映射\n     * 参数 keys - 传递待判断的 keys\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func remove ( key : K ) : Option < V > {   let node = set . doRemove ( SkipListKey < K > ( key ) ) NL extractValue ( node ) NL }","func_name":"remove","docstring":"/*\n     * 从此映射中删除指定键的映射（如果存在）\n     * 参数 key - 传入要删除的 key\n     * 返回值 Option<V> - 被移除映射的 V 用 Option 封装\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  for ( k in keys ) {  remove ( k ) NL } NL }","func_name":"removeAll","docstring":"/*\n     * 从此映射中删除指定集合的映射（如果存在）\n     * 参数 keys - 传入要删除的集合\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  set . removeIf { entry => match ( entry ) { case e : SkipListEntry < K , V > => predicate ( e . key , e . val ) NL case _ => throw UnreachableException ( ) NL } NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足条件，则删除对应的键值\n     * 参数 predicate - 传递一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  set . isEmpty ( ) NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Map 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {  SkipListMapIterator < K , V > ( set . iterator ( ) ) NL }","func_name":"iterator","docstring":"/*\n     * 返回 Map 的迭代器\n     * 返回值 Iterator<(K,V)> - Map 的迭代器\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func keys ( ) : Keys < K > {  MapKeys < K , V > ( this ) NL }","func_name":"keys","docstring":"/*\n     * 返回 Map 中所有的 key，并将所有 key 存储在一个 Keys 容器中\n     * 返回值 Keys<K> - 保存所有返回的 key\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func values ( ) : Values < V > {  MapValues < K , V > ( this ) NL }","func_name":"values","docstring":"/*\n     * 返回 Map 中所有的 value，并将所有 value 存储在一个 Values 容器中\n     * 返回值 Values<V> - 保存所有返回的 value\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  get ( key ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  put ( key , value ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func clone ( ) : Map < K , V > {   let map = ConcurrentSkipListMap < K , V > ( this . cmp ) NL for ( e in set ) {  map . set . put ( e ) NL } NL map NL }","func_name":"clone","docstring":"/*\n     * 克隆 Map\n     * 返回值 Map<K, V> - 返回一个 Map<K, V>\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"static func wrapKey ( key : K ) : SkipListKey < K > {  SkipListKey < K > ( key ) NL }","func_name":"wrapKey","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"private func subMap ( low : Option < SkipListKey < K > > , high : Option < SkipListKey < K > > , lowInclusive ! : Bool = true , highInclusive ! : Bool = false ) : ConcurrentSkipListSubMap < K , V > {  ConcurrentSkipListSubMap < K , V > ( set . subSet ( low , high , lowInclusive : lowInclusive , highInclusive : highInclusive ) ) NL }","func_name":"subMap","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func subMap ( low : K , high : K , lowInclusive ! : Bool = true , highInclusive ! : Bool = false ) : ConcurrentSkipListSubMap < K , V > {  subMap ( wrapKey ( low ) , wrapKey ( high ) , lowInclusive : lowInclusive , highInclusive : highInclusive ) NL }","func_name":"subMap","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func headMap ( end : K , inclusive ! : Bool = false ) : ConcurrentSkipListSubMap < K , V > {  subMap ( None < SkipListKey < K > > , wrapKey ( end ) , highInclusive : inclusive ) NL }","func_name":"headMap","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func tailMap ( start : K , inclusive ! : Bool = true ) : ConcurrentSkipListSubMap < K , V > {  subMap ( wrapKey ( start ) , None < SkipListKey < K > > , lowInclusive : inclusive ) NL }","func_name":"tailMap","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"private func extractEntry ( opt : Option < SkipListKey < K > > ) {  match ( opt ) { case entry : SkipListEntry < K , V > => ( entry . key , entry . val ) NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"extractEntry","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func ceiling ( key : K ) : Option < ( K , V ) > {  extractEntry ( set . ceiling ( SkipListKey < K > ( key ) ) ) NL }","func_name":"ceiling","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func floor ( key : K ) : Option < ( K , V ) > {  extractEntry ( set . floor ( SkipListKey < K > ( key ) ) ) NL }","func_name":"floor","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func lower ( key : K ) : Option < ( K , V ) > {  extractEntry ( set . lower ( SkipListKey < K > ( key ) ) ) NL }","func_name":"lower","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func higher ( key : K ) : Option < ( K , V ) > {  extractEntry ( set . higher ( SkipListKey < K > ( key ) ) ) NL }","func_name":"higher","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListMap.cj","path":"fountain/src/collection/ConcurrentSkipListMap.cj","code_tokens":"public func containsValue ( value : V ) : Bool {  for ( ( k , v ) in this where v == value ) {  return true NL } NL return false NL }","func_name":"containsValue","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"static public func create < T > ( ) : TreeSet < T > where T <: Comparable < T > {  TreeSet < T > ( Comparator . compare < T > ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"static public func create < T > ( elements : Iterable < T > ) : TreeSet < T > where T <: Comparable < T > {   let set = create < T > ( ) NL set . putAll ( elements ) NL set NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"static public func create ( elements : SortedSet < T > ) : TreeSet < T > {  TreeSet < T > ( elements , elements . comparator ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func putAll ( elements : Iterable < T > ) : Unit {  for ( e in elements ) {  put ( e ) NL } NL }","func_name":"putAll","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func putAll ( elements : Collection < T > ) : Unit {   let itr = elements NL putAll ( itr ) NL }","func_name":"putAll","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func put ( element : T ) : Bool {  store . put ( element , ( ) ) . none NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func clear ( ) : Unit {  store . clear ( ) NL }","func_name":"clear","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func clone ( ) : TreeSet < T > {  TreeSet < T > ( this , cmp ) NL }","func_name":"clone","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func contains ( value : T ) : Bool {  store . contains ( value ) NL }","func_name":"contains","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func containsAll ( values : Collection < T > ) : Bool {  store . containsAll ( values ) NL }","func_name":"containsAll","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func isEmpty ( ) : Bool {  store . isEmpty ( ) NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func remove ( value : T ) : Bool {  store . remove ( value ) . some NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func removeAll ( values : Collection < T > ) : Unit {  store . removeAll ( values ) NL }","func_name":"removeAll","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  store . removeIf { k , v => predicate ( k ) NL } NL }","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  TreeSetIterator < T > ( store . iterator ( ) ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func retainAll ( retained : Set < T > ) : Unit {  for ( v in this where ! retained . contains ( v ) ) {  remove ( v ) NL } NL }","func_name":"retainAll","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func subsetOf ( other : Set < T > ) : Bool {  for ( v in this ) {  if ( ! other . contains ( v ) ) {  return false NL } NL } NL return true NL }","func_name":"subsetOf","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func subSet ( low : T , high : T , lowInclusive ! : Bool = true , highInclusive ! : Bool = false ) : TreeSet < T > {  TreeSet < T > ( cmp , store . subMap ( low , high , lowInclusive : lowInclusive , highInclusive : highInclusive ) ) NL }","func_name":"subSet","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func headSet ( end : T , inclusive ! : Bool = false ) : TreeSet < T > {  TreeSet < T > ( cmp , store . headMap ( end , inclusive : inclusive ) ) NL }","func_name":"headSet","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func tailSet ( start : T , inclusive ! : Bool = true ) : TreeSet < T > {  TreeSet < T > ( cmp , store . tailMap ( start , inclusive : inclusive ) ) NL }","func_name":"tailSet","docstring":""}
{"repo":"fountain","file":"TreeSet.cj","path":"fountain/src/collection/TreeSet.cj","code_tokens":"public func next ( ) : Option < T > {  for ( v in itr ) {  v [ 0 ] NL } NL None NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func sameAs ( n : TreeNode < K , V > ) : Bool {  match ( ( this , n ) ) { case _ : ( NoneTreeNode < K , V > , NoneTreeNode < K , V > ) => true NL case _ : ( RootTreeNode < K , V > , RootTreeNode < K , V > ) => true NL case x : ( TreeMapEntry < K , V > , TreeMapEntry < K , V > ) => x [ 0 ] == x [ 1 ] NL case _ => false NL } NL }","func_name":"sameAs","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"operator func == ( n : TreeNode < K , V > ) : Bool {  sameAs ( n ) NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"operator func != ( n : TreeNode < K , V > ) : Bool {  ! sameAs ( n ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func compare ( other : TreeMapEntry < K , V > ) : Ordering {  comparator ( this . key , other . key ) NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"static public func create < K > ( ) : TreeMap < K , V > where K <: Comparable < K > {  TreeMap < K , V > ( Comparator . compare < K > ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"static public func create < K > ( elements : Iterable < ( K , V ) > ) : TreeMap < K , V > where K <: Comparable < K > {   let map = create < K > ( ) NL map . putAll ( elements ) NL map NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"static public func create ( elements : SortedMap < K , V > ) : TreeMap < K , V > {  TreeMap < K , V > ( elements , elements . comparator ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  currentSize == 0 NL }","func_name":"isEmpty","docstring":"/*\n     * 判断对象是否为空\n     * 返回值 Bool - 若为空返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func contains ( key : K ) : Bool {  return getEntry ( key ) is TreeMapEntry < K , V > NL }","func_name":"contains","docstring":"/*\n     * 判断是否包含指定键的映射\n     * 参数 key - 传递要判断的 key\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  for ( key in keys where ! contains ( key ) ) {  return false NL } NL return true NL }","func_name":"containsAll","docstring":"/*\n     * 判断是否包含指定集合键的映射\n     * 参数 keys - 传递待判断的 keys\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func get ( key : K ) : Option < V > {  match ( getEntry ( key ) ) { case n : TreeMapEntry < K , V > => n . value NL case _ => None NL } NL }","func_name":"get","docstring":"/*\n     * 根据 key 得到 Map 中映射的值\n     * 参数 key - 传递 key，获取 value\n     * 返回值 Option<V> - key 对应的值是用 Option 封装的\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func firstKey ( ) : Option < K > {  return keyOrNone ( getFirstEntry ( ) ) NL }","func_name":"firstKey","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func lastKey ( ) : Option < K > {  return keyOrNone ( getLastEntry ( ) ) NL }","func_name":"lastKey","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func putAll ( map : Map < K , V > ) : Unit {   let itr : Iterable < ( K , V ) > = map NL putAll ( itr ) NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 element - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func putAll ( elements : Iterable < ( K , V ) > ) : Unit {  for ( e in elements ) {  put ( e ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 element - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func getEntry ( key : K ) : TreeNode < K , V > {   let cmp = this . cmp NL  var p : TreeNode < K , V > = root . child NL while ( p is TreeMapEntry < K , V > ) {  match ( p ) { case e : TreeMapEntry < K , V > => match ( cmp ( key , e . key ) ) { case LT => p = e . left NL case GT => p = e . right NL case _ => return p NL } NL case _ => break NL } NL } NL return NoneTreeNode < K , V > . instance NL }","func_name":"getEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func getCeilingEntry ( key : K ) : TreeNode < K , V > {   let cmp = this . cmp NL  var p : TreeNode < K , V > = root . child NL while ( p . hasValue ) {  match ( cmp ( key , p . key ) ) { case LT => if ( p . left . hasValue ) {  p = p . left NL } else {  return p NL } NL case GT => if ( p . right . hasValue ) {  p = p . right NL } else {   var parent = p . parent NL  var ch = p NL while ( parent . hasValue && ch == parent . right ) {  ch = parent NL parent = parent . parent NL } NL return parent NL } NL case EQ => return p NL } NL } NL return NoneTreeNode < K , V > . instance NL }","func_name":"getCeilingEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func getFloorEntry ( key : K ) : TreeNode < K , V > {   let cmp = this . cmp NL  var p : TreeNode < K , V > = root . child NL while ( p . hasValue ) {  match ( cmp ( key , p . key ) ) { case GT => if ( p . right . hasValue ) {  p = p . right NL } else {  return p NL } NL case LT => if ( p . left . hasValue ) {  p = p . left NL } else {   var parent = p . parent NL  var ch = p NL while ( parent . hasValue && ch == parent . left ) {  ch = parent NL parent = parent . parent NL } NL return parent NL } NL case EQ => return p NL } NL } NL return NoneTreeNode < K , V > . instance NL }","func_name":"getFloorEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func getHigherEntry ( key : K ) : TreeNode < K , V > {   let cmp = this . cmp NL  var p : TreeNode < K , V > = root . child NL while ( p . hasValue ) {  match ( cmp ( key , p . key ) ) { case LT => if ( p . left . hasValue ) {  p = p . left NL } else {  return p NL } NL case _ => if ( p . right . hasValue ) {  p = p . right NL } else {   var parent = p . parent NL  var ch = p NL while ( parent . hasValue && ch == parent . right ) {  ch = parent NL parent = parent . parent NL } NL return parent NL } NL } NL } NL return NoneTreeNode < K , V > . instance NL }","func_name":"getHigherEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func getLowerEntry ( key : K ) : TreeNode < K , V > {   let cmp = this . cmp NL  var p : TreeNode < K , V > = root . child NL while ( p . hasValue ) {  match ( cmp ( key , p . key ) ) { case GT => if ( p . right . hasValue ) {  p = p . right NL } else {  return p NL } NL case _ =>  var parent = p . parent NL  var ch = p NL while ( parent . hasValue && ch == parent . left ) {  ch = parent NL parent = parent . parent NL } NL return parent NL } NL } NL return NoneTreeNode < K , V > . instance NL }","func_name":"getLowerEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func put ( key : K , value : V ) : Option < V > {  return put ( key , value , true ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func put ( entry : ( K , V ) ) : Option < V > {  put ( entry [ 0 ] , entry [ 1 ] ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  for ( e in elements ) {  put ( e ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 element - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func putIfNonExistent ( key : K , value : V ) : Option < V > {  return put ( key , value , false ) NL }","func_name":"putIfNonExistent","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func computeIfAbsent ( key : K , fn : ( K ) -> Option < V > ) : Option < V > {   var newValue : Option < V > NL  var t = root . child NL if ( t . hasNoValue ) {  newValue = callMappingFunctionWithCheck ( key , fn ) NL if ( let Some ( v ) = newValue ) {  addEntryToEmptyMap ( key , v ) NL return newValue NL } else {  return None < V > NL } NL } NL  var ord : Ordering = LT NL  var parent : TreeNode < K , V > = t NL  let cmp = this . cmp NL do {  parent = t NL ord = cmp ( key , t . key ) NL match ( ord ) { case LT => t = t . left NL case GT => t = t . right NL case EQ => return t . value NL } NL } while ( t . hasValue ) NL newValue = callMappingFunctionWithCheck ( key , fn ) NL if ( let Some ( v ) = newValue ) {  addEntry ( key , v , parent , ord . lt ) NL return newValue NL } NL return None < V > NL }","func_name":"computeIfAbsent","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func computeIfPresent ( key : K , fn : ( K , V ) -> Option < V > ) : Option < V > {   let oldEntry = getEntry ( key ) NL if ( oldEntry . hasValue ) {  return remapValue ( oldEntry , key ) { k , v => fn ( k , v . getOrThrow ( ) ) NL } NL } else {  return None NL } NL }","func_name":"computeIfPresent","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func compute ( key : K , fn : ( K , Option < V > ) -> Option < V > ) : Option < V > {   var newValue = None < V > NL  var t = root . child NL if ( t . hasNoValue ) {  newValue = callRemappingFunctionWithCheck ( key , None < V > , fn ) NL if ( let Some ( v ) = newValue ) {  addEntryToEmptyMap ( key , v ) NL return newValue NL } else {  return None NL } NL } NL  var ord : Ordering = LT NL  var parent : TreeNode < K , V > = t NL  let cmp = this . cmp NL do {  parent = t NL ord = cmp ( key , t . key ) NL match ( ord ) { case LT => t = t . left NL case GT => t = t . right NL case EQ => return remapValue ( t , key , fn ) NL } NL } while ( t . hasValue ) NL newValue = callRemappingFunctionWithCheck ( key , None < V > , fn ) NL if ( let Some ( v ) = newValue ) {  addEntry ( key , v , parent , ord . lt ) NL return newValue NL } NL return None NL }","func_name":"compute","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func merge ( key : K , value : V , fn : ( V , V ) -> Option < V > ) : Option < V > {   var t = root . child NL if ( t . hasNoValue ) {  addEntryToEmptyMap ( key , value ) NL return value NL } NL  var ord : Ordering = LT NL  var parent : TreeNode < K , V > = NoneTreeNode < K , V > . instance NL  let cmp = this . cmp NL do {  parent = t NL ord = cmp ( key , t . key ) NL match ( ord ) { case LT => t = t . left NL case GT => t = t . right NL case EQ => return mergeValue ( t , value , fn ) NL } NL } while ( t . hasValue ) NL addEntry ( key , value , parent , ord . lt ) NL return value NL }","func_name":"merge","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func callMappingFunctionWithCheck ( key : K , fn : ( K ) -> Option < V > ) : Option < V > {   let mc = modCount NL  let newValue = fn ( key ) NL if ( mc != modCount ) {  throw ConcurrentModificationException ( ) NL } NL return newValue NL }","func_name":"callMappingFunctionWithCheck","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func callRemappingFunctionWithCheck ( key : K , oldValue : Option < V > , fn : ( K , Option < V > ) -> Option < V > ) : Option < V > {   let mc = modCount NL  let newValue = fn ( key , oldValue ) NL if ( mc != modCount ) {  throw ConcurrentModificationException ( ) NL } NL return newValue NL }","func_name":"callRemappingFunctionWithCheck","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func addEntry ( key : K , value : V , parent : TreeNode < K , V > , addToLeft : Bool ) : Unit {   let e = TreeMapEntry < K , V > ( key , value , parent , cmp ) NL match ( parent ) { case x : RootTreeNode < K , V > => x . child = e NL case x : TreeMapEntry < K , V > => if ( addToLeft ) {  x . left = e NL } else {  x . right = e NL } NL case _ => throw UnreachableException ( ) NL } NL fixAfterInsertion ( e ) NL currentSize ++ NL modCount ++ NL }","func_name":"addEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func addEntryToEmptyMap ( key : K , value : V ) : Unit {  root . child = TreeMapEntry < K , V > ( key , value , root , cmp ) NL currentSize = 1 NL modCount ++ NL }","func_name":"addEntryToEmptyMap","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func fixAfterInsertion ( x : TreeNode < K , V > ) {   var t = x NL t . color = TreeColor . Red NL while ( t . hasValue && ! ( t is RootTreeNode < K , V > || t == root . child ) && t . parent . color . isRed ) {  if ( t . parentOf == t . parentOf . parentOf . leftOf ) {   let y = t . parentOf . parentOf . rightOf NL if ( let Red = y . colorOf ) {  t . parentOf . color = TreeColor . Black NL y . color = TreeColor . Black NL t . parentOf . parentOf . color = TreeColor . Red NL t = t . parentOf . parentOf NL } else {  if ( t == t . parentOf . rightOf ) {  t = t . parentOf NL rotateLeft ( t ) NL } NL t . parentOf . color = TreeColor . Black NL t . parentOf . parentOf . color = TreeColor . Red NL rotateRight ( t . parentOf . parentOf ) NL } NL } else {   let y = t . parentOf . parentOf . leftOf NL if ( let Red = y . colorOf ) {  t . parentOf . color = TreeColor . Black NL y . color = TreeColor . Black NL t . parentOf . parentOf . color = TreeColor . Red NL t = t . parentOf . parentOf NL } else {  if ( t == t . parentOf . leftOf ) {  t = t . parentOf NL rotateRight ( t ) NL } NL t . parentOf . color = TreeColor . Black NL t . parentOf . parentOf . color = TreeColor . Red NL rotateLeft ( t . parentOf . parentOf ) NL } NL } NL } NL root . child . color = TreeColor . Black NL }","func_name":"fixAfterInsertion","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func rotateLeft ( p : TreeNode < K , V > ) : Unit {  if ( p . hasValue ) {   let r = p . right NL p . right = r . left NL if ( r . left . hasValue ) {  r . left . parent = p NL } NL r . parent = p . parent NL if ( p . parent . hasNoValue ) {  root . child = r NL } else if ( p . parent . left == p ) {  p . parent . left = r NL } else {  p . parent . right = r NL } NL r . left = p NL p . parent = r NL } NL }","func_name":"rotateLeft","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func rotateRight ( p : TreeNode < K , V > ) : Unit {  if ( p . hasValue ) {   let l = p . left NL p . left = l . right NL if ( l . right . hasValue ) {  l . right . parent = p NL } NL l . parent = p . parent NL if ( p . parent . hasNoValue ) {  root . child = l NL } else if ( p . parent . right == p ) {  p . parent . right = l NL } else {  p . parent . left = l NL } NL l . right = p NL p . parent = l NL } NL }","func_name":"rotateRight","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func put ( key : K , value : V , replaceOld : Bool ) : Option < V > {   var t = root . child NL if ( t . hasNoValue ) {  addEntryToEmptyMap ( key , value ) NL return None NL } NL  var parent : TreeNode < K , V > = t NL  let cmp = this . cmp NL  var ord : Ordering = LT NL do {  parent = t NL ord = cmp ( key , t . key ) NL match ( ord ) { case LT => t = t . left NL case GT => t = t . right NL case EQ =>  let old = t . value NL if ( replaceOld ) {  t . value = value NL } NL return old NL } NL } while ( t . hasValue ) NL addEntry ( key , value , parent , ord . lt ) NL return None NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func remapValue ( t : TreeNode < K , V > , key : K , fn : ( K , Option < V > ) -> Option < V > ) : Option < V > {   let new = callRemappingFunctionWithCheck ( key , t . value , fn ) NL match ( new ) { case Some ( v ) => t . value = v NL return new NL case _ => deleteEntry ( t ) NL return None NL } NL }","func_name":"remapValue","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func deleteEntry ( p : TreeNode < K , V > ) : Unit {   var n = p NL modCount ++ NL currentSize -- NL if ( n . left . hasValue && n . right . hasValue ) {   let s = successor ( n ) NL n . key = s . key NL n . value = s . value NL n = s NL } NL  let replacement = if ( n . left . hasValue ) {  n . left NL } else {  n . right NL } NL if ( replacement . hasValue ) {  replacement . parent = n . parent NL if ( n . parent . hasNoValue ) {  root . child = replacement NL } else if ( n == n . parent . left ) {  n . parent . left = replacement NL } else {  n . parent . right = replacement NL } NL n . left = NoneTreeNode < K , V > . instance NL n . right = NoneTreeNode < K , V > . instance NL n . parent = NoneTreeNode < K , V > . instance NL if ( let Black = n . color ) {  fixAfterDeletion ( replacement ) NL } NL } else if ( n . parent . hasNoValue ) {  root . child = NoneTreeNode < K , V > . instance NL } else {  if ( let Black = n . color ) {  fixAfterDeletion ( p ) NL } NL if ( n . parent . hasValue ) {  if ( n == n . parent . left ) {  n . parent . left = NoneTreeNode < K , V > . instance NL } else if ( n == n . parent . right ) {  n . parent . right = NoneTreeNode < K , V > . instance NL } NL n . parent = NoneTreeNode < K , V > . instance NL } NL } NL }","func_name":"deleteEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func fixAfterDeletion ( x : TreeNode < K , V > ) : Unit {   var n = x NL while ( ! ( n == root . child || n is RootTreeNode < K , V > ) && n . colorOf . isBlack ) {  if ( n == n . parentOf . leftOf ) {   var sib = n . parentOf . rightOf NL if ( let Red = sib . colorOf ) {  sib . color = TreeColor . Black NL n . parentOf . color = TreeColor . Red NL rotateLeft ( n . parentOf ) NL sib = n . parentOf . rightOf NL } NL if ( let ( Black , Black ) = ( sib . leftOf . colorOf , sib . rightOf . colorOf ) ) {  sib . color = TreeColor . Red NL n = n . parentOf NL } else {  if ( let Black = sib . rightOf . colorOf ) {  sib . leftOf . color = TreeColor . Black NL sib . color = TreeColor . Red NL rotateRight ( sib ) NL sib = n . parentOf . rightOf NL } NL sib . color = n . parentOf . colorOf NL n . parentOf . color = TreeColor . Black NL sib . rightOf . color = TreeColor . Black NL rotateLeft ( n . parentOf ) NL n = root . child NL } NL } else {   var sib = n . parentOf . leftOf NL if ( let Red = sib . colorOf ) {  sib . color = TreeColor . Black NL n . parentOf . color = TreeColor . Red NL rotateRight ( n . parentOf ) NL sib = n . parentOf . leftOf NL } NL if ( let ( Black , Black ) = ( sib . rightOf . colorOf , sib . leftOf . colorOf ) ) {  sib . color = TreeColor . Red NL n = x . parentOf NL } else {  if ( let Black = sib . leftOf . colorOf ) {  sib . rightOf . color = TreeColor . Black NL sib . color = TreeColor . Red NL rotateLeft ( sib ) NL sib = n . parentOf . leftOf NL } NL sib . color = n . parentOf . colorOf NL n . parentOf . color = TreeColor . Black NL sib . leftOf . color = TreeColor . Black NL rotateRight ( n . parentOf ) NL n = root . child NL } NL } NL } NL n . color = TreeColor . Black NL }","func_name":"fixAfterDeletion","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"static func successor ( t : TreeNode < K , V > ) : TreeNode < K , V > {  if ( t . hasNoValue ) {  return NoneTreeNode < K , V > . instance NL } else if ( t . right . hasValue ) {   var p = t . right NL while ( p . left . hasValue ) {  p = p . left NL } NL return p NL } else {   var p = t . parent NL  var ch = t NL while ( p . hasValue && ch == p . right ) {  ch = p NL p = p . parent NL } NL return p NL } NL }","func_name":"successor","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"private func mergeValue ( t : TreeNode < K , V > , value : V , fn : ( V , V ) -> Option < V > ) : Option < V > {   let old = t . value NL  var new = None < V > NL if ( t . hasNoValue ) {  new = value NL } else {   let mc = modCount NL new = fn ( old , value ) NL if ( mc != modCount ) {  throw ConcurrentModificationException ( ) NL } NL } NL match ( new ) { case Some ( v ) => t . value = v NL return new NL case _ => deleteEntry ( t ) NL return None NL } NL }","func_name":"mergeValue","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func remove ( key : K ) : Option < V > {   let p = getEntry ( key ) NL if ( p . hasNoValue ) {  return None NL } NL  let old = p . value NL deleteEntry ( p ) NL return old NL }","func_name":"remove","docstring":"/*\n     * 从此映射中删除指定键的映射（如果存在）\n     * 参数 key - 传入要删除的 key\n     * 返回值 Option<V> - 被移除映射的 V 用 Option 封装\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) {  for ( k in keys ) {  remove ( k ) NL } NL }","func_name":"removeAll","docstring":"/*\n     * 从此映射中删除指定集合的映射（如果存在）\n     * 参数 keys - 传人要删除的集合\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) {  for ( ( k , v ) in this where predicate ( k , v ) ) {  remove ( k ) NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足条件，则删除对应的键值\n     * 参数 predicate - 传递一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  get ( key ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  put ( key , value ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func clear ( ) : Unit {  modCount ++ NL currentSize = 0 NL root . child = NoneTreeNode < K , V > . instance NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func clone ( ) : TreeMap < K , V > {  return TreeMap < K , V > ( this , cmp ) NL }","func_name":"clone","docstring":"/*\n     * 克隆 Map\n     * 返回值 Map<K, V> - 返回一个 Map<K, V>\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func getFirstEntry ( ) : TreeNode < K , V > {   var p = root . child NL if ( p . hasValue ) {  while ( p . left . hasValue ) {  p = p . left NL } NL } NL return p NL }","func_name":"getFirstEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func getLastEntry ( ) : TreeNode < K , V > {   var p = root . child NL if ( p . hasValue ) {  while ( p . right . hasValue ) {  p = p . right NL } NL } NL return p NL }","func_name":"getLastEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func firstEntry ( ) : Option < ( K , V ) > {  return exportEntry ( getFirstEntry ( ) ) NL }","func_name":"firstEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func lastEntry ( ) : Option < ( K , V ) > {  return exportEntry ( getLastEntry ( ) ) NL }","func_name":"lastEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func pollFirstEntry ( ) : Option < ( K , V ) > {   let p = getFirstEntry ( ) NL if ( p . hasNoValue ) {  deleteEntry ( p ) NL return None NL } NL return exportEntry ( p ) NL }","func_name":"pollFirstEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func pollLastEntry ( ) : Option < ( K , V ) > {   let p = getLastEntry ( ) NL if ( p . hasNoValue ) {  deleteEntry ( p ) NL return None NL } NL return exportEntry ( p ) NL }","func_name":"pollLastEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func lowerEntry ( key : K ) : Option < ( K , V ) > {  return exportEntry ( getLowerEntry ( key ) ) NL }","func_name":"lowerEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func lowerKey ( key : K ) : Option < K > {  return keyOrNone ( getLowerEntry ( key ) ) NL }","func_name":"lowerKey","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func floorEntry ( key : K ) : Option < ( K , V ) > {  return exportEntry ( getFloorEntry ( key ) ) NL }","func_name":"floorEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func floorKey ( key : K ) : Option < K > {  return keyOrNone ( getFloorEntry ( key ) ) NL }","func_name":"floorKey","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func ceilingEntry ( key : K ) : Option < ( K , V ) > {  return exportEntry ( getCeilingEntry ( key ) ) NL }","func_name":"ceilingEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func ceilingKey ( key : K ) : Option < K > {  return keyOrNone ( getCeilingEntry ( key ) ) NL }","func_name":"ceilingKey","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func higherEntry ( key : K ) : Option < ( K , V ) > {  return exportEntry ( getHigherEntry ( key ) ) NL }","func_name":"higherEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func higherKey ( key : K ) : Option < K > {  return keyOrNone ( getHigherEntry ( key ) ) NL }","func_name":"higherKey","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"static func exportEntry ( e : TreeNode < K , V > ) : Option < ( K , V ) > {  if ( e . hasValue ) {  ( e . key , e . value ) NL } else {  None NL } NL }","func_name":"exportEntry","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"static func keyOrNone ( e : TreeNode < K , V > ) : Option < K > {  match ( e ) { case n : TreeMapEntry < K , V > => n . key NL case _ => None NL } NL }","func_name":"keyOrNone","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"static func key ( e : TreeNode < K , V > ) : Option < K > {  match ( e ) { case n : TreeMapEntry < K , V > => n . key NL case _ => throw NoSuchElementException ( ) NL } NL }","func_name":"key","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func keys ( ) : Keys < K > {  MapKeys < K , V > ( this ) NL }","func_name":"keys","docstring":"/*\n     * 返回 Map 中所有的 key，并将所有 key 存储在一个 Keys 容器中\n     * 返回值 Keys<K> - 保存所有返回的 key\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func values ( ) : Values < V > {  MapValues < K , V > ( this ) NL }","func_name":"values","docstring":"/*\n     * 返回 Map 中所有的 value，并将所有 value 存储在一个 Values 容器中\n     * 返回值 Values<V> - 保存所有返回的 value\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func descending ( ) : TreeMap < K , V > {  TreeMap < K , V > ( this , { k1 , k2 => cmp ( k2 , k1 ) NL } ) NL }","func_name":"descending","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func descendingKeys ( ) : Keys < K > {  descending ( ) . keys ( ) NL }","func_name":"descendingKeys","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func descendingValues ( ) : Values < V > {  descending ( ) . values ( ) NL }","func_name":"descendingValues","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {  TreeMapIterator < K , V > ( this , getFirstEntry ( ) ) NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<(K,V)> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func subMap ( low : K , high : K , lowInclusive ! : Bool , highInclusive ! : Bool ) : SubTreeMap < K , V > {  SubTreeMap < K , V > ( this , low , high , lowInclusive : lowInclusive , highInclusive : highInclusive ) NL }","func_name":"subMap","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func headMap ( end : K , inclusive ! : Bool ) : SubTreeMap < K , V > {  SubTreeMap < K , V > ( this , Option < K > . None , end , highInclusive : inclusive ) NL }","func_name":"headMap","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func tailMap ( start : K , inclusive ! : Bool ) : SubTreeMap < K , V > {  SubTreeMap < K , V > ( this , start , Option < K > . None , lowInclusive : inclusive ) NL }","func_name":"tailMap","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func next ( ) : Option < ( K , V ) > {   let e = nextNode NL if ( e . hasNoValue ) {  throw NoSuchElementException ( ) NL } NL if ( map . modCount != expectedModCount ) {  throw ConcurrentModificationException ( ) NL } NL nextNode = TreeMap < K , V > . successor ( e ) NL lastReturned = e NL return ( e . key , e . value ) NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func containsValue ( value : V ) : Bool {   var e : TreeNode < K , V > = getFirstEntry ( ) NL while ( ! ( e is NoneTreeNode < K , V > || e is RootTreeNode < K , V > ) ) {  if ( value == e . value ) {  return true NL } NL e = successor ( e ) NL } NL return false NL }","func_name":"containsValue","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func next ( ) : Option < ( K , V ) > {  while ( true ) {   let opt = itr . next ( ) NL if ( let Some ( entry ) = opt ) {  if ( map . inRange ( entry [ 0 ] ) ) {  return opt NL } NL } else {  return None NL } NL } NL return None NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func origin ( ) : TreeMap < K , V > {  origin_ NL }","func_name":"origin","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func descending ( ) : SubTreeMap < K , V > {  SubTreeMap < K , V > ( { k1 , k2 => cmp ( k2 , k1 ) NL } , origin_ , high , low , lowInclusive : highInclusive , highInclusive : lowInclusive ) NL }","func_name":"descending","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  return size == 0 NL }","func_name":"isEmpty","docstring":"/*\n     * 判断对象是否为空\n     * 返回值 Bool - 若为空返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func toArray ( ) : Array < ( K , V ) > {  return Array < ( K , V ) > ( this ) NL }","func_name":"toArray","docstring":"/*\n     * 将对象转为数组类型\n     * 返回值 Array<T> - 转换后的数组\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {   let itr : Iterator < ( K , V ) > = origin_ . iterator ( ) NL  let subitr : SubTreeMapIterator < K , V > = SubTreeMapIterator < K , V > ( itr , this ) NL return subitr NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<(K,V)> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func inRange ( key : K ) : Bool {   func compareKey ( k : K , expected : Ordering , including : Bool ) : Bool {   let ordering = comparator ( k , key ) NL ordering == expected || ( including && ordering == Ordering . EQ ) NL } NL  func isInRange ( keyOpt : Option < K > , expected : Ordering , including : Bool ) : Bool {  if ( let Some ( k ) = keyOpt ) {  compareKey ( k , expected , including ) NL } NL true NL } NL return isInRange ( low , Ordering . LT , lowInclusive ) && isInRange ( high , Ordering . GT , highInclusive ) NL }","func_name":"inRange","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func compareKey ( k : K , expected : Ordering , including : Bool ) : Bool {   let ordering = comparator ( k , key ) NL ordering == expected || ( including && ordering == Ordering . EQ ) NL }","func_name":"compareKey","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func isInRange ( keyOpt : Option < K > , expected : Ordering , including : Bool ) : Bool {  if ( let Some ( k ) = keyOpt ) {  compareKey ( k , expected , including ) NL } NL true NL }","func_name":"isInRange","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func exec < T > ( key : K , fn : ( ) -> Option < T > ) : Option < T > {  if ( inRange ( key ) ) {  return fn ( ) NL } NL return None NL }","func_name":"exec","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func get ( key : K ) : Option < V > {  return exec ( key ) { origin_ . get ( key ) NL } NL }","func_name":"get","docstring":"/*\n     * 根据 key 得到 Map 中映射的值\n     * 参数 key - 传递 key，获取 value\n     * 返回值 Option<V> - key 对应的值是用 Option 封装的\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func contains ( key : K ) : Bool {   func fn ( ) : Option < Bool > {  Some ( origin_ . contains ( key ) ) NL } NL return exec ( key , fn ) ?? false NL }","func_name":"contains","docstring":"/*\n     * 判断是否包含指定键的映射\n     * 参数 key - 传递要判断的 key\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"func fn ( ) : Option < Bool > {  Some ( origin_ . contains ( key ) ) NL }","func_name":"fn","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  for ( k in keys ) {  if ( contains ( k ) ) {  return false NL } NL } NL return true NL }","func_name":"containsAll","docstring":"/*\n     * 判断是否包含指定集合键的映射\n     * 参数 keys - 传递待判断的 keys\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func put ( key : K , value : V ) : Option < V > {  return exec ( key ) { origin_ . put ( key , value ) NL } NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func put ( entry : ( K , V ) ) : Option < V > {  return put ( entry [ 0 ] , entry [ 1 ] ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  for ( e in elements ) {  put ( e ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 element - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func remove ( key : K ) : Option < V > {  return exec ( key ) { origin_ . remove ( key ) NL } NL }","func_name":"remove","docstring":"/*\n     * 从此映射中删除指定键的映射（如果存在）\n     * 参数 key - 传入要删除的 key\n     * 返回值 Option<V> - 被移除映射的 V 用 Option 封装\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  for ( k in keys ) {  if ( inRange ( k ) ) {  remove ( k ) NL } NL } NL }","func_name":"removeAll","docstring":"/*\n     * 从此映射中删除指定集合的映射（如果存在）\n     * 参数 keys - 传人要删除的集合\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  for ( entry in this ) {   let ( k , v ) = entry NL if ( inRange ( k ) && predicate ( k , v ) ) {  remove ( k ) NL } NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足条件，则删除对应的键值\n     * 参数 predicate - 传递一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func clear ( ) : Unit {  removeIf { k , v => inRange ( k ) NL } NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func clone ( ) : Map < K , V > {  return TreeMap < K , V > ( this , cmp ) NL }","func_name":"clone","docstring":"/*\n     * 克隆 Map\n     * 返回值 Map<K, V> - 返回一个 Map<K, V>\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  get ( key ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  put ( key , value ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func keys ( ) : Keys < K > {  return MapKeys < K , V > ( this ) NL }","func_name":"keys","docstring":"/*\n     * 返回 Map 中所有的 key，并将所有 key 存储在一个 Keys 容器中\n     * 返回值 Keys<K> - 保存所有返回的 key\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func values ( ) : Values < V > {  return MapValues < K , V > ( this ) NL }","func_name":"values","docstring":"/*\n     * 返回 Map 中所有的 value，并将所有 value 存储在一个 Values 容器中\n     * 返回值 Values<V> - 保存所有返回的 value\n     */"}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func subMap ( low : K , high : K , lowInclusive ! : Bool = true , highInclusive ! : Bool = false ) : SubTreeMap < K , V > {   let cmp = this . cmp NL  let l = match ( this . low ) { case Some ( l ) => if ( cmp ( low , l ) . gt ) {  low NL } else {  l NL } NL case _ => low NL } NL  let h = match ( this . high ) { case Some ( h ) => if ( cmp ( high , h ) . lt ) {  high NL } else {  h NL } NL case _ => high NL } NL SubTreeMap < K , V > ( origin_ , l , h , lowInclusive : lowInclusive , highInclusive : highInclusive ) NL }","func_name":"subMap","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func headMap ( end : K , inclusive ! : Bool = false ) : SubTreeMap < K , V > {   let h = match ( this . high ) { case Some ( h ) => if ( cmp ( end , h ) . lt ) {  end NL } else {  h NL } NL case _ => end NL } NL SubTreeMap < K , V > ( origin_ , Option < K > . None , h , highInclusive : inclusive ) NL }","func_name":"headMap","docstring":""}
{"repo":"fountain","file":"TreeMap.cj","path":"fountain/src/collection/TreeMap.cj","code_tokens":"public func tailMap ( start : K , inclusive ! : Bool = true ) : SubTreeMap < K , V > {   let l = match ( this . low ) { case Some ( l ) => if ( cmp ( start , l ) . gt ) {  start NL } else {  l NL } NL case _ => low NL } NL SubTreeMap < K , V > ( origin_ , l , Option < K > . None , lowInclusive : inclusive ) NL }","func_name":"tailMap","docstring":""}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"public func prev ( ) : Option < T > {  if ( idx > = 0 ) {   let opt = list . get ( idx ) NL idx -- NL opt NL } else {  None < T > NL } NL }","func_name":"prev","docstring":""}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"public func reverseIterator ( ) : ReverseIterator < T > {  this NL }","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"public func reverseIterator ( ) : ReverseIterator < T > {  ListReverseIterator < T > ( size - 1 , this ) NL }","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func get ( index : Int64 ) : Option < T >","func_name":"get","docstring":"/*\n     * 返回此 List 中指定位置的元素\n     * 参数 index - index 表示 get 接口的索引\n     * 返回值 Option<T> - 返回指定位置的元素\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func set ( index : Int64 , element : T ) : Unit","func_name":"set","docstring":"/*\n     * 将此 List 中指定位置的元素替换为指定的元素\n     * 参数 index - 要设置的索引值\n     * 参数 element - 元素的 T 类型\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func append ( element : T ) : Unit","func_name":"append","docstring":"/*\n     * 将指定的元素附加到此 List 的末尾\n     * 参数 element - 插入元素，类型为 t\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func appendAll ( elements : Collection < T > ) : Unit","func_name":"appendAll","docstring":"/*\n     * 将指定集合中的所有元素附加到此 List 的末尾\n     * 按指定集合的迭代器返回的顺序排列\n     * 参数 elements - 导入集合类型的元素，并逐个插入\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func appendAll ( elements : Iterable < T > ) : Unit {  for ( e in elements ) {  append ( e ) NL } NL }","func_name":"appendAll","docstring":"/*\n     * 将指定集合中的所有元素附加到此 List 的末尾\n     * 按指定集合的迭代器返回的顺序排列\n     * 参数 elements - 导入集合类型的元素，并逐个插入\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func insert ( index : Int64 , element : T ) : Unit","func_name":"insert","docstring":"/*\n     * 在此 List 中的指定位置插入指定元素\n     * 参数 index - 要插入的元素的索引\n     * 参数 element - 要插入的元素类型为 T\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func insertAll ( index : Int64 , elements : Collection < T > ) : Unit","func_name":"insertAll","docstring":"/*\n     * 从指定位置开始，将指定集合中的所有元素插入此 List\n     * 参数 index - 要插入的元素的索引\n     * 参数 element - 要插入的元素属于集合类型\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func prepend ( element : T ) : Unit","func_name":"prepend","docstring":"/*\n     * 在起始位置，将指定元素插入此 List\n     * 参数 element - 要插入的元素属于集合类型\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func prependAll ( elements : Collection < T > ) : Unit","func_name":"prependAll","docstring":"/*\n     * 从起始位置开始，将指定集合中的所有元素插入此 List\n     * 参数 element - 要插入的元素属于集合类型\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func remove ( index : Int64 ) : T","func_name":"remove","docstring":"/*\n     * 删除此 List 中指定位置的元素\n     * 参数 index - 删除元素的索引\n     * 返回值 T - 被移除的元素\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func remove ( range : Range < Int64 > ) : Unit","func_name":"remove","docstring":"/*\n     * 删除此 List 中指定位置的元素\n     * 参数 index - 删除元素的索引\n     * 返回值 T - 被移除的元素\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func removeIf ( predicate : ( T ) -> Bool ) : Unit","func_name":"removeIf","docstring":"/*\n     * 删除此 List 中满足给定 lambda 表达式或函数的所有元素\n     * 参数 predicate - 传递判断删除的条件\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func clear ( ) : Unit","func_name":"clear","docstring":"/* 从此 List 中删除所有元素 */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func reverse ( ) : Unit","func_name":"reverse","docstring":"/* 反转此 List 中元素的顺序 */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func sortBy ( comparator : ( T , T ) -> Ordering , stable ! : Bool ) : Unit","func_name":"sortBy","docstring":"/*\n     * 通过传入的比较函数，根据其返回值 Ordering 类型的结果，可对数组进行自定义排序\n     * 参数 comparator - (T, T) -> Ordering 类型，例:\n     * comparator: (t1: T, t2: T) -> Ordering，\n     * 如果 comparator 的返回值为 Ordering.GT，排序后 t1 在 t2\n     * 后；如果 comparator 的返回值为 Ordering.LT，排序后 t1 在\n     * t2 前；如果 comparator 的返回值为 Ordering.EQ，且为稳定排序\n     * 那么 t1 在 t2 之前； 如果 comparator 的返回值为 Ordering.EQ，\n     * 且为不稳定排序，那么 t1，t2 顺序不确定\n     * 参数 stable - 是否使用稳定排序\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func reserve ( additional : Int64 ) : Unit","func_name":"reserve","docstring":"/*\n     * 为至少要插入到此 List 中的更多元素保留容量\n     * 参数 additional - 确保有足够的容量，additional 表示要添加的数量\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func capacity ( ) : Int64","func_name":"capacity","docstring":"/* 返回值 Int64 - List 的容量 */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func isEmpty ( ) : Bool","func_name":"isEmpty","docstring":"/*\n     * 判断 List 是否为空\n     * 返回值 Bool - 如果为空，则返回 true, 否则，返回 false\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func slice ( range : Range < Int64 > ) : ArrayList < T >","func_name":"slice","docstring":"/*\n     * 传入参数 range 作为索引，返回索引对应的 List<T>\n     * 参数 range - 传递切片的范围\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func clone ( ) : ArrayList < T >","func_name":"clone","docstring":"/*\n     * 克隆新 List\n     * 返回值 List<T> - 返回新 List<T>\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"operator func [ ] ( index : Int64 ) : T","func_name":"[]","docstring":""}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"operator func [ ] ( index : Int64 , value ! : T ) : Unit","func_name":"[]","docstring":""}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"operator func [ ] ( range : Range < Int64 > ) : ArrayList < T >","func_name":"[]","docstring":""}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func toArray ( ) : Array < T >","func_name":"toArray","docstring":"/*\n     * 将对象转为数组类型\n     * 返回值 Array<T> - 转换后的数组\n     */"}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func iterator ( ) : Iterator < T >","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"List.cj","path":"fountain/src/collection/List.cj","code_tokens":"func reverseIterator ( ) : ReverseIterator < T >","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public operator func == ( other : GraphNodeColor ) {  match ( ( this , other ) ) { case ( White , White ) | ( Gray , Gray ) | ( Black , Black ) => true NL case _ => false NL } NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public operator func != ( other : GraphNodeColor ) {  ! ( this == other ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func hashCode ( ) {  id . hashCode ( ) NL }","func_name":"hashCode","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public operator func == ( other : GraphNode < ID , V > ) : Bool {  this . id == other . id NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public operator func != ( other : GraphNode < ID , V > ) : Bool {  this . id != other . id NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func hashCode ( ) {  hash NL }","func_name":"hashCode","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public operator func == ( other : GraphEdge < ID , W > ) {  if ( hasDirection ) {  this . start == other . start && this . end == other . end NL } else {  ( this . start == other . start && this . end == other . end ) || this . start == other . end && this . end == other . start NL } NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public operator func != ( other : GraphEdge < ID , W > ) {  ! ( this == other ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"func getId ( ) : ID","func_name":"getId","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"func getPrev ( ) : GraphRingNode < ID >","func_name":"getPrev","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getId ( ) : ID {  throw UnreachableException ( ) NL }","func_name":"getId","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getPrev ( ) : GraphRingNode < ID > {  throw UnreachableException ( ) NL }","func_name":"getPrev","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getId ( ) : ID {  id NL }","func_name":"getId","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getPrev ( ) : GraphRingNode < ID > {  prev NL }","func_name":"getPrev","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"func append ( id : ID ) {  tail = GraphRingIDNode < ID > ( id , prev : tail ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"func confirm ( ) {  ring = true NL }","func_name":"confirm","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func toString ( ) : String {   var current = tail NL  let string = StringBuilder ( ) NL while ( current . isNotNone ) {  if ( ! string . isEmpty ( ) ) {  string . append (  <-  ) NL } NL string . append ( current . getId ( ) ) NL current = current . getPrev ( ) NL } NL string . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func iterator ( ) : Iterator < ID > {  GraphRingIterator < ID > ( tail ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func next ( ) : Option < ID > {  if ( current . isNotNone ) {   let id = current . getId ( ) NL current = current . getPrev ( ) NL return id NL } NL None NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"func getId ( ) : ID","func_name":"getId","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"func setFa ( fa : GraphRoute < ID , C > ) : Unit","func_name":"setFa","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"func getG ( ) : C","func_name":"getG","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"func toArrayList ( ) : ArrayList < ID >","func_name":"toArrayList","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getId ( ) : ID {  throw UnreachableException ( ) NL }","func_name":"getId","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func setFa ( fa : GraphRoute < ID , C > ) : Unit {  throw UnreachableException ( ) NL }","func_name":"setFa","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getG ( ) : C {  throw UnreachableException ( ) NL }","func_name":"getG","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func toArrayList ( ) : ArrayList < ID > {  ArrayList < ID > ( ) NL }","func_name":"toArrayList","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public operator func == ( other : GraphRoute < ID , C > ) {  other is GraphRouteNode < ID , C > && this . id == other . getId ( ) NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public operator func != ( other : GraphRoute < ID , C > ) {  ! ( this == other ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func hashCode ( ) : Int64 {  this . id . hashCode ( ) NL }","func_name":"hashCode","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getId ( ) : ID {  id NL }","func_name":"getId","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func setFa ( fa : GraphRoute < ID , C > ) {  this . fa = fa NL }","func_name":"setFa","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getG ( ) : C {  g NL }","func_name":"getG","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func toString ( ) : String {   var current : GraphRoute < ID , C > = this NL  let string = StringBuilder ( ) NL while ( current is GraphRouteNode < ID , C > ) {  string . append ( current . getId ( ) ) NL current = current . prev NL if ( current is GraphRouteNode < ID , C > ) {  string . append (  <-  ) NL } NL } NL return string . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func toArrayList ( ) : ArrayList < ID > {   var current : GraphRoute < ID , C > = this NL  let list = ArrayList < ID > ( ) NL while ( current is GraphRouteNode < ID , C > ) {  list . append ( current . getId ( ) ) NL current = current . prev NL } NL return list NL }","func_name":"toArrayList","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func addNode ( id : ID , value : V ) : Unit {  nodes . put ( id , GraphNode < ID , V > ( id , value ) ) NL }","func_name":"addNode","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func addNode ( node : ( ID , V ) ) : Unit {  addNode ( node [ 0 ] , node [ 1 ] ) NL }","func_name":"addNode","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func addNodes ( values : Iterable < ( ID , V ) > ) {  for ( v in values ) {  addNode ( v ) NL } NL }","func_name":"addNodes","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func addEdge ( start : ID , end : ID , weight : W , hasDirection ! : Bool = false ) {   let edge = GraphEdge < ID , W > ( start , end , weight , hasDirection ) NL edges . computeIfAbsent ( start ) { k => ArrayList < GraphEdge < ID , W > > ( ) NL } . getOrThrow ( ) . append ( edge ) NL if ( ! hasDirection ) {  edges . computeIfAbsent ( end ) { k => ArrayList < GraphEdge < ID , W > > ( ) NL } . getOrThrow ( ) . append ( GraphEdge < ID , W > ( end , start , weight , hasDirection ) ) NL } NL }","func_name":"addEdge","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func addEdge ( edge : ( ID , ID , W ) ) {  addEdge ( edge [ 0 ] , edge [ 1 ] , edge [ 2 ] ) NL }","func_name":"addEdge","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func addEdge ( edge : ( ID , ID , W , Bool ) ) {  addEdge ( edge [ 0 ] , edge [ 1 ] , edge [ 2 ] , hasDirection : edge [ 3 ] ) NL }","func_name":"addEdge","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func addEdges ( edges : Iterable < ( ID , ID , W ) > ) {  for ( e in edges ) {  addEdge ( e ) NL } NL }","func_name":"addEdges","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func addEdges ( edges : Iterable < ( ID , ID , W , Bool ) > ) {  for ( e in edges ) {  addEdge ( e ) NL } NL }","func_name":"addEdges","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func containsNode ( id : ID ) : Bool {  nodes . contains ( id ) NL }","func_name":"containsNode","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getNodeValue ( id : ID ) : Option < V > {  nodes . get ( id ) ? . val NL }","func_name":"getNodeValue","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func getEdges ( id : ID ) : ArrayList < ( ID , ID , W , Bool ) > {   let result = ArrayList < ( ID , ID , W , Bool ) > ( ) NL match ( edges . get ( id ) ) { case Some ( list ) => for ( edge in list ) {  result . append ( ( edge . start , edge . end , edge . weight , edge . hasDirection ) ) NL } NL case _ => ( ) NL } NL return result NL }","func_name":"getEdges","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func rings ( one ! : Bool = false ) : ArrayList < GraphRing < ID > > {   let colorMap = HashMap < ID , GraphNodeColor > ( ) NL  let stack = LinkedDeque < GraphRingNode < ID > > ( ) NL  let rings = ArrayList < GraphRing < ID > > ( ) NL for ( n in nodes . values ( ) ) {  stack . push ( GraphRingIDNode < ID > ( n . id ) ) NL colorMap [ n . id ] = GraphNodeColor . White NL  var lastId = None < ID > NL while ( ! stack . isEmpty ( ) ) {   let n = stack . pop ( ) . getOrThrow ( ) NL  let id = n . getId ( ) NL if ( let Some ( color ) = colorMap . get ( id ) ) {  if ( let Gray = color ) {   let ring = GraphRing < ID > ( n ) NL rings . append ( ring ) NL if ( one ) {  return rings NL } else {  continue NL } NL } NL } NL if ( let Some ( last ) = lastId ) {  if ( last != id ) {  colorMap [ id ] = GraphNodeColor . Gray NL } NL } NL if ( ! stack . isEmpty ( ) ) {   let nextId = stack . head ( ) . getOrThrow ( ) . getId ( ) NL if ( id != nextId ) {  colorMap [ id ] = GraphNodeColor . Black NL } NL } NL if ( let Some ( nexts ) = edges . get ( id ) ) {  for ( next in nexts ) {   let nextId = next . end NL stack . push ( GraphRingIDNode < ID > ( nextId , prev : n ) ) NL } NL } NL lastId = id NL } NL } NL return rings NL }","func_name":"rings","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func hasRing ( ) : Bool {  ! rings ( one : true ) . isEmpty ( ) NL }","func_name":"hasRing","docstring":""}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func route < C > ( start : ID , end : ID , heuristic : ( ID , ID ) -> C ) : ArrayList < ID > where C <: Comparable < C > & GraphRouteEvaluation < C > {  route < C > ( start , end , Comparator < C > . compare < C > , heuristic ) NL }","func_name":"route","docstring":"//A* 参考实现https://blog.csdn.net/ldstartnow/article/details/51897970"}
{"repo":"fountain","file":"Graph.cj","path":"fountain/src/collection/Graph.cj","code_tokens":"public func route < C > ( start : ID , end : ID , comparator : ( C , C ) -> Ordering , heuristic : ( ID , ID ) -> C ) : ArrayList < ID > where C <: GraphRouteEvaluation < C > {   let opened = LinkedMap < ID , GraphRouteNode < ID , C > > ( ) NL  let closed = LinkedMap < ID , GraphRouteNode < ID , C > > ( ) NL  var route : GraphRoute < ID , C > = GraphRouteNone < ID , C > . instance NL opened [ start ] = GraphRouteNode < ID , C > ( start , h : heuristic ( start , end ) ) NL do {   let openedItr = opened . values ( ) . iterator ( ) NL  var currentNode = openedItr . next ( ) . getOrThrow ( ) NL for ( n in openedItr where comparator ( currentNode . f , n . f ) . gt ) {  currentNode = n NL } NL  let curId = currentNode . getId ( ) NL closed [ curId ] = currentNode NL opened . remove ( curId ) NL  let nexts = edges . get ( currentNode . getId ( ) ) NL if ( let Some ( nexts ) = edges . get ( currentNode . getId ( ) ) ) {  for ( next in nexts ) {   let tmpId = next . start NL  let tmp = GraphRouteNode < ID , C > ( tmpId , h : heuristic ( tmpId , end ) , fa : currentNode ) NL if ( closed . contains ( tmpId ) ) {  continue NL } NL if ( opened . putIfNonExistent ( tmpId , tmp ) . some ) {   var prev : GraphRoute < ID , C > = GraphRouteNone < ID , C > . instance NL for ( r in opened where r [ 0 ] == tmpId ) {  prev = r [ 1 ] NL break NL } NL if ( comparator ( tmp . g , prev . getG ( ) ) . lt ) {  prev . setFa ( currentNode ) NL } NL } NL } NL } else {  return ArrayList < ID > ( ) NL } NL for ( r in opened . values ( ) where r . getId ( ) == end ) {  route = r NL break NL } NL } while ( ! opened . isEmpty ( ) ) NL route . toArrayList ( ) NL }","func_name":"route","docstring":"//A* 参考实现https://blog.csdn.net/ldstartnow/article/details/51897970"}
{"repo":"fountain","file":"GrowSizePolicy.cj","path":"fountain/src/collection/GrowSizePolicy.cj","code_tokens":"public func reject ( o : C , fn : ( ) -> Unit ) : Unit {  o . grow ( ) NL fn ( ) NL }","func_name":"reject","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"func put ( value : T , timeout ! : UInt64 ) : Unit","func_name":"put","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"func take ( timeout ! : UInt64 ) : Option < T >","func_name":"take","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"func awaitHead ( timeout ! : UInt64 ) : Bool","func_name":"awaitHead","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"func wakeHead ( ) : Unit","func_name":"wakeHead","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"func awaitTail ( timeout ! : UInt64 ) : Bool","func_name":"awaitTail","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"func wakeTail ( ) : Unit","func_name":"wakeTail","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"public func awaitHead ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {  true NL }","func_name":"awaitHead","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"public func wakeHead ( ) : Unit {  }","func_name":"wakeHead","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"public func awaitTail ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {  true NL }","func_name":"awaitTail","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"public func wakeTail ( ) : Unit {  }","func_name":"wakeTail","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"public func awaitHead ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {  synchronized ( monitor ) {  monitor . wait ( headCond , timeout : timeout ) NL } NL }","func_name":"awaitHead","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"public func awaitTail ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {  synchronized ( monitor ) {  monitor . wait ( tailCond , timeout : timeout ) NL } NL }","func_name":"awaitTail","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"public func wakeHead ( ) : Unit {  synchronized ( monitor ) {  monitor . notifyAll ( headCond ) NL } NL }","func_name":"wakeHead","docstring":""}
{"repo":"fountain","file":"BlockingQueue.cj","path":"fountain/src/collection/BlockingQueue.cj","code_tokens":"public func wakeTail ( ) : Unit {  synchronized ( monitor ) {  monitor . notifyAll ( tailCond ) NL } NL }","func_name":"wakeTail","docstring":""}
{"repo":"fountain","file":"ValueEqualMap.cj","path":"fountain/src/collection/ValueEqualMap.cj","code_tokens":"func containsValue ( value : V ) : Bool","func_name":"containsValue","docstring":""}
{"repo":"fountain","file":"Growable.cj","path":"fountain/src/collection/Growable.cj","code_tokens":"func grow ( ) : Unit","func_name":"grow","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func next ( ) : Option < T > {  syncer . tryRead < T > { itr . next ( ) NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"static public func createHashSet < T > ( ) : SyncSet < T > where T <: Hashable & Equatable < T > {  SyncSet < T > ( HashSet < T > ( ) ) NL }","func_name":"createHashSet","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"static public func createHashSet < T > ( elements : Iterable < T > ) : SyncSet < T > where T <: Hashable & Equatable < T > {   let set = SyncSet < T > ( HashSet < T > ( ) ) NL set . putAll ( elements ) NL return set NL }","func_name":"createHashSet","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"static public func createHashSet < T > ( set : HashSet < T > ) : SyncSet < T > where T <: Hashable & Equatable < T > {   let itr : Iterable < T > = set NL createHashSet < T > ( itr ) NL }","func_name":"createHashSet","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"static public func createSortedSet < T > ( ) : SyncSet < T > where T <: Comparable < T > {  SyncSet < T > ( TreeSet < T > . create < T > ( ) ) NL }","func_name":"createSortedSet","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"static public func createSortedSet < T > ( elements : SortedSet < T > ) : SyncSet < T > where T <: Comparable < T > {   let itr : Iterable < T > = elements NL  let set = createSortedSet < T > ( itr , elements . comparator ) NL return set NL }","func_name":"createSortedSet","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"static public func createSortedSet < T > ( comparator : ( T , T ) -> Ordering ) : SyncSet < T > where T <: Equatable < T > {  SyncSet < T > ( TreeSet < T > ( comparator ) ) NL }","func_name":"createSortedSet","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"static public func createSortedSet < T > ( elements : Iterable < T > , comparator : ( T , T ) -> Ordering ) : SyncSet < T > where T <: Equatable < T > {   let set = createSortedSet < T > ( comparator ) NL set . putAll ( elements ) NL return set NL }","func_name":"createSortedSet","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func put ( value : T ) : Bool {  syncer . tryWrite < Bool > { store . put ( value ) NL } ?? false NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func putAll ( values : Collection < T > ) : Unit {  syncer . tryWrite < Unit > { store . putAll ( values ) NL } ?? ( ) NL }","func_name":"putAll","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func putAll ( values : Iterable < T > ) : Unit {  syncer . tryWrite < Unit > { for ( v in values ) {  store . put ( v ) NL } NL } ?? ( ) NL }","func_name":"putAll","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func clear ( ) : Unit {  syncer . tryWrite < Unit > { store . clear ( ) NL } NL }","func_name":"clear","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func clone ( ) : SyncSet < T > {  syncer . tryRead < SyncSet < T > > { return SyncSet < T > ( store . clone ( ) ) NL } . getOrThrow ( ) NL }","func_name":"clone","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func contains ( value : T ) : Bool {  syncer . tryRead < Bool > { store . contains ( value ) NL } ?? false NL }","func_name":"contains","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func containsAll ( values : Collection < T > ) : Bool {   let itr : Iterable < T > = values NL containsAll ( itr ) NL }","func_name":"containsAll","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func containsAll ( values : Iterable < T > ) : Bool {  syncer . tryRead < Bool > { for ( v in values where ! contains ( v ) ) {  return false NL } NL return true NL } ?? false NL }","func_name":"containsAll","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func isEmpty ( ) : Bool {  syncer . tryRead < Bool > { store . isEmpty ( ) NL } ?? false NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  SyncSetIterator < T > ( store . iterator ( ) , syncer ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func subsetOf ( set : Set < T > ) : Bool {  syncer . tryRead < Bool > { for ( v in store where ! set . contains ( v ) ) {  return false NL } NL return true NL } ?? false NL }","func_name":"subsetOf","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func remove ( value : T ) : Bool {  syncer . tryWrite < Bool > { store . remove ( value ) NL } ?? false NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func removeAll ( values : Collection < T > ) : Unit {   let itr : Iterable < T > = values NL removeAll ( itr ) NL }","func_name":"removeAll","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func removeAll ( values : Iterable < T > ) : Unit {  syncer . tryWrite < Unit > { for ( v in values ) {  remove ( v ) NL } NL } ?? ( ) NL }","func_name":"removeAll","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  syncer . tryWrite < Unit > { store . removeIf ( predicate ) NL } ?? ( ) NL }","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"SyncSet.cj","path":"fountain/src/collection/SyncSet.cj","code_tokens":"public func retainAll ( set : Set < T > ) : Unit {  syncer . tryWrite < Unit > { for ( v in store where ! set . contains ( v ) ) {  store . remove ( v ) NL } NL } ?? ( ) NL }","func_name":"retainAll","docstring":""}
{"repo":"fountain","file":"KeyPutState.cj","path":"fountain/src/collection/KeyPutState.cj","code_tokens":"public operator func == ( other : KeyPutState ) : Bool {  match ( ( this , other ) ) { case ( Absent , Absent ) | ( Present , Present ) | ( All , All ) => true NL case _ => false NL } NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"KeyPutState.cj","path":"fountain/src/collection/KeyPutState.cj","code_tokens":"public operator func != ( other : KeyPutState ) : Bool {  ! ( this == other ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"ReverseIterable.cj","path":"fountain/src/collection/ReverseIterable.cj","code_tokens":"func reverseIterator ( ) : ReverseIterator < T >","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"Queue.cj","path":"fountain/src/collection/Queue.cj","code_tokens":"func offer ( data : T ) : Unit","func_name":"offer","docstring":""}
{"repo":"fountain","file":"Queue.cj","path":"fountain/src/collection/Queue.cj","code_tokens":"func offerAll ( data : Iterable < T > ) : Unit","func_name":"offerAll","docstring":""}
{"repo":"fountain","file":"Queue.cj","path":"fountain/src/collection/Queue.cj","code_tokens":"func poll ( ) : Option < T >","func_name":"poll","docstring":""}
{"repo":"fountain","file":"Queue.cj","path":"fountain/src/collection/Queue.cj","code_tokens":"func peek ( ) : Option < T >","func_name":"peek","docstring":""}
{"repo":"fountain","file":"Queue.cj","path":"fountain/src/collection/Queue.cj","code_tokens":"func removeIf ( predicate : ( T ) -> Bool ) : Unit","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"Queue.cj","path":"fountain/src/collection/Queue.cj","code_tokens":"func isEmpty ( ) : Bool {  size == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"func get ( idx : I ) : Option < T >","func_name":"get","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"func set ( idx : I , val : T ) : Unit","func_name":"set","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"func appendToTail ( element : T ) : Unit","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : T ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Char ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : String ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : StringBuilder ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Array < Char > ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : ToString ) : Unit {  this . append ( element . toString ( ) ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Bool ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Int64 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Int32 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Int16 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Int8 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : UInt64 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : UInt32 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : UInt16 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : UInt8 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Float64 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Float32 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func appendToTail ( element : Float16 ) : Unit {  this . append ( element ) NL }","func_name":"appendToTail","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func copy < I , T > ( src : Iterable < T > , dst : SetByIndex < I , T > , dstStart : I , length : Int64 , extends ! : Bool = true ) : Unit where I <: Indexer < I > {  copy < I , T > ( src . iterator ( ) , dst , dstStart , length , extends : extends ) NL }","func_name":"copy","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func copy < I , T > ( src : Iterator < T > , dst : SetByIndex < I , T > , dstStart : I , length : Int64 , extends ! : Bool = true ) : Unit where I <: Indexer < I > {   var dstCur : I = dstStart NL  let dstLen = dst . size NL if ( dstCur > = dstLen ) {   let msg : String = throw IllegalArgumentException ( start of dst is larger than or equals to argument of length ) NL } else if ( ! extends && dstCur . next ( length ) > = dstLen ) {  throw IllegalArgumentException ( start of dst to the end is less than argument of length ) NL } NL while ( true ) {   let opt = src . next ( ) NL if ( let Some ( v ) = opt ) {  if ( dstCur < dstLen ) {  dst . set ( dstCur , v ) NL } else if ( extends && dst is AppendToTail < T > ) {  ( dst as AppendToTail < T > ) . getOrThrow ( ) . appendToTail ( v ) NL } else {  throw IllegalArgumentException ( start of dst to the end is less than argument of length ) NL } NL dstCur = dstCur . next ( 1 ) NL if ( dstCur == dstLen ) {  break NL } NL } else {  break NL } NL } NL }","func_name":"copy","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func copy < I1 , I2 , T > ( src : GetByIndex < I1 , T > , dst : SetByIndex < I2 , T > , srcStart : I1 , dstStart : I2 , length : Int64 , extends ! : Bool = true ) : Unit where I1 <: Indexer < I1 > , I2 <: Indexer < I2 > {   var srcCur : I1 = srcStart NL  var dstCur : I2 = dstStart NL  let srcLen = src . size NL  let dstLen = dst . size NL if ( srcCur . position ( ) < 0 ) {  throw IllegalArgumentException ( start of src is less than zero ) NL } else if ( srcLen < srcCur . next ( length ) ) {  throw IllegalArgumentException ( start of src to the end is less than argument of length ) NL } else if ( dstCur > = dstLen ) {  throw IllegalArgumentException ( start of dst is larger than or equals to argument of length ) NL } else if ( ! extends && dstCur . next ( length ) > = dstLen ) {  throw IllegalArgumentException ( start of dst to the end is less than argument of length ) NL } NL  var i = 0 NL while ( i < length ) {   let val = src . get ( srcCur ) NL if ( dstCur < dstLen ) {  dst . set ( dstCur , val . getOrThrow ( ) ) NL } else if ( extends && dst is AppendToTail < T > ) {  ( dst as AppendToTail < T > ) . getOrThrow ( ) . appendToTail ( val . getOrThrow ( ) ) NL } else {  throw IllegalArgumentException ( start of dst to the end is less than argument of length ) NL } NL srcCur = srcCur . next ( 1 ) NL dstCur = dstCur . next ( 1 ) NL i ++ NL } NL }","func_name":"copy","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func copy < I , T > ( src : GetByIndex < I , T > , dst : AppendToTail < T > , srcStart : I , length : Int64 ) : Unit where I <: Indexer < I > {   var srcCur : I = srcStart NL while ( srcCur . position ( ) < length ) {   let val = src . get ( srcCur ) NL dst . appendToTail ( val . getOrThrow ( ) ) NL srcCur = srcCur . next ( 1 ) NL } NL }","func_name":"copy","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func copy < T > ( src : Iterable < T > , dst : AppendToTail < T > , length ! : Int64 = 0 ) : Unit {  copy < T > ( src . iterator ( ) , dst , length : length ) NL }","func_name":"copy","docstring":""}
{"repo":"fountain","file":"Copy.cj","path":"fountain/src/collection/Copy.cj","code_tokens":"public func copy < T > ( src : Iterator < T > , dst : AppendToTail < T > , length ! : Int64 = 0 ) : Unit {   var i = 0 NL for ( v in src where length == 0 || i < length ) {  dst . appendToTail ( v ) NL i ++ NL } NL }","func_name":"copy","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"static public func create ( concurrencyLevel ! : Int64 = ConcurrentHashMap < T , Unit > . DEFAULT_CONCURRENCY , linked ! : Bool = false ) : ConcurrentHashSet < T > {  ConcurrentHashSet < T > ( concurrencyLevel , linked ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"static public func create ( elements : Iterable < T > , concurrencyLevel ! : Int64 = ConcurrentHashMap < T , Unit > . DEFAULT_CONCURRENCY , linked ! : Bool = false ) : ConcurrentHashSet < T > {   let set = ConcurrentHashSet < T > ( concurrencyLevel , linked ) NL set . putAll ( elements ) NL return set NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func isEmpty ( ) : Bool {  return store . isEmpty ( ) NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  return store . keys ( ) . iterator ( ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func put ( value : T ) : Bool {  store . put ( value , ( ) ) . none NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func putAll ( values : Collection < T > ) : Unit {   let itr : Iterable < T > = values NL putAll ( itr ) NL }","func_name":"putAll","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func putAll ( values : Iterable < T > ) : Unit {  for ( v in values ) {  put ( v ) NL } NL }","func_name":"putAll","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func contains ( value : T ) : Bool {  store . contains ( value ) NL }","func_name":"contains","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func containsAll ( values : Collection < T > ) : Bool {   let itr : Iterable < T > = values NL containsAll ( itr ) NL }","func_name":"containsAll","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func containsAll ( values : Iterable < T > ) : Bool {  for ( v in values where ! contains ( v ) ) {  return false NL } NL return true NL }","func_name":"containsAll","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func subsetOf ( other : Set < T > ) : Bool {  for ( v in this where ! other . contains ( v ) ) {  return false NL } NL return true NL }","func_name":"subsetOf","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func remove ( value : T ) : Bool {  store . remove ( value ) . some NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func removeAll ( values : Collection < T > ) : Unit {   let itr : Iterable < T > = values NL removeAll ( itr ) NL }","func_name":"removeAll","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func removeAll ( values : Iterable < T > ) : Unit {  for ( v in values ) {  store . remove ( v ) NL } NL }","func_name":"removeAll","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  store . removeIf { k , v => predicate ( k ) NL } NL }","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func clear ( ) : Unit {  store . clear ( ) NL }","func_name":"clear","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func retainAll ( values : Set < T > ) : Unit {  for ( v in this where ! values . contains ( v ) ) {  remove ( v ) NL } NL }","func_name":"retainAll","docstring":""}
{"repo":"fountain","file":"ConcurrentHashSet.cj","path":"fountain/src/collection/ConcurrentHashSet.cj","code_tokens":"public func clone ( ) : ConcurrentHashSet < T > {  ConcurrentHashSet < T > . create ( this , concurrencyLevel : concurrencyLevel , linked : linked ) NL }","func_name":"clone","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func seal ( ) : SealableList < T > {  sealed_ = true NL return this NL }","func_name":"seal","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func get ( index : Int64 ) : Option < T > {  store . get ( index ) NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func set ( index : Int64 , element : T ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . set ( index , element ) NL }","func_name":"set","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func append ( element : T ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . append ( element ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func appendAll ( elements : Collection < T > ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . appendAll ( elements ) NL }","func_name":"appendAll","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func insert ( index : Int64 , element : T ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . insert ( index , element ) NL }","func_name":"insert","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func insertAll ( index : Int64 , elements : Collection < T > ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . insertAll ( index , elements ) NL }","func_name":"insertAll","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func prepend ( element : T ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . prepend ( element ) NL }","func_name":"prepend","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func prependAll ( elements : Collection < T > ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . prependAll ( elements ) NL }","func_name":"prependAll","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func remove ( index : Int64 ) : T {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . remove ( index ) NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func remove ( range : Range < Int64 > ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . remove ( range ) NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . removeIf ( predicate ) NL }","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func clear ( ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . clear ( ) NL }","func_name":"clear","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func reverse ( ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . reverse ( ) NL }","func_name":"reverse","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func sortBy ( comparator : ( T , T ) -> Ordering , stable ! : Bool ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . sortBy ( comparator , stable : stable ) NL }","func_name":"sortBy","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func reserve ( additional : Int64 ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store . reserve ( additional ) NL }","func_name":"reserve","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func capacity ( ) : Int64 {  store . capacity ( ) NL }","func_name":"capacity","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func isEmpty ( ) : Bool {  store . isEmpty ( ) NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func slice ( range : Range < Int64 > ) : ArrayList < T > {  store . slice ( range ) NL }","func_name":"slice","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func clone ( ) : ArrayList < T > {  this . store . clone ( ) NL }","func_name":"clone","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public operator func [ ] ( index : Int64 ) : T {  store [ index ] NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public operator func [ ] ( index : Int64 , value ! : T ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current list is sealed ) NL } NL store [ index ] = value NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public operator func [ ] ( range : Range < Int64 > ) : ArrayList < T > {  store [ range ] NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func toArray ( ) : Array < T > {  store . toArray ( ) NL }","func_name":"toArray","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  store . iterator ( ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"SealableList.cj","path":"fountain/src/collection/SealableList.cj","code_tokens":"public func reverseIterator ( ) : ReverseIterator < T > {  ListReverseIterator < T > ( size - 1 , this ) NL }","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"ReverseIterator.cj","path":"fountain/src/collection/ReverseIterator.cj","code_tokens":"func prev ( ) : Option < T >","func_name":"prev","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func next ( ) : Option < T > {  for ( current in itr ) {  if ( idx > = max || current . none ) {  break NL } NL idx ++ NL return current . getOrThrow ( ) NL } NL PriorityQueue < T > . EMPTY_VALUE NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"static public func create < T > ( capacity ! : Int64 = 0 , overSizePolicy ! : OverSizePolicy < PriorityQueue < T > > = DiscardOverSizePolicy < PriorityQueue < T > > ( ) ) where T <: Comparable < T > {  PriorityQueue < T > . create ( Comparator < T > . create < T > ( ) , capacity : capacity , overSizePolicy : overSizePolicy ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"static public func createReverse < T > ( capacity ! : Int64 = 0 , overSizePolicy ! : OverSizePolicy < PriorityQueue < T > > = DiscardOverSizePolicy < PriorityQueue < T > > ( ) ) where T <: Comparable < T > {  PriorityQueue < T > . create ( Comparator < T > . create < T > ( ) . reverse ( ) , capacity : capacity , overSizePolicy : overSizePolicy ) NL }","func_name":"createReverse","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"static public func create ( comparator : Comparator < T > , capacity ! : Int64 = 0 , overSizePolicy ! : OverSizePolicy < PriorityQueue < T > > = DiscardOverSizePolicy < PriorityQueue < T > > ( ) ) {  PriorityQueue < T > ( comparator . comparator , capacity : capacity , overSizePolicy : overSizePolicy ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func isEmpty ( ) : Bool {  size == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func offer ( x : T ) : Unit {  if ( capacity > 0 && size > = capacity ) {  overSizePolicy . reject ( this ) { doOffer ( x ) NL } NL } else {  doOffer ( x ) NL } NL }","func_name":"offer","docstring":"/**\n     * add an element\n     */"}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"private func doOffer ( x : T ) : Bool {  if ( currentSize == 0 ) {  queue [ currentSize ] = x NL currentSize ++ NL true NL } else if ( ! isFull ( ) ) {  adjustUp ( currentSize , x ) NL currentSize ++ NL true NL } else if ( capacity <= 0 ) {  grow ( ) NL doOffer ( x ) NL } else {  false NL } NL }","func_name":"doOffer","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func grow ( ) : Unit {  queue = queue . newAndCopy ( currentSize * 2 , default : PriorityQueue < T > . EMPTY_VALUE ) NL if ( capacity > 0 ) {  capacity = queue . size NL } NL }","func_name":"grow","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func offerAll ( values : Iterable < T > ) {  for ( value in values ) {  offer ( value ) NL } NL }","func_name":"offerAll","docstring":"/**\n     * offer all elements in values to current queue\n     */"}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"private func isFull ( ) {  return currentSize > = queue . size NL }","func_name":"isFull","docstring":"/**\n     * is current heap full? if capacity is not greater than 0, heap is infinity\n     */"}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func peek ( ) : Option < T > {  if ( currentSize > 0 ) {  queue [ 0 ] NL } else {  PriorityQueue < T > . EMPTY_VALUE NL } NL }","func_name":"peek","docstring":"/**\n     * get element on top\n     */"}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func poll ( ) : Option < T > {   let cur = peek ( ) NL if ( let None < T > = cur ) {  return PriorityQueue < T > . EMPTY_VALUE NL } NL currentSize -- NL  let temp = queue [ currentSize ] NL queue [ currentSize ] = PriorityQueue < T > . EMPTY_VALUE NL if ( currentSize > 0 ) {  queue [ 0 ] = temp NL adjustDown ( 0 , temp . getOrThrow ( ) ) NL } NL return cur NL }","func_name":"poll","docstring":"/**\n     * get and remove element on top\n     */"}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"private func adjustUp ( k : Int64 , value : T ) {   var i = k NL while ( i > 0 ) {   let root = ( i - 1 ) >> 1 NL  let current = queue [ root ] . getOrThrow ( ) NL if ( comparator ( current , value ) . lte ) {  break NL } NL queue [ i ] = queue [ root ] NL i = root NL } NL queue [ i ] = value NL }","func_name":"adjustUp","docstring":"/**\n     * 从下往上调整\n     */"}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"private func adjustDown ( k : Int64 , value : T ) {   var i = k NL  let half = currentSize >> 1 NL while ( i < half ) {   var child = ( i << 1 ) + 1 NL  var childVal = queue [ child ] . getOrThrow ( ) NL  let rightChild = child + 1 NL  let current = queue [ rightChild ] . getOrThrow ( ) NL if ( rightChild < currentSize && comparator ( childVal , current ) . gt ) {  child = rightChild NL childVal = queue [ child ] . getOrThrow ( ) NL } NL if ( comparator ( childVal , value ) . gt ) {  break NL } NL queue [ i ] = queue [ child ] NL i = child NL } NL queue [ i ] = value NL }","func_name":"adjustDown","docstring":"/**\n     * 从上往下调整\n     */"}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func iterator ( ) : Iterator < T > {   let itr : Iterator < Option < T > > = queue . iterator ( ) NL  let size : Int64 = currentSize NL PriorityQueueIterator < T > ( itr , size ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {   var i = 0 NL  let size = currentSize NL  var lastIdx = size NL  var toAdjust = false NL while ( i < size ) {   let v = queue [ i ] . getOrThrow ( ) NL if ( predicate ( v ) ) {  queue [ i ] = PriorityQueue < T > . EMPTY_VALUE NL if ( ! toAdjust ) {  lastIdx = i NL toAdjust = true NL } NL } else if ( toAdjust ) {  queue [ i ] = PriorityQueue < T > . EMPTY_VALUE NL adjustUp ( lastIdx , v ) NL lastIdx ++ NL } NL i ++ NL } NL currentSize = lastIdx NL }","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"PriorityQueue.cj","path":"fountain/src/collection/PriorityQueue.cj","code_tokens":"public func toArray ( ) : Array < T > {   let itr = iterator ( ) NL Array < T > ( size ) { i => itr . next ( ) . getOrThrow ( ) NL } NL }","func_name":"toArray","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByHashEq < K > ( ) : SealableMap < K , V > where K <: Hashable & Equatable < K > {  return SealableMap < K , V > ( HashMap < K , V > ( ) ) NL }","func_name":"createByHashEq","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByHashEq < K > ( iterable : Iterable < ( K , V ) > , sealed ! : Bool = true ) : SealableMap < K , V > where K <: Hashable & Equatable < K > {   var map = HashMap < K , V > ( ) NL for ( ( k , v ) in iterable ) {  map . put ( k , v ) NL } NL return createByHashEq < K > ( map , sealed : sealed , copy : false ) NL }","func_name":"createByHashEq","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByCmp < K > ( iterable : Iterable < ( K , V ) > , sealed ! : Bool = true ) : SealableMap < K , V > where K <: Comparable < K > {   var map = TreeMap < K , V > . create < K > ( ) NL for ( ( k , v ) in iterable ) {  map . put ( k , v ) NL } NL return createByCmp < K > ( map , sealed : sealed , copy : false ) NL }","func_name":"createByCmp","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByHashEq < K > ( map : HashMap < K , V > , sealed ! : Bool = true , copy ! : Bool = true ) where K <: Hashable & Equatable < K > {  if ( copy ) {  return SealableMap ( HashMap < K , V > ( map ) , sealed_ : sealed ) NL } NL return SealableMap ( map , sealed_ : sealed ) NL }","func_name":"createByHashEq","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByCmp < K > ( map : TreeMap < K , V > , sealed ! : Bool = true , copy ! : Bool = true ) where K <: Comparable < K > {  if ( copy ) {  return SealableMap ( TreeMap < K , V > ( map ) , sealed_ : sealed ) NL } NL return SealableMap ( map , sealed_ : sealed ) NL }","func_name":"createByCmp","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByHashEq < K > ( map : LinkedMap < K , V > , sealed ! : Bool = true , copy ! : Bool = true ) where K <: Hashable & Equatable < K > {  if ( copy ) {  return SealableMap ( HashMap < K , V > ( map ) , sealed_ : sealed ) NL } NL return SealableMap ( map , sealed_ : sealed ) NL }","func_name":"createByHashEq","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByHashEq < K > ( map : SyncMap < K , V > , sealed ! : Bool = true ) where K <: Hashable & Equatable < K > {  return SealableMap ( HashMap < K , V > ( map ) , sealed_ : sealed ) NL }","func_name":"createByHashEq","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByCmp < K > ( map : SyncMap < K , V > , sealed ! : Bool = true ) where K <: Comparable < K > {  return SealableMap ( TreeMap < K , V > . create < K > ( map ) , sealed_ : sealed ) NL }","func_name":"createByCmp","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByHashEq < K > ( map : SealableMap < K , V > , sealed ! : Bool = true ) where K <: Hashable & Equatable < K > {  return SealableMap ( HashMap < K , V > ( map ) , sealed_ : sealed ) NL }","func_name":"createByHashEq","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByCmp < K > ( map : SealableMap < K , V > , sealed ! : Bool = true ) where K <: Comparable < K > {  return SealableMap ( TreeMap < K , V > . create < K > ( map ) , sealed_ : sealed ) NL }","func_name":"createByCmp","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func createByHashEqCmp < K > ( map : Map < K , V > , copy ! : Bool = true ) where K <: Hashable & Equatable < K > & Comparable < K > {  if ( ! copy ) {  return SealableMap ( map ) NL } else if ( let Some ( om ) = ( map as TreeMap < K , V > ) ) {  return SealableMap < K , V > ( TreeMap < K , V > ( om ) ) NL } else if ( let Some ( om ) = ( map as HashMap < K , V > ) ) {  return SealableMap < K , V > ( HashMap < K , V > ( om ) ) NL } else if ( let Some ( om ) = ( map as LinkedMap < K , V > ) ) {  return SealableMap < K , V > ( LinkedMap < K , V > ( om ) ) NL } else if ( let Some ( om ) = ( map as SealableMap < K , V > ) ) {  return SealableMap < K , V > ( om . originMap ) NL } else if ( let Some ( om ) = ( map as SyncMap < K , V > ) ) {  return SealableMap < K , V > ( om . originMap ) NL } NL throw NotSupportedTypeException ( type of origin map does not support ) NL }","func_name":"createByHashEqCmp","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func create ( map : Map < K , V > , comparator : ( K , K ) -> Ordering ) : SealableMap < K , V > {  return SealableMap < K , V > ( TreeMap < K , V > ( map , comparator ) ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"static public func create ( map : Map < K , V > , comparator : Comparator < K > ) : SealableMap < K , V > {  create ( map , comparator . comparator ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func seal ( ) : Map < K , V > {  this . sealed_ = true NL return this NL }","func_name":"seal","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  return map . isEmpty ( ) NL }","func_name":"isEmpty","docstring":"/*\n     * 判断对象是否为空\n     * 返回值 Bool - 若为空返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func toArray ( ) : Array < ( K , V ) > {  return map . toArray ( ) NL }","func_name":"toArray","docstring":"/*\n     * 将对象转为数组类型\n     * 返回值 Array<T> - 转换后的数组\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {  return map . iterator ( ) NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<(K,V)> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func get ( key : K ) : Option < V > {  return map . get ( key ) NL }","func_name":"get","docstring":"/*\n     * 根据 key 得到 Map 中映射的值\n     * 参数 key - 传递 key，获取 value\n     * 返回值 Option<V> - key 对应的值是用 Option 封装的\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func contains ( key : K ) : Bool {  return map . contains ( key ) NL }","func_name":"contains","docstring":"/*\n     * 判断是否包含指定键的映射\n     * 参数 key - 传递要判断的 key\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  return map . containsAll ( keys ) NL }","func_name":"containsAll","docstring":"/*\n     * 判断是否包含指定集合键的映射\n     * 参数 keys - 传递待判断的 keys\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func put ( key : K , value : V ) : Option < V > {  if ( sealed ) {  return Option . None NL } NL return map . put ( key , value ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func put ( entry : ( K , V ) ) : Option < V > {  if ( sealed ) {  return Option . None NL } NL return put ( entry [ 0 ] , entry [ 1 ] ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  if ( sealed ) {  return NL } NL for ( e in elements ) {  put ( e ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 element - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func remove ( key : K ) : Option < V > {  if ( sealed ) {  return Option . None NL } NL return map . remove ( key ) NL }","func_name":"remove","docstring":"/*\n     * 从此映射中删除指定键的映射（如果存在）\n     * 参数 key - 传入要删除的 key\n     * 返回值 Option<V> - 被移除映射的 V 用 Option 封装\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  if ( sealed ) {  return NL } NL for ( k in keys ) {  remove ( k ) NL } NL }","func_name":"removeAll","docstring":"/*\n     * 从此映射中删除指定集合的映射（如果存在）\n     * 参数 keys - 传人要删除的集合\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  if ( sealed ) {  return NL } NL map . removeIf ( predicate ) NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足条件，则删除对应的键值\n     * 参数 predicate - 传递一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func clear ( ) : Unit {  if ( sealed ) {  return NL } NL map . clear ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func clone ( ) : Map < K , V > {  return SealableMap < K , V > ( this . originMap ) . seal ( ) NL }","func_name":"clone","docstring":"/*\n     * 克隆 Map\n     * 返回值 Map<K, V> - 返回一个 Map<K, V>\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  get ( key ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  put ( key , value ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func keys ( ) : Keys < K > {  return MapKeys < K , V > ( this ) NL }","func_name":"keys","docstring":"/*\n     * 返回 Map 中所有的 key，并将所有 key 存储在一个 Keys 容器中\n     * 返回值 Keys<K> - 保存所有返回的 key\n     */"}
{"repo":"fountain","file":"SealableMap.cj","path":"fountain/src/collection/SealableMap.cj","code_tokens":"public func values ( ) : Values < V > {  return MapValues < K , V > ( this ) NL }","func_name":"values","docstring":"/*\n     * 返回 Map 中所有的 value，并将所有 value 存储在一个 Values 容器中\n     * 返回值 Values<V> - 保存所有返回的 value\n     */"}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func next ( ) : Option < T > {  return match ( current ) { case n : ValueNode < T > => current = n . next NL n . value NL case _ => None < T > NL } NL }","func_name":"next","docstring":"/*\n     * 返回迭代过程中的下一个元素\n     * 返回值 Option<E> - 迭代过程中的下一个元素\n     */"}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  return this NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<E> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func prev ( ) : Option < T > {  return match ( current ) { case n : ValueNode < T > => current = n . prev NL n . value NL case _ => None < T > NL } NL }","func_name":"prev","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func reverseIterator ( ) : ReverseIterator < T > {  this NL }","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func clear ( ) : Unit {  head_ . reset ( tail_ ) NL }","func_name":"clear","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func isEmpty ( ) : Bool {  size == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"private func remove ( node : Node < T > ) : Option < T > {  return match ( node ) { case n : HeadNode < T > => None < T > NL case n : TailNode < T > => None < T > NL case n : ValueNode < T > => currentSize -- NL n . remove ( ) NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"private func peek ( node : Node < T > ) : Option < T > {  return match ( node ) { case n : HeadNode < T > => None < T > NL case n : TailNode < T > => None < T > NL case n : ValueNode < T > => n . value NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"peek","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"private func isOverSize ( fn : ( ) -> Unit ) {  if ( maxSize > 0 && size > = maxSize ) {  overSizePolicy . reject ( this , fn ) NL } else {  fn ( ) NL } NL this NL }","func_name":"isOverSize","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"private func doPush ( value : T ) {  head_ . insertNext ( value ) NL currentSize ++ NL return this NL }","func_name":"doPush","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func push ( value : T ) : Deque < T > {  isOverSize { doPush ( value ) NL } NL }","func_name":"push","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func pushAll ( elements : Iterable < T > ) : Deque < T > {  for ( e in elements ) {  push ( e ) NL } NL return this NL }","func_name":"pushAll","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func pop ( ) : Option < T > {  if ( size == 0 ) {  None < T > NL } NL return remove ( head_ . next ) NL }","func_name":"pop","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"private func doOffer ( value : T ) {  tail_ . insertPrev ( value ) NL currentSize ++ NL return this NL }","func_name":"doOffer","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func offer ( value : T ) : Deque < T > {  isOverSize { doOffer ( value ) NL } NL }","func_name":"offer","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func offerAll ( elements : Iterable < T > ) : Deque < T > {  for ( e in elements ) {  offer ( e ) NL } NL return this NL }","func_name":"offerAll","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func poll ( ) : Option < T > {  pop ( ) NL }","func_name":"poll","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func head ( ) : Option < T > {  return peek ( head_ . next ) NL }","func_name":"head","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func tail ( ) : Option < T > {  return peek ( tail_ . prev ) NL }","func_name":"tail","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func toArray ( ) : Array < T > {  return Array < T > ( this ) NL }","func_name":"toArray","docstring":"/*\n     * 将对象转为数组类型\n     * 返回值 Array<T> - 转换后的数组\n     */"}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {   var current : Node < T > = head_ . next NL while ( true ) {  match ( current ) { case n : ValueNode < T > where predicate ( n . value ) => current = n . next NL currentSize -- NL n . remove ( ) NL case n : ValueNode < T > => current = n . next NL case n : TailNode < T > => break NL case _ => throw UnreachableException ( ) NL } NL } NL }","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  return LinkedDequeIterator < T > ( head_ ) NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<E> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"LinkedDeque.cj","path":"fountain/src/collection/LinkedDeque.cj","code_tokens":"public func reverseIterator ( ) : ReverseIterator < T > {  return LinkedDequeReverseIterator < T > ( tail_ ) NL }","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"SortedSet.cj","path":"fountain/src/collection/SortedSet.cj","code_tokens":"func subSet ( low : T , high : T , lowInclusive ! : Bool , highInclusive ! : Bool ) : SortedSet < T >","func_name":"subSet","docstring":""}
{"repo":"fountain","file":"SortedSet.cj","path":"fountain/src/collection/SortedSet.cj","code_tokens":"func headSet ( end : T , inclusive ! : Bool ) : SortedSet < T >","func_name":"headSet","docstring":""}
{"repo":"fountain","file":"SortedSet.cj","path":"fountain/src/collection/SortedSet.cj","code_tokens":"func tailSet ( start : T , inclusive ! : Bool ) : SortedSet < T >","func_name":"tailSet","docstring":""}
{"repo":"fountain","file":"RemoveTopPolicy.cj","path":"fountain/src/collection/RemoveTopPolicy.cj","code_tokens":"public func reject ( o : C , fn : ( ) -> Unit ) : Unit {  policy . reject ( o , fn ) NL }","func_name":"reject","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func next ( ) : Option < ( String , String ) > {  synchronized ( lock ) {  itr . next ( ) NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func contains ( key : String ) : Bool {  store . contains ( key ) NL }","func_name":"contains","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func set ( key : String , value : String ) {  synchronized ( lock ) {  store . put ( key , value ) NL } NL }","func_name":"set","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func get ( key : String ) : Option < String > {  synchronized ( lock ) {  store . get ( key ) NL } NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func getInt64 ( key : String ) : Option < Int64 > {  if ( let Some ( val ) = get ( key ) ) {  Int64 . parse ( val ) NL } else {  None < Int64 > NL } NL }","func_name":"getInt64","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func remove ( key : String ) : Unit {  synchronized ( lock ) {  store . remove ( key ) NL } NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func iterator ( ) : Iterator < ( String , String ) > {  PropeertiesIterator ( store . iterator ( ) , lock ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func clear ( ) : Unit {  synchronized ( lock ) {  store . clear ( ) NL } NL }","func_name":"clear","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func save ( output : OutputStream ) {  synchronized ( lock ) {  for ( ( key , value ) in this ) {  output . write ( key . toUtf8Array ( ) ) NL output . write ( = . toUtf8Array ( ) ) NL output . write ( value . toUtf8Array ( ) ) NL output . write ( \\n . toUtf8Array ( ) ) NL } NL } NL }","func_name":"save","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func load ( file : File ) : Unit {   let input : InputStream = file NL load ( input ) NL }","func_name":"load","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func load ( input : InputStream ) : Unit {  load ( StringReader ( input ) ) NL }","func_name":"load","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func load ( reader : StringReader ) : Unit {  loadContent ( reader . readToEnd ( ) ) NL }","func_name":"load","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func loadContent ( content : String ) : Unit {   let regex = BLANK_HEAD_OR_TAIL NL  let props = content NL for ( line in props . split ( \\n , removeEmpty : true ) ) {   let idxopt = line . indexOf ( = ) NL if ( let Some ( idx ) = idxopt ) {  if ( idx == 0 ) {   var val = line . substring ( 1 ) NL val = regex . matcher ( val ) . replace (  ) NL store . put (  , val ) NL } else {   var key = line . substring ( 0 , idx ) NL  var val = line . substring ( idx + 1 ) NL key = regex . matcher ( key ) . replace (  ) NL val = regex . matcher ( val ) . replace (  ) NL store . put ( key , val ) NL } NL } else {  store . put ( line ,  ) NL } NL } NL }","func_name":"loadContent","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"private func openFile ( file : String ) : File {  File ( file , OpenOption . Append ) NL }","func_name":"openFile","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func save ( file : String ) {  try (  let stream = openFile ( file ) ) {  save ( stream ) NL } NL }","func_name":"save","docstring":""}
{"repo":"fountain","file":"Properties.cj","path":"fountain/src/collection/Properties.cj","code_tokens":"public func load ( file : String ) {  try (  let stream = openFile ( file ) ) {  load ( stream ) NL } NL }","func_name":"load","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"func iterator ( ) : Iterator < T >","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"func get ( k : K ) : Option < V >","func_name":"get","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"mut func put ( k : K , v : V ) : Option < V >","func_name":"put","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"mut func remove ( k : K ) : Option < V >","func_name":"remove","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"func getOrDefault ( k : K , defaultValue : V ) : V {  return get ( k ) ?? defaultValue NL }","func_name":"getOrDefault","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"mut func putIfNonExistent ( k : K , v : V ) : Option < V > {   let opt = get ( k ) NL if ( let Some ( _ ) = opt ) {  return opt NL } NL return put ( k , v ) NL }","func_name":"putIfNonExistent","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"mut func putIfPresent ( k : K , v : V ) : Option < V > {   let opt = get ( k ) NL return match ( opt ) { case Some ( _ ) => put ( k , v ) NL opt NL case _ => opt NL } NL }","func_name":"putIfPresent","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"mut func compute ( k : K , fn : ( K , Option < V > ) -> Option < V > ) : Option < V > {   let old = get ( k ) NL if ( let Some ( v ) = fn ( k , old ) ) {  put ( k , v ) NL } else {  old NL } NL }","func_name":"compute","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"mut func computeIfAbsent ( k : K , fn : ( K ) -> Option < V > ) : Option < V > {  return if ( let Some ( v ) = get ( k ) ) {  v NL } else if ( let Some ( v ) = fn ( k ) ) {  put ( k , v ) NL v NL } else {  None NL } NL }","func_name":"computeIfAbsent","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"mut func computeIfPresent ( k : K , fn : ( K , V ) -> Option < V > ) : Option < V > {  return if ( let Some ( v ) = get ( k ) ) {  if ( let Some ( fv ) = fn ( k , v ) ) {  put ( k , fv ) NL } NL v NL } else {  None NL } NL }","func_name":"computeIfPresent","docstring":""}
{"repo":"fountain","file":"ExtendCollection.cj","path":"fountain/src/collection/ExtendCollection.cj","code_tokens":"mut func remove ( k : K , v : V ) : Bool {  if ( let Some ( cur ) = get ( k ) ) {  if ( let Some ( val ) = cur as Equatable < V > ) {  if ( val == v ) {  remove ( k ) NL return true NL } NL } NL } NL return false NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  return map . isEmpty ( ) NL }","func_name":"isEmpty","docstring":"/*\n     * 判断对象是否为空\n     * 返回值 Bool - 若为空返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func toArray ( ) : Array < ( K , V ) > {  return Array < ( K , V ) > ( this ) NL }","func_name":"toArray","docstring":"/*\n     * 将对象转为数组类型\n     * 返回值 Array<T> - 转换后的数组\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {  return LinkedDequeIterator < ( K , V ) > ( head ) NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<(K,V)> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"private func turnToTail ( entry : ValueNode < ( K , V ) > ) {  if ( size <= 1 ) {  return NL } NL entry . turnTo ( tail ) NL }","func_name":"turnToTail","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func get ( key : K ) : Option < V > {  return match ( map . get ( key ) ) { case Some ( n ) => turnToTail ( n ) NL n . value [ 1 ] NL case _ => None NL } NL }","func_name":"get","docstring":"/*\n     * 根据 key 得到 Map 中映射的值\n     * 参数 key - 传递 key，获取 value\n     * 返回值 Option<V> - key 对应的值是用 Option 封装的\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func contains ( key : K ) : Bool {  return map . contains ( key ) NL }","func_name":"contains","docstring":"/*\n     * 判断是否包含指定键的映射\n     * 参数 key - 传递要判断的 key\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  return map . containsAll ( keys ) NL }","func_name":"containsAll","docstring":"/*\n     * 判断是否包含指定集合键的映射\n     * 参数 keys - 传递待判断的 keys\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"private func delete ( opt : Option < ValueNode < ( K , V ) > > , removeMap ! : Bool = false ) : Option < V > {  return match ( opt ) { case Some ( n ) => n . remove ( ) NL if ( removeMap ) {  map . remove ( n . value [ 0 ] ) NL } NL n . value [ 1 ] NL case _ => None < V > NL } NL }","func_name":"delete","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"private func getFirstEntry ( ) : Option < ValueNode < ( K , V ) > > {  match ( head . next ) { case n : ValueNode < ( K , V ) > => n NL case n : TailNode < ( K , V ) > => None NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"getFirstEntry","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"private func getLastEntry ( ) : Option < ValueNode < ( K , V ) > > {  match ( tail . prev ) { case n : ValueNode < ( K , V ) > => n NL case n : HeadNode < ( K , V ) > => None NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"getLastEntry","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"private func extract ( opt : Option < ValueNode < ( K , V ) > > ) : Option < ( K , V ) > {  match ( opt ) { case Some ( n ) => n . value NL case _ => None NL } NL }","func_name":"extract","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func firstEntry ( ) : Option < ( K , V ) > {  if ( map . isEmpty ( ) ) {  return None NL } NL  let entry = getFirstEntry ( ) NL match ( entry ) { case Some ( e ) => turnToTail ( e ) NL return extract ( entry ) NL case _ => return None NL } NL }","func_name":"firstEntry","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func pollFirstEntry ( ) : Option < ( K , V ) > {  if ( map . isEmpty ( ) ) {  return None NL } NL  let entry = getFirstEntry ( ) NL delete ( entry , removeMap : true ) NL return extract ( entry ) NL }","func_name":"pollFirstEntry","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func lastEntry ( ) : Option < ( K , V ) > {  if ( map . isEmpty ( ) ) {  return None NL } NL  let entry = getLastEntry ( ) NL return extract ( entry ) NL }","func_name":"lastEntry","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func pollLastEntry ( ) : Option < ( K , V ) > {  if ( map . isEmpty ( ) ) {  return None NL } NL  let entry = getLastEntry ( ) NL delete ( entry , removeMap : true ) NL return extract ( entry ) NL }","func_name":"pollLastEntry","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func put ( key : K , value : V ) : Option < V > {   var s = size NL while ( max && s > 0 && s > = size_ && ! contains ( key ) ) {  match ( head . next ) { case n : ValueNode < ( K , V ) > => remove ( n . value [ 0 ] ) NL case _ => throw UnreachableException ( ) NL } NL s = size NL } NL  let old = map . put ( key , tail . insertPrev ( ( key , value ) ) ) NL delete ( old ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func put ( entry : ( K , V ) ) : Option < V > {  return put ( entry [ 0 ] , entry [ 1 ] ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  for ( e in elements ) {  put ( e ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 element - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func remove ( key : K ) : Option < V > {   let opt = map . remove ( key ) NL return delete ( opt ) NL }","func_name":"remove","docstring":"/*\n     * 从此映射中删除指定键的映射（如果存在）\n     * 参数 key - 传入要删除的 key\n     * 返回值 Option<V> - 被移除映射的 V 用 Option 封装\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  for ( k in keys ) {  remove ( k ) NL } NL }","func_name":"removeAll","docstring":"/*\n     * 从此映射中删除指定集合的映射（如果存在）\n     * 参数 keys - 传人要删除的集合\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  for ( ( k , v ) in iterator ( ) ) {  if ( predicate ( k , v ) ) {  remove ( k ) NL } NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足条件，则删除对应的键值\n     * 参数 predicate - 传递一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func clear ( ) : Unit {  map . clear ( ) NL this . head . reset ( tail ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func clone ( ) : Map < K , V > {  return LinkedMap < K , V > ( this ) NL }","func_name":"clone","docstring":"/*\n     * 克隆 Map\n     * 返回值 Map<K, V> - 返回一个 Map<K, V>\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  get ( key ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  put ( key , value ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func keys ( ) : Keys < K > {  return MapKeys < K , V > ( this ) NL }","func_name":"keys","docstring":"/*\n     * 返回 Map 中所有的 key，并将所有 key 存储在一个 Keys 容器中\n     * 返回值 Keys<K> - 保存所有返回的 key\n     */"}
{"repo":"fountain","file":"LinkedMap.cj","path":"fountain/src/collection/LinkedMap.cj","code_tokens":"public func values ( ) : Values < V > {  return MapValues < K , V > ( this ) NL }","func_name":"values","docstring":"/*\n     * 返回 Map 中所有的 value，并将所有 value 存储在一个 Values 容器中\n     * 返回值 Values<V> - 保存所有返回的 value\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func next ( ) : Option < ( K , V ) > {  return map . read { itr . next ( ) NL } NL }","func_name":"next","docstring":"/*\n     * 返回迭代过程中的下一个元素\n     * 返回值 Option<E> - 迭代过程中的下一个元素\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func create < K > ( ) where K <: Hashable & Equatable < K > {  return SyncMap ( HashMap < K , V > ( ) ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func create < K > ( map : HashMap < K , V > , copy ! : Bool = true ) where K <: Hashable & Equatable < K > {  if ( copy ) {  return SyncMap ( HashMap < K , V > ( map ) ) NL } NL return SyncMap ( map ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func create < K > ( map : SortedMap < K , V > , copy ! : Bool = true ) where K <: Comparable < K > {  if ( copy ) {  return SyncMap ( TreeMap < K , V > ( map ) ) NL } NL return SyncMap ( map ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func create < K > ( map : LinkedMap < K , V > , copy ! : Bool = true ) where K <: Hashable & Equatable < K > {  if ( copy ) {  return SyncMap ( LinkedMap < K , V > ( map ) ) NL } NL return SyncMap ( map ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func createByHashEq < K > ( map : SyncMap < K , V > ) where K <: Hashable & Equatable < K > {  return SyncMap ( HashMap < K , V > ( map ) ) NL }","func_name":"createByHashEq","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func createByCmp < K > ( map : SyncMap < K , V > ) where K <: Comparable < K > {  return SyncMap ( TreeMap < K , V > . create < K > ( map ) ) NL }","func_name":"createByCmp","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func createByHashEqCmp < K > ( map : SyncMap < K , V > ) where K <: Hashable & Equatable < K > & Comparable < K > {   let origin = map . originMap NL return createByHashEqCmp < K > ( origin ) NL }","func_name":"createByHashEqCmp","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func create < K > ( map : SealableMap < K , V > ) where K <: Hashable & Equatable < K > {  return SyncMap ( HashMap < K , V > ( map ) ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func create < K > ( map : SealableMap < K , V > ) where K <: Comparable < K > {  return SyncMap ( TreeMap < K , V > . create < K > ( map ) ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func create < K > ( map : SealableMap < K , V > ) where K <: Hashable & Equatable < K > & Comparable < K > {   let origin = map . originMap NL return createByHashEqCmp < K > ( origin ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func createByHashEqCmp < K > ( map : Map < K , V > , copy ! : Bool = true ) where K <: Hashable & Equatable < K > & Comparable < K > {  if ( ! copy ) {  return SyncMap < K , V > ( map ) NL } else if ( let Some ( om ) = ( map as TreeMap < K , V > ) ) {  return SyncMap < K , V > ( TreeMap < K , V > ( om ) ) NL } else if ( let Some ( om ) = ( map as HashMap < K , V > ) ) {  return SyncMap < K , V > ( HashMap < K , V > ( om ) ) NL } else if ( let Some ( om ) = ( map as LinkedMap < K , V > ) ) {  return SyncMap < K , V > ( LinkedMap < K , V > ( om ) ) NL } NL throw NotSupportedTypeException ( type of origin map does not support ) NL }","func_name":"createByHashEqCmp","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func create ( comparator : ( K , K ) -> Ordering , map : Map < K , V > ) : SyncMap < K , V > {  return SyncMap < K , V > ( TreeMap < K , V > ( map , comparator ) ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"static public func create ( comparator : ( K , K ) -> Ordering ) : SyncMap < K , V > {  return SyncMap < K , V > ( TreeMap < K , V > ( comparator ) ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"func read < T > ( defaultValue : T , fn : ( ) -> T ) : T {  return syncer . tryRead < T > ( defaultValue , fn ) NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"func read < T > ( fn : ( ) -> Option < T > ) : Option < T > {  return syncer . tryRead ( fn ) NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"func write ( fn : ( ) -> Option < V > ) : Option < V > {  return syncer . tryWrite ( fn ) NL }","func_name":"write","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"func write ( defaultValue : V , fn : ( ) -> V ) : V {  return syncer . tryWrite < V > ( defaultValue , fn ) NL }","func_name":"write","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func sync ( fn : ( ) -> Option < V > ) : Option < V > {  return write ( fn ) NL }","func_name":"sync","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  return read ( true ) { map . isEmpty ( ) NL } NL }","func_name":"isEmpty","docstring":"/*\n     * 判断对象是否为空\n     * 返回值 Bool - 若为空返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func toArray ( ) : Array < ( K , V ) > {  return read ( Array < ( K , V ) > ( ) ) { map . toArray ( ) NL } NL }","func_name":"toArray","docstring":"/*\n     * 将对象转为数组类型\n     * 返回值 Array<T> - 转换后的数组\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {  return SyncMapIterator < K , V > ( this ) NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<(K,V)> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func get ( key : K ) : Option < V > {  return read { map . get ( key ) NL } NL }","func_name":"get","docstring":"/*\n     * 根据 key 得到 Map 中映射的值\n     * 参数 key - 传递 key，获取 value\n     * 返回值 Option<V> - key 对应的值是用 Option 封装的\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func contains ( key : K ) : Bool {  return read ( false ) { map . contains ( key ) NL } NL }","func_name":"contains","docstring":"/*\n     * 判断是否包含指定键的映射\n     * 参数 key - 传递要判断的 key\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  return read ( false ) { map . containsAll ( keys ) NL } NL }","func_name":"containsAll","docstring":"/*\n     * 判断是否包含指定集合键的映射\n     * 参数 keys - 传递待判断的 keys\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func put ( key : K , value : V ) : Option < V > {  return write { map . put ( key , value ) NL } NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func put ( entry : ( K , V ) ) : Option < V > {  return put ( entry [ 0 ] , entry [ 1 ] ) NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 None<V>\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  for ( e in elements ) {  put ( e ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 element - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func remove ( key : K ) : Option < V > {  return write { map . remove ( key ) NL } NL }","func_name":"remove","docstring":"/*\n     * 从此映射中删除指定键的映射（如果存在）\n     * 参数 key - 传入要删除的 key\n     * 返回值 Option<V> - 被移除映射的 V 用 Option 封装\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  for ( k in keys ) {  remove ( k ) NL } NL }","func_name":"removeAll","docstring":"/*\n     * 从此映射中删除指定集合的映射（如果存在）\n     * 参数 keys - 传人要删除的集合\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  for ( entry in this ) {   let ( k , v ) = entry NL if ( predicate ( k , v ) ) {  remove ( k ) NL } NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足条件，则删除对应的键值\n     * 参数 predicate - 传递一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func clear ( ) : Unit {  write { map . clear ( ) NL None < V > NL } NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func clone ( ) : Map < K , V > {  return SyncMap ( this . map ) NL }","func_name":"clone","docstring":"/*\n     * 克隆 Map\n     * 返回值 Map<K, V> - 返回一个 Map<K, V>\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  get ( key ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  put ( key , value ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func keys ( ) : Keys < K > {  return MapKeys < K , V > ( this ) NL }","func_name":"keys","docstring":"/*\n     * 返回 Map 中所有的 key，并将所有 key 存储在一个 Keys 容器中\n     * 返回值 Keys<K> - 保存所有返回的 key\n     */"}
{"repo":"fountain","file":"SyncMap.cj","path":"fountain/src/collection/SyncMap.cj","code_tokens":"public func values ( ) : Values < V > {  return MapValues < K , V > ( this ) NL }","func_name":"values","docstring":"/*\n     * 返回 Map 中所有的 value，并将所有 value 存储在一个 Values 容器中\n     * 返回值 Values<V> - 保存所有返回的 value\n     */"}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func clear ( ) : Unit","func_name":"clear","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func isEmpty ( ) : Bool","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func push ( value : T ) : Deque < T >","func_name":"push","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func pushAll ( elements : Iterable < T > ) : Deque < T >","func_name":"pushAll","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func pop ( ) : Option < T >","func_name":"pop","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func offer ( value : T ) : Deque < T >","func_name":"offer","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func offerAll ( elements : Iterable < T > ) : Deque < T >","func_name":"offerAll","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func poll ( ) : Option < T >","func_name":"poll","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func head ( ) : Option < T >","func_name":"head","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func tail ( ) : Option < T >","func_name":"tail","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func removeIf ( predicate : ( T ) -> Bool ) : Unit","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func insertPrev ( value : T ) : ValueNode < T > {  throw UnreachableException ( ) NL }","func_name":"insertPrev","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func insertNext ( value : T ) : ValueNode < T > {  throw UnreachableException ( ) NL }","func_name":"insertNext","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func remove ( ) : T {  throw UnreachableException ( ) NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func removePrev ( ) : Option < T > {  throw UnreachableException ( ) NL }","func_name":"removePrev","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"func removeNext ( ) : Option < T > {  throw UnreachableException ( ) NL }","func_name":"removeNext","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func insertNext ( value : T ) : ValueNode < T > {  ValueNode < T > ( value , this , this . next ) NL }","func_name":"insertNext","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func removeNext ( ) : Option < T > {  match ( this . next ) { case n : ValueNode < T > => n . remove ( ) NL case n : TailNode < T > => None < T > NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"removeNext","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func reset ( tail : TailNode < T > ) : Unit {  tail . prev = this NL this . next = tail NL }","func_name":"reset","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func insertPrev ( value : T ) : ValueNode < T > {  ValueNode < T > ( value , this . prev , this ) NL }","func_name":"insertPrev","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func removePrev ( ) : Option < T > {  match ( this . prev ) { case n : ValueNode < T > => n . remove ( ) NL case n : HeadNode < T > => None < T > NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"removePrev","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func remove ( ) : T {  match ( this . prev ) { case n : HeadNode < T > => n . next = this . next NL case n : ValueNode < T > => n . next = this . next NL case _ => throw UnreachableException ( ) NL } NL match ( this . next ) { case n : TailNode < T > => n . prev = this . prev NL case n : ValueNode < T > => n . prev = this . prev NL case _ => throw UnreachableException ( ) NL } NL this . prev = NoneNode < T > . instance NL this . next = NoneNode < T > . instance NL this . value NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func removeNext ( ) : Option < T > {  match ( this . next ) { case n : ValueNode < T > => n . remove ( ) NL case n : TailNode < T > => None < T > NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"removeNext","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func removePrev ( ) : Option < T > {  match ( this . prev ) { case n : ValueNode < T > => n . remove ( ) NL case n : HeadNode < T > => None < T > NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"removePrev","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func turnTo ( node : HeadNode < T > ) : Unit {  remove ( ) NL match ( node . next ) { case n : TailNode < T > => n . prev = this NL this . next = n NL case n : ValueNode < T > => n . prev = this NL this . next = n NL case _ => throw UnreachableException ( ) NL } NL node . next = this NL this . prev = node NL }","func_name":"turnTo","docstring":""}
{"repo":"fountain","file":"Deque.cj","path":"fountain/src/collection/Deque.cj","code_tokens":"public func turnTo ( node : TailNode < T > ) : Unit {  remove ( ) NL match ( node . prev ) { case n : HeadNode < T > => n . next = this NL this . prev = n NL case n : ValueNode < T > => n . next = this NL this . prev = n NL case _ => throw UnreachableException ( ) NL } NL node . prev = this NL this . next = node NL }","func_name":"turnTo","docstring":""}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func next ( ) : Option < K > {  entryIterator . next ( ) ? [ 0 ] NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func iterator ( ) : Iterator < K > {  return this NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<E> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func isEmpty ( ) : Bool {  return map . isEmpty ( ) NL }","func_name":"isEmpty","docstring":"/*\n     * 判断对象是否为空\n     * 返回值 Bool - 若为空返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func toArray ( ) : Array < K > {  return Array < K > ( this ) NL }","func_name":"toArray","docstring":"/*\n     * 将对象转为数组类型\n     * 返回值 Array<T> - 转换后的数组\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func iterator ( ) : Iterator < K > {  return MapKeyIterator ( map . iterator ( ) ) NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<E> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func contains ( element : K ) : Bool {  return map . contains ( element ) NL }","func_name":"contains","docstring":"/*\n     * 判断 Keys 是否包含指定元素\n     * 参数 element - T\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func containsAll ( elements : Collection < K > ) : Bool {  return map . containsAll ( elements ) NL }","func_name":"containsAll","docstring":"/*\n     * 判断 Keys 是否包含指定集合的元素\n     * 参数 elements - 待判断的集合 elements\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func remove ( element : K ) : Bool {  map . remove ( element ) . some NL }","func_name":"remove","docstring":"/*\n     * 如果指定元素存在于此 Keys ，则将其移除\n     * 参数 element - T\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func removeAll ( elements : Collection < K > ) : Unit {  map . removeAll ( elements ) NL }","func_name":"removeAll","docstring":"/*\n     * 移除此 Keys 中那些也包含在指定 Collection 中的所有元素\n     * 参数 element - 传入 Collection<T>\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func removeIf ( predicate : ( K ) -> Bool ) : Unit {   let lambda : ( K , V ) -> Bool = { k , v => predicate ( k ) NL } NL map . removeIf ( lambda ) NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传递判断删除的条件\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func clear ( ) : Unit {  map . clear ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有 Keys 中的元素\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func next ( ) : Option < V > {  entryIterator . next ( ) ? [ 1 ] NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func iterator ( ) : Iterator < V > {  return this NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<E> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func iterator ( ) : Iterator < V > {  return MapValueIterator ( map . iterator ( ) ) NL }","func_name":"iterator","docstring":"/*\n     * 返回实例类型的迭代器\n     * 返回值 Iterator<E> - 返回实例类型的迭代器。\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func isEmpty ( ) : Bool {  return map . isEmpty ( ) NL }","func_name":"isEmpty","docstring":"/*\n     * 判断对象是否为空\n     * 返回值 Bool - 若为空返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func removeIf ( predicate : ( V ) -> Bool ) : Unit {   let lambda : ( K , V ) -> Bool = { k , v => predicate ( v ) NL } NL map . removeIf ( lambda ) NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传递判断删除的条件\n     */"}
{"repo":"fountain","file":"MapExtend.cj","path":"fountain/src/collection/MapExtend.cj","code_tokens":"public func clear ( ) : Unit {  map . clear ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有 Keys 中的元素\n     */"}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"static public func createHashSet < T > ( ) : SealableSet < T > where T <: Hashable & Equatable < T > {  SealableSet < T > ( HashSet < T > ( ) ) NL }","func_name":"createHashSet","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"static public func createHashSet < T > ( elements : Iterable < T > , sealed ! : Bool = false ) : SealableSet < T > where T <: Hashable & Equatable < T > {   let set = SealableSet < T > ( HashSet < T > ( ) , sealed_ : sealed ) NL set . putAll ( elements ) NL return set NL }","func_name":"createHashSet","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"static public func createHashSet < T > ( set : HashSet < T > , sealed ! : Bool = false ) : SealableSet < T > where T <: Hashable & Equatable < T > {   let itr : Iterable < T > = set NL createHashSet < T > ( itr , sealed : sealed ) NL }","func_name":"createHashSet","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"static public func createSortedSet < T > ( ) : SealableSet < T > where T <: Comparable < T > {  SealableSet < T > ( TreeSet < T > . create < T > ( ) ) NL }","func_name":"createSortedSet","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"static public func createSortedSet < T > ( elements : SortedSet < T > , sealed ! : Bool = false ) : SealableSet < T > where T <: Comparable < T > {   let itr : Iterable < T > = elements NL  let set = createSortedSet < T > ( itr , elements . comparator ) NL set . sealed_ = sealed NL return set NL }","func_name":"createSortedSet","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"static public func createSortedSet < T > ( comparator : ( T , T ) -> Ordering ) : SealableSet < T > where T <: Equatable < T > {  SealableSet < T > ( TreeSet < T > ( comparator ) ) NL }","func_name":"createSortedSet","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"static public func createSortedSet < T > ( elements : Iterable < T > , comparator : ( T , T ) -> Ordering ) : SealableSet < T > where T <: Equatable < T > {   let set = createSortedSet < T > ( comparator ) NL set . putAll ( elements ) NL return set NL }","func_name":"createSortedSet","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"private func checkSealed ( ) : Unit {  if ( sealed_ ) {  throw IllegalAccessException ( current set is sealed ) NL } NL }","func_name":"checkSealed","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func seal ( ) : SealableSet < T > {  sealed_ = true NL return this NL }","func_name":"seal","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func put ( value : T ) : Bool {  checkSealed ( ) NL store . put ( value ) NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func putAll ( values : Collection < T > ) : Unit {  checkSealed ( ) NL store . putAll ( values ) NL }","func_name":"putAll","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func putAll ( values : Iterable < T > ) : Unit {  checkSealed ( ) NL for ( v in values ) {  store . put ( v ) NL } NL }","func_name":"putAll","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func clear ( ) : Unit {  checkSealed ( ) NL store . clear ( ) NL }","func_name":"clear","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func clone ( ) : SealableSet < T > {  return SealableSet < T > ( store . clone ( ) , sealed_ : sealed_ ) NL }","func_name":"clone","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func contains ( value : T ) : Bool {  store . contains ( value ) NL }","func_name":"contains","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func containsAll ( values : Collection < T > ) : Bool {   let itr : Iterable < T > = values NL containsAll ( itr ) NL }","func_name":"containsAll","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func containsAll ( values : Iterable < T > ) : Bool {  for ( v in values where ! contains ( v ) ) {  return false NL } NL return true NL }","func_name":"containsAll","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func isEmpty ( ) : Bool {  store . isEmpty ( ) NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  store . iterator ( ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func subsetOf ( set : Set < T > ) : Bool {  for ( v in store where ! set . contains ( v ) ) {  return false NL } NL return true NL }","func_name":"subsetOf","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func remove ( value : T ) : Bool {  checkSealed ( ) NL store . remove ( value ) NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func removeAll ( values : Collection < T > ) : Unit {   let itr : Iterable < T > = values NL removeAll ( itr ) NL }","func_name":"removeAll","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func removeAll ( values : Iterable < T > ) : Unit {  checkSealed ( ) NL for ( v in values ) {  remove ( v ) NL } NL }","func_name":"removeAll","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  checkSealed ( ) NL store . removeIf ( predicate ) NL }","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"SealableSet.cj","path":"fountain/src/collection/SealableSet.cj","code_tokens":"public func retainAll ( set : Set < T > ) : Unit {  checkSealed ( ) NL for ( v in store where ! set . contains ( v ) ) {  store . remove ( v ) NL } NL }","func_name":"retainAll","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func sameAs ( other : SkipListNode < T > ) {  this . seq == other . seq NL }","func_name":"sameAs","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func compareAndSet ( old : SkipListNode < T > , new : SkipListNode < T > ) : Bool","func_name":"compareAndSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func compareAndSet ( old : SkipListNode < T > , new : SkipListNode < T > ) : Bool {  throw UnreachableException ( ) NL }","func_name":"compareAndSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func compareAndSet ( old : SkipListNode < T > , new : SkipListNode < T > ) : Bool {  synchronized ( this ) {  if ( this . next_ . sameAs ( old ) ) {  this . next_ = new NL true NL } else {  false NL } NL } NL }","func_name":"compareAndSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func sameAs ( other : SkipListIndex < T > ) {  this . seq == other . seq NL }","func_name":"sameAs","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func compareAndSet ( old : SkipListIndex < T > , new : SkipListIndex < T > ) : Bool","func_name":"compareAndSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func compareAndSet ( old : SkipListIndex < T > , new : SkipListIndex < T > ) : Bool {  throw UnreachableException ( ) NL }","func_name":"compareAndSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func compareAndSet ( old : SkipListIndex < T > , new : SkipListIndex < T > ) : Bool {  synchronized ( this ) {  if ( this . right_ . sameAs ( old ) ) {  this . right_ = new NL true NL } else {  false NL } NL } NL }","func_name":"compareAndSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func descending ( ) : ConcurrentSkipListSubSet < T > {  ConcurrentSkipListSubSet < T > ( { t1 , t2 => set . comparator ( t2 , t1 ) NL } , set , high , low , lowInclusive : highInclusive , highInclusive : lowInclusive ) NL }","func_name":"descending","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func contains ( element : T ) : Bool {  doFind ( element ) is SkipListValueNode < T > NL }","func_name":"contains","docstring":"/*\n     * 如果该集合包含指定元素，则返回 true\n     * 参数 element - 需要判断的元素\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func doFind ( element : T ) : SkipListNode < T > {   let cmp = set . comparator NL  var c = match ( low ) { case None < T > => GT NL case Some ( l ) => cmp ( element , l ) NL } NL if ( c . lt || ( ! lowInclusive && c . eq ) ) {  return SkipListNoneNode < T > . instance NL } NL c = match ( high ) { case None < T > => LT NL case Some ( h ) => cmp ( element , h ) NL } NL if ( c . gt || ( ! highInclusive && c . eq ) ) {  return SkipListNoneNode < T > . instance NL } NL return set . doFind ( element ) NL }","func_name":"doFind","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func subsetOf ( other : Set < T > ) : Bool {   let cmp = set . comparator NL  let itr = set . iterator ( ) NL match ( low ) { case None < T > => ( ) NL case Some ( l ) => for ( v in itr ) {  match ( cmp ( v , l ) ) { case LT => continue NL case EQ where ! lowInclusive => continue NL case _ => if ( other . contains ( v ) ) {  match ( high ) { case None < T > => break NL case Some ( h ) => match ( cmp ( v , h ) ) { case EQ where highInclusive => break NL case LT => break NL case _ => return true NL } NL } NL break NL } else {  return false NL } NL } NL } NL } NL match ( high ) { case None < T > => ( ) NL case Some ( h ) => for ( v in itr ) {  match ( cmp ( v , h ) ) { case GT => break NL case EQ where ! highInclusive => break NL case _ => if ( other . contains ( v ) ) {  continue NL } else {  return false NL } NL } NL } NL } NL true NL }","func_name":"subsetOf","docstring":"/*\n     * 检查该集合是否为其他集合的子集\n     * 参数 other - 其他集合\n     * 返回值 Bool - 如果它是子集，则返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func containsAll ( elements : Collection < T > ) : Bool {   let eitr = elements . iterator ( ) NL  let cmp = set . comparator NL match ( low ) { case None < T > => ( ) NL case Some ( l ) => for ( e in eitr ) {  match ( cmp ( e , l ) ) { case LT => return false NL case EQ where ! lowInclusive => return false NL case _ => match ( high ) { case None < T > => break NL case Some ( h ) => match ( cmp ( e , h ) ) { case EQ where ! highInclusive => return false NL case GT => return false NL case _ => if ( set . contains ( e ) ) {  break NL } else {  return false NL } NL } NL } NL } NL } NL } NL match ( high ) { case Some ( h ) => for ( e in eitr ) {  match ( cmp ( e , h ) ) { case GT => return false NL case EQ where ! highInclusive => return false NL case _ => if ( ! set . contains ( e ) ) {  return false NL } NL } NL } NL case _ => for ( e in eitr where ! set . contains ( e ) ) {  return false NL } NL } NL return true NL }","func_name":"containsAll","docstring":"/*\n     * 检查该集合是否包含其他集合\n     * 参数 elements - 其他集合\n     * 返回值 Bool - 如果包含，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"private func checkHigh ( e : T , h : T ) {  match ( set . comparator ( e , h ) ) { case GT => return false NL case EQ where ! highInclusive => return false NL case _ => return true NL } NL }","func_name":"checkHigh","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"private func checkLow ( e : T , l : T , fn : ( ) -> Bool ) : Bool {  match ( set . comparator ( e , l ) ) { case LT => return false NL case EQ where ! lowInclusive => return false NL case _ => return fn ( ) NL } NL }","func_name":"checkLow","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func checkLow ( e : T ) : Bool {  match ( low ) { case Some ( l ) => checkLow ( e , l ) { true NL } NL case None => true NL } NL }","func_name":"checkLow","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func checkHigh ( e : T ) : Bool {  match ( high ) { case Some ( h ) => checkHigh ( e , h ) NL case None => true NL } NL }","func_name":"checkHigh","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func checkHiLo ( element : T ) : Bool {  match ( ( low , high ) ) { case ( Some ( l ) , Some ( h ) ) => checkLow ( element , l ) { checkHigh ( element , h ) NL } NL case ( Some ( l ) , _ ) => checkLow ( element , l ) { true NL } NL case ( _ , Some ( h ) ) => return checkHigh ( element , h ) NL case _ => true NL } NL }","func_name":"checkHiLo","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func put ( element : T ) : Bool {  match ( doPut ( element ) ) { case Some ( x ) where x is SkipListNoneNode < T > => true NL case _ => false NL } NL }","func_name":"put","docstring":"/*\n     * 添加元素操作。如果元素已经存在，则不会添加它\n     * 参数 element - 要添加的元素\n     * 返回值 Bool - 如果添加成功，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func doPut ( element : T ) : Option < SkipListNode < T > > {  if ( checkHiLo ( element ) ) {  set . doPut ( element ) NL } else {  None NL } NL }","func_name":"doPut","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func putAll ( elements : Collection < T > ) : Unit {   let itr : Iterable < T > = elements NL putAll ( itr ) NL }","func_name":"putAll","docstring":"/*\n     * 添加 Collection 中的所有元素至此 Set 中，如果元素存在，则不添加\n     * 参数 elements - 需要被添加的元素的集合\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func putAll ( elements : Iterable < T > ) : Unit {  for ( e in elements ) {  put ( e ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 添加 Collection 中的所有元素至此 Set 中，如果元素存在，则不添加\n     * 参数 elements - 需要被添加的元素的集合\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func remove ( element : T ) : Bool {  doRemove ( element ) is SkipListValueNode < T > NL }","func_name":"remove","docstring":"/*\n     * 从该结合中移除指定元素（如果存在）\n     * 参数 element - 要删除的元素\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func doRemove ( element : T ) : SkipListNode < T > {  if ( checkHiLo ( element ) ) {  set . doRemove ( element ) NL } else {  SkipListNoneNode < T > . instance NL } NL }","func_name":"doRemove","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func removeAll ( elements : Collection < T > ) : Unit {  for ( e in elements ) {  remove ( e ) NL } NL }","func_name":"removeAll","docstring":"/*\n     * 移除此 Set 中那些也包含在指定 Collection 中的所有元素\n     * 参数 elements - 传入 Collection<T>\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  for ( v in this where predicate ( v ) ) {  remove ( v ) NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传入一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func clear ( ) : Unit {  removeIf ( checkHiLo ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func retainAll ( elements : Set < T > ) : Unit {  for ( v in this where ! elements . contains ( v ) ) {  remove ( v ) NL } NL }","func_name":"retainAll","docstring":"/*\n     * 只保留重复的 T\n     * 参数 elements - 要保存的元素集合\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func clone ( ) : Set < T > {  ConcurrentSkipListSubSet < T > ( set , low , high , lowInclusive : lowInclusive , highInclusive : highInclusive ) NL }","func_name":"clone","docstring":"/*\n     * 克隆 Set\n     * 返回新的 Set\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func isEmpty ( ) : Bool {  if ( set . isEmpty ( ) ) {  return true NL } NL for ( v in this ) {  if ( checkHiLo ( v ) ) {  return false NL } NL } NL return true NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  ConcurrentSkipListSubSetIterator < T > ( this ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func subSet ( low : T , high : T , lowInclusive ! : Bool = true , highInclusive ! : Bool = false ) : ConcurrentSkipListSubSet < T > {   let cmp = set . comparator NL  let l = match ( this . low ) { case Some ( l ) => if ( cmp ( low , l ) . gt ) {  low NL } else {  l NL } NL case _ => low NL } NL  let h = match ( this . high ) { case Some ( h ) => if ( cmp ( high , h ) . lt ) {  high NL } else {  h NL } NL case _ => high NL } NL ConcurrentSkipListSubSet < T > ( set , l , h , lowInclusive : lowInclusive , highInclusive : highInclusive ) NL }","func_name":"subSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func headSet ( end : T , inclusive ! : Bool = false ) : ConcurrentSkipListSubSet < T > {   let h = match ( this . high ) { case Some ( h ) => if ( set . comparator ( end , h ) . lt ) {  end NL } else {  h NL } NL case _ => end NL } NL ConcurrentSkipListSubSet < T > ( set , low , h , lowInclusive : lowInclusive , highInclusive : highInclusive ) NL }","func_name":"headSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func tailSet ( start : T , inclusive ! : Bool = true ) : ConcurrentSkipListSubSet < T > {   let l = match ( this . low ) { case Some ( l ) => if ( set . comparator ( start , l ) . gt ) {  start NL } else {  l NL } NL case _ => start NL } NL ConcurrentSkipListSubSet < T > ( set , l , high , lowInclusive : lowInclusive , highInclusive : highInclusive ) NL }","func_name":"tailSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func next ( ) : Option < T > {   let tmp = current NL if ( tmp . none ) {  tmp NL } NL for ( v in itr ) {  current = if ( set . checkHigh ( v ) ) {  v NL } else {  None < T > NL } NL return tmp NL } NL tmp NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func next ( ) : Option < T > {  match ( nextNode ) { case n where n . hasNoValue => None < T > NL case n : SkipListValueNode < T > => advance ( n ) NL n . value NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"private func advance ( b : SkipListNode < T > ) {   var c = b NL  var n : SkipListNode < T > = SkipListNoneNode < T > . instance NL  var v = None < T > NL if ( b . isNotNone ) {  lastReturned = c NL n = c . next NL while ( n . isNotNone && n . hasNoValue ) {  n = c . next NL c = n NL } NL } NL nextValue = v NL nextNode = n NL }","func_name":"advance","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"static public func create < T > ( ) : ConcurrentSkipListSet < T > where T <: Comparable < T > {  ConcurrentSkipListSet < T > ( Comparator . compare < T > ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"static public func create < T > ( elements : Iterable < T > ) : ConcurrentSkipListSet < T > where T <: Comparable < T > {   let set = create < T > ( ) NL set . putAll ( elements ) NL set NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"static public func create ( elements : SortedSet < T > ) : ConcurrentSkipListSet < T > {  ConcurrentSkipListSet < T > ( elements , elements . comparator ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"private func compareAndSet ( oldHead : SkipListIndex < T > , newHead : SkipListIndex < T > ) : Bool {  synchronized ( this ) {  if ( this . head . sameAs ( oldHead ) ) {  this . head = newHead NL true NL } else {  false NL } NL } NL }","func_name":"compareAndSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func isEmpty ( ) : Bool {  size == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"static func compare ( cmp : ( T , T ) -> Ordering , x : Option < T > , y : Option < T > ) : Ordering {  match ( ( x , y ) ) { case ( Some ( x ) , Some ( y ) ) => cmp ( x , y ) NL case ( Some ( _ ) , _ ) => GT NL case ( _ , Some ( _ ) ) => LT NL case _ => EQ NL } NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"static func compare ( cmp : ( T , T ) -> Ordering , x : Option < T > , y : SkipListNode < T > ) : Ordering {  compare ( cmp , x , ( y as SkipListValueNode < T > ) ? . value ) NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"static func compare ( cmp : ( T , T ) -> Ordering , x : SkipListNode < T > , y : SkipListNode < T > ) : Ordering {  compare ( cmp , ( x as SkipListValueNode < T > ) ? . value , ( y as SkipListValueNode < T > ) ? . value ) NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func baseHead ( ) : SkipListNode < T > {  memoryFence { match ( head ) { case h : SkipListNoneIndex < T > => SkipListNoneNode < T > . instance NL case h : SkipListValueIndex < T > => h . node NL case _ => throw UnreachableException ( ) NL } NL } NL }","func_name":"baseHead","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"static func unlinkNode ( b : SkipListNode < T > , n : SkipListNode < T > ) {  if ( b . isNotNone && n . isNotNone ) {   var p : SkipListNode < T > = SkipListNoneNode < T > . instance NL while ( true ) {   let f = n . next NL if ( f . isNotNone && f . hasNoValue ) {  p = f . next NL break NL } else if ( n . compareAndSet ( f , SkipListLinkedNode < T > ( f ) ) ) {  p = f NL break NL } NL } NL b . compareAndSet ( n , p ) NL } NL }","func_name":"unlinkNode","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"private func findPredecessor ( val : T , cmp : ( T , T ) -> Ordering ) : SkipListNode < T > {  memoryFence {  var q : SkipListIndex < T > = head NL if ( q . isNone ) {  return SkipListNoneNode < T > . instance NL } else {  while ( true ) {   let r = q . right NL while ( r . isNotNone ) {   var p : SkipListNode < T > = r . node NL if ( p . isNone || p . hasNoValue ) {  q . compareAndSet ( r , r . right ) NL } else if ( compare ( cmp , val , p ) . gt ) {  q = r NL } else {  break NL } NL } NL  let d = q . down NL if ( d . isNotNone ) {  q = d NL } else {  return q . node NL } NL } NL throw UnreachableException ( ) NL } NL } NL }","func_name":"findPredecessor","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"private func findNode ( val : T ) : SkipListNode < T > {   let cmp = this . cmp NL  var b : SkipListNode < T > NL while ( true ) {  b = findPredecessor ( val , cmp ) NL if ( b . isNone ) {  break NL } NL  var outerBreak = false NL while ( true ) {   let n = b . next NL if ( n . isNone ) {  outerBreak = true NL break NL } else if ( n . hasNoValue ) {  break NL } else {  match ( compare ( cmp , val , n ) ) { case GT => b = n NL case EQ => return n NL case _ => outerBreak = true NL break NL } NL } NL } NL if ( outerBreak ) {  break NL } NL } NL return SkipListNoneNode < T > . instance NL }","func_name":"findNode","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func doFind ( val : T ) : SkipListNode < T > {  memoryFence {  let cmp = this . cmp NL  var result : SkipListNode < T > = SkipListNoneNode < T > . instance NL  var q : SkipListIndex < T > = head NL if ( q . isNotNone ) {  while ( true ) {   var outerBreak = false NL  let r = q . right NL while ( r . isNotNone ) {   var p : SkipListNode < T > = r . node NL if ( p . isNone || p . hasNoValue ) {  q . compareAndSet ( r , r . right ) NL } else {  match ( compare ( cmp , val , p ) ) { case GT => q = r NL case EQ => result = p NL outerBreak = true NL break NL case _ => break NL } NL } NL } NL if ( outerBreak ) {  break NL } NL  let d : SkipListIndex < T > = q . down NL if ( d . isNotNone ) {  q = d NL } else {   var b : SkipListNode < T > = q . node NL if ( b . isNotNone ) {   let n : SkipListNode < T > = b . next NL while ( n . isNotNone ) {  if ( n . hasNoValue ) {  b = n NL } else {  match ( compare ( cmp , val , n ) ) { case GT => b = n NL case EQ => result = n NL break NL case _ => break NL } NL } NL } NL } NL break NL } NL if ( outerBreak ) {  break NL } NL } NL } NL return result NL } NL }","func_name":"doFind","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func contains ( value : T ) : Bool {  doFind ( value ) is SkipListValueNode < T > NL }","func_name":"contains","docstring":"/*\n     * 如果该集合包含指定元素，则返回 true\n     * 参数 element - 需要判断的元素\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"private func containsAll ( left : Set < T > , right : Collection < T > ) : Bool {  for ( v in right ) {  if ( ! ( left . contains ( v ) ) ) {  return false NL } NL } NL true NL }","func_name":"containsAll","docstring":"/*\n     * 检查该集合是否包含其他集合\n     * 参数 elements - 其他集合\n     * 返回值 Bool - 如果包含，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func subsetOf ( other : Set < T > ) : Bool {  containsAll ( other , this ) NL }","func_name":"subsetOf","docstring":"/*\n     * 检查该集合是否为其他集合的子集\n     * 参数 other - 其他集合\n     * 返回值 Bool - 如果它是子集，则返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func containsAll ( elements : Collection < T > ) : Bool {  containsAll ( this , elements ) NL }","func_name":"containsAll","docstring":"/*\n     * 检查该集合是否包含其他集合\n     * 参数 elements - 其他集合\n     * 返回值 Bool - 如果包含，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func doPut ( value : T ) : SkipListNode < T > {   let cmp = this . cmp NL while ( true ) {   let node : Option < SkipListNode < T > > = memoryFence < Option < SkipListNode < T > > > {  var h : SkipListIndex < T > = head NL  var b : SkipListNode < T > = SkipListNoneNode < T > . instance NL  var levels = 0 NL if ( h . isNone ) {   let base = SkipListLinkedNode < T > ( ) NL h = SkipListValueIndex < T > ( base ) NL b = if ( this . compareAndSet ( SkipListNoneIndex < T > . instance , h ) ) {  base NL } else {  SkipListNoneNode < T > . instance NL } NL } else {   var q : SkipListIndex < T > = h NL while ( true ) {   let r = q . right NL while ( r . isNotNone ) {   var p : SkipListNode < T > = r . node NL if ( p . isNone || p . hasNoValue ) {  q . compareAndSet ( r , r . right ) NL } else if ( compare ( cmp , value , p ) . gt ) {  q = r NL } else {  break NL } NL } NL  let d : SkipListIndex < T > = q . down NL if ( d . isNotNone ) {  levels ++ NL q = d NL } else {  b = q . node NL break NL } NL } NL } NL if ( b . isNotNone ) {   var z : SkipListNode < T > = SkipListNoneNode < T > . instance NL while ( true ) {   let n = b . next NL  var c : Ordering NL if ( n . isNone ) {  if ( b . hasNoValue ) {  compare ( cmp , value , value ) NL } NL c = LT NL } else if ( n . hasNoValue ) {  break NL } else {  match ( compare ( cmp , value , n ) ) { case GT => b = n NL c = GT NL case EQ => return n NL case LT =>  let p : SkipListNode < T > = SkipListValueNode < T > ( value , n ) NL if ( b . compareAndSet ( n , p ) ) {  z = p NL break NL } NL } NL } NL } NL if ( z . isNotNone ) {   let lr = random . nextInt64 ( ) NL if ( ( lr & 0x3 ) == 0 ) {   let hr = random . nextInt64 ( ) NL  var rnd = ( hr << 32 ) | ( lr & 0xffffffff ) NL  var skips = levels NL  var x : SkipListIndex < T > = SkipListNoneIndex < T > . instance NL while ( true ) {  x = SkipListValueIndex < T > ( z , down : x , right : SkipListNoneIndex < T > . instance ) NL if ( rnd > = 0 ) {  break NL } else {  skips -- NL if ( skips < 0 ) {  break NL } else {  rnd <<= 1 NL } NL } NL } NL if ( addIndices ( h , skips , x , cmp ) && skips < 0 && head . sameAs ( h ) ) {   let hx = SkipListValueIndex < T > ( z , down : x , right : SkipListNoneIndex < T > . instance ) NL  let nh = SkipListValueIndex < T > ( h . node , down : h , right : hx ) NL this . compareAndSet ( h , nh ) NL } NL } NL currentSize . fetchAdd ( 1 ) NL return SkipListNoneNode < T > . instance NL } NL } NL return None NL } NL if ( let Some ( n ) = node ) {  return n NL } NL } NL throw UnreachableException ( ) NL }","func_name":"doPut","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"static private func addIndices ( idx : SkipListIndex < T > , skp : Int64 , x : SkipListIndex < T > , cmp : ( T , T ) -> Ordering ) : Bool {   var q = idx NL  var skips = skp NL  var z : SkipListNode < T > = x . node NL if ( x . isNotNone && z . isNotNone && z . hasValue && q . isNotNone ) {   var retrying = false NL while ( true ) {   var r : SkipListIndex < T > = q . right NL  var c : Ordering NL if ( r . isNotNone ) {   var p : SkipListNode < T > = r . node NL  var v : T NL if ( p . isNone || p . hasNoValue ) {  q . compareAndSet ( r , r . right ) NL c = EQ NL } else {  match ( compare ( cmp , z , p ) ) { case GT => q = r NL c = GT NL case EQ => c = EQ NL break NL case LT => c = LT NL } NL } NL } else {  c = LT NL } NL if ( c . lt ) {   let d : SkipListIndex < T > = q . down NL if ( d . isNotNone && skips > 0 ) {  skips -- NL q = d NL } else if ( d . isNotNone && ! retrying && ! addIndices ( d , 0 , x . down , cmp ) ) {  break NL } else {  x . right = r NL if ( q . compareAndSet ( r , x ) ) {  return true NL } else {  retrying = true NL } NL } NL } NL } NL } NL return false NL }","func_name":"addIndices","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func put ( element : T ) : Bool {  doPut ( element ) is SkipListNoneNode < T > NL }","func_name":"put","docstring":"/*\n     * 添加元素操作。如果元素已经存在，则不会添加它\n     * 参数 element - 要添加的元素\n     * 返回值 Bool - 如果添加成功，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func putAll ( elements : Collection < T > ) : Unit {   let itr : Iterable < T > = elements NL putAll ( itr ) NL }","func_name":"putAll","docstring":"/*\n     * 添加 Collection 中的所有元素至此 Set 中，如果元素存在，则不添加\n     * 参数 elements - 需要被添加的元素的集合\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func putAll ( elements : Iterable < T > ) : Unit {  for ( v in elements ) {  put ( v ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 添加 Collection 中的所有元素至此 Set 中，如果元素存在，则不添加\n     * 参数 elements - 需要被添加的元素的集合\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func doRemove ( value : T ) : SkipListNode < T > {   let cmp = this . cmp NL  var result : SkipListNode < T > = SkipListNoneNode < T > . instance NL  var b : SkipListNode < T > NL while ( true ) {  b = findPredecessor ( value , cmp ) NL if ( ! ( b . isNone || result . isNotNone ) ) {  break NL } NL  var outerBreak = false NL while ( true ) {   var v : T NL  var n : SkipListNode < T > NL if ( b . next . isNone ) {  outerBreak = true NL break NL } else {  n = b . next NL } NL if ( n . hasNoValue ) {  break NL } else {  match ( compare ( cmp , value , n ) ) { case GT => b = n NL case LT => outerBreak = true NL break NL case _ => result = n NL unlinkNode ( b , n ) NL break NL } NL } NL } NL if ( outerBreak ) {  break NL } NL } NL if ( result . isNotNone ) {  tryReduceLevel ( ) NL currentSize . fetchSub ( 1 ) NL } NL result NL }","func_name":"doRemove","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"private func tryReduceLevel ( ) {   let h = head NL if ( h . isNone || h . right . isNotNone ) {  return NL } NL  let d = h . down NL if ( d . isNone || d . right . isNotNone ) {  return NL } NL  let e = d . down NL if ( e . isNotNone && e . right . isNone && this . compareAndSet ( h , d ) && h . right . isNotNone ) {  this . compareAndSet ( d , h ) NL } NL }","func_name":"tryReduceLevel","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func remove ( element : T ) : Bool {  doRemove ( element ) is SkipListValueNode < T > NL }","func_name":"remove","docstring":"/*\n     * 从该结合中移除指定元素（如果存在）\n     * 参数 element - 要删除的元素\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func removeAll ( elements : Collection < T > ) : Unit {  for ( v in elements ) {  remove ( v ) NL } NL }","func_name":"removeAll","docstring":"/*\n     * 移除此 Set 中那些也包含在指定 Collection 中的所有元素\n     * 参数 elements - 传入 Collection<T>\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  for ( v in this where predicate ( v ) ) {  remove ( v ) NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传入一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func clear ( ) : Unit {  synchronized ( this ) {  head = SkipListNoneIndex < T > . instance NL currentSize . store ( 0 ) NL } NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func retainAll ( elements : Set < T > ) : Unit {   let set = ConcurrentSkipListSet < T > ( this . cmp ) NL for ( v in elements where contains ( v ) ) {  set . put ( v ) NL } NL copy ( set , this ) NL }","func_name":"retainAll","docstring":"/*\n     * 只保留重复的 T\n     * 参数 elements - 要保存的元素集合\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"private func copy ( src : ConcurrentSkipListSet < T > , dst : ConcurrentSkipListSet < T > ) {  synchronized ( this ) {  dst . head = src . head NL dst . currentSize . store ( src . currentSize . load ( ) ) NL } NL }","func_name":"copy","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func clone ( ) : Set < T > {   let set = ConcurrentSkipListSet < T > ( this . cmp ) NL copy ( this , set ) NL set NL }","func_name":"clone","docstring":"/*\n     * 克隆 Set\n     * 返回新的 Set\n     */"}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  ConcurrentSkipListSetIterator < T > ( this ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"func subSet ( low : Option < T > , high : Option < T > , lowInclusive ! : Bool = true , highInclusive ! : Bool = false ) : ConcurrentSkipListSubSet < T > {  ConcurrentSkipListSubSet < T > ( this , low , high , lowInclusive : lowInclusive , highInclusive : highInclusive ) NL }","func_name":"subSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func subSet ( low : T , high : T , lowInclusive ! : Bool = true , highInclusive ! : Bool = false ) : ConcurrentSkipListSubSet < T > {  subSet ( Some ( low ) , Some ( high ) , lowInclusive : lowInclusive , highInclusive : highInclusive ) NL }","func_name":"subSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func headSet ( end : T , inclusive ! : Bool = false ) : ConcurrentSkipListSubSet < T > {  subSet ( None < T > , end , highInclusive : inclusive ) NL }","func_name":"headSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func tailSet ( start : T , inclusive ! : Bool = true ) : ConcurrentSkipListSubSet < T > {  subSet ( start , None < T > , lowInclusive : inclusive ) NL }","func_name":"tailSet","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func ceiling ( element : T ) : Option < T > {   var r = None < T > NL for ( v in this ) {  match ( this . cmp ( v , element ) ) { case EQ => return v NL case LT => r = v NL case GT => return r NL } NL } NL r NL }","func_name":"ceiling","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func floor ( element : T ) : Option < T > {  for ( v in this ) {  match ( this . cmp ( v , element ) ) { case LT => ( ) NL case _ => return v NL } NL } NL None < T > NL }","func_name":"floor","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func lower ( element : T ) : Option < T > {   var r = None < T > NL for ( v in this ) {  match ( this . cmp ( v , element ) ) { case LT => r = v NL case _ => return r NL } NL } NL r NL }","func_name":"lower","docstring":""}
{"repo":"fountain","file":"ConcurrentSkipListSet.cj","path":"fountain/src/collection/ConcurrentSkipListSet.cj","code_tokens":"public func higher ( element : T ) : Option < T > {  for ( v in this ) {  match ( this . cmp ( v , element ) ) { case GT => return v NL case _ => ( ) NL } NL } NL None < T > NL }","func_name":"higher","docstring":""}
{"repo":"fountain","file":"SyncIterator.cj","path":"fountain/src/collection/SyncIterator.cj","code_tokens":"public func next ( ) : Option < T > {  syncer . tryRead { return itr . next ( ) NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"SyncIterator.cj","path":"fountain/src/collection/SyncIterator.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  return this NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"SyncIterator.cj","path":"fountain/src/collection/SyncIterator.cj","code_tokens":"public func prev ( ) : Option < T > {  syncer . tryRead < T > { itr . prev ( ) NL } NL }","func_name":"prev","docstring":""}
{"repo":"fountain","file":"SyncIterator.cj","path":"fountain/src/collection/SyncIterator.cj","code_tokens":"public func reverseIterator ( ) : ReverseIterator < T > {  this NL }","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func next ( ) : Option < K > {  if ( let Some ( ( k , v ) ) = itr . next ( ) ) {  return Some ( k ) NL } NL return None < K > NL }","func_name":"next","docstring":"/*\n     * 返回迭代过程中的下一个元素\n     * 返回值 Option<E> - 迭代过程中的下一个元素\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func iterator ( ) : Iterator < K > {  return this NL }","func_name":"iterator","docstring":"/*\n     * 返回 Keys 的迭代器\n     * 返回值 Iterator<K> - Keys 的迭代器\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func iterator ( ) : Iterator < K > {  ConcurrentHashMapKeysIterator < K , V > ( map . iterator ( ) ) NL }","func_name":"iterator","docstring":"/*\n     * 返回 Keys 的迭代器\n     * 返回值 Iterator<K> - Keys 的迭代器\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  return map . isEmpty ( ) NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Keys 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func contains ( element : K ) : Bool {  map . contains ( element ) NL }","func_name":"contains","docstring":"/*\n     * 判断 Keys 是否包含指定元素\n     * 参数 element - K\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func containsAll ( elements : Collection < K > ) : Bool {  map . containsAll ( elements ) NL }","func_name":"containsAll","docstring":"/*\n     * 判断 Keys 是否包含指定集合的元素\n     * 参数 elements - 待判断的集合 elements\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func remove ( element : K ) : Bool {  if ( let Some ( _ ) = map . remove ( element ) ) {  return true NL } NL return false NL }","func_name":"remove","docstring":"/*\n     * 如果指定元素存在于此 Keys ，则将其移除\n     * 参数 element - K\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func removeAll ( elements : Collection < K > ) : Unit {  map . removeAll ( elements ) NL }","func_name":"removeAll","docstring":"/*\n     * 移除此 Keys 中那些也包含在指定 Collection 中的所有元素\n     * 参数 element - 传入 Collection<K>\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func removeIf ( predicate : ( K ) -> Bool ) : Unit {  map . removeIf { k , v => return predicate ( k ) NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传递判断删除的条件\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func clear ( ) : Unit {  map . clear ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有 Keys 中的元素\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func next ( ) : Option < V > {  if ( let Some ( ( k , v ) ) = itr . next ( ) ) {  return Some ( v ) NL } NL return None < V > NL }","func_name":"next","docstring":"/*\n     * 返回迭代过程中的下一个元素\n     * 返回值 Option<E> - 迭代过程中的下一个元素\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func iterator ( ) : Iterator < V > {  return this NL }","func_name":"iterator","docstring":"/*\n     * 返回 Keys 的迭代器\n     * 返回值 Iterator<K> - Keys 的迭代器\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func iterator ( ) : Iterator < V > {  ConcurrentHashMapValuesIterator < K , V > ( map . iterator ( ) ) NL }","func_name":"iterator","docstring":"/*\n     * 返回 Keys 的迭代器\n     * 返回值 Iterator<K> - Keys 的迭代器\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  map . isEmpty ( ) NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Keys 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func removeIf ( predicate : ( V ) -> Bool ) : Unit {  map . removeIf { k , v => return predicate ( v ) NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传递判断删除的条件\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func clear ( ) : Unit {  map . clear ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有 Keys 中的元素\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func next ( ) : Option < ( K , V ) > {  if ( let Some ( itr ) = itropt ) {   let opt = itr . next ( ) NL if ( let Some ( _ ) = opt ) {  return opt NL } NL } NL if ( nextSegment ( ) ) {  return next ( ) NL } NL return None < ( K , V ) > NL }","func_name":"next","docstring":"/*\n     * 返回迭代过程中的下一个元素\n     * 返回值 Option<E> - 迭代过程中的下一个元素\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {  return this NL }","func_name":"iterator","docstring":"/*\n     * 返回 Keys 的迭代器\n     * 返回值 Iterator<K> - Keys 的迭代器\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func nextSegment ( ) : Bool {  if ( cur > = 0 && cur < map . size ) {  itropt = segmentIterator ( cur ) NL cur ++ NL true NL } else {  false NL } NL }","func_name":"nextSegment","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func segmentIterators ( ) : Array < Iterator < ( K , V ) > > {  Array < Iterator < ( K , V ) > > ( this . map . concurrency ) { i => segmentIterator ( i ) NL } NL }","func_name":"segmentIterators","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"private func segmentIterator ( idx : Int64 ) : Iterator < ( K , V ) > {  this . map . segments [ idx ] . iterator ( ) NL }","func_name":"segmentIterator","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"static public func create ( concurrencyLevel ! : Int64 = DEFAULT_CONCURRENCY , linked ! : Bool = false ) : ConcurrentHashMap < K , V > {   let concurrency = conc ( concurrencyLevel ) NL  let segments = newSegments ( concurrency , linked ) NL ConcurrentHashMap < K , V > ( segments , concurrency ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"static public func create ( map : Map < K , V > , concurrencyLevel ! : Int64 = DEFAULT_CONCURRENCY , linked ! : Bool = false ) : ConcurrentHashMap < K , V > {   var concurrency : Int64 NL if ( concurrencyLevel == 0 ) {  if ( let Some ( m ) = map as ConcurrentHashMap < K , V > ) {  concurrency = m . concurrency NL } else {  concurrency = DEFAULT_CONCURRENCY NL } NL } else {  concurrency = conc ( concurrencyLevel ) NL } NL  let segments = newSegments ( concurrency , linked ) NL  var result = ConcurrentHashMap < K , V > ( segments , concurrency ) NL result . putAll ( map ) NL return result NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"static private func newSegments ( concurrency : Int64 , linked : Bool ) {  Array < SyncMap < K , V > > ( concurrency ) { s => if ( linked ) {  SyncMap < K , V > . create < K > ( LinkedMap < K , V > ( ) ) NL } else {  SyncMap < K , V > . create < K > ( ) NL } NL } NL }","func_name":"newSegments","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"static private func conc ( concurrencyLevel : Int64 ) {   var concurrency = 1 NL while ( concurrency < concurrencyLevel ) {  concurrency <<= 1 NL } NL return concurrency NL }","func_name":"conc","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"private func segment ( key : K ) : SyncMap < K , V > {  segments [ key . hashCode ( ) & ( concurrency - 1 ) ] NL }","func_name":"segment","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"private func incrSize ( ) {  size_ . fetchAdd ( 1 ) NL }","func_name":"incrSize","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"private func decrSize ( ) {  size_ . fetchSub ( 1 ) NL }","func_name":"decrSize","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func get ( key : K ) : Option < V > {  segment ( key ) . get ( key ) NL }","func_name":"get","docstring":"/*\n     * 根据 key 得到 Map 中映射的值\n     * 参数 key - 传递 key，获取 value\n     * 返回值 Option<V> - key 对应的值是用 Option 封装的\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func contains ( key : K ) : Bool {  segment ( key ) . contains ( key ) NL }","func_name":"contains","docstring":"/*\n     * 判断 Keys 是否包含指定元素\n     * 参数 element - K\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {   var cont = true NL for ( key in keys ) {  cont &&= segment ( key ) . contains ( key ) NL if ( ! cont ) {  break NL } NL } NL return cont NL }","func_name":"containsAll","docstring":"/*\n     * 判断 Keys 是否包含指定集合的元素\n     * 参数 elements - 待判断的集合 elements\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func put ( key : K , value : V ) : Option < V > {   let opt = segment ( key ) . put ( key , value ) NL incrSize ( ) NL return opt NL }","func_name":"put","docstring":"/*\n     * 将指定的值与此映射中指定的键关联\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 key - 要放置的键\n     * 参数 value - 要分配的值\n     * 返回值 Option<V> - 如果赋值之前 key 存在，旧的 value 用 Option 封装；\n     * 否则，返回 Option<V>.None\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  for ( ( key , val ) in elements ) {  segment ( key ) . put ( key , val ) NL incrSize ( ) NL } NL }","func_name":"putAll","docstring":"/*\n     * 传递指定元素进行遍历，并按顺序赋值\n     * 如果映射以前包含键的映射，则旧值将被替换\n     * 参数 element - 传递给遍历赋值的元素\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func remove ( key : K ) : Option < V > {   let opt = segment ( key ) . remove ( key ) NL if ( let Some ( _ ) = opt ) {  decrSize ( ) NL } NL return opt NL }","func_name":"remove","docstring":"/*\n     * 如果指定元素存在于此 Keys ，则将其移除\n     * 参数 element - K\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  for ( key in keys ) {  remove ( key ) NL } NL }","func_name":"removeAll","docstring":"/*\n     * 移除此 Keys 中那些也包含在指定 Collection 中的所有元素\n     * 参数 element - 传入 Collection<K>\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  for ( segm in segments ) {  segm . removeIf { k , v =>  let check = predicate ( k , v ) NL if ( check ) {  decrSize ( ) NL } NL return check NL } NL } NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传递判断删除的条件\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func clear ( ) : Unit {  for ( segm in segments ) {  segm . clear ( ) NL } NL }","func_name":"clear","docstring":"/*\n     * 清除所有 Keys 中的元素\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func clone ( ) : Map < K , V > {  create ( this ) NL }","func_name":"clone","docstring":"/*\n     * 克隆 Map\n     * 返回值 Map<K, V> - 返回一个 Map<K, V>\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  get ( key ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  put ( key , value ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func keys ( ) : Keys < K > {  ConcurrentHashMapKeys < K , V > ( this ) NL }","func_name":"keys","docstring":"/*\n     * 返回 Map 中所有的 key，并将所有 key 存储在一个 Keys 容器中\n     * 返回值 Keys<K> - 保存所有返回的 key\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func values ( ) : Values < V > {  ConcurrentHashMapValues < K , V > ( this ) NL }","func_name":"values","docstring":"/*\n     * 返回 Map 中所有的 value，并将所有 value 存储在一个 Values 容器中\n     * 返回值 Values<V> - 保存所有返回的 value\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func isEmpty ( ) : Bool {  size == 0 NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Keys 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"ConcurrentHashMap.cj","path":"fountain/src/collection/ConcurrentHashMap.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {  return ConcurrentHashMapIterator < K , V > ( this ) NL }","func_name":"iterator","docstring":"/*\n     * 返回 Keys 的迭代器\n     * 返回值 Iterator<K> - Keys 的迭代器\n     */"}
{"repo":"fountain","file":"SortedMap.cj","path":"fountain/src/collection/SortedMap.cj","code_tokens":"func subMap ( low : K , high : K , lowInclusive ! : Bool , highInclusive ! : Bool ) : SortedMap < K , V >","func_name":"subMap","docstring":""}
{"repo":"fountain","file":"SortedMap.cj","path":"fountain/src/collection/SortedMap.cj","code_tokens":"func headMap ( end : K , inclusive ! : Bool ) : SortedMap < K , V >","func_name":"headMap","docstring":""}
{"repo":"fountain","file":"SortedMap.cj","path":"fountain/src/collection/SortedMap.cj","code_tokens":"func tailMap ( start : K , inclusive ! : Bool ) : SortedMap < K , V >","func_name":"tailMap","docstring":""}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"static public func createByArrayList ( ) : SyncList < T > {  SyncList < T > ( ArrayList < T > ( ) ) NL }","func_name":"createByArrayList","docstring":""}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func get ( index : Int64 ) : Option < T > {  return syncer . tryRead { list . get ( index ) NL } NL }","func_name":"get","docstring":"/*\n     * 返回此 List 中指定位置的元素\n     * 参数 index - index 表示 get 接口的索引\n     * 返回值 Option<T> - 返回指定位置的元素\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func set ( index : Int64 , element : T ) : Unit {  syncer . tryWrite { list . set ( index , element ) NL } NL }","func_name":"set","docstring":"/*\n     * 将此 List 中指定位置的元素替换为指定的元素\n     * 参数 index - 要设置的索引值\n     * 参数 element - 元素的 T 类型\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func append ( element : T ) : Unit {  syncer . tryWrite { list . append ( element ) NL } NL }","func_name":"append","docstring":"/*\n     * 将指定的元素附加到此 List 的末尾\n     * 参数 element - 插入元素，类型为 t\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func appendAll ( elements : Collection < T > ) : Unit {  syncer . tryWrite { list . appendAll ( elements ) NL } NL }","func_name":"appendAll","docstring":"/*\n     * 将指定集合中的所有元素附加到此 List 的末尾\n     * 按指定集合的迭代器返回的顺序排列\n     * 参数 elements - 导入集合类型的元素，并逐个插入\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func insert ( index : Int64 , element : T ) : Unit {  syncer . tryWrite { list . insert ( index , element ) NL } NL }","func_name":"insert","docstring":"/*\n     * 在此 List 中的指定位置插入指定元素\n     * 参数 index - 要插入的元素的索引\n     * 参数 element - 要插入的元素类型为 T\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func insertAll ( index : Int64 , elements : Collection < T > ) : Unit {  syncer . tryWrite { list . insertAll ( index , elements ) NL } NL }","func_name":"insertAll","docstring":"/*\n     * 从指定位置开始，将指定集合中的所有元素插入此 List\n     * 参数 index - 要插入的元素的索引\n     * 参数 element - 要插入的元素属于集合类型\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func prepend ( element : T ) : Unit {  syncer . tryWrite { list . prepend ( element ) NL } NL }","func_name":"prepend","docstring":"/*\n     * 在起始位置，将指定元素插入此 List\n     * 参数 element - 要插入的元素属于集合类型\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func prependAll ( elements : Collection < T > ) : Unit {  syncer . tryWrite { list . prependAll ( elements ) NL } NL }","func_name":"prependAll","docstring":"/*\n     * 从起始位置开始，将指定集合中的所有元素插入此 List\n     * 参数 element - 要插入的元素属于集合类型\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func remove ( index : Int64 ) : T {  syncer . tryWrite < T > { Some < T > ( list . remove ( index ) ) NL } . getOrThrow ( ) NL }","func_name":"remove","docstring":"/*\n     * 删除此 List 中指定位置的元素\n     * 参数 index - 删除元素的索引\n     * 返回值 T - 被移除的元素\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func remove ( range : Range < Int64 > ) : Unit {  syncer . tryWrite { list . remove ( range ) NL } NL }","func_name":"remove","docstring":"/*\n     * 删除此 List 中指定位置的元素\n     * 参数 index - 删除元素的索引\n     * 返回值 T - 被移除的元素\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  syncer . tryWrite { list . removeIf ( predicate ) NL } NL }","func_name":"removeIf","docstring":"/*\n     * 删除此 List 中满足给定 lambda 表达式或函数的所有元素\n     * 参数 predicate - 传递判断删除的条件\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func clear ( ) : Unit {  syncer . tryWrite { list . clear ( ) NL } NL }","func_name":"clear","docstring":"/* 从此 List 中删除所有元素 */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func reverse ( ) : Unit {  syncer . tryWrite { list . reverse ( ) NL } NL }","func_name":"reverse","docstring":"/* 反转此 List 中元素的顺序 */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func sortBy ( comparator : ( T , T ) -> Ordering , stable ! : Bool ) : Unit {  syncer . tryWrite { list . sortBy ( comparator , stable : stable ) NL } NL }","func_name":"sortBy","docstring":"/*\n     * 通过传入的比较函数，根据其返回值 Ordering 类型的结果，可对数组进行自定义排序\n     * 参数 comparator - (T, T) -> Ordering 类型，例:\n     * comparator: (t1: T, t2: T) -> Ordering，\n     * 如果 comparator 的返回值为 Ordering.GT，排序后 t1 在 t2\n     * 后；如果 comparator 的返回值为 Ordering.LT，排序后 t1 在\n     * t2 前；如果 comparator 的返回值为 Ordering.EQ，且为稳定排序\n     * 那么 t1 在 t2 之前； 如果 comparator 的返回值为 Ordering.EQ，\n     * 且为不稳定排序，那么 t1，t2 顺序不确定\n     * 参数 stable - 是否使用稳定排序\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func reserve ( additional : Int64 ) : Unit {  syncer . tryWrite { list . reserve ( additional ) NL } NL }","func_name":"reserve","docstring":"/*\n     * 为至少要插入到此 List 中的更多元素保留容量\n     * 参数 additional - 确保有足够的容量，additional 表示要添加的数量\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func capacity ( ) : Int64 {  syncer . tryRead < Int64 > ( 0 ) { list . capacity ( ) NL } NL }","func_name":"capacity","docstring":"/* 返回值 Int64 - List 的容量 */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func isEmpty ( ) : Bool {  syncer . tryRead < Bool > ( false ) { list . isEmpty ( ) NL } NL }","func_name":"isEmpty","docstring":"/*\n     * 判断 List 是否为空\n     * 返回值 Bool - 如果为空，则返回 true, 否则，返回 false\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func slice ( range : Range < Int64 > ) : ArrayList < T > {  syncer . tryRead < ArrayList < T > > { Some < ArrayList < T > > ( list . slice ( range ) ) NL } . getOrThrow ( ) NL }","func_name":"slice","docstring":"/*\n     * 传入参数 range 作为索引，返回索引对应的 List<T>\n     * 参数 range - 传递切片的范围\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func clone ( ) : ArrayList < T > {  syncer . tryRead < ArrayList < T > > { Some < ArrayList < T > > ( list . clone ( ) ) NL } . getOrThrow ( ) NL }","func_name":"clone","docstring":"/*\n     * 克隆新 List\n     * 返回值 List<T> - 返回新 List<T>\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public operator func [ ] ( index : Int64 ) : T {  this . get ( index ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public operator func [ ] ( index : Int64 , value ! : T ) : Unit {  this . set ( index , value ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public operator func [ ] ( range : Range < Int64 > ) : ArrayList < T > {  this . slice ( range ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func toArray ( ) : Array < T > {  syncer . tryRead < Array < T > > ( [ ] ) { list . toArray ( ) NL } NL }","func_name":"toArray","docstring":"/*\n     * 将对象转为数组类型\n     * 返回值 Array<T> - 转换后的数组\n     */"}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  return SyncIterator < T > ( list . iterator ( ) , syncer : syncer ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"SyncList.cj","path":"fountain/src/collection/SyncList.cj","code_tokens":"public func reverseIterator ( ) : ReverseIterator < T > {  return SyncReverseIterator < T > ( list . reverseIterator ( ) , syncer : syncer ) NL }","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func next ( ) : Option < T > {  queue . tryLock < Option < T > > ( timeout ) { itr . next ( ) NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"static public func create < T > ( capacity ! : Int64 = 0 , overSizePolicy ! : OverSizePolicy < PriorityQueue < T > > = DiscardOverSizePolicy < PriorityQueue < T > > ( ) ) where T <: Comparable < T > {  BlockingPriorityQueue < T > ( Comparator < T > . create < T > ( ) , capacity : capacity , overSizePolicy : overSizePolicy ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"static public func createReverse < T > ( capacity ! : Int64 = 0 , overSizePolicy ! : OverSizePolicy < PriorityQueue < T > > = DiscardOverSizePolicy < PriorityQueue < T > > ( ) ) where T <: Comparable < T > {  BlockingPriorityQueue < T > ( Comparator < T > . create < T > ( ) . reverse ( ) , capacity : capacity , overSizePolicy : overSizePolicy ) NL }","func_name":"createReverse","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"static public func create ( comparator : Comparator < T > , capacity ! : Int64 = 0 , overSizePolicy ! : OverSizePolicy < PriorityQueue < T > > = DiscardOverSizePolicy < PriorityQueue < T > > ( ) ) {  BlockingPriorityQueue < T > ( comparator , capacity : capacity , overSizePolicy : overSizePolicy ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"func tryLock < R > ( fn : ( ) -> R ) : R {  tryLock < R > ( INFINITE_TIMEOUT , fn ) NL }","func_name":"tryLock","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"func tryLock < R > ( timeout : UInt64 , fn : ( ) -> R ) : R {  lock . tryLock < R > ( timeout , fn ) NL }","func_name":"tryLock","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func put ( value : T , timeout ! : UInt64 ) : Unit {  tryLock < Unit > ( timeout ) { queue . offer ( value ) NL } NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func take ( timeout ! : UInt64 ) : Option < T > {  tryLock < Option < T > > ( timeout ) { queue . poll ( ) NL } NL }","func_name":"take","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func isEmpty ( ) : Bool {  size == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func offer ( data : T ) : Unit {  tryLock < Unit > { queue . offer ( data ) NL } NL }","func_name":"offer","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func offerAll ( data : Iterable < T > ) : Unit {  tryLock < Unit > { queue . offerAll ( data ) NL } NL }","func_name":"offerAll","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func poll ( ) : Option < T > {  tryLock < Option < T > > { queue . poll ( ) NL } NL }","func_name":"poll","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func peek ( ) : Option < T > {  tryLock < Option < T > > { queue . peek ( ) NL } NL }","func_name":"peek","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func toArray ( ) : Array < T > {  tryLock < Array < T > > {  let itr = iterator ( ) NL  let size = this . size NL Array < T > ( size ) { i => itr . next ( ) . getOrThrow ( ) NL } NL } NL }","func_name":"toArray","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  tryLock < Unit > { queue . removeIf ( predicate ) NL } NL }","func_name":"removeIf","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  iterator ( INFINITE_TIMEOUT ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"BlockingPriorityQueue.cj","path":"fountain/src/collection/BlockingPriorityQueue.cj","code_tokens":"public func iterator ( timeout : UInt64 ) : Iterator < T > {  BlockingPriorityQueueIterator < T > ( this , queue . iterator ( ) , timeout ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func toString ( ) : String {  toString ( value ) NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func toString ( v : UInt64 ) : String {  if ( v == nothing ) {  Nothing NL } else if ( v == head ) {  HeadWriting NL } else if ( v == tail ) {  TailWriting NL } else if ( v == writing ) {  HeadAndTailWriting NL } else if ( readingCheck ( v ) ) {  Reading(${v}) NL } else {  Error(${v}) NL } NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func readingCheck ( x : UInt64 ) : Bool {  ( ( x & reading ) != nothing ) && ( ( x & writing ) == nothing ) NL }","func_name":"readingCheck","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func writingCheck ( x : UInt64 ) : Bool {  writingCheck ( x , writing ) NL }","func_name":"writingCheck","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func readingAndWritingCheck ( x : UInt64 ) : Bool {  ( ( x & reading ) != nothing ) && ( ( x & writing ) != nothing ) NL }","func_name":"readingAndWritingCheck","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func writingCheck ( x : UInt64 , writingMask : UInt64 ) : Bool {  ( ( x & writingMask ) != nothing ) && ( ( x & reading ) == nothing ) NL }","func_name":"writingCheck","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func toDuration ( timeout : UInt64 ) : Duration {  return Duration . nanosecond ( Int64 ( timeout ) ) NL }","func_name":"toDuration","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func toChange ( timeout : UInt64 , fn : ( ) -> Bool ) {   let timeoutDuration = toDuration ( timeout ) NL  var changed = false NL  let start = Time . now ( ) NL do {  changed = fn ( ) NL } while ( ! changed && ( timeout == 0 || Time . since ( start ) < timeoutDuration ) ) NL if ( Time . since ( start ) > = timeoutDuration ) {  throw IllegalSynchronizationStateException ( ) NL } NL changed NL }","func_name":"toChange","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func toRead ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {  toChange ( timeout ) { match ( value ) { case x where x == nothing || readingCheck ( x ) => current . compareAndSwap ( x , x + oneReading ) NL case x where readingAndWritingCheck ( x ) => throw StatusException ( this . toString ( x ) ) NL case _ => false NL } NL } NL }","func_name":"toRead","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func finishedReading ( ) : Bool {  toChange ( INFINITE_TIMEOUT ) { match ( value ) { case x where readingCheck ( x ) => current . compareAndSwap ( x , x - oneReading ) NL case x => throw StatusException ( this . toString ( x ) ) NL } NL } NL }","func_name":"finishedReading","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func toWrite ( writing : UInt64 , timeout : UInt64 ) : Bool {  toChange ( timeout ) { match ( value ) { case x where readingCheck ( x ) => false NL case x where readingAndWritingCheck ( x ) => throw StatusException ( this . toString ( x ) ) NL case x where ( x & writing ) == nothing => current . compareAndSwap ( x , x | writing ) NL case _ => false NL } NL } NL }","func_name":"toWrite","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func finishedWriting ( writingMask : UInt64 ) : Bool {  toChange ( INFINITE_TIMEOUT ) { match ( value ) { case x where writingCheck ( x , writingMask ) => current . compareAndSwap ( x , x & ( writingMask ^ writing ) ) NL case x => throw StatusException ( this . toString ( x ) ) NL } NL } NL }","func_name":"finishedWriting","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func toWriteHead ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {  toWrite ( head , timeout ) NL }","func_name":"toWriteHead","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func finishedWritingHead ( ) : Bool {  finishedWriting ( head ) NL }","func_name":"finishedWritingHead","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func toWriteTail ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Bool {  toWrite ( tail , timeout ) NL }","func_name":"toWriteTail","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func finishedWritingTail ( ) : Bool {  finishedWriting ( tail ) NL }","func_name":"finishedWritingTail","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func read < T > ( timeout : UInt64 , thrownIfNotRead : Bool , fn : ( ) -> T ) : Option < T > {  if ( toRead ( timeout : timeout ) ) {  try {  return fn ( ) NL } finally {  finishedReading ( ) NL } NL } else if ( thrownIfNotRead ) {  throw IllegalSynchronizationStateException ( ) NL } else {  return None < T > NL } NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func read < T > ( timeout : UInt64 , fn : ( ) -> T ) : T {  read < T > ( timeout , true , fn ) . getOrThrow ( ) NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func read < T > ( timeout : UInt64 , default : T , fn : ( ) -> T ) : T {  read < T > ( timeout , false , fn ) ?? default NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func read < T > ( fn : ( ) -> T ) : T {  read < T > ( INFINITE_TIMEOUT , fn ) NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"private func checkTimeoutBeforeLocking ( timeout : UInt64 , start : Time ) : UInt64 {   let remainder = ( toDuration ( timeout ) - Time . since ( start ) ) . nanoseconds ( ) NL if ( timeout > 0 && remainder <= 0 ) {  throw IllegalSynchronizationStateException ( ) NL } NL if ( timeout > 0 ) {  UInt64 ( remainder ) NL } else {  0 NL } NL }","func_name":"checkTimeoutBeforeLocking","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeHead < T > ( timeout : UInt64 , thrownIfNotWrite : Bool , fn : ( ) -> T ) : Option < T > {   let start = Time . now ( ) NL if ( toWriteHead ( timeout : timeout ) ) {  try {   let remainder = checkTimeoutBeforeLocking ( timeout , start ) NL return headMutex . tryLock < T > ( remainder , fn ) NL } finally {  finishedWritingHead ( ) NL } NL } else if ( thrownIfNotWrite ) {  throw IllegalSynchronizationStateException ( ) NL } else {  None < T > NL } NL }","func_name":"writeHead","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeHead < T > ( timeout : UInt64 , fn : ( ) -> T ) : Option < T > {  writeHead < T > ( timeout , true , fn ) NL }","func_name":"writeHead","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeHead < T > ( timeout : UInt64 , default : T , fn : ( ) -> T ) : T {  writeHead < T > ( timeout , false , fn ) ?? default NL }","func_name":"writeHead","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeHead ( timeout : UInt64 , fn : ( ) -> Unit ) : Unit {  return writeHead < Unit > ( timeout , fn ) ?? ( ) NL }","func_name":"writeHead","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeHead < T > ( fn : ( ) -> T ) : Option < T > {  return writeHead < T > ( INFINITE_TIMEOUT , fn ) NL }","func_name":"writeHead","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeHead ( fn : ( ) -> Unit ) : Unit {  return writeHead < Unit > ( fn ) ?? ( ) NL }","func_name":"writeHead","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeTail < T > ( timeout : UInt64 , thrownIfNotWrite : Bool , fn : ( ) -> T ) : Option < T > {   let start = Time . now ( ) NL if ( toWriteTail ( timeout : timeout ) ) {  try {   let remainder = checkTimeoutBeforeLocking ( timeout , start ) NL return tailMutex . tryLock < T > ( remainder , fn ) NL } finally {  finishedWritingTail ( ) NL } NL } else if ( thrownIfNotWrite ) {  throw IllegalSynchronizationStateException ( ) NL } else {  None < T > NL } NL }","func_name":"writeTail","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeTail < T > ( timeout : UInt64 , fn : ( ) -> T ) : Option < T > {  writeTail < T > ( timeout , true , fn ) NL }","func_name":"writeTail","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeTail < T > ( timeout : UInt64 , default : T , fn : ( ) -> T ) : T {  writeTail < T > ( timeout , false , fn ) ?? default NL }","func_name":"writeTail","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeTail ( timeout : UInt64 , fn : ( ) -> Unit ) : Unit {  return writeTail < Unit > ( timeout , fn ) ?? ( ) NL }","func_name":"writeTail","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeTail < T > ( fn : ( ) -> T ) : Option < T > {  return writeTail < T > ( INFINITE_TIMEOUT , fn ) NL }","func_name":"writeTail","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func writeTail ( fn : ( ) -> Unit ) : Unit {  return writeTail < Unit > ( fn ) ?? ( ) NL }","func_name":"writeTail","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func next ( ) : Option < T > {  status . read < Option < T > > { itr . next ( ) NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func prev ( ) : Option < T > {  status . read < Option < T > > { itr . prev ( ) NL } NL }","func_name":"prev","docstring":""}
{"repo":"fountain","file":"SyncDequeStatus.cj","path":"fountain/src/collection/SyncDequeStatus.cj","code_tokens":"public func reverseIterator ( ) : ReverseIterator < T > {  this NL }","func_name":"reverseIterator","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func refresh ( ) : Unit {  synchronized ( lock ) {  conf . clear ( ) NL  var pathOpt = getConfPath ( confPath ) NL if ( let Some ( path ) = pathOpt ) {  conf . load ( path ) NL } NL getMonitorInterval ( ) NL } NL refresh { } NL }","func_name":"refresh","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func refresh ( fn : ( ) -> Unit ) : Unit {  if ( let Some ( interval ) = getMonitorInterval ( ) ) {  if ( interval <= 0 ) {  return NL } NL  func doTimer ( interval : Int64 , t : ( Duration , ( ) -> Unit ) -> Unit ) : Unit {  t ( Duration . second ( interval ) ) { refresh ( ) NL fn ( ) NL refresh ( fn ) NL } NL } NL match ( timer ) { case Some ( t ) => doTimer ( interval ) { d , f => t . reset ( d , f ) NL } NL case _ => doTimer ( interval ) { d , f => timer = Timer ( d , f ) NL } NL } NL } NL }","func_name":"refresh","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"func doTimer ( interval : Int64 , t : ( Duration , ( ) -> Unit ) -> Unit ) : Unit {  t ( Duration . second ( interval ) ) { refresh ( ) NL fn ( ) NL refresh ( fn ) NL } NL }","func_name":"doTimer","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getMonitorInterval ( ) : Option < Int64 > {  if ( let Some ( interval ) = getConfValue ( monitorInterval ) ) {  Int64 . parse ( interval ) NL } NL None < Int64 > NL }","func_name":"getMonitorInterval","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"private func getConfPath ( name : String ) : Option < String > {   var pathOpt = CmdArgs . instance . getArg ( -D + name ) NL if ( let None < String > = pathOpt ) {  pathOpt = getEnv ( dot . matcher ( name ) . replaceAll ( _ ) . toAsciiUpper ( ) ) NL } else {  pathOpt = ${getcwd()}/app.properties NL } NL return pathOpt NL }","func_name":"getConfPath","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"private func getConfValue ( name : String ) : Option < String > {   var val = CmdArgs . instance . getArg ( -D + name ) NL if ( let None < String > = val ) {  val = conf . get ( name ) NL } NL if ( let None < String > = val ) {  val = getEnv ( name ) NL } NL if ( let Some ( v ) = val ) {  conf . set ( name , v ) NL } NL return val NL }","func_name":"getConfValue","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getConf ( item : String ) : Option < String > {  getConfValue ( if ( confPrefix . isEmpty ( ) ) {  item NL } else {  ${confPrefix}.${item} NL } ) NL }","func_name":"getConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getConf < T > ( item : String , parser : ( String ) -> T ) : Option < T > {  match ( getConf ( item ) ) { case Some ( v ) => parser ( v ) NL case _ => None NL } NL }","func_name":"getConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getIntConf ( item : String ) : Option < Int64 > {  getConf < Int64 > ( item , Int64 . parse ) NL }","func_name":"getIntConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getFloatConf ( item : String ) : Option < Float64 > {  getConf < Float64 > ( item , Float64 . parse ) NL }","func_name":"getFloatConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getArrayConf < T > ( item : String , parser : ( String ) -> T , delimiter ! : String = , ) : Array < T > {  getConf < Array < T > > ( item ) { s =>  let array = s . split ( delimiter ) NL Array < T > ( array . size ) { i => parser ( array [ i ] ) NL } NL } ?? [ ] NL }","func_name":"getArrayConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getStringArrayConf ( item : String , delimiter ! : String = , ) : Array < String > {  getArrayConf < String > ( item , { s => s NL } , delimiter : delimiter ) NL }","func_name":"getStringArrayConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getIntArrayConf ( item : String , delimiter ! : String = , ) : Array < Int64 > {   let array = getStringArrayConf ( item , delimiter : delimiter ) NL Array < Int64 > ( array . size ) { i => Int64 . parse ( array [ i ] ) NL } NL }","func_name":"getIntArrayConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getFloatArrayConf ( item : String , delimiter ! : String = , ) : Array < Float64 > {   let array = getStringArrayConf ( item , delimiter : delimiter ) NL Array < Float64 > ( array . size ) { i => Float64 . parse ( array [ i ] ) NL } NL }","func_name":"getFloatArrayConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getConf ( item : String , default : String ) : String {  getConf ( item ) ?? default NL }","func_name":"getConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getConf ( item : String , default : ( ) -> String ) : String {  getConf ( item ) ?? default ( ) NL }","func_name":"getConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getConf < T > ( item : String , default : T , parser : ( String ) -> T ) : T {  getConf < T > ( item , parser ) ?? default NL }","func_name":"getConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getConf < T > ( item : String , default : ( ) -> T , parser : ( String ) -> T ) : T {  getConf < T > ( item , parser ) ?? default ( ) NL }","func_name":"getConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getIntConf ( item : String , default : Int64 ) : Int64 {  getIntConf ( item ) ?? default NL }","func_name":"getIntConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getIntConf ( item : String , default : ( ) -> Int64 ) : Int64 {  getIntConf ( item ) ?? default ( ) NL }","func_name":"getIntConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getFloatConf ( item : String , default : Float64 ) : Float64 {  getFloatConf ( item ) ?? default NL }","func_name":"getFloatConf","docstring":""}
{"repo":"fountain","file":"Config.cj","path":"fountain/src/config/Config.cj","code_tokens":"public func getFloatConf ( item : String , default : ( ) -> Float64 ) : Float64 {  getFloatConf ( item ) ?? default ( ) NL }","func_name":"getFloatConf","docstring":""}
{"repo":"fountain","file":"Emitter.cj","path":"fountain/src/timewheel/Emitter.cj","code_tokens":"func emit ( ) : Unit","func_name":"emit","docstring":""}
{"repo":"fountain","file":"TimeWheelTaskExecuting.cj","path":"fountain/src/timewheel/TimeWheelTaskExecuting.cj","code_tokens":"func executing ( name : String ) : Bool {  return executing ( name , Time . now ( ) ) NL }","func_name":"executing","docstring":""}
{"repo":"fountain","file":"TimeWheelTaskExecuting.cj","path":"fountain/src/timewheel/TimeWheelTaskExecuting.cj","code_tokens":"func executing ( name : String , now : Time ) : Bool","func_name":"executing","docstring":""}
{"repo":"fountain","file":"TimeWheelTaskExecuting.cj","path":"fountain/src/timewheel/TimeWheelTaskExecuting.cj","code_tokens":"func defaultImpl ( ) : Bool {  return true NL }","func_name":"defaultImpl","docstring":""}
{"repo":"fountain","file":"TimeWheelTaskExecuting.cj","path":"fountain/src/timewheel/TimeWheelTaskExecuting.cj","code_tokens":"func reset ( name : String ) : Unit","func_name":"reset","docstring":""}
{"repo":"fountain","file":"Currently.cj","path":"fountain/src/timewheel/Currently.cj","code_tokens":"func current ( now : Time ) : Int64","func_name":"current","docstring":""}
{"repo":"fountain","file":"HourlyTimeWheel.cj","path":"fountain/src/timewheel/HourlyTimeWheel.cj","code_tokens":"public func toString ( ) {  commons/timewheel.HourlyTimeWheel NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"DelayedCronTimeWheelTask.cj","path":"fountain/src/timewheel/DelayedCronTimeWheelTask.cj","code_tokens":"public func wrapExecutor ( remover : ( String ) -> Unit , repeater : ( DelayedCronTimeWheelTask ) -> Unit ) {   let fn = function NL if ( once ) {  function = { => remover ( name ) NL fn ( ) NL } NL } else {  function = match ( delayedPeriodic ) { case FixedRate => { => remover ( name ) NL repeater ( this ) NL fn ( ) NL } NL case FixedDelay => { => remover ( name ) NL fn ( ) NL repeater ( this ) NL } NL } NL } NL }","func_name":"wrapExecutor","docstring":""}
{"repo":"fountain","file":"Trigger.cj","path":"fountain/src/timewheel/Trigger.cj","code_tokens":"func emit ( task : TimeWheelTask , now : Time ) : Bool","func_name":"emit","docstring":"/**\n     * 触发任务\n     */"}
{"repo":"fountain","file":"Trigger.cj","path":"fountain/src/timewheel/Trigger.cj","code_tokens":"func shutdown ( ) : Unit","func_name":"shutdown","docstring":""}
{"repo":"fountain","file":"SecondlyTimeWheel.cj","path":"fountain/src/timewheel/SecondlyTimeWheel.cj","code_tokens":"public func toString ( ) {  commons/timewheel.SecondlyTimeWheel NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"LastMonthDayTask.cj","path":"fountain/src/timewheel/LastMonthDayTask.cj","code_tokens":"public override func reset ( stamp : Int64 ) {  task . reset ( stamp ) NL }","func_name":"reset","docstring":""}
{"repo":"fountain","file":"LastMonthDayTask.cj","path":"fountain/src/timewheel/LastMonthDayTask.cj","code_tokens":"public override func executing ( stamp : Int64 ) : Bool {  return task . executing ( stamp ) NL }","func_name":"executing","docstring":""}
{"repo":"fountain","file":"LastMonthDayTask.cj","path":"fountain/src/timewheel/LastMonthDayTask.cj","code_tokens":"public func execute ( ) {  task . execute ( ) NL }","func_name":"execute","docstring":""}
{"repo":"fountain","file":"FuncCronTimeWheelTask.cj","path":"fountain/src/timewheel/FuncCronTimeWheelTask.cj","code_tokens":"public func execute ( ) : Unit {  executor ( ) NL }","func_name":"execute","docstring":""}
{"repo":"fountain","file":"FuncCronTimeWheelTask.cj","path":"fountain/src/timewheel/FuncCronTimeWheelTask.cj","code_tokens":"public func executing ( stamp : Int64 ) : Bool {  return isExecuting ( stamp ) NL }","func_name":"executing","docstring":""}
{"repo":"fountain","file":"FuncCronTimeWheelTask.cj","path":"fountain/src/timewheel/FuncCronTimeWheelTask.cj","code_tokens":"public func reset ( stamp : Int64 ) : Unit {  toReset ( stamp ) NL }","func_name":"reset","docstring":""}
{"repo":"fountain","file":"TestCurrently_test.cj","path":"fountain/src/timewheel/TestCurrently_test.cj","code_tokens":"public func current ( now : Time ) {  return cur NL }","func_name":"current","docstring":""}
{"repo":"fountain","file":"MinutelyTimeWheel.cj","path":"fountain/src/timewheel/MinutelyTimeWheel.cj","code_tokens":"public func toString ( ) {  commons/timewheel.MinutelyTimeWheel NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"MonthlyTimeWheel.cj","path":"fountain/src/timewheel/MonthlyTimeWheel.cj","code_tokens":"public func toString ( ) {  commons/timewheel.MonthlyTimeWheel NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"TimeWheelTask.cj","path":"fountain/src/timewheel/TimeWheelTask.cj","code_tokens":"public func run ( ) : Unit {   let currentStamp = stamped . fetchAdd ( 1 ) + 1 NL  let notExecuting = ! executing ( currentStamp ) NL if ( notExecuting || ( concurrentable && ( ! this . once && notExecuting ) ) ) {  try {  execute ( ) NL } finally {  reset ( currentStamp ) NL } NL } NL }","func_name":"run","docstring":"/**\n     * 不需要覆盖本方法，任务逻辑都在void execute()方法实现，\n     * 控制逻辑都在boolean concurrentable() boolean executing(boolean) 和 boolean once()\n     */"}
{"repo":"fountain","file":"TimeWheelTask.cj","path":"fountain/src/timewheel/TimeWheelTask.cj","code_tokens":"public func hashCode ( ) : Int64 {  return name . hashCode ( ) NL }","func_name":"hashCode","docstring":""}
{"repo":"fountain","file":"TimeWheelTask.cj","path":"fountain/src/timewheel/TimeWheelTask.cj","code_tokens":"public operator func == ( task : TimeWheelTaskDef ) : Bool {  return this . name == task . name NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"TimeWheelTask.cj","path":"fountain/src/timewheel/TimeWheelTask.cj","code_tokens":"public operator func != ( task : TimeWheelTaskDef ) : Bool {  return this . name != task . name NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"TimeWheelTask.cj","path":"fountain/src/timewheel/TimeWheelTask.cj","code_tokens":"public operator func == ( name : String ) : Bool {  return this . name == name NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"TimeWheelTask.cj","path":"fountain/src/timewheel/TimeWheelTask.cj","code_tokens":"public operator func != ( name : String ) : Bool {  return this . name != name NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"TimeWheelTask.cj","path":"fountain/src/timewheel/TimeWheelTask.cj","code_tokens":"public open func executing ( stamp : Int64 ) : Bool {  return DefaultTimeWheelTaskExecuting . executing ( name , stamp ) NL }","func_name":"executing","docstring":"/**\n     * 当前任务是否正在执行\n     *\n     * @return\n     */"}
{"repo":"fountain","file":"TimeWheelTask.cj","path":"fountain/src/timewheel/TimeWheelTask.cj","code_tokens":"public open func reset ( stamp : Int64 ) : Unit {  DefaultTimeWheelTaskExecuting . reset ( name , stamp ) NL }","func_name":"reset","docstring":"/**\n     * 重置执行状态\n     */"}
{"repo":"fountain","file":"TimeWheelTaskTest_test.cj","path":"fountain/src/timewheel/TimeWheelTaskTest_test.cj","code_tokens":"public func execute ( ) : Unit {  println ( success ) NL }","func_name":"execute","docstring":""}
{"repo":"fountain","file":"CronCompiler.cj","path":"fountain/src/timewheel/CronCompiler.cj","code_tokens":"static public func compile ( cronExpr : String ) : Collection < CronDataCollection > {  if ( cronExpr . isEmpty ( ) ) {  throw IllegalArgumentException ( arg cronExpr must not be null or empty string!!! ) NL } NL  let exprs = cronExpr . split ( | ) NL  var datas = ArrayList < CronDataCollection > ( ) NL for ( expr in exprs ) {   let units = ArrayList < String > ( expr . split (   ) ) NL  var i = TimeWheelUnit . values . size - units . size NL while ( i > 0 ) {  units . append ( * ) NL i -- NL } NL  var cronc = CronDataCollection ( ) NL datas . append ( cronc ) NL i = 0 NL  let l = units . size NL while ( i < l ) {   var unit = units [ i ] NL  let wheelUnit = TimeWheelUnit . valueOf ( i ) NL unit = unit . replace ( */ , ${wheelUnit.min}/ ) NL if ( unit . equals ( * ) ) {   let range = wheelUnit . range NL cronc . put ( wheelUnit , range [ 0 ] , range [ 1 ] ) NL } else {  for ( value in unit . split ( , ) ) {  if ( let Some ( _ ) = ^(\\\\d{1,2}|\\\\*)?/(\\\\d{1,2}|\\\\*)?-(\\\\d{1,2}|\\\\*)?$ . regex ( solid : true ) . matches ( value ) ) {   var first = 0 NL  var last = value . indexOf ( / , first ) ?? - 1 NL  var start = parsePart ( value , first , last , wheelUnit . min ) NL if ( start == 0 && start < wheelUnit . min ) {  start = wheelUnit . min NL } NL first = last + 1 NL last = value . indexOf ( - , first ) ?? - 1 NL  var duration = parsePart ( value , first , last , 1 ) NL first = last + 1 NL last = value . size NL  var end = parsePart ( value , first , last , wheelUnit . max ) NL putCronc ( cronc , wheelUnit , start , end , duration ) NL } else if ( let Some ( _ ) = ^(\\\\d{1,2}|\\\\*)?/(\\\\d{1,2}|\\\\*)?$ . regex ( solid : true ) . matches ( value ) ) {   var first = 0 NL  var last = value . indexOf ( / , first ) ?? - 1 NL  var start = parsePart ( value , first , last , wheelUnit . min ) NL if ( start == 0 && start < wheelUnit . min ) {  start = wheelUnit . min NL } NL first = last + 1 NL last = value . size NL  var duration = parsePart ( value , first , last , 1 ) NL  var end = wheelUnit . max NL putCronc ( cronc , wheelUnit , start , end , duration ) NL } else if ( let Some ( _ ) = ^(\\\\d{1,2}|\\\\*)?-(\\\\d{1,2}|\\\\*)?$ . regex ( solid : true ) . matches ( value ) ) {   var first = 0 NL  var last = value . indexOf ( - , first ) ?? - 1 NL  var start = parsePart ( value , first , last , wheelUnit . min ) NL if ( start == 0 && start < wheelUnit . min ) {  start = wheelUnit . min NL } NL first = last + 1 NL last = value . size NL  var end = parsePart ( value , first , last , wheelUnit . max ) NL  var range = wheelUnit . convertRange ( start , end ) NL cronc . put ( wheelUnit , range [ 0 ] , range [ 1 ] ) NL if ( range . size == 3 ) {  cronc . put ( wheelUnit , range [ 2 ] ) NL } NL } else if ( value == L ) {  cronc . putLast ( wheelUnit ) NL } else if ( let Some ( _ ) = ^\\\\d{1,2}$ . regex ( solid : true ) . matches ( value ) ) {   var single = Int64 . parse ( value ) NL cronc . put ( wheelUnit , wheelUnit . convertSingle ( single ) ) NL } else {  throw IllegalArgumentException ( illegal cron expression part '${value}' for ${wheelUnit} ) NL } NL } NL } NL i ++ NL } NL } NL return datas NL }","func_name":"compile","docstring":"/* 所有的表达式单元都可以统一成a/b-c这种格式，\n       但是每种表达式都单独处理是为了给这些表达式单独的异常信息，\n       为了方便编写表达式的人\n     */"}
{"repo":"fountain","file":"CronCompiler.cj","path":"fountain/src/timewheel/CronCompiler.cj","code_tokens":"static private func parsePart ( value : String , first : Int64 , last : Int64 , defaultValue : Int64 ) : Int64 {  if ( last == first ) {  return defaultValue NL } else {   let part = value . substring ( first , last ) NL if ( part == * ) {  return defaultValue NL } else {  return Int64 . parse ( part ) NL } NL } NL }","func_name":"parsePart","docstring":""}
{"repo":"fountain","file":"CronCompiler.cj","path":"fountain/src/timewheel/CronCompiler.cj","code_tokens":"static private func putCronc ( cronc : CronDataCollection , wheelUnit : TimeWheelUnit , start : Int64 , end : Int64 , duration : Int64 ) : Unit {   var converted : Array < Int64 > = wheelUnit . convertDuration ( start , end , duration ) NL cronc . put ( wheelUnit , converted [ 0 ] , converted [ 1 ] , converted [ 2 ] ) NL if ( converted . size == 4 ) {  cronc . put ( wheelUnit , converted [ 3 ] ) NL } NL }","func_name":"putCronc","docstring":""}
{"repo":"fountain","file":"YearlyTimeWheel.cj","path":"fountain/src/timewheel/YearlyTimeWheel.cj","code_tokens":"override func addOrReplaceTask ( currently : Int64 , name : String , task : TimeWheelTask ) {  if ( min > currently || max < currently ) {  log . warn ( YearlyTimeWheel.addOrReplaceTask: currently value must not be earlier than current year  + or later than ${TimeWheelUnit.YEARLY.max} year, however it is ${currently}. ) NL return NL } NL super . addOrReplaceTask ( currently , name , task ) NL }","func_name":"addOrReplaceTask","docstring":""}
{"repo":"fountain","file":"YearlyTimeWheel.cj","path":"fountain/src/timewheel/YearlyTimeWheel.cj","code_tokens":"public func toString ( ) {  commons/timewheel.YearlyTimeWheel NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"WeekDailyTimeWheel.cj","path":"fountain/src/timewheel/WeekDailyTimeWheel.cj","code_tokens":"public func toString ( ) {  commons/timewheel.WeekDailyTimeWheel NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"FuncInvocationTask.cj","path":"fountain/src/timewheel/FuncInvocationTask.cj","code_tokens":"public func setName ( name : String ) {  this . name_ = name NL }","func_name":"setName","docstring":""}
{"repo":"fountain","file":"FuncInvocationTask.cj","path":"fountain/src/timewheel/FuncInvocationTask.cj","code_tokens":"public func setConcurrentable ( concurrentable : Bool ) {  this . concurrentable_ = concurrentable NL }","func_name":"setConcurrentable","docstring":""}
{"repo":"fountain","file":"FuncInvocationTask.cj","path":"fountain/src/timewheel/FuncInvocationTask.cj","code_tokens":"public func setOnce ( once : Bool ) {  this . once_ = once NL }","func_name":"setOnce","docstring":""}
{"repo":"fountain","file":"FuncInvocationTask.cj","path":"fountain/src/timewheel/FuncInvocationTask.cj","code_tokens":"public func setFunction ( function : ( ) -> Unit ) {  this . function = function NL }","func_name":"setFunction","docstring":""}
{"repo":"fountain","file":"FuncInvocationTask.cj","path":"fountain/src/timewheel/FuncInvocationTask.cj","code_tokens":"public func execute ( ) : Unit {  function ( ) NL }","func_name":"execute","docstring":""}
{"repo":"fountain","file":"MonthDailyTimeWheel.cj","path":"fountain/src/timewheel/MonthDailyTimeWheel.cj","code_tokens":"public override func emit ( task : TimeWheelTask , now : Time ) : Bool {   let lastDay = this . lastDay ( now ) NL  var emitted = false NL if ( lastDay || ! ( task is LastMonthDayTask ) ) {  emitted = super . emit ( task , now ) NL } else {  emitted = false NL } NL if ( LOGGER . debugEnabled ) {  LOGGER . debug ( TimeWheel:MonthDaily.emit::${task.name};${task is LastMonthDayTask};${lastDay};${emitted} ) NL } NL return emitted NL }","func_name":"emit","docstring":""}
{"repo":"fountain","file":"MonthDailyTimeWheel.cj","path":"fountain/src/timewheel/MonthDailyTimeWheel.cj","code_tokens":"protected open func lastDay ( now : Time ) : Bool {  return TimeWheelUnit . MONTH_DAILY . last ( now ) NL }","func_name":"lastDay","docstring":""}
{"repo":"fountain","file":"MonthDailyTimeWheel.cj","path":"fountain/src/timewheel/MonthDailyTimeWheel.cj","code_tokens":"public func toString ( ) {  commons/timewheel.MonthDailyTimeWheel NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"AlwaysLastMonthDayWheel_test.cj","path":"fountain/src/timewheel/AlwaysLastMonthDayWheel_test.cj","code_tokens":"public func lastDay ( now : Time ) {  true NL }","func_name":"lastDay","docstring":""}
{"repo":"fountain","file":"TimeWheelTaskExecutor.cj","path":"fountain/src/timewheel/TimeWheelTaskExecutor.cj","code_tokens":"public func emit ( task : TimeWheelTask , now : Time ) : Bool {  try {  task . run ( ) NL } catch ( e : Exception ) {  LOGGER . warn ( TimeWheelTaskExecutor.emit:${task.name} , e ) NL } NL return true NL }","func_name":"emit","docstring":""}
{"repo":"fountain","file":"TimeWheelTaskExecutor.cj","path":"fountain/src/timewheel/TimeWheelTaskExecutor.cj","code_tokens":"public func shutdown ( ) {  }","func_name":"shutdown","docstring":""}
{"repo":"fountain","file":"TimeWheelTaskExecutor.cj","path":"fountain/src/timewheel/TimeWheelTaskExecutor.cj","code_tokens":"public func toString ( ) : String {  commons/timewheel.TimeWheelTaskExecutor NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func create ( ) : TimeWheelLauncher {  return createWheels ( ) . launch ( ) NL }","func_name":"create","docstring":"/**\n     * 使用默认参数创建时间轮，并启动\n     * @return\n     */"}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"private func createWheels ( ) : TimeWheelLauncher {   var trigger = timewheel NL  var i = TimeWheelUnit . WEEK_DAILY . value NL while ( i > = 0 ) {   let unit = TimeWheelUnit . valueOf ( i ) NL trigger = putTimeWheel ( unit , trigger ) NL i -- NL } NL return this NL }","func_name":"createWheels","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"private func putTimeWheel ( unit : TimeWheelUnit , trigger : Trigger ) : TimeWheel {   let wheel = unit . create ( trigger ) NL timewheel = wheel NL wheels . put ( unit , wheel ) NL return wheel NL }","func_name":"putTimeWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createYearlyWheel ( ) : TimeWheelLauncher {  return createYearlyWheel ( TimeWheelUnit . YEARLY ) NL }","func_name":"createYearlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createYearlyWheel ( currently : Currently ) : TimeWheelLauncher {  return createYearlyWheel ( TimeWheelTaskExecutor ( ) , currently ) NL }","func_name":"createYearlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createYearlyWheel ( next : Trigger , currently : Currently ) : TimeWheelLauncher {  timewheel = YearlyTimeWheel ( next , currently ) NL wheels . put ( TimeWheelUnit . YEARLY , timewheel ) NL return this NL }","func_name":"createYearlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createWeekDailyWheel ( ) : TimeWheelLauncher {  return createWeekDailyWheel ( TimeWheelUnit . WEEK_DAILY ) NL }","func_name":"createWeekDailyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createWeekDailyWheel ( currently : Currently ) : TimeWheelLauncher {   let yearly = wheels . computeIfAbsent ( TimeWheelUnit . YEARLY ) { k => createYearlyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createWeekDailyWheel ( yearly , currently ) NL }","func_name":"createWeekDailyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createWeekDailyWheel ( next : Trigger , currently : Currently ) : TimeWheelLauncher {  timewheel = WeekDailyTimeWheel ( next , currently ) NL wheels . put ( TimeWheelUnit . WEEK_DAILY , timewheel ) NL return this NL }","func_name":"createWeekDailyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createMonthlyWheel ( ) : TimeWheelLauncher {  return createMonthlyWheel ( TimeWheelUnit . MONTHLY ) NL }","func_name":"createMonthlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createMonthlyWheel ( currently : Currently ) : TimeWheelLauncher {   let weekDaily = wheels . computeIfAbsent ( TimeWheelUnit . WEEK_DAILY ) { k => createWeekDailyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createMonthlyWheel ( weekDaily , currently ) NL }","func_name":"createMonthlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createMonthlyWheel ( next : Trigger , currently : Currently ) : TimeWheelLauncher {  timewheel = MonthlyTimeWheel ( next , currently ) NL wheels . put ( TimeWheelUnit . MONTHLY , timewheel ) NL return this NL }","func_name":"createMonthlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createMonthDailyWheel ( ) : TimeWheelLauncher {   let monthly = wheels . computeIfAbsent ( TimeWheelUnit . MONTHLY ) { k => createMonthlyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createMonthDailyWheel ( monthly , TimeWheelUnit . MONTH_DAILY ) NL }","func_name":"createMonthDailyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createMonthDailyWheel ( currently : Currently ) : TimeWheelLauncher {   let monthly = wheels . computeIfAbsent ( TimeWheelUnit . MONTHLY ) { k => createMonthlyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createMonthDailyWheel ( monthly , currently ) NL }","func_name":"createMonthDailyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createMonthDailyWheel ( next : Trigger , currently : Currently ) : TimeWheelLauncher {  timewheel = MonthDailyTimeWheel ( next , currently ) NL wheels . put ( TimeWheelUnit . MONTH_DAILY , timewheel ) NL return this NL }","func_name":"createMonthDailyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createHourlyWheel ( ) : TimeWheelLauncher {   let monthDaily = wheels . computeIfAbsent ( TimeWheelUnit . MONTH_DAILY ) { k => createMonthDailyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createHourlyWheel ( monthDaily , TimeWheelUnit . HOURLY ) NL }","func_name":"createHourlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createHourlyWheel ( currently : Currently ) : TimeWheelLauncher {   let weekDaily = wheels . computeIfAbsent ( TimeWheelUnit . MONTH_DAILY ) { k => createMonthDailyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createHourlyWheel ( weekDaily , currently ) NL }","func_name":"createHourlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createHourlyWheel ( next : Trigger , currently : Currently ) : TimeWheelLauncher {  timewheel = HourlyTimeWheel ( next , currently ) NL wheels . put ( TimeWheelUnit . HOURLY , timewheel ) NL return this NL }","func_name":"createHourlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createMinutelyWheel ( ) : TimeWheelLauncher {   let hourly = wheels . computeIfAbsent ( TimeWheelUnit . HOURLY ) { k => createHourlyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createMinutelyWheel ( hourly , TimeWheelUnit . MINUTELY ) NL }","func_name":"createMinutelyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createMinutelyWheel ( currently : Currently ) : TimeWheelLauncher {   let hourly = wheels . computeIfAbsent ( TimeWheelUnit . HOURLY ) { k => createHourlyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createMinutelyWheel ( hourly , currently ) NL }","func_name":"createMinutelyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createMinutelyWheel ( next : Trigger , currently : Currently ) : TimeWheelLauncher {  timewheel = MinutelyTimeWheel ( next , currently ) NL wheels . put ( TimeWheelUnit . MINUTELY , timewheel ) NL return this NL }","func_name":"createMinutelyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createSecondlyWheel ( ) : TimeWheelLauncher {   let minutely = wheels . computeIfAbsent ( TimeWheelUnit . MINUTELY ) { k => createMinutelyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createSecondlyWheel ( minutely , TimeWheelUnit . SECONDLY ) NL }","func_name":"createSecondlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createSecondlyWheel ( currently : Currently ) : TimeWheelLauncher {   let minutely = wheels . computeIfAbsent ( TimeWheelUnit . MINUTELY ) { k => createMinutelyWheel ( ) NL return timewheel NL } . getOrThrow ( ) NL return createSecondlyWheel ( minutely , currently ) NL }","func_name":"createSecondlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func createSecondlyWheel ( next : Trigger , currently : Currently ) : TimeWheelLauncher {  timewheel = SecondlyTimeWheel ( next , currently ) NL wheels . put ( TimeWheelUnit . SECONDLY , timewheel ) NL return this NL }","func_name":"createSecondlyWheel","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func removeTask ( task : TimeWheelTask ) {  removeTask ( task . name ) NL }","func_name":"removeTask","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func removeTask ( name : String ) {  tasks . remove ( name ) NL timewheel . removeTask ( name ) NL }","func_name":"removeTask","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func addOrReplaceDelayTask ( name : String , delayedPeriodic : DelayedPeriodic , delay : Duration , immediate : Bool , function : ( ) -> Unit ) {  addOrReplaceDelayTask ( DelayedCronTimeWheelTask ( name , delayedPeriodic , delay , immediate , function ) ) NL }","func_name":"addOrReplaceDelayTask","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func addOrReplaceDelayTask ( task : DelayedCronTimeWheelTaskDef ) {  addOrReplaceDelayTask ( DelayedCronTimeWheelTask ( task ) ) NL }","func_name":"addOrReplaceDelayTask","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func addOrReplaceDelayTask ( task : DelayedCronTimeWheelTask ) {  task . wrapExecutor ( removeTask , addOrReplaceDelayTask0 ) NL addOrReplaceDelayTask0 ( task ) NL }","func_name":"addOrReplaceDelayTask","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"private func addOrReplaceDelayTask0 ( task : DelayedCronTimeWheelTask ) : Unit {  if ( task . immediate ) {  spawn { task . execute ( ) NL } NL if ( task . once ) {  return NL } NL } NL addOrReplaceTask ( task , task . cron ) NL }","func_name":"addOrReplaceDelayTask0","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func addOrReplaceTask ( task : CronTimeWheelTask ) {  addOrReplaceTask ( task , task . cron ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 添加任务\n     * @param task\n     * @param cronExpr 关于表达式的解释请见{@code CronCompiler}\n     */"}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func addOrReplaceTask ( taskName ! : String , taskCron ! : String , execOnce ! : Bool = false , concurrenctly ! : Bool = false , executor ! : ( ) -> Unit , isExecuting ! : ( Int64 ) -> Bool = { stamp => DefaultTimeWheelTaskExecuting . executing ( taskName , stamp ) NL } , toReset ! : ( Int64 ) -> Unit = { stamp => DefaultTimeWheelTaskExecuting . reset ( taskName , stamp ) NL } ) {  addOrReplaceTask ( FuncCronTimeWheelTask ( taskName : taskName , taskCron : taskCron , execOnce : execOnce , concurrenctly : concurrenctly , executor : executor , isExecuting : isExecuting , toReset : toReset ) ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 添加任务\n     * @param task\n     * @param cronExpr 关于表达式的解释请见{@code CronCompiler}\n     */"}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func addOrReplaceTask ( task : TimeWheelTask , cronExpr : String ) {  timewheel . addOrReplaceTask ( task , CronCompiler . compile ( cronExpr ) ) NL tasks . put ( task . name , task ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 添加任务\n     * @param task\n     * @param cronExpr 关于表达式的解释请见{@code CronCompiler}\n     */"}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func launch ( ) : TimeWheelLauncher {  if ( launched ) {  throw IllegalStateException ( current instance of TimeWheelLauncher has been launched!!! ) NL } NL tiktok . tiktok ( this ) NL launched = true NL return this NL }","func_name":"launch","docstring":"/**\n     * 启动时间轮\n     */"}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func emit ( ) : Unit {  spawn {  let now = Time . now ( ) NL for ( ( name , task ) in tasks ) {  spawn {  var emitted = false NL try {  emitted = timewheel . emit ( task , now ) NL if ( emitted && task . once ) {  this . removeTask ( task . name ) NL } NL if ( LOGGER . debugEnabled ) {  LOGGER . debug ( TimeWheelLauncher.emit:${task.name}${task is LastMonthDayTask}${emitted}${task.once} ) NL } NL } catch ( e : Exception ) {  LOGGER . warn ( TimeWheelLauncher.emit:${task.name}${task is LastMonthDayTask}${emitted}${task.once} , e ) NL } NL } NL } NL } NL }","func_name":"emit","docstring":""}
{"repo":"fountain","file":"TimeWheelLauncher.cj","path":"fountain/src/timewheel/TimeWheelLauncher.cj","code_tokens":"public func shutdown ( ) {  tiktok . shutdown ( ) NL timewheel . shutdown ( ) NL }","func_name":"shutdown","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"static public func valueOf ( value : Int64 ) : TimeWheelUnit {  values [ value ] NL }","func_name":"valueOf","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func toString ( ) : String {  name NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func hashCode ( ) : Int64 {  name . hashCode ( ) NL }","func_name":"hashCode","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public operator func == ( unit : TimeWheelUnit ) {  this . name == unit . name NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public operator func != ( unit : TimeWheelUnit ) {  this . name != unit . name NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func create ( next : Trigger ) : TimeWheel","func_name":"create","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public open func convert ( task : TimeWheelTask , last : Bool ) : TimeWheelTask {  return task NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public open func last ( now : Time ) : Bool {  return current ( now ) == lastRange [ 1 ] NL }","func_name":"last","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public open func convertRange ( start : Int64 , end : Int64 ) : Array < Int64 > {   let begin = if ( oneStart && start == 0 ) {  1 NL } else {  start NL } NL  let range = this . range NL if ( end == 0 ) {  throw IllegalArgumentException ( ${begin}-${end}, end must be greater than zero ) NL } else if ( begin > range [ 1 ] ) {  throw IllegalArgumentException ( ${begin}-${end}, start must be less than or equals to the max value in range of ${name}, max value: ${range[1]} ) NL } else if ( end > range [ 1 ] ) {  throw IllegalArgumentException ( ${begin}-${end}, end must be less than or equals to the max value in range of ${name} , max value: ${range[1]} ) NL } else if ( begin > end ) {  throw IllegalArgumentException ( start must be less than end, start:${begin}, end:${end} ) NL } else if ( begin < range [ 0 ] ) {  throw IllegalArgumentException ( start must be greater than or equals to min value of ${name} range, between ${range[0]} and ${range[1]}, start: ${begin} ) NL } else if ( end < range [ 0 ] ) {  throw IllegalArgumentException ( end must be greater than or equals to min value of ${name} range, between ${range[0]} and ${range[1]}, end: ${end} ) NL } NL return [ begin , end ] NL }","func_name":"convertRange","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func convertRange ( exprPart : ArrayList < Int64 > ) : Array < Int64 > {   let size = exprPart . size NL if ( size > 2 || size < 1 ) {  throw IllegalArgumentException ( value count of cron expression part must be one or two two!!! current TimeWheelUnit is ${name} ) NL } NL  var first : Int64 NL  var second : Int64 NL if ( size == 2 ) {  first = exprPart [ 0 ] NL second = exprPart [ 1 ] NL if ( first > second ) {  throw IllegalArgumentException ( first value must be less than the second one, which in the same part of cron expression!!! current TimeWheelUnit is ${name} ) NL } NL } else {  second = exprPart [ 0 ] NL first = second NL } NL  var result = convertRange ( first , second ) NL  var range = this . range NL if ( range [ 0 ] <= result [ 0 ] && result [ 0 ] <= range [ 1 ] && range [ 0 ] <= result [ 1 ] && result [ 1 ] <= range [ 1 ] ) {  return result NL } NL throw IllegalArgumentException ( at least one of the two values in same part of cron expression overflow!!! current TimeWheelUnit is ${name}, min: ${range[0]}, max: ${range[1]} ) NL }","func_name":"convertRange","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public open func convertDuration ( start : Int64 , end : Int64 , duration : Int64 ) : Array < Int64 > {   let range = this . range NL if ( end == 0 ) {  throw IllegalArgumentException ( ${start}-${end}, end must be greater than zero ) NL } else if ( start > range [ 1 ] ) {  throw IllegalArgumentException ( ${start}/${duration}-${end}, start must be less than or equals to the toplimit in range of ${name}, toplimit: ${range[1]} ) NL } else if ( end > range [ 1 ] ) {  throw IllegalArgumentException ( ${start}/${duration}-${end}, end must be less than or equals to the toplimit in range of ${name}, toplimit: ${range[1]} ) NL } else if ( duration == 0 ) {  throw IllegalArgumentException ( duration must be great than zero, duration: ${duration} ) NL } else if ( start > end ) {  throw IllegalArgumentException ( start must be less than end, start:${start}, end:${end}, duration:${duration} ) NL } else if ( start < range [ 0 ] ) {  throw IllegalArgumentException ( start must be greater than or equals to min value of ${name} range, between ${range[0]} and ${range[1]}, start: ${start} ) NL } else if ( end < range [ 0 ] ) {  throw IllegalArgumentException ( end must be greater than or equals to min value of ${name} range, between ${range[0]} and ${range[1]}, end: ${end} ) NL } NL if ( oneStart && start == 0 ) {  return [ duration , end , duration ] NL } NL return [ start , end , duration ] NL }","func_name":"convertDuration","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public open func convertSingle ( value : Int64 ) {   let range = this . range NL if ( value > = range [ 0 ] && value <= range [ 1 ] ) {  return value NL } NL throw IllegalArgumentException ( value of ${name} must be between ${range[0]} and ${range[1]} ) NL }","func_name":"convertSingle","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func wheelSize ( ) {  return range [ 1 ] + 1 NL }","func_name":"wheelSize","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func create ( next : Trigger ) : SecondlyTimeWheel {  return SecondlyTimeWheel ( next ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func current ( now : Time ) : Int64 {  return now . second ( ) NL }","func_name":"current","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func create ( next : Trigger ) : MinutelyTimeWheel {  return MinutelyTimeWheel ( next ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func current ( now : Time ) : Int64 {  return now . minute ( ) NL }","func_name":"current","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func create ( next : Trigger ) : HourlyTimeWheel {  return HourlyTimeWheel ( next ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func current ( now : Time ) : Int64 {  return now . hour ( ) NL }","func_name":"current","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func create ( next : Trigger ) : MonthDailyTimeWheel {  return MonthDailyTimeWheel ( next ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func current ( now : Time ) : Int64 {  return now . day ( ) NL }","func_name":"current","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public override func convert ( task : TimeWheelTask , last : Bool ) : TimeWheelTask {  if ( last && ( ! ( task is LastMonthDayTask ) ) ) {  return LastMonthDayTask ( task ) NL } NL return task NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public override func last ( now : Time ) : Bool {  now . isLastMonthDay NL }","func_name":"last","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func create ( next : Trigger ) : MonthlyTimeWheel {  return MonthlyTimeWheel ( next ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func current ( now : Time ) : Int64 {  return now . month ( ) . value ( ) NL }","func_name":"current","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func create ( next : Trigger ) : WeekDailyTimeWheel {  return WeekDailyTimeWheel ( next ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func current ( now : Time ) : Int64 {  return now . weekDay ( ) . value ( ) NL }","func_name":"current","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public override func convertRange ( start : Int64 , end : Int64 ) : Array < Int64 > {  if ( start == 0 ) {  if ( end == 0 ) {  return [ 7 , 7 ] NL } else if ( end == 7 || end == 6 ) {  return [ 1 , 7 ] NL } else {  return [ 1 , end , 7 ] NL } NL } NL return super . convertRange ( start , end ) NL }","func_name":"convertRange","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public override func convertDuration ( start : Int64 , end : Int64 , duration : Int64 ) : Array < Int64 > {  if ( start == 0 ) {   let r = super . convertDuration ( duration , end , duration ) NL return [ r [ 0 ] , r [ 1 ] , r [ 2 ] , 7 ] NL } else {  return super . convertDuration ( start , end , duration ) NL } NL }","func_name":"convertDuration","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public override func convertSingle ( value : Int64 ) : Int64 {  if ( value == 0 ) {  return 7 NL } NL return super . convertSingle ( value ) NL }","func_name":"convertSingle","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func create ( next : Trigger ) : YearlyTimeWheel {  return YearlyTimeWheel ( next ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public override func convert ( task : TimeWheelTask , last : Bool ) : TimeWheelTask {  if ( last ) {  throw IllegalArgumentException ( L tag for YEARLY unit in cron expression is forbidden, task is named as ${task.name} ) NL } NL return task NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"TimeWheelUnit.cj","path":"fountain/src/timewheel/TimeWheelUnit.cj","code_tokens":"public func current ( now : Time ) : Int64 {  return now . year ( ) NL }","func_name":"current","docstring":""}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public func addOrReplaceTask ( task : TimeWheelTask , value : Int64 ) : Unit {  addOrReplaceTask ( task , value , true ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"private func addOrReplaceTask ( task : TimeWheelTask , value : Int64 , remove : Bool ) : Unit {  if ( LOGGER . debugEnabled ) {  LOGGER . debug ( TimeWheel.addOrReplaceTask:${unit}${task.name}${task is LastMonthDayTask}${value} ) NL } NL addOrReplaceTask ( task , value , value , remove ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public func addOrReplaceTask ( task : TimeWheelTask , min : Int64 , max : Int64 ) : Unit {  addOrReplaceTask ( task , min , max , true ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"private func addOrReplaceTask ( task : TimeWheelTask , min : Int64 , max : Int64 , remove : Bool ) : Unit {  if ( LOGGER . debugEnabled ) {  LOGGER . debug ( TimeWheel.addOrReplaceTask:${unit}${task.name}${task is LastMonthDayTask}${min}${max} ) NL } NL addOrReplaceTask ( task , min , max , 1 , remove ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public func addOrReplaceTask ( task : TimeWheelTask , min : Int64 , max : Int64 , duration : Int64 ) : Unit {  addOrReplaceTask ( task , min , max , duration , true ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"private func addOrReplaceTask ( task : TimeWheelTask , min : Int64 , max : Int64 , duration : Int64 , remove : Bool ) : Unit {  if ( duration <= 0 ) {  throw TimeWheelException ( duration must be greater than zero!!! duration: ${duration} ) NL } NL  let name = task . name NL if ( remove ) {  removeTask ( name ) NL } NL for ( i in min ..= max : duration ) {  if ( LOGGER . debugEnabled ) {  LOGGER . debug ( TimeWheel.addOrReplaceTask:${unit};${task.name};${task is LastMonthDayTask};${min};${max};${duration};${i} ) NL } NL addOrReplaceTask ( i , name , task ) NL } NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"open func addOrReplaceTask ( currently : Int64 , name : String , task : TimeWheelTask ) : Unit {  if ( currently > = min && currently <= max ) {  tasksInRing ( currently ) . put ( name , task ) NL } NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"private func tasksInRing ( currently : Int64 ) : Map < String , TimeWheelTask > {   let fn : ( Int64 ) -> Option < Map < String , TimeWheelTask > > = { k => ConcurrentHashMap < String , TimeWheelTask > . create ( ) NL } NL return ring . computeIfAbsent ( currently , fn ) . getOrThrow ( ) NL }","func_name":"tasksInRing","docstring":""}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public func addOrReplaceTask ( task : TimeWheelTask , cronDatas : Collection < CronDataCollection > ) : Unit {  removeTask ( task . name ) NL for ( cron in cronDatas ) {  addOrReplaceTask ( task , cron , false ) NL } NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public func addOrReplaceTask ( task : TimeWheelTask , cronData : CronDataCollection ) : Unit {  addOrReplaceTask ( task , cronData , true ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"private func addOrReplaceTask ( task : TimeWheelTask , cronData : CronDataCollection , remove : Bool ) : Unit {  if ( remove ) {  removeTask ( task . name ) NL } NL for ( cron in cronData . get ( unit ) ?? EmptyCollection < CronData > . instance ) {  addOrReplaceTask ( task , cron , false ) NL } NL ( next as TimeWheel ) ? . addOrReplaceTask ( task , cronData , false ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public func addOrReplaceTask ( task : TimeWheelTask , cronData : CronData ) : Unit {  addOrReplaceTask ( task , cronData , true ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"private func addOrReplaceTask ( task : TimeWheelTask , cronData : CronData , remove : Bool ) : Unit {  addOrReplaceTask ( cronData . convert ( task ) , cronData . start , cronData . end , cronData . duration , remove ) NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public func addOrReplaceTask ( task : TimeWheelTask , values : Array < Int64 > ) : Unit {  for ( v in values ) {  addOrReplaceTask ( task , v ) NL } NL }","func_name":"addOrReplaceTask","docstring":"/**\n     * 向当前时间轮值等于value的节点添加任务\n     * @param task\n     * @param value\n     */"}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"private func getTasks ( currently : Int64 ) : Map < String , TimeWheelTask > {  return ring . getOrDefault ( currently , EmptyMap < String , TimeWheelTask > . instance ) NL }","func_name":"getTasks","docstring":""}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public func removeTask ( name : String ) : Unit {  for ( i in min ..= max ) {  getTasks ( i ) . remove ( name ) NL } NL ( next as TimeWheel ) ? . removeTask ( name ) NL }","func_name":"removeTask","docstring":""}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public open func emit ( task : TimeWheelTask , now : Time ) : Bool {   let taskOpt = getTasks ( currently . current ( now ) ) . get ( task . name ) NL  var emitted : Bool NL if ( let Some ( t ) = taskOpt ) {  emitted = next . emit ( task , now ) NL } else {  emitted = false NL } NL if ( LOGGER . debugEnabled ) {  if ( let Some ( _ ) = taskOpt ) {  LOGGER . debug ( TimeWheel.emit:${unit};${task.name};${task is LastMonthDayTask};${emitted} ) NL } else {  LOGGER . debug ( TimeWheel.emit:${unit};${emitted} ) NL } NL } NL return emitted NL }","func_name":"emit","docstring":""}
{"repo":"fountain","file":"TimeWheel.cj","path":"fountain/src/timewheel/TimeWheel.cj","code_tokens":"public func shutdown ( ) : Unit {  next . shutdown ( ) NL }","func_name":"shutdown","docstring":""}
{"repo":"fountain","file":"DefaultTimeWheelTaskExecution.cj","path":"fountain/src/timewheel/DefaultTimeWheelTaskExecution.cj","code_tokens":"static func executing ( name : String , stamp : Int64 ) : Bool {  if ( let Some ( _ ) = executingMap . putIfNonExistent ( name , stamp ) ) {  return true NL } NL return false NL }","func_name":"executing","docstring":""}
{"repo":"fountain","file":"DefaultTimeWheelTaskExecution.cj","path":"fountain/src/timewheel/DefaultTimeWheelTaskExecution.cj","code_tokens":"static func reset ( name : String , stamp : Int64 ) : Unit {  executingMap . remove ( name , stamp ) NL }","func_name":"reset","docstring":""}
{"repo":"fountain","file":"CronData.cj","path":"fountain/src/timewheel/CronData.cj","code_tokens":"public func toString ( ) : String {  unit: ${unit_}, start: ${start_}, end: ${end_}, duration: ${duration_}, last: ${last_} NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"CronData.cj","path":"fountain/src/timewheel/CronData.cj","code_tokens":"public func convert ( task : TimeWheelTask ) : TimeWheelTask {  return unit_ . convert ( task , last ) NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"TimeWheelTaskDef.cj","path":"fountain/src/timewheel/TimeWheelTaskDef.cj","code_tokens":"func executing ( stamp : Int64 ) : Bool {  return DefaultTimeWheelTaskExecuting . executing ( name , stamp ) NL }","func_name":"executing","docstring":"/**\n     * 当前任务是否正在执行\n     *\n     * @return\n     */"}
{"repo":"fountain","file":"TimeWheelTaskDef.cj","path":"fountain/src/timewheel/TimeWheelTaskDef.cj","code_tokens":"func reset ( stamp : Int64 ) : Unit {  DefaultTimeWheelTaskExecuting . reset ( name , stamp ) NL }","func_name":"reset","docstring":"/**\n     * 重置执行状态\n     */"}
{"repo":"fountain","file":"TimeWheelTaskDef.cj","path":"fountain/src/timewheel/TimeWheelTaskDef.cj","code_tokens":"func execute ( ) : Unit","func_name":"execute","docstring":"/**\n     * 定时任务逻辑\n     */"}
{"repo":"fountain","file":"TimeWheelTaskDef.cj","path":"fountain/src/timewheel/TimeWheelTaskDef.cj","code_tokens":"func toString ( ) : String {  return this . name NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"CronDataCollection.cj","path":"fountain/src/timewheel/CronDataCollection.cj","code_tokens":"public func put ( unit : TimeWheelUnit , data : CronData ) : Unit {  datas . computeIfAbsent ( unit ) { u => ArrayList < CronData > ( ) NL } ? . append ( data ) NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"CronDataCollection.cj","path":"fountain/src/timewheel/CronDataCollection.cj","code_tokens":"public func put ( unit : TimeWheelUnit , start : Int64 , end : Int64 , duration : Int64 ) : Unit {  put ( unit , CronData ( unit , start , end , duration ) ) NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"CronDataCollection.cj","path":"fountain/src/timewheel/CronDataCollection.cj","code_tokens":"public func put ( unit : TimeWheelUnit , start : Int64 , end : Int64 ) {  put ( unit , CronData ( unit , start , end ) ) NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"CronDataCollection.cj","path":"fountain/src/timewheel/CronDataCollection.cj","code_tokens":"public func put ( unit : TimeWheelUnit , value : Int64 ) {  put ( unit , CronData ( unit , value ) ) NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"CronDataCollection.cj","path":"fountain/src/timewheel/CronDataCollection.cj","code_tokens":"public func putLast ( unit : TimeWheelUnit ) {   var value : Array < Int64 > = unit . lastRange NL put ( unit , CronData ( unit , value [ 0 ] , value [ 1 ] , true ) ) NL }","func_name":"putLast","docstring":""}
{"repo":"fountain","file":"CronDataCollection.cj","path":"fountain/src/timewheel/CronDataCollection.cj","code_tokens":"public func get ( unit : TimeWheelUnit ) : Option < Collection < CronData > > {  if ( let Some ( list ) = datas . get ( unit ) ) {  list as Collection < CronData > NL } else {  None < Collection < CronData > > NL } NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"Tiktok.cj","path":"fountain/src/timewheel/Tiktok.cj","code_tokens":"func tiktok ( emitter : Emitter ) {  ticker . reset ( oneSecond , emitter . emit ) NL }","func_name":"tiktok","docstring":""}
{"repo":"fountain","file":"Tiktok.cj","path":"fountain/src/timewheel/Tiktok.cj","code_tokens":"func shutdown ( ) {  ticker . stop ( ) NL }","func_name":"shutdown","docstring":""}
{"repo":"fountain","file":"DelayedCronTimeWheelTaskDef.cj","path":"fountain/src/timewheel/DelayedCronTimeWheelTaskDef.cj","code_tokens":"func execute ( ) : Unit","func_name":"execute","docstring":""}
{"repo":"fountain","file":"DelayedTask.cj","path":"fountain/src/timewheel/annotation/DelayedTask.cj","code_tokens":"func generateDelayedTaskTokens ( attr : Tokens , decl : FuncDecl , input : Tokens ) : Tokens {   let funcName = decl . getIdentifier ( ) NL  var name = `empty_string` [ 0 ] NL  var delayedPeriodic = Token ( IDENTIFIER , FixedDelay ) NL  var immediate = `false` [ 0 ] NL  var delay = `empty_tokens` NL  var i = 0 NL while ( i < attr . size ) {   let token = attr [ i ] NL i += 2 NL match ( token . value ) { case name => name = attr [ i ] NL case delayedPeriodic => name = attr [ i ] NL case immediate => immediate = attr [ i ] NL case delay => delay = attr [ i ] + attr [ i + 1 ] NL i += 1 NL case _ => throw TimeWheelException ( illegal token (kind: ${token.kind}, value: ${token.value}) in attr ${attr}, only four attrs are supported: cron name once concurrenctly ) NL } NL i ++ NL } NL if ( name . kind . toString ( ) != STRING_LITERAL . toString ( ) ) {  throw TimeWheelException ( delayed task name must be a string literal ) NL } NL if ( delayedPeriodic . kind . toString ( ) != IDENTIFIER . toString ( ) || delayedPeriodic . value != FixedRate || delayedPeriodic . value != FixedDelay ) {  throw TimeWheelException ( delayedPeriodic must be FixedDelay or FixedRate ) NL } NL if ( immediate . kind . toString ( ) != BOOL_LITERAL . toString ( ) ) {  throw TimeWheelException ( value of immediate attr must be a bool literal ) NL } NL if ( ( delay [ 0 ] . kind . toString ( ) != INTEGER_LITERAL . toString ( ) || delay [ 1 ] . kind . toString ( ) != IDENTIFIER . toString ( ) || delay [ 1 ] . value != nanosecond || delay [ 1 ] . value != microsecond || delay [ 1 ] . value != second || delay [ 1 ] . value != minute || delay [ 1 ] . value != hour ) ) {  throw TimeWheelException ( value of delay attr must be a INTEGER_LITERAL with one of identifier as nanosecond microsecond second minute hour ) NL } NL  let isStatic = macro_fragments . isStatic ( decl ) NL delayedTaskHolder ++ NL  let holder = Token ( IDENTIFIER , dElAy_EdTAsk_hOldEr__${delayedTaskHolder}___ ) NL input + `nl` + if ( isStatic ) {  `static` NL } else {  `empty_tokens` NL } + quote ( \\n let $holder = { => \\n timewheel . global . wheel . addOrReplaceDelayTask ( $name , $delayedPeriodic , Duration . $ ( delay [ 1 ] ) ( $ ( delay [ 0 ] ) ) , $immediate , $funcName ) \\n } ( ) \\n ) NL }","func_name":"generateDelayedTaskTokens","docstring":""}
{"repo":"fountain","file":"DelayedTask.cj","path":"fountain/src/timewheel/annotation/DelayedTask.cj","code_tokens":"func generateDelayedTaskTokens ( attr : Tokens , decl : ClassDecl , input : Tokens ) : Tokens {   let name = decl . getIdentifier ( ) NL input + `nl` + quote ( \\n let _ = { => \\n let task = $name ( ) \\n match ( task ) { \\n case x : timewheel . DelayedCronTimeWheelTaskDef => timewheel . global . wheel . addOrReplaceDelayTask ( x ) \\n case _ => throw TimeWheelException ( input must implement timewheel.DelayedCronTimeWheelTaskDef ) \\n } \\n } ( ) \\n ) NL }","func_name":"generateDelayedTaskTokens","docstring":""}
{"repo":"fountain","file":"CronTask.cj","path":"fountain/src/timewheel/annotation/CronTask.cj","code_tokens":"func generateCronTaskTokens ( attr : Tokens , decl : FuncDecl , input : Tokens ) : Tokens {   let funcName = decl . getIdentifier ( ) NL  var cron = `empty_string` [ 0 ] NL  var name = `empty_string` [ 0 ] NL  var once = `false` [ 0 ] NL  var concurrently = `false` [ 0 ] NL  var i = 0 NL while ( i < attr . size ) {   let token = attr [ i ] NL i += 2 NL match ( token . value ) { case cron => cron = attr [ i ] NL case name => name = attr [ i ] NL case once => once = attr [ i ] NL case concurrenctly => concurrently = attr [ i ] NL case _ => throw TimeWheelException ( illegal token (kind: ${token.kind}, value: ${token.value}) in attr ${attr}, only four attrs are supported: cron name once concurrenctly ) NL } NL i ++ NL } NL if ( cron . kind . toString ( ) != STRING_LITERAL . toString ( ) ) {  throw TimeWheelException ( cron expression must be a string literal ) NL } NL if ( name . kind . toString ( ) != IDENTIFIER . toString ( ) || ! #\"^[a-zA-Z]\\w*$\"# . regex ( ) . matched ( name . value ) ) {  throw TimeWheelException ( task name must be an identifier and must be an identifier ) NL } NL if ( once . kind . toString ( ) != BOOL_LITERAL . toString ( ) ) {  throw TimeWheelException ( value of once attr must be a bool literal ) NL } NL if ( concurrently . kind . toString ( ) != BOOL_LITERAL . toString ( ) ) {  throw TimeWheelException ( value of concurrenctly attr must be a bool literal ) NL } NL  let isStatic = macro_fragments . isStatic ( decl ) NL cronTaskHolder ++ NL  let holder = Token ( IDENTIFIER , crOn_tAsk_hOldEr__${cronTaskHolder}___ ) NL input + `nl` + if ( isStatic ) {  `static` NL } else {  `empty_tokens` NL } + quote ( \\n let $holder = { => \\n timewheel . global . wheel . addOrReplaceTask ( \\n taskName : $name , \\n execOnce : $once , \\n concurrently : $concurrently , \\n executor : { => \\n $funcName ( ) \\n ( ) \\n } \\n ) \\n } ( ) \\n ) NL }","func_name":"generateCronTaskTokens","docstring":""}
{"repo":"fountain","file":"CronTask.cj","path":"fountain/src/timewheel/annotation/CronTask.cj","code_tokens":"func generateCronTaskTokens ( attr : Tokens , decl : ClassDecl , input : Tokens ) : Tokens {   let cron = Token ( STRING_LITERAL , attr . toString ( ) ) NL  let name = decl . getIdentifier ( ) NL input + `nl` + quote ( \\n let _ = { => \\n let task = $name ( ) \\n match ( task ) { \\n case x : timewheel . CronTimeWheelTask => timewheel . global . wheel . addOrReplaceTask ( task ) \\n case x : timewheel . TimeWheelTask => timewheel . global . wheel . addOrReplaceTask ( task , $ ( cron ) ) \\n case _ => throw TimeWheelException ( input must extend timewheel.CronTimeWheelTask or timewheel.TimeWheelTask ) \\n } \\n } ( ) \\n ) NL }","func_name":"generateCronTaskTokens","docstring":""}
{"repo":"fountain","file":"JsonToOutputStream.cj","path":"fountain/src/json/JsonToOutputStream.cj","code_tokens":"func toOutputStream ( output : OutputStream ) : Unit","func_name":"toOutputStream","docstring":""}
{"repo":"fountain","file":"JsonToOutputStream.cj","path":"fountain/src/json/JsonToOutputStream.cj","code_tokens":"public func toOutputStream ( output : OutputStream ) : Unit {  output . write ( toString ( ) . toUtf8Array ( ) ) NL }","func_name":"toOutputStream","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func put ( name : String , value : Any ) : Unit","func_name":"put","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getInt ( name : String ) : Option < Int64 >","func_name":"getInt","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getFloat ( name : String ) : Option < Float64 >","func_name":"getFloat","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getBool ( name : String ) : Option < Bool >","func_name":"getBool","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getNull ( name : String ) : Option < Unit >","func_name":"getNull","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getString ( name : String ) : Option < String >","func_name":"getString","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func add ( value : Any ) : Unit","func_name":"add","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getInt ( index : Int64 ) : Option < Int64 >","func_name":"getInt","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getFloat ( index : Int64 ) : Option < Float64 >","func_name":"getFloat","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getBool ( index : Int64 ) : Option < Bool >","func_name":"getBool","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getNull ( index : Int64 ) : Option < Unit >","func_name":"getNull","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"func getString ( index : Int64 ) : Option < String >","func_name":"getString","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func put ( name : String , value : Any ) : Unit {  match ( value ) { case x : Float64 => this . put ( name , JsonFloat ( ( x as Float64 ) . getOrThrow ( ) ) ) NL case x : Float32 => this . put ( name , JsonFloat ( Float64 ( x ) ) ) NL case x : Float16 => this . put ( name , JsonFloat ( Float64 ( x ) ) ) NL case x : Int64 => this . put ( name , JsonInt ( Int64 ( x ) ) ) NL case x : UInt64 => this . put ( name , JsonInt ( Int64 ( x ) ) ) NL case x : Int32 => this . put ( name , JsonInt ( Int64 ( x ) ) ) NL case x : UInt32 => this . put ( name , JsonInt ( Int64 ( x ) ) ) NL case x : Int16 => this . put ( name , JsonInt ( Int64 ( x ) ) ) NL case x : UInt16 => this . put ( name , JsonInt ( Int64 ( x ) ) ) NL case x : Int8 => this . put ( name , JsonInt ( Int64 ( x ) ) ) NL case x : UInt8 => this . put ( name , JsonInt ( Int64 ( x ) ) ) NL case x : Map < String , Any > => for ( e in x ) {   let obj = JsonObject ( ) NL  let key = e [ 0 ] NL  let val = e [ 1 ] NL obj . put ( key , val ) NL this . put ( name , obj ) NL } NL case x : Iterable < Any > => for ( e in x ) {   let arr = JsonArray ( ) NL arr . add ( e ) NL this . put ( name , arr ) NL } NL case x : JsonValue => this . put ( name , x ) NL case x : ToJson => this . put ( name , x . toJson ( ) ) NL case _ => throw IllegalArgumentException ( ) NL } NL }","func_name":"put","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getInt ( name : String ) : Option < Int64 > {  match ( this . get ( name ) ) { case Some ( v ) where v is JsonInt => ( v as JsonInt ) . getOrThrow ( ) . getValue ( ) NL case _ => None NL } NL }","func_name":"getInt","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getFloat ( name : String ) : Option < Float64 > {  match ( this . get ( name ) ) { case Some ( v ) where v is JsonFloat => ( v as JsonFloat ) . getOrThrow ( ) . getValue ( ) NL case _ => None NL } NL }","func_name":"getFloat","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getBool ( name : String ) : Option < Bool > {  match ( this . get ( name ) ) { case Some ( v ) where v is JsonBool => ( v as JsonBool ) . getOrThrow ( ) . getValue ( ) NL case _ => None NL } NL }","func_name":"getBool","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getNull ( name : String ) : Option < Unit > {  match ( this . get ( name ) ) { case Some ( v ) where v is JsonNull => ( ) NL case _ => None NL } NL }","func_name":"getNull","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getString ( name : String ) : Option < String > {  match ( this . get ( name ) ) { case Some ( v ) where v is JsonString => ( v as JsonString ) . getOrThrow ( ) . getValue ( ) NL case _ => None NL } NL }","func_name":"getString","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func add ( value : Any ) : Unit {  match ( value ) { case x : Float64 => this . add ( JsonFloat ( ( x as Float64 ) . getOrThrow ( ) ) ) NL case x : Float32 => this . add ( JsonFloat ( Float64 ( x ) ) ) NL case x : Float16 => this . add ( JsonFloat ( Float64 ( x ) ) ) NL case x : Int64 => this . add ( JsonInt ( Int64 ( x ) ) ) NL case x : UInt64 => this . add ( JsonInt ( Int64 ( x ) ) ) NL case x : Int32 => this . add ( JsonInt ( Int64 ( x ) ) ) NL case x : UInt32 => this . add ( JsonInt ( Int64 ( x ) ) ) NL case x : Int16 => this . add ( JsonInt ( Int64 ( x ) ) ) NL case x : UInt16 => this . add ( JsonInt ( Int64 ( x ) ) ) NL case x : Int8 => this . add ( JsonInt ( Int64 ( x ) ) ) NL case x : UInt8 => this . add ( JsonInt ( Int64 ( x ) ) ) NL case x : Map < String , Any > => for ( e in x ) {   let obj = JsonObject ( ) NL  let key = e [ 0 ] NL  let val = e [ 1 ] NL obj . put ( key , val ) NL this . add ( obj ) NL } NL case x : Iterable < Any > => for ( e in x ) {   let arr = JsonArray ( ) NL arr . add ( e ) NL this . add ( arr ) NL } NL case x : JsonValue => this . add ( x ) NL case x : ToJson => this . add ( x . toJson ( ) ) NL case _ => throw IllegalArgumentException ( ) NL } NL }","func_name":"add","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getInt ( index : Int64 ) : Option < Int64 > {  match ( this . get ( index ) ) { case Some ( v ) where v is JsonInt => ( v as JsonInt ) . getOrThrow ( ) . getValue ( ) NL case _ => None NL } NL }","func_name":"getInt","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getFloat ( index : Int64 ) : Option < Float64 > {  match ( this . get ( index ) ) { case Some ( v ) where v is JsonFloat => ( v as JsonFloat ) . getOrThrow ( ) . getValue ( ) NL case _ => None NL } NL }","func_name":"getFloat","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getBool ( index : Int64 ) : Option < Bool > {  match ( this . get ( index ) ) { case Some ( v ) where v is JsonBool => ( v as JsonBool ) . getOrThrow ( ) . getValue ( ) NL case _ => None NL } NL }","func_name":"getBool","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getNull ( index : Int64 ) : Option < Unit > {  match ( this . get ( index ) ) { case Some ( v ) where v is JsonNull => ( ) NL case _ => None NL } NL }","func_name":"getNull","docstring":""}
{"repo":"fountain","file":"ExtendJson.cj","path":"fountain/src/json/ExtendJson.cj","code_tokens":"public func getString ( index : Int64 ) : Option < String > {  match ( this . get ( index ) ) { case Some ( v ) where v is JsonString => ( v as JsonString ) . getOrThrow ( ) . getValue ( ) NL case _ => None NL } NL }","func_name":"getString","docstring":""}
{"repo":"fountain","file":"JsonFromInputStream.cj","path":"fountain/src/json/JsonFromInputStream.cj","code_tokens":"static func fromInputStream ( input : InputStream ) : JsonValue","func_name":"fromInputStream","docstring":""}
{"repo":"fountain","file":"JsonFromInputStream.cj","path":"fountain/src/json/JsonFromInputStream.cj","code_tokens":"static public func fromInputStream ( input : InputStream ) : JsonValue {   let builder = StringBuilder ( ) NL  let buf = Array < Byte > ( 128 , item : 0 ) NL  var len = 0 NL do {  len = input . read ( buf ) NL builder . appendFromUtf8 ( buf . slice ( 0 , len ) ) NL } while ( len > 0 ) NL fromStr ( builder . toString ( ) ) NL }","func_name":"fromInputStream","docstring":""}
{"repo":"fountain","file":"EqualsIgnoreCase.cj","path":"fountain/src/base/EqualsIgnoreCase.cj","code_tokens":"func equalsIgnoreCase ( other : String ) : Bool","func_name":"equalsIgnoreCase","docstring":""}
{"repo":"fountain","file":"EqualsIgnoreCase.cj","path":"fountain/src/base/EqualsIgnoreCase.cj","code_tokens":"public func equalsIgnoreCase ( other : String ) : Bool {   let curSize = this . size NL  let othSize = other . size NL if ( curSize != othSize ) {  return false NL } NL  var i = 0 NL while ( i < curSize ) {   let cur = this . charAt ( i ) NL  let oth = other . charAt ( i ) NL if ( cur != oth && cur . toAsciiLowerCase ( ) != oth . toAsciiLowerCase ( ) ) {  return false NL } NL i ++ NL } NL return true NL }","func_name":"equalsIgnoreCase","docstring":""}
{"repo":"fountain","file":"ExtendInt.cj","path":"fountain/src/base/ExtendInt.cj","code_tokens":"static func fromHex ( val : String ) : I","func_name":"fromHex","docstring":""}
{"repo":"fountain","file":"ExtendInt.cj","path":"fountain/src/base/ExtendInt.cj","code_tokens":"static public func fromHex ( val : String ) : Int8 {   var r : Int8 = 0 NL for ( c in val ) {  r = ( r << 4 ) | Int8 ( hexIntMap [ c . toLowerCase ( ) ] ) NL } NL r NL }","func_name":"fromHex","docstring":""}
{"repo":"fountain","file":"ExtendInt.cj","path":"fountain/src/base/ExtendInt.cj","code_tokens":"static public func fromHex ( val : String ) : UInt8 {   var r : UInt8 = 0 NL for ( c in val ) {  r = ( r << 4 ) | UInt8 ( hexIntMap [ c . toLowerCase ( ) ] ) NL } NL r NL }","func_name":"fromHex","docstring":""}
{"repo":"fountain","file":"ExtendInt.cj","path":"fountain/src/base/ExtendInt.cj","code_tokens":"static public func fromHex ( val : String ) : Int16 {   var r : Int16 = 0 NL for ( c in val ) {  r = ( r << 4 ) | Int16 ( hexIntMap [ c . toLowerCase ( ) ] ) NL } NL r NL }","func_name":"fromHex","docstring":""}
{"repo":"fountain","file":"ExtendInt.cj","path":"fountain/src/base/ExtendInt.cj","code_tokens":"static public func fromHex ( val : String ) : UInt16 {   var r : UInt16 = 0 NL for ( c in val ) {  r = ( r << 4 ) | UInt16 ( hexIntMap [ c . toLowerCase ( ) ] ) NL } NL r NL }","func_name":"fromHex","docstring":""}
{"repo":"fountain","file":"ExtendInt.cj","path":"fountain/src/base/ExtendInt.cj","code_tokens":"static public func fromHex ( val : String ) : Int32 {   var r : Int32 = 0 NL for ( c in val ) {  r = ( r << 4 ) | Int32 ( hexIntMap [ c . toLowerCase ( ) ] ) NL } NL r NL }","func_name":"fromHex","docstring":""}
{"repo":"fountain","file":"ExtendInt.cj","path":"fountain/src/base/ExtendInt.cj","code_tokens":"static public func fromHex ( val : String ) : UInt32 {   var r : UInt32 = 0 NL for ( c in val ) {  r = ( r << 4 ) | UInt32 ( hexIntMap [ c . toLowerCase ( ) ] ) NL } NL r NL }","func_name":"fromHex","docstring":""}
{"repo":"fountain","file":"ExtendInt.cj","path":"fountain/src/base/ExtendInt.cj","code_tokens":"static public func fromHex ( val : String ) : Int64 {   var r : Int64 = 0 NL for ( c in val ) {  r = ( r << 4 ) | Int64 ( hexIntMap [ c . toLowerCase ( ) ] ) NL } NL r NL }","func_name":"fromHex","docstring":""}
{"repo":"fountain","file":"ExtendInt.cj","path":"fountain/src/base/ExtendInt.cj","code_tokens":"static public func fromHex ( val : String ) : UInt64 {   var r : UInt64 = 0 NL for ( c in val ) {  r = ( r << 4 ) | UInt64 ( hexIntMap [ c . toLowerCase ( ) ] ) NL } NL r NL }","func_name":"fromHex","docstring":""}
{"repo":"fountain","file":"Result.cj","path":"fountain/src/base/Result.cj","code_tokens":"public func toString ( ) : String {  match ( this ) { case Success ( v , c ) where v is ToString && c is ToString => Success(${(v as ToString).getOrThrow().toString()}, ${(c as ToString).getOrThrow().toString()}) NL case Success ( v , _ ) where v is ToString => Success(${(v as ToString).getOrThrow().toString()}, _) NL case Success ( _ , c ) where c is ToString => Success(_, ${(c as ToString).getOrThrow().toString()}) NL case Failure ( c ) where c is ToString => Failure(${(c as ToString).getOrThrow().toString()}) NL case SuccessValue ( v ) where v is ToString => SuccessValue(${(v as ToString).getOrThrow().toString()}) NL case SuccessCode ( c ) where c is ToString => SuccessCode(${(c as ToString).getOrThrow().toString()}) NL case Success => Success NL case Failure => Failure NL case Success ( _ , _ ) => Success(_,_) NL case Failure ( _ ) => Failure(_) NL case SuccessValue ( _ ) => SuccessValue(_) NL case SuccessCode ( _ ) => SuccessCode(_) NL case Thrown ( e ) where e is ToString => Thrown(${e.toString()}) NL case Thrown ( _ ) => Thrown(_) NL case None => None NL } NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"SingleIterable.cj","path":"fountain/src/base/SingleIterable.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  SingleIterator < T > ( value ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"SingleIterable.cj","path":"fountain/src/base/SingleIterable.cj","code_tokens":"public func next ( ) : Option < T > {  if ( got ) {  None < T > NL } else {  got = true NL value NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"IterableConverter.cj","path":"fountain/src/base/IterableConverter.cj","code_tokens":"public func next ( ) : Option < R > {  for ( v in itr ) {   let result = converter ( v ) NL match ( result ) { case Some ( _ ) => return result NL case _ where throwIfNotMatch => throw TypeCastException ( source contains some value which does not match target type ) NL case _ => continue NL } NL } NL None < R > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"OverSizePolicy.cj","path":"fountain/src/base/OverSizePolicy.cj","code_tokens":"func reject ( o : T , fn : ( ) -> Unit ) : Unit","func_name":"reject","docstring":""}
{"repo":"fountain","file":"OverSizePolicy.cj","path":"fountain/src/base/OverSizePolicy.cj","code_tokens":"public func reject ( o : T , fn : ( ) -> Unit ) : Unit {  throw OverSizeException ( max size is ${max} ) NL }","func_name":"reject","docstring":""}
{"repo":"fountain","file":"OverSizePolicy.cj","path":"fountain/src/base/OverSizePolicy.cj","code_tokens":"public func reject ( o : T , fn : ( ) -> Unit ) : Unit {  }","func_name":"reject","docstring":""}
{"repo":"fountain","file":"OverSizePolicy.cj","path":"fountain/src/base/OverSizePolicy.cj","code_tokens":"public func reject ( o : T , fn : ( ) -> Unit ) : Unit {  remove ( o ) NL fn ( ) NL }","func_name":"reject","docstring":""}
{"repo":"fountain","file":"OverSizePolicy.cj","path":"fountain/src/base/OverSizePolicy.cj","code_tokens":"public func reject ( o : T , fn : ( ) -> Unit ) : Unit {  fn ( ) NL }","func_name":"reject","docstring":""}
{"repo":"fountain","file":"OverSizePolicy.cj","path":"fountain/src/base/OverSizePolicy.cj","code_tokens":"public func reject ( o : T , fn : ( ) -> Unit ) : Unit {  synchronized ( monitor ) {  monitor . wait ( timeout : timeout ) NL } NL if ( recovered ( o ) ) {  policy . reject ( o , fn ) NL } NL }","func_name":"reject","docstring":""}
{"repo":"fountain","file":"OverSizePolicy.cj","path":"fountain/src/base/OverSizePolicy.cj","code_tokens":"public func notifyAll ( ) {  synchronized ( monitor ) {  monitor . notifyAll ( ) NL } NL }","func_name":"notifyAll","docstring":""}
{"repo":"fountain","file":"OverSizePolicy.cj","path":"fountain/src/base/OverSizePolicy.cj","code_tokens":"public func notify ( ) {  synchronized ( monitor ) {  monitor . notify ( ) NL } NL }","func_name":"notify","docstring":""}
{"repo":"fountain","file":"ExtendArray.cj","path":"fountain/src/base/ExtendArray.cj","code_tokens":"func get ( index : Int64 , default : T ) : T","func_name":"get","docstring":""}
{"repo":"fountain","file":"ExtendArray.cj","path":"fountain/src/base/ExtendArray.cj","code_tokens":"func newAndCopy ( size : Int64 , default ! : T ) : Array < T > {  Array < T > ( size ) { i => get ( i , default ) NL } NL }","func_name":"newAndCopy","docstring":""}
{"repo":"fountain","file":"ExtendArray.cj","path":"fountain/src/base/ExtendArray.cj","code_tokens":"public func get ( index : Int64 , default : T ) : T {  if ( index < this . size ) {  this [ index ] NL } else {  default NL } NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"static public func compare < T > ( left : T , right : T ) : Ordering where T <: Comparable < T > {  left . compare ( right ) NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"static public func create < T > ( ) where T <: Comparable < T > {  Comparator < T > ( compare < T > ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"public operator func ( ) ( left : T , right : T ) : Ordering {  comparator ( left , right ) NL }","func_name":"()","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"public func reverse ( ) : Comparator < T > {  Comparator < T > { left , right => match ( comparator ( left , right ) ) { case LT => GT NL case GT => LT NL case EQ => EQ NL } NL } NL }","func_name":"reverse","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"public func then ( comparator : ( T , T ) -> Ordering ) : Comparator < T > {  Comparator < T > { left , right => match ( this . comparator ( left , right ) ) { case EQ => comparator ( left , right ) NL case x => x NL } NL } NL }","func_name":"then","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"public func then ( comparator : Comparator < T > ) : Comparator < T > {  Comparator < T > { left , right => match ( this . comparator ( left , right ) ) { case EQ => comparator ( left , right ) NL case x => x NL } NL } NL }","func_name":"then","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"static public func comparing < O , T > ( mapper : ( O ) -> T ) : Comparator < O > where T <: Comparable < T > {  Comparator < O > { left , right => mapper ( left ) . compare ( mapper ( right ) ) NL } NL }","func_name":"comparing","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"static public func comparing < O , T > ( mapper : ( O ) -> T , comparator : ( T , T ) -> Ordering ) : Comparator < O > {  Comparator < O > { left , right => comparator ( mapper ( left ) , mapper ( right ) ) NL } NL }","func_name":"comparing","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"static public func comparing < O > ( mapper : ( O ) -> T , comparator : Comparator < T > ) : Comparator < O > {  Comparator < O > { left , right => comparator ( mapper ( left ) , mapper ( right ) ) NL } NL }","func_name":"comparing","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"public func then < O > ( mapper : ( O ) -> T , comparator : ( T , T ) -> Ordering ) : Comparator < O > {  Comparator < O > { left , right =>  let l = mapper ( left ) NL  let r = mapper ( right ) NL match ( this . comparator ( l , r ) ) { case EQ => comparator ( l , r ) NL case x => x NL } NL } NL }","func_name":"then","docstring":""}
{"repo":"fountain","file":"Comparator.cj","path":"fountain/src/base/Comparator.cj","code_tokens":"public func then < O > ( mapper : ( O ) -> T , comparator : Comparator < T > ) : Comparator < O > {  Comparator < O > { left , right =>  let l = mapper ( left ) NL  let r = mapper ( right ) NL match ( this . comparator ( l , r ) ) { case EQ => comparator ( l , r ) NL case x => x NL } NL } NL }","func_name":"then","docstring":""}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  EmptyIterator < T > . instance NL }","func_name":"iterator","docstring":"/*\n     * 返回 Map 的迭代器\n     * 返回值 Iterator<(K,V)> - Map 的迭代器\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func isEmpty ( ) : Bool {  true NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Map 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func contains ( element : T ) : Bool {  false NL }","func_name":"contains","docstring":"/*\n     * 如果该集合包含指定元素，则返回 true\n     * 参数 element - 需要判断的元素\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func subsetOf ( other : Set < T > ) : Bool {  true NL }","func_name":"subsetOf","docstring":"/*\n     * 检查该集合是否为其他集合的子集\n     * 参数 other - 其他集合\n     * 返回值 Bool - 如果它是子集，则返回 true，否则返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func containsAll ( elements : Collection < T > ) : Bool {  if ( elements . isEmpty ( ) ) {  true NL } else {  false NL } NL }","func_name":"containsAll","docstring":"/*\n     * 检查该集合是否包含其他集合\n     * 参数 elements - 其他集合\n     * 返回值 Bool - 如果包含，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func put ( element : T ) : Bool {  false NL }","func_name":"put","docstring":"/*\n     * 添加元素操作。如果元素已经存在，则不会添加它\n     * 参数 element - 要添加的元素\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func putAll ( elements : Collection < T > ) : Unit {  ( ) NL }","func_name":"putAll","docstring":"/*\n     * 添加 Collection 中的所有元素至此 Set 中，如果元素存在，则不添加\n     * 参数 elements - 需要被添加的元素的集合\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func remove ( element : T ) : Bool {  false NL }","func_name":"remove","docstring":"/*\n     * 从该结合中移除指定元素（如果存在）\n     * 参数 element - 要删除的元素\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func removeAll ( elements : Collection < T > ) : Unit {  ( ) NL }","func_name":"removeAll","docstring":"/*\n     * 移除此 Set 中那些也包含在指定 Collection 中的所有元素\n     * 参数 elements - 传入 Collection<T>\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func removeIf ( predicate : ( T ) -> Bool ) : Unit {  ( ) NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传入一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func clear ( ) : Unit {  ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func retainAll ( elements : Set < T > ) : Unit {  ( ) NL }","func_name":"retainAll","docstring":"/*\n     * 只保留重复的 T\n     * 参数 elements - 要保存的元素集合\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func clone ( ) : Set < T > {  this NL }","func_name":"clone","docstring":"/*\n     * 克隆 Set\n     * 返回新的 Set\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func next ( ) : Option < T > {  None < T > NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  EmptyIterator < T > . instance NL }","func_name":"iterator","docstring":"/*\n     * 返回 Map 的迭代器\n     * 返回值 Iterator<(K,V)> - Map 的迭代器\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func get ( key : K ) : Option < V > {  None < V > NL }","func_name":"get","docstring":"/*\n     * 根据 key 得到 Map 中映射的值\n     * 参数 key - 传递 key，获取 value\n     * 返回值 Option<V> - key 对应的值是用 Option 封装的\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func contains ( key : K ) : Bool {  false NL }","func_name":"contains","docstring":"/*\n     * 如果该集合包含指定元素，则返回 true\n     * 参数 element - 需要判断的元素\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  if ( keys . isEmpty ( ) ) {  true NL } else {  false NL } NL }","func_name":"containsAll","docstring":"/*\n     * 检查该集合是否包含其他集合\n     * 参数 elements - 其他集合\n     * 返回值 Bool - 如果包含，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func put ( key : K , value : V ) : Option < V > {  None < V > NL }","func_name":"put","docstring":"/*\n     * 添加元素操作。如果元素已经存在，则不会添加它\n     * 参数 element - 要添加的元素\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  ( ) NL }","func_name":"putAll","docstring":"/*\n     * 添加 Collection 中的所有元素至此 Set 中，如果元素存在，则不添加\n     * 参数 elements - 需要被添加的元素的集合\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func remove ( key : K ) : Option < V > {  None < V > NL }","func_name":"remove","docstring":"/*\n     * 从该结合中移除指定元素（如果存在）\n     * 参数 element - 要删除的元素\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  ( ) NL }","func_name":"removeAll","docstring":"/*\n     * 移除此 Set 中那些也包含在指定 Collection 中的所有元素\n     * 参数 elements - 传入 Collection<T>\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  ( ) NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传入一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func clear ( ) : Unit {  ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func clone ( ) : Map < K , V > {  this NL }","func_name":"clone","docstring":"/*\n     * 克隆 Set\n     * 返回新的 Set\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public operator func [ ] ( key : K ) : V {  None < V > . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  ( ) NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func keys ( ) : Keys < K > {  emptyKeys NL }","func_name":"keys","docstring":""}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func values ( ) : Values < V > {  emptyValues NL }","func_name":"values","docstring":""}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func isEmpty ( ) : Bool {  true NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Map 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func iterator ( ) : Iterator < ( K , V ) > {  EmptyIterator < ( K , V ) > . instance NL }","func_name":"iterator","docstring":"/*\n     * 返回 Map 的迭代器\n     * 返回值 Iterator<(K,V)> - Map 的迭代器\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func iterator ( ) : Iterator < K > {  EmptyIterator < K > . instance NL }","func_name":"iterator","docstring":"/*\n     * 返回 Map 的迭代器\n     * 返回值 Iterator<(K,V)> - Map 的迭代器\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func isEmpty ( ) : Bool {  true NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Map 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func contains ( element : K ) : Bool {  false NL }","func_name":"contains","docstring":"/*\n     * 如果该集合包含指定元素，则返回 true\n     * 参数 element - 需要判断的元素\n     * 返回值 Bool - 如果存在，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func containsAll ( elements : Collection < K > ) : Bool {  if ( elements . isEmpty ( ) ) {  true NL } else {  false NL } NL }","func_name":"containsAll","docstring":"/*\n     * 检查该集合是否包含其他集合\n     * 参数 elements - 其他集合\n     * 返回值 Bool - 如果包含，则返回 true；否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func remove ( element : K ) : Bool {  false NL }","func_name":"remove","docstring":"/*\n     * 从该结合中移除指定元素（如果存在）\n     * 参数 element - 要删除的元素\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func removeAll ( elements : Collection < K > ) : Unit {  ( ) NL }","func_name":"removeAll","docstring":"/*\n     * 移除此 Set 中那些也包含在指定 Collection 中的所有元素\n     * 参数 elements - 传入 Collection<T>\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func removeIf ( predicate : ( K ) -> Bool ) : Unit {  ( ) NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传入一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func clear ( ) : Unit {  ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func iterator ( ) : Iterator < V > {  EmptyIterator < V > . instance NL }","func_name":"iterator","docstring":"/*\n     * 返回 Map 的迭代器\n     * 返回值 Iterator<(K,V)> - Map 的迭代器\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func isEmpty ( ) : Bool {  true NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Map 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func removeIf ( predicate : ( V ) -> Bool ) : Unit {  ( ) NL }","func_name":"removeIf","docstring":"/*\n     * 传入 lambda 表达式，如果满足 true 条件，则删除对应的元素\n     * 参数 predicate - 传入一个 lambda 表达式进行判断\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func clear ( ) : Unit {  ( ) NL }","func_name":"clear","docstring":"/*\n     * 清除所有键值对\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func isEmpty ( ) : Bool {  true NL }","func_name":"isEmpty","docstring":"/*\n     * 检查 Map 是否为空\n     * 返回值 Bool - 如果是，则返回 true; 否则，返回 false\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func toArray ( ) : Array < T > {  EmptyArray < T > . instance NL }","func_name":"toArray","docstring":"/*\n     * 将对象转为数组类型\n     * 返回值 Array<T> - 转换后的数组\n     */"}
{"repo":"fountain","file":"EmptyCollections.cj","path":"fountain/src/base/EmptyCollections.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  EmptyIterator < T > . instance NL }","func_name":"iterator","docstring":"/*\n     * 返回 Map 的迭代器\n     * 返回值 Iterator<(K,V)> - Map 的迭代器\n     */"}
{"repo":"fountain","file":"EmptyObject.cj","path":"fountain/src/base/EmptyObject.cj","code_tokens":"public operator func == ( value : Any ) {  value is EmptyObject NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"EmptyObject.cj","path":"fountain/src/base/EmptyObject.cj","code_tokens":"public operator func != ( value : Any ) {  ! ( this == value ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"EmptyObject.cj","path":"fountain/src/base/EmptyObject.cj","code_tokens":"public func compare ( rhs : Any ) : Ordering {  if ( this == rhs ) {  Ordering . EQ NL } else {  Ordering . LT NL } NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"EmptyObject.cj","path":"fountain/src/base/EmptyObject.cj","code_tokens":"public operator func < ( rhs : Any ) : Bool {  compare ( rhs ) . lt NL }","func_name":"<","docstring":""}
{"repo":"fountain","file":"EmptyObject.cj","path":"fountain/src/base/EmptyObject.cj","code_tokens":"public operator func <= ( rhs : Any ) : Bool {  match ( compare ( rhs ) ) { case LT | EQ => true NL case _ => false NL } NL }","func_name":"<=","docstring":""}
{"repo":"fountain","file":"EmptyObject.cj","path":"fountain/src/base/EmptyObject.cj","code_tokens":"public operator func > ( rhs : Any ) : Bool {  false NL }","func_name":">","docstring":""}
{"repo":"fountain","file":"EmptyObject.cj","path":"fountain/src/base/EmptyObject.cj","code_tokens":"public operator func > = ( rhs : Any ) : Bool {  this == rhs NL }","func_name":">=","docstring":""}
{"repo":"fountain","file":"NoneOrder.cj","path":"fountain/src/base/NoneOrder.cj","code_tokens":"public func compare ( other : NoneOrder ) {  match ( ( this , other ) ) { case ( Greatest , Greatest ) | ( Least , Least ) => EQ NL case ( Greatest , Least ) => GT NL case ( Least , Greatest ) => LT NL } NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"Comparable.cj","path":"fountain/src/base/Comparable.cj","code_tokens":"operator func == ( other : T ) : Bool {  compare ( other ) == EQ NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"Comparable.cj","path":"fountain/src/base/Comparable.cj","code_tokens":"operator func != ( other : T ) : Bool {  compare ( other ) != EQ NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"Comparable.cj","path":"fountain/src/base/Comparable.cj","code_tokens":"operator func > ( other : T ) : Bool {  compare ( other ) == GT NL }","func_name":">","docstring":""}
{"repo":"fountain","file":"Comparable.cj","path":"fountain/src/base/Comparable.cj","code_tokens":"operator func < ( other : T ) : Bool {  compare ( other ) == LT NL }","func_name":"<","docstring":""}
{"repo":"fountain","file":"Comparable.cj","path":"fountain/src/base/Comparable.cj","code_tokens":"operator func > = ( other : T ) : Bool {  match ( compare ( other ) ) { case GT | EQ => true NL case _ => false NL } NL }","func_name":">=","docstring":""}
{"repo":"fountain","file":"Comparable.cj","path":"fountain/src/base/Comparable.cj","code_tokens":"operator func <= ( other : T ) : Bool {  match ( compare ( other ) ) { case LT | EQ => true NL case _ => false NL } NL }","func_name":"<=","docstring":""}
{"repo":"fountain","file":"OptionComparable.cj","path":"fountain/src/base/OptionComparable.cj","code_tokens":"operator func == ( other : T ) : Bool {  compare ( other , noneOrder : Least ) == EQ NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"OptionComparable.cj","path":"fountain/src/base/OptionComparable.cj","code_tokens":"operator func != ( other : T ) : Bool {  compare ( other , noneOrder : Least ) != EQ NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"OptionComparable.cj","path":"fountain/src/base/OptionComparable.cj","code_tokens":"operator func > ( other : T ) : Bool {  compare ( other , noneOrder : Least ) == GT NL }","func_name":">","docstring":""}
{"repo":"fountain","file":"OptionComparable.cj","path":"fountain/src/base/OptionComparable.cj","code_tokens":"operator func < ( other : T ) : Bool {  compare ( other , noneOrder : Least ) == LT NL }","func_name":"<","docstring":""}
{"repo":"fountain","file":"OptionComparable.cj","path":"fountain/src/base/OptionComparable.cj","code_tokens":"operator func > = ( other : T ) : Bool {  match ( compare ( other , noneOrder : Least ) ) { case GT | EQ => true NL case _ => false NL } NL }","func_name":">=","docstring":""}
{"repo":"fountain","file":"OptionComparable.cj","path":"fountain/src/base/OptionComparable.cj","code_tokens":"operator func <= ( other : T ) : Bool {  match ( compare ( other , noneOrder : NoneOrder . Least ) ) { case LT | EQ => true NL case _ => false NL } NL }","func_name":"<=","docstring":""}
{"repo":"fountain","file":"OptionComparable.cj","path":"fountain/src/base/OptionComparable.cj","code_tokens":"func compare ( other : T , noneOrder ! : NoneOrder ) : Ordering","func_name":"compare","docstring":""}
{"repo":"fountain","file":"OptionComparable.cj","path":"fountain/src/base/OptionComparable.cj","code_tokens":"public func compare ( other : Option < T > , noneOrder ! : NoneOrder = Least ) : Ordering {  match ( ( this , other ) ) { case ( Some ( v1 ) , Some ( v2 ) ) => v1 . compare ( v2 ) NL case ( Some ( _ ) , _ ) => if ( let Greatest = noneOrder ) {  LT NL } else {  GT NL } NL case ( _ , Some ( _ ) ) => if ( let Greatest = noneOrder ) {  GT NL } else {  LT NL } NL case _ => EQ NL } NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"HashBuilder.cj","path":"fountain/src/base/HashBuilder.cj","code_tokens":"public func finish ( ) : Int64 {   let h = hashed NL hashed = initHash NL h NL }","func_name":"finish","docstring":"//调用一次，本类的实例回到初始状态"}
{"repo":"fountain","file":"HashBuilder.cj","path":"fountain/src/base/HashBuilder.cj","code_tokens":"public func append ( arg : Int64 ) : HashBuilder {  hashed = hashed . wrappingMul ( coefficient ) . wrappingAdd ( arg ) NL this NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"HashBuilder.cj","path":"fountain/src/base/HashBuilder.cj","code_tokens":"public func append < T > ( arg : T ) : HashBuilder where T <: Hashable {  append ( arg . hashCode ( ) ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"HashBuilder.cj","path":"fountain/src/base/HashBuilder.cj","code_tokens":"public func append < T > ( args : Iterable < T > ) : HashBuilder where T <: Hashable {  match ( args ) { case x : Hashable => append ( x . hashCode ( ) ) NL case _ => append ( IterableConverter < T , Hashable > ( args ) ) NL } NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"HashBuilder.cj","path":"fountain/src/base/HashBuilder.cj","code_tokens":"public func append ( arg : String ) : HashBuilder {  append < String > ( arg ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"HashBuilder.cj","path":"fountain/src/base/HashBuilder.cj","code_tokens":"public func append ( arg : StringBuilder ) : HashBuilder {  append < Char > ( arg ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"HashBuilder.cj","path":"fountain/src/base/HashBuilder.cj","code_tokens":"public func append ( args : Iterable < Hashable > ) : HashBuilder {  match ( args ) { case x : Hashable => append ( x . hashCode ( ) ) NL case _ =>  let builder = HashBuilder ( ) NL for ( arg in args ) {  builder . append < Hashable > ( arg ) NL } NL this . append ( builder . finish ( ) ) NL } NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func + ( right : T ) : T","func_name":"+","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func - ( right : T ) : T","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func * ( right : T ) : T","func_name":"*","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func / ( right : T ) : T","func_name":"/","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func > ( right : T ) : Bool","func_name":">","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func > = ( right : T ) : Bool","func_name":">=","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func < ( right : T ) : Bool","func_name":"<","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func <= ( right : T ) : Bool","func_name":"<=","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func == ( right : T ) : Bool","func_name":"==","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func != ( right : T ) : Bool","func_name":"!=","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func % ( right : T ) : T","func_name":"%","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func & ( right : T ) : T","func_name":"&","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func | ( right : T ) : T","func_name":"|","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func ^ ( right : T ) : T","func_name":"^","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func > > ( right : T ) : T","func_name":">>","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func << ( right : T ) : T","func_name":"<<","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func ! ( ) : T","func_name":"!","docstring":""}
{"repo":"fountain","file":"ExtendNumber.cj","path":"fountain/src/base/ExtendNumber.cj","code_tokens":"operator func ** ( right : P ) : T","func_name":"**","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func next ( ) : Option < ToString > {  if ( current < count ) {  current ++ NL sub NL } else {  None < ToString > NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func next ( ) : Option < ToString > {  if ( current < count ) {   let sub = fn ( current ) NL current ++ NL sub NL } else {  None < ToString > NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func indexof ( ch : Char ) : Int64","func_name":"indexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func indexof ( ch : Char , fromIndex : Int64 ) : Int64","func_name":"indexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func indexof ( sub : String ) : Int64","func_name":"indexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func indexof ( sub : String , fromIndex : Int64 ) : Int64","func_name":"indexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func lastIndexof ( ch : Char ) : Int64","func_name":"lastIndexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func lastIndexof ( ch : Char , fromIndex : Int64 ) : Int64","func_name":"lastIndexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func lastIndexof ( sub : String ) : Int64","func_name":"lastIndexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func lastIndexof ( sub : String , fromIndex : Int64 ) : Int64","func_name":"lastIndexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func substr ( start : Int64 , end : Int64 ) : String","func_name":"substr","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func toUpperCase ( ) : String","func_name":"toUpperCase","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func toLowerCase ( ) : String","func_name":"toLowerCase","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"func convert ( fn : ( Char ) -> Char ) : String","func_name":"convert","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"static func join ( sub : ToString , count : Int64 , delimiter ! : String ) : String","func_name":"join","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"static func join ( iterable : Iterable < ToString > , delimiter ! : String ) : String","func_name":"join","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func indexof ( ch : Char ) : Int64 {  indexOf ( ch ) ?? - 1 NL }","func_name":"indexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func indexof ( ch : Char , fromIndex : Int64 ) : Int64 {  indexOf ( ch , fromIndex ) ?? - 1 NL }","func_name":"indexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func indexof ( sub : String ) : Int64 {  indexOf ( sub ) ?? - 1 NL }","func_name":"indexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func indexof ( sub : String , fromIndex : Int64 ) : Int64 {  indexOf ( sub , fromIndex ) ?? - 1 NL }","func_name":"indexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func lastIndexof ( ch : Char ) : Int64 {  lastIndexOf ( ch ) ?? - 1 NL }","func_name":"lastIndexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func lastIndexof ( ch : Char , fromIndex : Int64 ) : Int64 {  lastIndexOf ( ch , fromIndex ) ?? - 1 NL }","func_name":"lastIndexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func lastIndexof ( sub : String ) : Int64 {  lastIndexOf ( sub ) ?? - 1 NL }","func_name":"lastIndexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func lastIndexof ( sub : String , fromIndex : Int64 ) : Int64 {  lastIndexOf ( sub , fromIndex ) ?? - 1 NL }","func_name":"lastIndexof","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func substr ( start : Int64 , end : Int64 ) : String {  return this . substring ( start , end - start ) NL }","func_name":"substr","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func convert ( fn : ( Char ) -> Char ) : String {   let builder = StringBuilder ( ) NL for ( c in this ) {  builder . append ( fn ( c ) ) NL } NL return builder . toString ( ) NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func toUpperCase ( ) : String {  return toUpper ( ) NL }","func_name":"toUpperCase","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"public func toLowerCase ( ) : String {  return toLower ( ) NL }","func_name":"toLowerCase","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"static public func join ( sub : ToString , count : Int64 , delimiter ! : String =  ) : String {  return join ( JoinSubIterator ( sub , count ) , delimiter : delimiter ) NL }","func_name":"join","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"static public func join ( sub : ( Int64 ) -> ToString , count : Int64 , delimiter ! : String =  ) : String {  return join ( JoinSubFuncIterator ( sub , count ) , delimiter : delimiter ) NL }","func_name":"join","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"static public func join ( iterable : Iterable < ToString > , delimiter ! : String =  ) : String {  StringJoiner . join < ToString > ( iterable , delimiter : delimiter ) . toString ( ) NL }","func_name":"join","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"static public func join < T > ( iterable : Iterable < T > , delimiter ! : String =  ) : String where T <: ToString {  StringBuilderJoiner . join < T > ( iterable , delimiter : delimiter ) . toString ( ) NL }","func_name":"join","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"static public func join < T > ( iterable : Iterable < T > , mapper : ( T ) -> String , delimiter ! : String =  ) : String {  StringBuilderJoiner . join < T > ( iterable , mapper , delimiter : delimiter ) . toString ( ) NL }","func_name":"join","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"static public func join < T > ( iterable : Iterable < T > , delimiter ! : String =  , builder ! : StringBuilder = StringBuilder ( ) ) : StringBuilder where T <: ToString {   var i = 0 NL for ( s in iterable ) {  if ( i > 0 ) {  builder . append ( delimiter ) NL } NL builder . append ( s ) NL i ++ NL } NL builder NL }","func_name":"join","docstring":""}
{"repo":"fountain","file":"ExtendString.cj","path":"fountain/src/base/ExtendString.cj","code_tokens":"static public func join < T > ( iterable : Iterable < T > , mapper : ( T ) -> String , delimiter ! : String =  , builder ! : StringBuilder = StringBuilder ( ) ) : StringBuilder {   let itr : Iterable < String > = IterableConverter < T , String > ( iterable , throwIfNotMatch : true , converter : { v => mapper ( v ) NL } ) NL join < String > ( itr , delimiter : delimiter , builder : builder ) NL }","func_name":"join","docstring":""}
{"repo":"fountain","file":"ExtendOption.cj","path":"fountain/src/base/ExtendOption.cj","code_tokens":"func filter ( fn : ( T ) -> Bool ) : Option < T > {   let cur = current NL if ( let Some ( v ) = cur ) {  if ( fn ( v ) ) {  return cur NL } NL } NL return None < T > NL }","func_name":"filter","docstring":""}
{"repo":"fountain","file":"ExtendOption.cj","path":"fountain/src/base/ExtendOption.cj","code_tokens":"func iterator ( ) : Iterator < T >","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"ExtendOption.cj","path":"fountain/src/base/ExtendOption.cj","code_tokens":"public func next ( ) : Option < T > {  if ( got ) {  None < T > NL } else {  got = true NL opt NL } NL }","func_name":"next","docstring":""}
{"repo":"fountain","file":"ExtendOption.cj","path":"fountain/src/base/ExtendOption.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  OptionIterator < T > ( this ) NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getInt16 ( offset ! : Int64 , endian ! : Endian ) : Int16","func_name":"getInt16","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getUInt16 ( offset ! : Int64 , endian ! : Endian ) : UInt16","func_name":"getUInt16","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getInt32 ( offset ! : Int64 , endian ! : Endian ) : Int32","func_name":"getInt32","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getUInt32 ( offset ! : Int64 , endian ! : Endian ) : UInt32","func_name":"getUInt32","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getInt64 ( offset ! : Int64 , endian ! : Endian ) : Int64","func_name":"getInt64","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getUInt64 ( offset ! : Int64 , endian ! : Endian ) : UInt64","func_name":"getUInt64","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getInt16s ( array : Array < Int16 > , targetOffset ! : Int64 , count ! : Int64 , currentOffset ! : Int64 , endian ! : Endian ) : Unit","func_name":"getInt16s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getUInt16s ( array : Array < UInt16 > , targetOffset ! : Int64 , count ! : Int64 , currentOffset ! : Int64 , endian ! : Endian ) : Unit","func_name":"getUInt16s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getInt32s ( array : Array < Int32 > , targetOffset ! : Int64 , count ! : Int64 , currentOffset ! : Int64 , endian ! : Endian ) : Unit","func_name":"getInt32s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getUInt32s ( array : Array < UInt32 > , targetOffset ! : Int64 , count ! : Int64 , currentOffset ! : Int64 , endian ! : Endian ) : Unit","func_name":"getUInt32s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getInt64s ( array : Array < Int64 > , targetOffset ! : Int64 , count ! : Int64 , currentOffset ! : Int64 , endian ! : Endian ) : Unit","func_name":"getInt64s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"func getUInt64s ( array : Array < UInt64 > , targetOffset ! : Int64 , count ! : Int64 , currentOffset ! : Int64 , endian ! : Endian ) : Unit","func_name":"getUInt64s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"private func doGetInt16 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : ( Int16 , Int64 ) {   var remaining = this . size - offset NL  let bytes = 2 NL  var off = 0 NL  let mask = 0xff_i16 NL match ( this ) { case array : Array < Byte > =>  var result = 0_i16 NL match ( endian ) { case Little => while ( remaining > 0 && off < bytes ) {  result |= ( Int16 ( array [ offset + off ] ) & mask ) << ( off * 8 ) NL remaining -- NL off ++ NL } NL case Big => while ( remaining > 0 && off < bytes ) {  result = ( result << 8 ) | ( Int16 ( array [ offset + off ] ) & mask ) NL remaining -- NL off ++ NL } NL } NL if ( off > 0 ) {  return ( result , offset + off ) NL } else {  throw IndexOutOfBoundsException ( current array size is ${this.size} and offset is ${offset} ) NL } NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"doGetInt16","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getInt16 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : Int16 {  doGetInt16 ( offset : offset , endian : endian ) [ 0 ] NL }","func_name":"getInt16","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"private func doGetUInt16 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : ( UInt16 , Int64 ) {   var remaining = this . size - offset NL  let bytes = 2 NL  var off = 0 NL  let mask = 0xff_u16 NL match ( this ) { case array : Array < Byte > =>  var result = 0_u16 NL match ( endian ) { case Little => while ( remaining > 0 && off < bytes ) {  result |= ( UInt16 ( array [ offset + off ] ) & mask ) << ( off * 8 ) NL remaining -- NL off ++ NL } NL case Big => while ( remaining > 0 && off < bytes ) {  result = ( result << 8 ) | ( UInt16 ( array [ offset + off ] ) & mask ) NL remaining -- NL off ++ NL } NL } NL if ( off > 0 ) {  return ( result , offset + off ) NL } else {  throw IndexOutOfBoundsException ( current array size is ${this.size} and offset is ${offset} ) NL } NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"doGetUInt16","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getUInt16 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : UInt16 {  doGetUInt16 ( offset : offset , endian : endian ) [ 0 ] NL }","func_name":"getUInt16","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"private func doGetInt32 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : ( Int32 , Int64 ) {   var remaining = this . size - offset NL  let bytes = 4 NL  var off = 0 NL  let mask = 0xff_i32 NL match ( this ) { case array : Array < Byte > =>  var result = 0_i32 NL match ( endian ) { case Little => while ( remaining > 0 && off < bytes ) {  result |= ( Int32 ( array [ offset + off ] ) & mask ) << ( off * 8 ) NL remaining -- NL off ++ NL } NL case Big => while ( remaining > 0 && off < bytes ) {  result = ( result << 8 ) | ( Int32 ( array [ offset + off ] ) & mask ) NL remaining -- NL off ++ NL } NL } NL if ( off > 0 ) {  return ( result , offset + off ) NL } else {  throw IndexOutOfBoundsException ( current array size is ${this.size} and offset is ${offset} ) NL } NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"doGetInt32","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getInt32 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : Int32 {  doGetInt32 ( offset : offset , endian : endian ) [ 0 ] NL }","func_name":"getInt32","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"private func doGetUInt32 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : ( UInt32 , Int64 ) {   var remaining = this . size - offset NL  let bytes = 4 NL  var off = 0 NL  let mask = 0xff_u32 NL match ( this ) { case array : Array < Byte > =>  var result = 0_u32 NL match ( endian ) { case Little => while ( remaining > 0 && off < bytes ) {  result |= ( UInt32 ( array [ offset + off ] ) & mask ) << ( off * 8 ) NL remaining -- NL off ++ NL } NL case Big => while ( remaining > 0 && off < bytes ) {  result = ( result << 8 ) | ( UInt32 ( array [ offset + off ] ) & mask ) NL remaining -- NL off ++ NL } NL } NL if ( off > 0 ) {  return ( result , offset + off ) NL } else {  throw IndexOutOfBoundsException ( current array size is ${this.size} and offset is ${offset} ) NL } NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"doGetUInt32","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getUInt32 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : UInt32 {  doGetUInt32 ( offset : offset , endian : endian ) [ 0 ] NL }","func_name":"getUInt32","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"private func doGetInt64 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : ( Int64 , Int64 ) {   var remaining = this . size - offset NL  let bytes = 8 NL  var off = 0 NL  let mask = 0xff_i64 NL match ( this ) { case array : Array < Byte > =>  var result = 0_i64 NL match ( endian ) { case Little => while ( remaining > 0 && off < bytes ) {  result |= ( Int64 ( array [ offset + off ] ) & mask ) << ( off * 8 ) NL remaining -- NL off ++ NL } NL case Big => while ( remaining > 0 && off < bytes ) {  result = ( result << 8 ) | ( Int64 ( array [ offset + off ] ) & mask ) NL remaining -- NL off ++ NL } NL } NL if ( off > 0 ) {  return ( result , offset + off ) NL } else {  throw IndexOutOfBoundsException ( current array size is ${this.size} and offset is ${offset} ) NL } NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"doGetInt64","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getInt64 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : Int64 {  doGetInt64 ( offset : offset , endian : endian ) [ 0 ] NL }","func_name":"getInt64","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"private func doGetUInt64 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : ( UInt64 , Int64 ) {   var remaining = this . size - offset NL  let bytes = 8 NL  var off = 0 NL  let mask = 0xff_u64 NL match ( this ) { case array : Array < Byte > =>  var result = 0_u64 NL match ( endian ) { case Little => while ( remaining > 0 && off < bytes ) {  result |= ( UInt64 ( array [ offset + off ] ) & mask ) << ( off * 8 ) NL remaining -- NL off ++ NL } NL case Big => while ( remaining > 0 && off < bytes ) {  result = ( result << 8 ) | ( UInt64 ( array [ offset + off ] ) & mask ) NL remaining -- NL off ++ NL } NL } NL if ( off > 0 ) {  return ( result , offset + off ) NL } else {  throw IndexOutOfBoundsException ( current array size is ${this.size} and offset is ${offset} ) NL } NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"doGetUInt64","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getUInt64 ( offset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : UInt64 {  doGetUInt64 ( offset : offset , endian : endian ) [ 0 ] NL }","func_name":"getUInt64","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"private func checkSize < T > ( array : Array < T > , targetOffset ! : Int64 = 0 , count ! : Int64 = array . size - targetOffset , currentOffset ! : Int64 = 0 ) {  if ( count > array . size - targetOffset ) {  throw IndexOutOfBoundsException ( target array size is ${array.size} and target offset is ${targetOffset}, but count arg is ${count} ) NL } else if ( currentOffset > = this . size ) {  throw IndexOutOfBoundsException ( current array size is ${this.size} and current offset is ${currentOffset} ) NL } NL }","func_name":"checkSize","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getInt16s ( array : Array < Int16 > , targetOffset ! : Int64 = 0 , count ! : Int64 = array . size - targetOffset , currentOffset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : Unit {  checkSize < Int16 > ( array , targetOffset : targetOffset , count : count , currentOffset : currentOffset ) NL  var curoff = currentOffset NL  var dstoff = targetOffset NL  let dstsize = array . size NL  var c = 0 NL while ( c < count ) {   let tpl = doGetInt16 ( offset : curoff , endian : endian ) NL array [ dstoff ] = tpl [ 0 ] NL curoff = tpl [ 1 ] NL dstoff ++ NL c ++ NL } NL }","func_name":"getInt16s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getUInt16s ( array : Array < UInt16 > , targetOffset ! : Int64 = 0 , count ! : Int64 = array . size - targetOffset , currentOffset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : Unit {  checkSize < UInt16 > ( array , targetOffset : targetOffset , count : count , currentOffset : currentOffset ) NL  var curoff = currentOffset NL  var dstoff = targetOffset NL  let dstsize = array . size NL  var c = 0 NL while ( c < count ) {   let tpl = doGetUInt16 ( offset : curoff , endian : endian ) NL array [ dstoff ] = tpl [ 0 ] NL curoff = tpl [ 1 ] NL dstoff ++ NL c ++ NL } NL }","func_name":"getUInt16s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getInt32s ( array : Array < Int32 > , targetOffset ! : Int64 = 0 , count ! : Int64 = array . size - targetOffset , currentOffset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : Unit {  checkSize < Int32 > ( array , targetOffset : targetOffset , count : count , currentOffset : currentOffset ) NL  var curoff = currentOffset NL  var dstoff = targetOffset NL  let dstsize = array . size NL  var c = 0 NL while ( c < count ) {   let tpl = doGetInt32 ( offset : curoff , endian : endian ) NL array [ dstoff ] = tpl [ 0 ] NL curoff = tpl [ 1 ] NL dstoff ++ NL c ++ NL } NL }","func_name":"getInt32s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getUInt32s ( array : Array < UInt32 > , targetOffset ! : Int64 = 0 , count ! : Int64 = array . size - targetOffset , currentOffset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : Unit {  checkSize < UInt32 > ( array , targetOffset : targetOffset , count : count , currentOffset : currentOffset ) NL  var curoff = currentOffset NL  var dstoff = targetOffset NL  let dstsize = array . size NL  var c = 0 NL while ( c < count ) {   let tpl = doGetUInt32 ( offset : curoff , endian : endian ) NL array [ dstoff ] = tpl [ 0 ] NL curoff = tpl [ 1 ] NL dstoff ++ NL c ++ NL } NL }","func_name":"getUInt32s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getInt64s ( array : Array < Int64 > , targetOffset ! : Int64 = 0 , count ! : Int64 = array . size - targetOffset , currentOffset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : Unit {  checkSize < Int64 > ( array , targetOffset : targetOffset , count : count , currentOffset : currentOffset ) NL  var curoff = currentOffset NL  var dstoff = targetOffset NL  let dstsize = array . size NL  var c = 0 NL while ( c < count ) {   let tpl = doGetInt64 ( offset : curoff , endian : endian ) NL array [ dstoff ] = tpl [ 0 ] NL curoff = tpl [ 1 ] NL dstoff ++ NL c ++ NL } NL }","func_name":"getInt64s","docstring":""}
{"repo":"fountain","file":"ExtendByteArray.cj","path":"fountain/src/base/ExtendByteArray.cj","code_tokens":"public func getUInt64s ( array : Array < UInt64 > , targetOffset ! : Int64 = 0 , count ! : Int64 = array . size - targetOffset , currentOffset ! : Int64 = 0 , endian ! : Endian = CURRENT_ENDIAN ) : Unit {  checkSize < UInt64 > ( array , targetOffset : targetOffset , count : count , currentOffset : currentOffset ) NL  var curoff = currentOffset NL  var dstoff = targetOffset NL  let dstsize = array . size NL  var c = 0 NL while ( c < count ) {   let tpl = doGetUInt64 ( offset : curoff , endian : endian ) NL array [ dstoff ] = tpl [ 0 ] NL curoff = tpl [ 1 ] NL dstoff ++ NL c ++ NL } NL }","func_name":"getUInt64s","docstring":""}
{"repo":"fountain","file":"ExtendIterator.cj","path":"fountain/src/base/ExtendIterator.cj","code_tokens":"func iterator ( ) : Iterator < T > {  this NL }","func_name":"iterator","docstring":""}
{"repo":"fountain","file":"Initializer.cj","path":"fountain/src/base/Initializer.cj","code_tokens":"static func initialize ( ) : Unit","func_name":"initialize","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"operator func + ( n : UInt32 ) : Char","func_name":"+","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"operator func - ( n : UInt32 ) : Char","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"operator func - ( c : Char ) : Int64","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"operator func + ( n : Int64 ) : Char","func_name":"+","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"operator func - ( n : Int64 ) : Char","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"operator func + ( n : UInt64 ) : Char","func_name":"+","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"operator func - ( n : UInt64 ) : Char","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"operator func + ( n : Int32 ) : Char","func_name":"+","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"operator func - ( n : Int32 ) : Char","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"public operator func + ( n : UInt32 ) : Char {  Char ( UInt32 ( this ) + n ) NL }","func_name":"+","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"public operator func - ( n : UInt32 ) : Char {  Char ( UInt32 ( this ) - n ) NL }","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"public operator func - ( c : Char ) : Int64 {  Int64 ( UInt32 ( this ) ) - Int64 ( UInt32 ( c ) ) NL }","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"public operator func + ( n : Int64 ) : Char {  if ( n > 0 ) {  this + UInt32 ( n ) NL } else {  this - UInt32 ( - n ) NL } NL }","func_name":"+","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"public operator func - ( n : Int64 ) : Char {  if ( n > 0 ) {  this - UInt32 ( n ) NL } else {  this + UInt32 ( - n ) NL } NL }","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"public operator func + ( n : UInt64 ) : Char {  this + UInt32 ( n ) NL }","func_name":"+","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"public operator func - ( n : UInt64 ) : Char {  this - UInt32 ( n ) NL }","func_name":"-","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"public operator func + ( n : Int32 ) : Char {  if ( n > 0 ) {  this + UInt32 ( n ) NL } else {  this - UInt32 ( - n ) NL } NL }","func_name":"+","docstring":""}
{"repo":"fountain","file":"ExtendChar.cj","path":"fountain/src/base/ExtendChar.cj","code_tokens":"public operator func - ( n : Int32 ) : Char {  if ( n > 0 ) {  this - UInt32 ( n ) NL } else {  this + UInt32 ( - n ) NL } NL }","func_name":"-","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isEmpty ( current : Option < T > ) : Bool {  match ( current ) { case None < T > => true NL case Some ( x ) where x is Unit => true NL case Some ( x ) where x is Collection < R > => ( x as Collection < R > ) . getOrThrow ( ) . isEmpty ( ) NL case Some ( _ ) => false NL } NL }","func_name":"isEmpty","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isNotEmpty ( current : Option < T > ) : Bool {  ! isEmpty ( current ) NL }","func_name":"isNotEmpty","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isEmptyOrUnit ( current : Option < T > ) : Bool {  if ( isEmpty ( current ) ) {  return true NL } NL match ( current ) { case Some ( v ) => v is Unit NL case None => true NL } NL }","func_name":"isEmptyOrUnit","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isNotEmptyOrUnit ( current : Option < T > ) : Bool {  ! isEmptyOrUnit ( current ) NL }","func_name":"isNotEmptyOrUnit","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isEmptyOrZero ( current : Option < T > ) : Bool {  if ( isEmpty ( current ) ) {  return true NL } NL match ( current ) { case Some ( v ) => match ( v ) { case x : Int64 where x == 0 => true NL case x : UInt64 where x == 0 => true NL case x : Int32 where x == 0 => true NL case x : UInt32 where x == 0 => true NL case x : Int16 where x == 0 => true NL case x : UInt16 where x == 0 => true NL case x : Int8 where x == 0 => true NL case x : UInt8 where x == 0 => true NL case x : Float64 where x == 0.0 => true NL case x : Float32 where x == 0.0 => true NL case x : Float16 where x == 0.0 => true NL case x : Char where x == \\0 => true NL case x : String where x . size == 1 && x [ 0 ] == \\0 => true NL case _ => false NL } NL case None => true NL } NL }","func_name":"isEmptyOrZero","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isNotEmptyOrZero ( current : Option < T > ) : Bool {  ! isEmptyOrZero ( current ) NL }","func_name":"isNotEmptyOrZero","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isEmptyOrBlank ( current : Option < T > ) : Bool {   func isBlankChar ( c : Char ) {  c == \\0 || c . isWhiteSpace ( ) NL } NL if ( isEmpty ( current ) ) {  return true NL } NL match ( current . getOrThrow ( ) ) { case v : String => v . isBlank ( ) NL case v : Iterable < Char > => for ( c in v where ! isBlankChar ( c ) ) {  return false NL } NL true NL case v : Char => isBlankChar ( v ) NL case _ => false NL } NL }","func_name":"isEmptyOrBlank","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"func isBlankChar ( c : Char ) {  c == \\0 || c . isWhiteSpace ( ) NL }","func_name":"isBlankChar","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isNotEmptyOrBlank ( current : Option < T > ) : Bool {  ! isEmptyOrBlank ( current ) NL }","func_name":"isNotEmptyOrBlank","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isEmptyOrZeroOrBlank ( current : Option < T > ) {  isEmptyOrZero ( current ) || isEmptyOrBlank ( current ) NL }","func_name":"isEmptyOrZeroOrBlank","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func isNotEmptyOrZeroOrBlank ( current : Option < T > ) {  ! isEmptyOrZeroOrBlank ( current ) NL }","func_name":"isNotEmptyOrZeroOrBlank","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func convert ( origin : Option < T > , default : R , converter : ( T ) -> Option < R > ) : R {  convert ( origin , converter ) ?? default NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func convert ( origin : Option < T > , default : R ) : Option < R > {  convert ( origin ) ?? default NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func convert ( origin : Option < T > ) : Option < R > {  doConvert ( origin , false ) NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func convertOrThrow ( origin : Option < T > , default : R ) : Option < R > {  convertOrThrow ( origin ) ?? default NL }","func_name":"convertOrThrow","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func convertOrThrow ( origin : Option < T > ) : Option < R > {  doConvert ( origin , true ) NL }","func_name":"convertOrThrow","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static private func doConvert ( origin : Option < T > , toThrow : Bool ) : Option < R > {  doConvert ( origin , { v => v as R NL } , toThrow ) NL }","func_name":"doConvert","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func convert ( origin : Option < T > , converter : ( T ) -> Option < R > ) : Option < R > {  doConvert ( origin , converter , false ) NL }","func_name":"convert","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static public func convertOrThrow ( origin : Option < T > , converter : ( T ) -> Option < R > ) {  doConvert ( origin , converter , true ) NL }","func_name":"convertOrThrow","docstring":""}
{"repo":"fountain","file":"Options.cj","path":"fountain/src/base/Options.cj","code_tokens":"static private func doConvert ( origin : Option < T > , converter : ( T ) -> Option < R > , toThrow : Bool ) : Option < R > {  if ( let Some ( v ) = origin ) {  match ( converter ( v ) ) { case Some ( r ) => r NL case _ where toThrow => throw IllegalArgumentException ( ) NL case _ => None < R > NL } NL } else {  None < R > NL } NL }","func_name":"doConvert","docstring":""}
{"repo":"fountain","file":"BaseException.cj","path":"fountain/src/base/exception/BaseException.cj","code_tokens":"public func printStackTrace ( exception : Exception , writer : OutputStream ) : Unit {   var trace = StringBuilder ( ) NL trace . append ( An exception has occured:  ) NL trace . append ( exception . toString ( ) ) NL trace . append ( \\n ) NL  let stacks = exception . getStackTrace ( ) NL  var i = 0 NL  let size = stacks . size NL while ( i < size ) {   let stack = stacks [ i ] NL trace . append (          at  ) . append ( String . fromUtf8 ( stack . declaringClass ) ) . append (   ) . append ( String . fromUtf8 ( stack . methodName ) ) . append ( ( ) . append ( String . fromUtf8 ( stack . fileName ) ) . append ( :  ) . append ( stack . lineNumber ) . append ( )\\n ) NL i ++ NL } NL writer . write ( trace . toString ( ) . toUtf8Array ( ) ) NL }","func_name":"printStackTrace","docstring":""}
{"repo":"fountain","file":"BaseException.cj","path":"fountain/src/base/exception/BaseException.cj","code_tokens":"public func addSuppressed ( suppressed : Exception ) : Unit {  this . suppressed_ . append ( suppressed ) NL }","func_name":"addSuppressed","docstring":""}
{"repo":"fountain","file":"BaseException.cj","path":"fountain/src/base/exception/BaseException.cj","code_tokens":"public func printStackTrace ( writer : OutputStream ) : Unit {  printStackTrace ( this , writer ) NL  let causedBy = Caused by:  . toUtf8Array ( ) NL if ( let Some ( c ) = caused ) {  writer . write ( causedBy ) NL if ( let Some ( cp ) = c as BaseException ) {  cp . printStackTrace ( writer ) NL } else {  printStackTrace ( c , writer ) NL } NL } NL if ( ! suppressed . isEmpty ( ) ) {  writer . write ( Suppressed: \\n . toUtf8Array ( ) ) NL } NL for ( s in suppressed ) {  if ( let Some ( se ) = s as BaseException ) {  se . printStackTrace ( writer ) NL } else {  printStackTrace ( s , writer ) NL } NL } NL }","func_name":"printStackTrace","docstring":""}
{"repo":"fountain","file":"IndexedPriority.cj","path":"fountain/src/cache/IndexedPriority.cj","code_tokens":"public func compare ( other : IndexedPriority < V > ) {  this . priority . compare ( other . priority ) NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"static public func builder ( ) : HeapCacheBuilder < V > {  return HeapCacheBuilder < V > ( ) NL }","func_name":"builder","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"private func checkOrRemove ( maxLife : Duration , maxSize : Int64 ) : Unit {  timer . reset ( CHECK_DURATION ) {  let iterator = ( store . iterator ( ) as ConcurrentHashMapIterator < String , Priority < V > > ) . getOrThrow ( ) NL checkTimeout ( maxLife , iterator ) NL checkOverSize ( maxSize , iterator ) NL checkOrRemove ( maxLife , maxSize ) NL } NL }","func_name":"checkOrRemove","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"private func checkTimeout ( maxLife : Duration , iterator : ConcurrentHashMapIterator < String , Priority < V > > ) : Unit {   let itrs = iterator . segmentIterators ( ) NL  let latch = CountDownLatch ( count : itrs . size ) NL for ( itr in itrs ) {  spawn { for ( entry in itr ) {  if ( Time . since ( entry [ 1 ] . lastUsedTime ) > = maxLife ) {  remove ( entry [ 0 ] ) NL } NL } NL latch . countDown ( ) NL } NL } NL latch . await ( ) NL }","func_name":"checkTimeout","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"private func checkOverSize ( maxSize : Int64 , iterator : ConcurrentHashMapIterator < String , Priority < V > > ) : Unit {  while ( store . size > maxSize ) {   let segmItrs = iterator . segmentIterators ( ) NL  var segmItrMap = HashMap < Int64 , Iterator < ( String , Priority < V > ) > > ( ) NL  var i = 0 NL  let currentVals = PriorityQueue < IndexedPriority < V > > . create < IndexedPriority < V > > ( ) NL for ( segmItr in segmItrs ) {   let entry = segmItr . next ( ) NL if ( let Some ( e ) = entry ) {  segmItrMap [ i ] = segmItr NL  let p : Priority < V > = e [ 1 ] NL  let idxp : IndexedPriority < V > = IndexedPriority < V > ( i , p ) NL currentVals . offer ( idxp ) NL } NL i ++ NL } NL while ( store . size > maxSize ) {   var minIdx = - 1 NL if ( let Some ( p ) = currentVals . poll ( ) ) {  remove ( p . key ) NL minIdx = p . index NL } NL if ( minIdx < 0 ) {  throw UnreachableException ( ) NL } else if ( let Some ( segm ) = segmItrMap . get ( minIdx ) ) {  if ( let Some ( next ) = segm . next ( ) ) {  currentVals . offer ( IndexedPriority < V > ( minIdx , next [ 1 ] ) ) NL } else {  segmItrMap . remove ( minIdx ) NL ( ) NL } NL } NL } NL } NL }","func_name":"checkOverSize","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"public func get ( key : String ) : Option < V > {  return extractValue ( store . get ( key ) ) NL }","func_name":"get","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"public func set ( key : String , value : V ) : Unit {   let opt = store . get ( key ) NL if ( let Some ( p ) = opt ) {  p . store ( value ) NL } else {  store . put ( key , Priority < V > ( key , value ) ) NL ( ) NL } NL }","func_name":"set","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"public func getOrDefault ( key : String , default : V ) : V {  return get ( key ) ?? default NL }","func_name":"getOrDefault","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"public func getOrCompute ( key : String , callable : ( ) -> V ) : Option < V > {   let val = store . computeIfAbsent ( key ) { k => Priority < V > ( key , callable ( ) ) NL } NL return extractValue ( val ) NL }","func_name":"getOrCompute","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"public func remove ( key : String ) : Option < V > {  store . remove ( key ) ? . load ( ) NL }","func_name":"remove","docstring":""}
{"repo":"fountain","file":"HeapCache.cj","path":"fountain/src/cache/HeapCache.cj","code_tokens":"private func extractValue ( priority : Option < Priority < V > > ) : Option < V > {  if ( let Some ( p ) = priority ) {  return p . load ( ) NL } NL None < V > NL }","func_name":"extractValue","docstring":""}
{"repo":"fountain","file":"Priority.cj","path":"fountain/src/cache/Priority.cj","code_tokens":"public func compare ( other : Priority < V > ) : Ordering {  this . lastUsedTime . compare ( other . lastUsedTime ) NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"Priority.cj","path":"fountain/src/cache/Priority.cj","code_tokens":"protected open func incr ( ) {  ref . fetchAdd ( 1 ) NL lastUsed . store ( Time . now ( ) ) NL }","func_name":"incr","docstring":""}
{"repo":"fountain","file":"Priority.cj","path":"fountain/src/cache/Priority.cj","code_tokens":"public func load ( ) : V {  synchronized ( this ) {  incr ( ) NL return value . load ( ) NL } NL }","func_name":"load","docstring":""}
{"repo":"fountain","file":"Priority.cj","path":"fountain/src/cache/Priority.cj","code_tokens":"public func store ( value : V ) {  synchronized ( this ) {  this . value . store ( value ) NL incr ( ) NL } NL }","func_name":"store","docstring":""}
{"repo":"fountain","file":"HeapCacheBuilder.cj","path":"fountain/src/cache/HeapCacheBuilder.cj","code_tokens":"public func setMaxLife ( maxLife : Duration ) : HeapCacheBuilder < V > {  this . maxLife = maxLife NL return this NL }","func_name":"setMaxLife","docstring":""}
{"repo":"fountain","file":"HeapCacheBuilder.cj","path":"fountain/src/cache/HeapCacheBuilder.cj","code_tokens":"public func setConcurrencyLevel ( concurrencyLevel : Int64 ) : HeapCacheBuilder < V > {  this . concurrencyLevel = concurrencyLevel NL return this NL }","func_name":"setConcurrencyLevel","docstring":""}
{"repo":"fountain","file":"HeapCacheBuilder.cj","path":"fountain/src/cache/HeapCacheBuilder.cj","code_tokens":"public func setMaxSize ( maxSize : Int64 ) : HeapCacheBuilder < V > {  this . maxSize = maxSize NL this NL }","func_name":"setMaxSize","docstring":""}
{"repo":"fountain","file":"HeapCacheBuilder.cj","path":"fountain/src/cache/HeapCacheBuilder.cj","code_tokens":"public open func build ( ) : HeapCache < V > {  return HeapCache < V > ( concurrencyLevel : concurrencyLevel , maxLife : maxLife ) NL }","func_name":"build","docstring":""}
{"repo":"fountain","file":"TreeTransformer.cj","path":"fountain/src/util/TreeTransformer.cj","code_tokens":"func addChild ( child : T ) : Unit {  children . append ( child ) NL }","func_name":"addChild","docstring":""}
{"repo":"fountain","file":"TreeTransformer.cj","path":"fountain/src/util/TreeTransformer.cj","code_tokens":"func addChildren ( children : Iterable < T > ) {  for ( ch in children ) {  addChild ( ch ) NL } NL }","func_name":"addChildren","docstring":""}
{"repo":"fountain","file":"TreeTransformer.cj","path":"fountain/src/util/TreeTransformer.cj","code_tokens":"static func new ( ) : T","func_name":"new","docstring":""}
{"repo":"fountain","file":"TreeTransformer.cj","path":"fountain/src/util/TreeTransformer.cj","code_tokens":"public func transferTree < ID , S , T > ( iterable : Iterable < S > , emptyId : ID , transferFn ! : ( S ) -> Option < T > = { s => s as T NL } ) : ArrayList < T > where ID <: Hashable & Equatable < ID > , T <: TreeNode < ID , T > {   var map = HashMap < ID , T > ( ) NL  var root : T = T . new ( ) NL map . put ( emptyId , root ) NL  var list = ArrayList < T > ( ) NL for ( s in iterable ) {  if ( let Some ( t ) = transferFn ( s ) ) {  map . putIfNonExistent ( t . id , t ) NL list . append ( t ) NL } NL } NL for ( t in list ) {  map [ t . parentId ] . addChild ( t ) NL } NL return root . children NL }","func_name":"transferTree","docstring":""}
{"repo":"fountain","file":"Factory.cj","path":"fountain/src/util/Factory.cj","code_tokens":"func produce ( ) : O {  throw IllegalAccessException ( unimplemented ) NL }","func_name":"produce","docstring":""}
{"repo":"fountain","file":"Factory.cj","path":"fountain/src/util/Factory.cj","code_tokens":"func produce ( arg : A ) : O {  throw IllegalAccessException ( unimplemented ) NL }","func_name":"produce","docstring":""}
{"repo":"fountain","file":"Factory.cj","path":"fountain/src/util/Factory.cj","code_tokens":"public func assemble ( producer : Producer < A , O > ) : Unit {  producers . put ( producer . name , producer ) NL }","func_name":"assemble","docstring":""}
{"repo":"fountain","file":"Factory.cj","path":"fountain/src/util/Factory.cj","code_tokens":"public func assemble ( producers : Iterable < Producer < A , O > > ) : Unit {  for ( producer in producers ) {  assemble ( producer ) NL } NL }","func_name":"assemble","docstring":""}
{"repo":"fountain","file":"Factory.cj","path":"fountain/src/util/Factory.cj","code_tokens":"public func produce ( name : String ) : O {  producers [ name ] . produce ( ) NL }","func_name":"produce","docstring":""}
{"repo":"fountain","file":"Factory.cj","path":"fountain/src/util/Factory.cj","code_tokens":"public func produce ( name : String , arg : A ) : O {  producers [ name ] . produce ( arg ) NL }","func_name":"produce","docstring":""}
{"repo":"fountain","file":"StrategyPattern.cj","path":"fountain/src/util/StrategyPattern.cj","code_tokens":"func execute ( arg : A ) : R","func_name":"execute","docstring":"//执行策略"}
{"repo":"fountain","file":"StrategyPattern.cj","path":"fountain/src/util/StrategyPattern.cj","code_tokens":"public func register ( strategy : Strategy < N , A , R > ) : Strategies < N , A , R > {  strategies [ strategy . name ] = strategy NL this NL }","func_name":"register","docstring":"/*把指定策略注册进来*/"}
{"repo":"fountain","file":"StrategyPattern.cj","path":"fountain/src/util/StrategyPattern.cj","code_tokens":"public func register < S > ( strategies : Iterable < S > ) : Unit where S <: Strategy < N , A , R > {  for ( s in strategies ) {  this . strategies [ s . name ] = s NL } NL }","func_name":"register","docstring":"/*把指定策略注册进来*/"}
{"repo":"fountain","file":"StrategyPattern.cj","path":"fountain/src/util/StrategyPattern.cj","code_tokens":"public func execute ( name : N , arg : A ) : R {  match ( strategies . get ( name ) ) { case Some ( s ) => s . execute ( arg ) NL case _ => throw IllegalAccessException ( there is no strategy to match current condition ) NL } NL }","func_name":"execute","docstring":"//执行策略"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func parts ( path : String , withExtName : Bool ) : Array < String > {  return trimExt ( path , withExtName ) . split ( / ) NL }","func_name":"parts","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func trimExt ( path : String , withExtName : Bool ) : String {   var p = path NL if ( ! withExtName ) {   let idx = path . lastIndexOf ( . ) ?? - 1 NL if ( idx > 0 && idx > ( path . lastIndexOf ( / ) ?? - 1 ) && idx > ( path . lastIndexOf ( } ) ?? - 1 ) ) {  p = path . substring ( 0 , idx ) NL } NL } NL return p NL }","func_name":"trimExt","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func countWithoutDoubleStar ( path : String , withExtName : Bool ) : Int64 {  return parts ( #\"/\\*\\*\"# . regex ( ) . matcher ( path ) . replaceAll (  ) , true ) . size NL }","func_name":"countWithoutDoubleStar","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func getPathNode ( len : Int64 ) : PathNode {   func populateNode ( node : PathNode ) {  patterns [ len ] = node NL for ( i in 1 ..= len ) {  for ( tuple in originPatterns [ i ] ) {   let pattern = tuple [ 0 ] NL  let data = tuple [ 1 ] NL  let parts = this . parts ( pattern , true ) NL  let d = this . data ( data ) NL compile ( node , parts , d ) NL } NL } NL node NL } NL match ( patterns . get ( len ) ) { case Some ( node ) where ( node is NonePathNode ) =>  let node = PathNode ( ) NL populateNode ( node ) NL case Some ( node ) => node NL case _ =>  let node = PathNode ( ) NL populateNode ( node ) NL } NL }","func_name":"getPathNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func populateNode ( node : PathNode ) {  patterns [ len ] = node NL for ( i in 1 ..= len ) {  for ( tuple in originPatterns [ i ] ) {   let pattern = tuple [ 0 ] NL  let data = tuple [ 1 ] NL  let parts = this . parts ( pattern , true ) NL  let d = this . data ( data ) NL compile ( node , parts , d ) NL } NL } NL node NL }","func_name":"populateNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func compile ( pattern : String ) : PathPattern {  return compile ( pattern , ( ) ) NL }","func_name":"compile","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func compile ( pattern : String , data : Any ) : PathPattern {   var p = pattern NL p = #\"/\\{\\*(?=[a-zA-Z][A-Za-z0-9_]*\\})\"# . regex ( ) . matcher ( p ) . replaceAll ( /**/{ ) NL p = #\"/\\*{3,}\"# . regex ( ) . matcher ( p ) . replaceAll ( /** ) NL p = #\"(/\\*{2}){2,}\"# . regex ( ) . matcher ( p ) . replaceAll ( /** ) NL p = p . replace ( // , / ) NL if ( ! p . startsWith ( / ) ) {  p = / + p NL } NL  let d = this . data ( data ) NL  let parts = parts ( pattern , true ) NL if ( pattern . contains ( ** ) ) {   let count = countWithoutDoubleStar ( pattern , true ) NL while ( patterns . size < count + 1 ) {  patterns . append ( NonePathNode ( ) ) NL } NL while ( originPatterns . size < count + 1 ) {  originPatterns . append ( ArrayList < ( String , Any ) > ( ) ) NL } NL originPatterns [ count ] . append ( ( pattern , data ) ) NL for ( i in count .. patterns . size ) {   var node = patterns [ i ] NL if ( node is NonePathNode ) {  node = PathNode ( ) NL patterns [ i ] = node NL } NL compile ( node , parts , d ) NL } NL } NL  let prev = getPathNode ( parts . size ) NL return compile ( prev , parts , d ) NL }","func_name":"compile","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func compileIfAbsent < T > ( pattern : String , supplier : ( ) -> Option < T > ) : Option < T > {  match ( this . data < T > ( pattern ) ) { case None =>  let d = supplier ( ) NL compile ( pattern , d ) NL d NL case Some ( d ) => d NL } NL }","func_name":"compileIfAbsent","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func compile ( prev : PathNode , parts : Array < String > , data : Any ) : PathPattern {   var prev_ = prev NL for ( i in 0 .. parts . size ) {   let part = parts [ i ] NL prev_ = appendSubPathNode ( prev , part ) NL } NL prev_ . end = true NL prev_ . data ( data ) NL return this NL }","func_name":"compile","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func appendSubPathNode ( prev : PathNode , name : String ) : PathNode {  return prev . appendSubPathNode ( name ) . getOrThrow ( ) NL }","func_name":"appendSubPathNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func exrtractVariableInPath ( path : String , name : String ) : Option < String > {  return extractVariableInPath ( path , name , false ) NL }","func_name":"exrtractVariableInPath","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func extractVariableInPath ( path : String , name : String , withExtName : Bool ) : Option < String > {  return extractVariablesInPath ( path , withExtName ) . get ( name ) NL }","func_name":"extractVariableInPath","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func extractVariablesInPath ( path : String ) : Map < String , String > {  return extractVariablesInPath ( path , false ) NL }","func_name":"extractVariablesInPath","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func extractVariablesInPath ( path : String , withExtName : Bool ) : Map < String , String > {   let parts = this . parts ( path , withExtName ) NL  let variables = get < Map < Int64 , Any > > ( parts , Mode . EXTRACTION ) NL  let result = HashMap < String , String > ( ) NL match ( variables ) { case Some ( map ) => for ( tuple in map ) {  match ( tuple [ 1 ] ) { case name : String => result . put ( name , parts [ tuple [ 0 ] ] ) NL case node : ComplexPathNode => result . putAll ( node . extract ( parts [ tuple [ 0 ] ] ) ) NL case _ => ( ) NL } NL } NL result NL case _ => result NL } NL }","func_name":"extractVariablesInPath","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func extractTimeVariableInPath ( path : String , name : String , format : String ) : Option < Time > {  return extractTimeVariableInPath ( path , name , false , format ) NL }","func_name":"extractTimeVariableInPath","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func extractTimeVariableInPath ( path : String , name : String , withExtName : Bool , format : String ) : Option < Time > {   let value = extractVariableInPath ( path , name , withExtName ) NL match ( value ) { case Some ( v ) => Time . parse ( v , format ) NL case _ => None < Time > NL } NL }","func_name":"extractTimeVariableInPath","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func extractPasableVairableInPath < T > ( path : String , name : String ) : Option < T > where T <: Parsable < T > {  return extractPasableVariableInPath < T > ( path , name , false ) NL }","func_name":"extractPasableVairableInPath","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func extractPasableVariableInPath < T > ( path : String , name : String , withExtName : Bool ) : Option < T > where T <: Parsable < T > {   let value = extractVariableInPath ( path , name , withExtName ) NL match ( value ) { case Some ( v ) => T . parse ( v ) NL case _ => None < T > NL } NL }","func_name":"extractPasableVariableInPath","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func get < T > ( parts : Array < String > , mode : Mode ) : Option < T > {  return get < T > ( parts , mode , parts . size ) NL }","func_name":"get","docstring":"/**\n     * 想不到更漂亮的做法。\n     * 如果觉的这段代码很丑，可以参考学习一下航天飞机模式。\n     *\n     * @param parts\n     * @param mode\n     * @param <T>\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func get < T > ( parts : Array < String > , mode : Mode , len : Int64 ) : Option < T > {   var node : PathNode = getPathNode ( len ) NL  var prevDoubleStar : PathNode = NonePathNode . instance NL  var prevComplex : PathNode = NonePathNode . instance NL  var prevRegexPlaceholder : PathNode = NonePathNode . instance NL  var prevPlaceholder : PathNode = NonePathNode . instance NL  var endNode : PathNode = NonePathNode . instance NL  let variables : Map < Int64 , Any > = if ( let EXTRACTION = mode ) {  HashMap < Int64 , Any > ( ) NL } else {  EmptyMap < Int64 , Any > . instance NL } NL  var i = 0 NL while ( i < parts . size ) {   let part = parts [ i ] NL  var tmp : Option < PathNode > = node . getSub ( part ) NL if ( let Some ( n ) = tmp ) {  node = n NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL prevPlaceholder = NonePathNode . instance NL continue NL } NL tmp = node . getRegexPlaceholderNode ( part , prevRegexPlaceholder ) NL if ( let Some ( n ) = tmp ) {  node = n NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL prevDoubleStar = NonePathNode . instance NL prevPlaceholder = NonePathNode . instance NL if ( let EXTRACTION = mode ) {  variables . put ( i , node . name ) NL } NL continue NL } NL tmp = node . getPlaceholderNode ( prevPlaceholder ) NL if ( let Some ( n ) = tmp ) {  node = n NL prevPlaceholder = NonePathNode . instance NL prevDoubleStar = NonePathNode . instance NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL if ( let EXTRACTION = mode ) {  variables . put ( i , node . name ) NL } NL continue NL } NL tmp = node . getRegexNode ( part ) NL if ( let Some ( n ) = tmp ) {  node = n NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL prevPlaceholder = NonePathNode . instance NL continue NL } NL tmp = node . getComplexNode ( part , prevComplex ) NL if ( let Some ( n ) = tmp ) {  node = n NL prevPlaceholder = NonePathNode . instance NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL if ( let EXTRACTION = mode ) {  variables . put ( i , node ) NL } NL continue NL } NL tmp = node . getStarNode ( ) NL if ( let Some ( n ) = tmp ) {  node = n NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL prevPlaceholder = NonePathNode . instance NL continue NL } NL tmp = node . getDoubleStarNode ( ) NL if ( let Some ( n ) = tmp ) {  node = n NL prevDoubleStar = NonePathNode . instance NL prevPlaceholder = NonePathNode . instance NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL continue NL } NL  let end = node . end NL if ( end ) {  endNode = node NL } NL match ( node . prev ) { case Some ( n ) where n is PlaceholderPathNode => if ( let EXTRACTION = mode ) {  variables . remove ( i ) NL } NL i -= 2 NL prevPlaceholder = n NL if ( let Some ( ppn ) = prevPlaceholder . prev ) {  node = ppn NL } NL prevDoubleStar = NonePathNode . instance NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL case Some ( n ) where n is PlaceholderRegexPathNode => if ( let EXTRACTION = mode ) {  variables . remove ( i ) NL } NL i -= 2 NL prevRegexPlaceholder = n NL if ( let Some ( prpn ) = prevRegexPlaceholder . prev ) {  node = prpn NL } NL prevComplex = NonePathNode . instance NL prevDoubleStar = NonePathNode . instance NL prevPlaceholder = NonePathNode . instance NL case Some ( n ) where n is ComplexPathNode => if ( let EXTRACTION = mode ) {  variables . remove ( i ) NL } NL i -= 2 NL prevComplex = n NL if ( let Some ( pcn ) = prevComplex . prev ) {  node = pcn NL } NL prevRegexPlaceholder = NonePathNode . instance NL prevDoubleStar = NonePathNode . instance NL prevPlaceholder = NonePathNode . instance NL case _ where ! ( prevDoubleStar is NonePathNode || prevDoubleStar is NonePathNode ) => node = prevDoubleStar NL prevPlaceholder = NonePathNode . instance NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL continue NL case _ where node is DoubleStarPathNode => prevDoubleStar = node NL prevPlaceholder = NonePathNode . instance NL prevComplex = NonePathNode . instance NL prevRegexPlaceholder = NonePathNode . instance NL continue NL case _ where end && mode . prefix ( ) => node = endNode NL break NL case _ => return None < T > NL } NL i ++ NL } NL if ( let EXTRACTION = mode ) {  return variables as T NL } else {  return node as T NL } NL }","func_name":"get","docstring":"/**\n     * 想不到更漂亮的做法。\n     * 如果觉的这段代码很丑，可以参考学习一下航天飞机模式。\n     *\n     * @param parts\n     * @param mode\n     * @param <T>\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func matches ( path : String ) : Bool {  return matches ( path , false ) NL }","func_name":"matches","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func matches ( path : String , withExtName : Bool ) : Bool {   let node = get ( path , Mode . MATCHING , withExtName ) NL return matches ( node ) NL }","func_name":"matches","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func matchesPrefix ( path : String ) : Bool {   let node = get ( path , Mode . PREFIX , false ) NL return matches ( node ) NL }","func_name":"matchesPrefix","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func matches ( node : PathNode ) : Bool {  ( ! ( node is NonePathNode ) ) && node . end NL }","func_name":"matches","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func matches ( node : Option < PathNode > ) : Bool {  matches ( node ?? NonePathNode . instance ) NL }","func_name":"matches","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func data ( data : Any ) : Any {  match ( data ) { case opt : Option < Any > => match ( opt ) { case Some ( x ) => x NL case _ => ( ) NL } NL case _ => data NL } NL }","func_name":"data","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @param <T>\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func data < T > ( path : String ) : Option < T > {  return data < T > ( path , false ) NL }","func_name":"data","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @param <T>\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func data < T > ( path : String , withExtName : Bool ) : Option < T > {  get ( path , Mode . MATCHING , withExtName ) . data < T > ( ) NL }","func_name":"data","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @param <T>\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func dataByPrefix < T > ( path : String ) : Option < T > {  dataByPrefix < T > ( path , false ) NL }","func_name":"dataByPrefix","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public func dataByPrefix < T > ( path : String , withExtName : Bool ) : Option < T > {  get ( path , Mode . PREFIX , withExtName ) . data < T > ( ) NL }","func_name":"dataByPrefix","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private func get ( path : String , mode : Mode , withExtName : Bool ) : PathNode {   let parts = this . parts ( path , withExtName ) NL match ( mode ) { case PREFIX =>  var node = None < PathNode > NL  var len = parts . size NL do {  node = get < PathNode > ( parts , mode , len ) NL len -- NL } while ( len > 0 && ! matches ( node ) ) NL node NL case _ => get < PathNode > ( parts , mode ) NL } ?? NonePathNode . instance NL }","func_name":"get","docstring":"/**\n     * 想不到更漂亮的做法。\n     * 如果觉的这段代码很丑，可以参考学习一下航天飞机模式。\n     *\n     * @param parts\n     * @param mode\n     * @param <T>\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func matches ( value : String ) : Bool {  match ( this ) { case Some ( n ) => n . matches ( value ) NL case None => false NL } NL }","func_name":"matches","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func getSub ( name : String ) : Option < PathNode > {  return subs . get ( name ) NL }","func_name":"getSub","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func getComplexNode ( value : String , current : Option < PathNode > ) : Option < PathNode > {  if ( complexPathNodes . isEmpty ( ) ) {  return None < PathNode > NL } NL  let iterator = complexPathNodes . values ( ) . iterator ( ) NL  var node = None < PathNode > NL if ( current . none || ! ( current . getOrThrow ( ) is ComplexPathNode ) ) {  for ( n in iterator ) {  node = n NL if ( node . matches ( value ) ) {  return node NL } NL } NL } else {  for ( n in iterator ) {  if ( current != node ) {  node = n NL } else {  break NL } NL } NL for ( n in iterator ) {  node = n NL if ( node . matches ( value ) ) {  return node NL } NL } NL } NL return None < PathNode > NL }","func_name":"getComplexNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func getRegexPlaceholderNode ( value : String , current : Option < PathNode > ) : Option < PathNode > {  if ( regexPlaceholderPathNodes . isEmpty ( ) ) {  return None < PathNode > NL } NL  let iterator = regexPlaceholderPathNodes . values ( ) . iterator ( ) NL  var node = None < PathNode > NL if ( current . none || ! ( current . getOrThrow ( ) is PlaceholderRegexPathNode ) ) {  for ( n in iterator ) {  node = n NL if ( node . matches ( value ) ) {  return node NL } NL } NL } else {  for ( n in iterator ) {  if ( current != node ) {  node = n NL } else {  break NL } NL } NL for ( n in iterator ) {  node = n NL if ( node . matches ( value ) ) {  return node NL } NL } NL } NL return None < PathNode > NL }","func_name":"getRegexPlaceholderNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func getPlaceholderNode ( current : Option < PathNode > ) : Option < PathNode > {  if ( placeholderPathNodes . isEmpty ( ) ) {  return None < PathNode > NL } NL  let iterator = placeholderPathNodes . values ( ) . iterator ( ) NL if ( current . none || ! ( current . getOrThrow ( ) is PlaceholderPathNode ) ) {  return Options < PlaceholderPathNode , PathNode > . convert ( iterator . next ( ) ) NL } NL for ( n in iterator ) {  if ( n == current ) {  match ( iterator . next ( ) ) { case Some ( x ) => return x NL case _ => continue NL } NL } NL } NL return None < PathNode > NL }","func_name":"getPlaceholderNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func getRegexNode ( name : String ) : Option < PathNode > {  for ( n in regexPathNodes . values ( ) ) {  if ( n . matches ( name ) ) {  return n NL } NL } NL return None < PathNode > NL }","func_name":"getRegexNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func getStarNode ( ) : Option < PathNode > {  return starNode NL }","func_name":"getStarNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func getDoubleStarNode ( ) : Option < PathNode > {  return doubleStarNode NL }","func_name":"getDoubleStarNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func appendSub ( name : String ) : Option < PathNode > {  return subs . computeIfAbsent ( name ) { n => SubPathNode ( n , this ) NL } NL }","func_name":"appendSub","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func appendRegexNode ( name : String , protogenesis : Bool ) : Option < PathNode > {  regexPathNodes . computeIfAbsent ( name ) { n => RegexPathNode ( n , protogenesis , this ) NL } . getOrThrow ( ) NL }","func_name":"appendRegexNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func createPlaceholderRegexNodeIfAbsent ( name : String , reg : String , protogenesis : Bool ) : Option < PathNode > {  regexPlaceholderPathNodes . computeIfAbsent ( name ) { n => PlaceholderRegexPathNode ( n , reg , protogenesis , this ) NL } . getOrThrow ( ) NL }","func_name":"createPlaceholderRegexNodeIfAbsent","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func createStarNodeIfAbsent ( ) : Option < PathNode > {  if ( starNode . none ) {  starNode = StarPathNode ( this ) NL } NL return starNode NL }","func_name":"createStarNodeIfAbsent","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func createDoubleStarNodeIfAbsent ( ) : Option < PathNode > {  if ( doubleStarNode . none ) {  doubleStarNode = DoubleStarPathNode ( this ) NL } NL return doubleStarNode NL }","func_name":"createDoubleStarNodeIfAbsent","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func createPlaceholderNodeIfAbsent ( name : String ) : Option < PathNode > {  placeholderPathNodes . computeIfAbsent ( name ) { n => PlaceholderPathNode ( n , this ) NL } . getOrThrow ( ) NL }","func_name":"createPlaceholderNodeIfAbsent","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func createComplexPathNode ( name : String ) : Option < PathNode > {  complexPathNodes . computeIfAbsent ( name ) { n => ComplexPathNode ( n , this ) NL } . getOrThrow ( ) NL }","func_name":"createComplexPathNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func appendSubPathNode ( name : String ) : Option < PathNode > {  match ( name ) { case * => this . createStarNodeIfAbsent ( ) NL case ** => this . createDoubleStarNodeIfAbsent ( ) NL case _ => if ( #\"^\\{#regex:.+\\}$\"# . regex ( ) . matches ( name ) . some ) {   let idx = ( name . indexOf ( : ) ?? - 1 ) + 1 NL  let n = name . substring ( idx , name . size - idx ) NL this . appendRegexNode ( n , true ) NL } else if ( #\"^\\{[a-zA-Z_]+\\w*:.+\\}$\"# . regex ( ) . matches ( name ) . some ) {   let idx = ( name . indexOf ( : ) ?? - 1 ) + 1 NL  let reg = name . substring ( idx , name . size - idx ) NL  let n = name . substring ( 1 , idx ) NL this . createPlaceholderRegexNodeIfAbsent ( n , reg , true ) NL } else if ( #\"^\\{[a-zA-Z_]+\\w*\\}$\"# . regex ( ) . matches ( name ) . some ) {  return this . createPlaceholderNodeIfAbsent ( name . substring ( 1 , name . size - 1 ) ) NL } else if ( #\"^(.*\\{[a-zA-Z_]+\\w*\\}.*)+$\"# . regex ( ) . matches ( name ) . some ) {  return this . createComplexPathNode ( name ) NL } else if ( name . contains ( * ) || name . contains ( ? ) ) {  return this . appendRegexNode ( name , false ) NL } else {  return this . appendSub ( name ) NL } NL } NL }","func_name":"appendSubPathNode","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func data ( data : Any ) : Unit {  this . data_ = data NL }","func_name":"data","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @param <T>\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func data < T > ( ) : Option < T > {  match ( data_ ) { case Some ( x ) => x as T NL case _ => None NL } NL }","func_name":"data","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @param <T>\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"open operator func == ( o : Any ) : Bool {  match ( o ) { case x : PathNode => name == x . name NL case x : String => name == x NL case opt : Option < PathNode > => match ( opt ) { case Some ( x ) => name == x . name NL case _ => false NL } NL case opt : Option < String > => match ( opt ) { case Some ( x ) => name == x NL case _ => false NL } NL case _ => false NL } NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public operator func == ( node : PathNode ) : Bool {  name == node . name NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"public operator func != ( node : PathNode ) : Bool {  name != node . name NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"open func matches ( value : String ) : Bool {  return this == value NL }","func_name":"matches","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"operator func == ( o : Any ) : Bool {  o is NonePathNode || ( o as Option < NonePathNode > ) . some NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"operator func == ( o : Any ) : Bool {  o is DoubleStarPathNode || o is StarPathNode || o is String || ( ( o is Option < DoubleStarPathNode > || o is Option < StarPathNode > || o is Option < String > ) && ( o as Option < Any > ) . some ) NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"operator func == ( o : Any ) {  o is DoubleStarPathNode || o is StarPathNode || o is String || ( ( o is Option < DoubleStarPathNode > || o is Option < StarPathNode > || o is Option < String > ) && ( o as Option < Any > ) . some ) NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func matches ( name : String ) {  return reg . matcher ( name ) . matches ( ) NL }","func_name":"matches","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"operator func == ( o : Any ) : Bool {  o is PlaceholderPathNode || o is String || ( ( o is Option < PlaceholderPathNode > || o is Option < String > ) && ( o as Option < Any > ) . some ) NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func matches ( name : String ) {  return this == name NL }","func_name":"matches","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"static private func compile ( name : String , patterns : ArrayList < PathNode > ) : Regex {   var start = 0 NL  var len = name . size NL  var part : String NL  let parts = ArrayList < String > ( ) NL  let tmp = PathNode ( ) NL  var i = 0 NL while ( i < len ) {   let c = name . charAt ( i ) NL if ( c == { ) {  patterns . append ( appendPart ( tmp , parts , name , start , i ) . getOrThrow ( ) ) NL  let end = name . indexOf ( } , i + 1 ) ?? - 1 NL patterns . append ( appendPart ( tmp , parts , name , i , end + 1 ) . getOrThrow ( ) ) NL i = end NL start = i + 1 NL } NL i ++ NL } NL if ( start < len ) {  part = name . substring ( start ) NL patterns . append ( tmp . appendSubPathNode ( part ) . getOrThrow ( ) ) NL } NL ^(${String.join(parts.toArray(), delimiter: \")(\")})$ . regex ( ) NL }","func_name":"compile","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"static private func appendPart ( tmp : PathNode , parts : ArrayList < String > , name : String , start : Int64 , end : Int64 ) : Option < PathNode > {   let part = name . substring ( start , end + 1 - start ) NL  let node = tmp . appendSubPathNode ( part ) NL if ( node is SubPathNode ) {  parts . append ( part ) NL } else {  parts . append ( .+? ) NL } NL node NL }","func_name":"appendPart","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func matches ( value : String ) : Bool {  for ( i in 0 .. patterns . size ) {   let node = patterns [ i ] NL if ( node is SubPathNode || node is RegexPathNode ) {  match ( reg . matcher ( value ) . find ( ) ) { case Some ( md ) where node . matches ( md . matchStr ( i + 1 ) ) => return false NL case _ => continue NL } NL } NL } NL return true NL }","func_name":"matches","docstring":"/**\n     * 不包含路径中的扩展名\n     * @param path\n     * @return\n     */"}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func extract ( value : String ) : Map < String , String > {   let datas = HashMap < String , String > ( ) NL  var matches = true NL for ( i in 0 .. patterns . size ) {   let node = patterns [ i ] NL if ( node is PlaceholderPathNode || node is PlaceholderRegexPathNode ) {   let matcher = reg . matcher ( value ) NL match ( matcher . find ( ) ) { case None => matches = false NL break NL case Some ( md ) =>  let part = md . matchStr ( i + 1 ) NL if ( node . matches ( part ) ) {   let name = node . name NL datas . put ( name , part ) NL } else {  matches = false NL break NL } NL } NL } NL } NL if ( ! matches ) {  datas . clear ( ) NL } NL return datas NL }","func_name":"extract","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"private operator func == ( mode : Mode ) {  match ( ( this , mode ) ) { case ( MATCHING , MATCHING ) | ( EXTRACTION , EXTRACTION ) | ( PREFIX , PREFIX ) => true NL case _ => false NL } NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func matching ( ) : Bool {  return this == MATCHING NL }","func_name":"matching","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func extraction ( ) : Bool {  return this == EXTRACTION NL }","func_name":"extraction","docstring":""}
{"repo":"fountain","file":"PathPattern.cj","path":"fountain/src/util/PathPattern.cj","code_tokens":"func prefix ( ) : Bool {  return this == PREFIX NL }","func_name":"prefix","docstring":""}
{"repo":"fountain","file":"Utils.cj","path":"fountain/src/util/Utils.cj","code_tokens":"public func computeBytes ( size : String ) : Option < Int64 > {   let sizeRegex = #\"^(\\d+)([kmgtpezyKMGTPEZY]?)[bB]?$\"# . regex ( solid : true ) NL  let matched = sizeRegex . matches ( size ) . getOrThrow ( ) NL  let num = Int64 . parse ( matched . matchStr ( 1 ) ) NL if ( matched . groupNumber ( ) > = 2 ) {   let unit = matched . matchStr ( 2 ) NL return computeBytes ( num , unit ) NL } NL return num NL }","func_name":"computeBytes","docstring":"//compute parameter such as 123KB 24M etc。 to a UInt64, "}
{"repo":"fountain","file":"Utils.cj","path":"fountain/src/util/Utils.cj","code_tokens":"public func computeBytes ( n : Int64 , unit : String ) : Option < Int64 > {  if ( unit . equalsIgnoreCase ( b ) ) {  n NL } else if ( unit . equalsIgnoreCase ( k ) || unit . equalsIgnoreCase ( kb ) ) {  n * 1024 NL } else if ( unit . equalsIgnoreCase ( m ) || unit . equalsIgnoreCase ( mb ) ) {  n * 1024 * 1024 NL } else if ( unit . equalsIgnoreCase ( g ) || unit . equalsIgnoreCase ( gb ) ) {  n * 1024 * 1024 * 1024 NL } else if ( unit . equalsIgnoreCase ( t ) || unit . equalsIgnoreCase ( tb ) ) {  n * 1024 * 1024 * 1024 * 1024 NL } else if ( unit . equalsIgnoreCase ( p ) || unit . equalsIgnoreCase ( pb ) ) {  n * 1024 * 1024 * 1024 * 1024 * 1024 NL } else if ( unit . equalsIgnoreCase ( e ) || unit . equalsIgnoreCase ( eb ) ) {  n * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 NL } else if ( unit . equalsIgnoreCase ( z ) || unit . equalsIgnoreCase ( zb ) ) {  n * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 NL } else if ( unit . equalsIgnoreCase ( y ) || unit . equalsIgnoreCase ( yb ) ) {  n * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 NL } NL throw IllegalArgumentException ( not supported byte unit: ${unit} ) NL }","func_name":"computeBytes","docstring":"//compute parameter such as 123KB 24M etc。 to a UInt64, "}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static private func convertCharToByte ( c : Int64 ) : Byte {  convertCharToByte ( toBase64 [ c ] ) NL }","func_name":"convertCharToByte","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static private func convertCharToByte ( c : Char ) : Byte {  UInt8 ( UInt32 ( c ) ) NL }","func_name":"convertCharToByte","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static private func encode ( data : Array < Byte > ) : ByteArrayStream {   let bytes = ByteArrayStream ( ) NL  let input : InputStream = ByteCollectionInputStream ( data ) NL encode ( input , bytes ) NL bytes NL }","func_name":"encode","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func encode ( input : InputStream , output : OutputStream ) : Unit {   let bufout = BufferedOutputStream ( output ) NL  let bufsize = 128 NL  var buf = Array < Byte > ( bufsize , item : 0 ) NL  var enc = Array < Byte > ( 4 , item : 0 ) NL  var resultLen = 0 NL  var tmp = 0 NL  var bufLen = input . read ( buf ) NL while ( bufLen > 0 ) {   var i = 0 NL while ( i < bufLen ) {   var b = buf [ i ] NL match ( resultLen % 4 ) { case 0 => enc [ 0 ] = convertCharToByte ( Int64 ( b ) >> 2 ) NL tmp = Int64 ( b << 6 ) >> 2 NL resultLen ++ NL case 1 => enc [ 1 ] = convertCharToByte ( tmp | ( Int64 ( b ) >> 4 ) ) NL tmp == Int64 ( b << 4 ) >> 2 NL resultLen ++ NL case 2 => enc [ 2 ] = convertCharToByte ( tmp | ( Int64 ( b ) >> 6 ) ) NL tmp == Int64 ( b << 2 ) >> 2 NL enc [ 3 ] = convertCharToByte ( tmp ) NL bufout . write ( enc ) NL resultLen += 2 NL case _ => throw UnreachableException ( ${resultLen} ${tmp} ${enc} ) NL } NL i ++ NL } NL bufLen = input . read ( buf ) NL } NL match ( resultLen % 4 ) { case 0 => ( ) NL case 1 => enc [ 1 ] = convertCharToByte ( tmp ) NL bufout . write ( enc . slice ( 0 , 2 ) ) NL bufout . write ( [ tailSymbol , tailSymbol ] ) NL case 2 => enc [ 2 ] = convertCharToByte ( tmp ) NL bufout . write ( enc . slice ( 0 , 3 ) ) NL bufout . write ( [ tailSymbol ] ) NL case _ => throw UnreachableException ( ${resultLen} ${tmp} ${enc} ) NL } NL bufout . flush ( ) NL }","func_name":"encode","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func encodeToOutputStream ( data : Array < Byte > , output : OutputStream ) : Unit {  encode ( ByteCollectionInputStream ( data ) , output ) NL }","func_name":"encodeToOutputStream","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func encodeToBytes ( data : Array < Byte > ) : Array < Byte > {  encode ( data ) . readToEnd ( ) NL }","func_name":"encodeToBytes","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func encodeToString ( data : Array < Byte > ) : String {  String . fromUtf8 ( encodeToBytes ( data ) ) NL }","func_name":"encodeToString","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func encodeToOutputStream ( data : String , output : OutputStream ) : Unit {  encodeToOutputStream ( data . toUtf8Array ( ) , output ) NL }","func_name":"encodeToOutputStream","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func encodeToBytes ( data : String ) : Array < Byte > {  encodeToBytes ( data . toUtf8Array ( ) ) NL }","func_name":"encodeToBytes","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func encodeToString ( data : String ) : String {  String . fromUtf8 ( encodeToBytes ( data ) ) NL }","func_name":"encodeToString","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static private func decode ( data : Array < Byte > ) : ByteArrayStream {   let bytes = ByteArrayStream ( ) NL  let input : InputStream = ByteCollectionInputStream ( data ) NL decode ( input , bytes ) NL bytes NL }","func_name":"decode","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func decode ( input : InputStream , output : OutputStream ) : Unit {   let bufout = BufferedOutputStream ( output ) NL  let bufsize = 128 NL  var buf = Array < Byte > ( bufsize , item : 0 ) NL  var dec = Array < Byte > ( 3 , item : 0 ) NL  var resultLen = 0 NL  var bufLen = input . read ( buf ) NL while ( bufLen > 0 ) {   var i = 0 NL while ( i < bufLen ) {   var b = buf [ i ] NL if ( b == tailSymbol ) {   let mod = resultLen % 4 NL if ( i + 1 == bufLen && mod == 2 ) {  input . read ( Array < Byte > ( 1 , item : 0 ) ) NL } NL if ( mod != 3 ) {  bufout . write ( dec . slice ( 0 , 3 - mod ) ) NL } NL bufout . flush ( ) NL return NL } NL  let idx = fromBase64 [ b ] NL match ( resultLen % 4 ) { case 0 => dec [ 0 ] = idx << 2 NL case 1 => dec [ 0 ] |= idx >> 4 NL dec [ 1 ] = idx << 4 NL case 2 => dec [ 1 ] |= idx >> 2 NL dec [ 2 ] = idx << 6 NL case 3 => dec [ 2 ] |= idx NL bufout . write ( dec ) NL case _ => throw UnreachableException ( ) NL } NL i ++ NL resultLen ++ NL } NL bufLen = input . read ( buf ) NL } NL bufout . flush ( ) NL }","func_name":"decode","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func decodeToOutputStream ( data : Array < Byte > , output : OutputStream ) : Unit {  decode ( ByteCollectionInputStream ( data ) , output ) NL }","func_name":"decodeToOutputStream","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func decodeToBytes ( data : Array < Byte > ) : Array < Byte > {  decode ( data ) . readToEnd ( ) NL }","func_name":"decodeToBytes","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func decodeToString ( data : Array < Byte > ) : String {  String . fromUtf8 ( decodeToBytes ( data ) ) NL }","func_name":"decodeToString","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func decodeToOutputStream ( data : String , output : OutputStream ) : Unit {  decodeToOutputStream ( data . toUtf8Array ( ) , output ) NL }","func_name":"decodeToOutputStream","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func decodeToBytes ( data : String ) : Array < Byte > {  decodeToBytes ( data . toUtf8Array ( ) ) NL }","func_name":"decodeToBytes","docstring":""}
{"repo":"fountain","file":"Base64.cj","path":"fountain/src/util/Base64.cj","code_tokens":"static public func decodeToString ( data : String ) : String {  String . fromUtf8 ( decodeToBytes ( data ) ) NL }","func_name":"decodeToString","docstring":""}
{"repo":"fountain","file":"ResposibilityChain.cj","path":"fountain/src/util/ResposibilityChain.cj","code_tokens":"func check ( condition : C ) : Bool","func_name":"check","docstring":"//检查指定条件是否满足执行当前策略的要求"}
{"repo":"fountain","file":"ResposibilityChain.cj","path":"fountain/src/util/ResposibilityChain.cj","code_tokens":"func execute ( arg : A ) : R","func_name":"execute","docstring":"//执行当前策略"}
{"repo":"fountain","file":"ResposibilityChain.cj","path":"fountain/src/util/ResposibilityChain.cj","code_tokens":"func execute ( arg : A ) : Unit {  }","func_name":"execute","docstring":"//执行当前策略"}
{"repo":"fountain","file":"ResposibilityChain.cj","path":"fountain/src/util/ResposibilityChain.cj","code_tokens":"public func register ( resposibility : Resposibility < C , A , R > ) : ResposibilityChain < C , A , R > {  resposibilities . append ( resposibility ) NL this NL }","func_name":"register","docstring":"//注册一个策略"}
{"repo":"fountain","file":"ResposibilityChain.cj","path":"fountain/src/util/ResposibilityChain.cj","code_tokens":"public func register < S > ( resposibilities : Iterable < S > ) : Unit where S <: Resposibility < C , A , R > {  this . resposibilities . appendAll ( IterableConverter < S , Resposibility < C , A , R > > ( resposibilities , throwIfNotMatch : true ) ) NL }","func_name":"register","docstring":"//注册一个策略"}
{"repo":"fountain","file":"ResposibilityChain.cj","path":"fountain/src/util/ResposibilityChain.cj","code_tokens":"public func execute ( condition : C , arg : A ) : R {  for ( r in resposibilities ) {  if ( r . check ( condition ) ) {  return r . execute ( arg ) NL } NL } NL throw IllegalAccessException ( there is no strategy to match current condition ) NL }","func_name":"execute","docstring":"//执行当前策略"}
{"repo":"fountain","file":"ResposibilityChain.cj","path":"fountain/src/util/ResposibilityChain.cj","code_tokens":"public func executeAll ( condition : C , arg : A ) : Unit {  for ( r in resposibilities where r . check ( condition ) ) {  r . execute ( arg ) NL } NL }","func_name":"executeAll","docstring":""}
{"repo":"fountain","file":"async.cj","path":"fountain/src/util/async/async.cj","code_tokens":"public func async < T , C > ( callable : ( ) -> ( T , C ) ) : Future < Result < T , C > > {  spawn { try {   let result = callable ( ) NL return Result . Success ( result [ 0 ] , result [ 1 ] ) NL } catch ( e : Exception ) {  asyncLogger . error ( e ) NL return Result . Thrown ( e ) NL } NL } NL }","func_name":"async","docstring":"//a wrapper of thread, a Exception thrown from callable will be catched and returned as Result.Thrown(Exception)"}
{"repo":"fountain","file":"async.cj","path":"fountain/src/util/async/async.cj","code_tokens":"public func async < T > ( callable : ( ) -> T ) : Future < Result < T , Unit > > {  return async < T , Unit > { return ( callable ( ) , ( ) ) NL } NL }","func_name":"async","docstring":"//a wrapper of thread, a Exception thrown from callable will be catched and returned as Result.Thrown(Exception)"}
{"repo":"fountain","file":"App.cj","path":"fountain/src/app/App.cj","code_tokens":"static public func startup ( configPathPrefix : String , startfn : ( ) -> Unit ) {  cfg = Config ( configPathPrefix ) NL startfn ( ) NL }","func_name":"startup","docstring":""}
{"repo":"fountain","file":"App.cj","path":"fountain/src/app/App.cj","code_tokens":"static public func startup ( configPathPrefix : String ) {  startup ( configPathPrefix ) { } NL }","func_name":"startup","docstring":""}
{"repo":"fountain","file":"App.cj","path":"fountain/src/app/App.cj","code_tokens":"static public func startup ( startfn : ( ) -> Unit ) {  startup (  , startfn ) NL }","func_name":"startup","docstring":""}
{"repo":"fountain","file":"App.cj","path":"fountain/src/app/App.cj","code_tokens":"static public func startup ( ) {  startup { } NL }","func_name":"startup","docstring":""}
{"repo":"fountain","file":"App.cj","path":"fountain/src/app/App.cj","code_tokens":"static public func addBeanFactory ( ) {   let factory = BeanFactory ( ) NL factory . setInherited ( beanFactory ) NL synchronized ( mutex ) {  beanFactory_ = factory NL } NL }","func_name":"addBeanFactory","docstring":""}
{"repo":"fountain","file":"TimeUnit.cj","path":"fountain/src/time/TimeUnit.cj","code_tokens":"static public func parse ( value : String ) : Option < TimeUnit > {  match ( value . toAsciiUpper ( ) ) { case NANOSECOND => Some ( NANOSECOND ) NL case MICROSECOND => Some ( MICROSECOND ) NL case MILLISECOND => Some ( MILLISECOND ) NL case SECOND => Some ( SECOND ) NL case MINUTE => Some ( MINUTE ) NL case HOUR => Some ( HOUR ) NL case DAY => Some ( DAY ) NL case WEEK => Some ( WEEK ) NL case MONTH => Some ( MONTH ) NL case YEAR => Some ( YEAR ) NL case _ => None < TimeUnit > NL } NL }","func_name":"parse","docstring":""}
{"repo":"fountain","file":"TimeUnit.cj","path":"fountain/src/time/TimeUnit.cj","code_tokens":"public func trim ( t : Time ) : Time {  match ( this ) { case NANOSECOND => t NL case MICROSECOND =>  let year = t . year ( ) NL  let month = t . month ( ) NL  let day = t . day ( ) NL  let hour = t . hour ( ) NL  let min = t . minute ( ) NL  let sec = t . second ( ) NL  let nano = ( t . nanosecond ( ) / 1000 ) * 1000 NL Time ( year , month , day , hour : hour , min : min , sec : sec , nsec : nano ) NL case MILLISECOND =>  let year = t . year ( ) NL  let month = t . month ( ) NL  let day = t . day ( ) NL  let hour = t . hour ( ) NL  let min = t . minute ( ) NL  let sec = t . second ( ) NL  let nano = ( t . nanosecond ( ) / 1000000 ) * 1000000 NL Time ( year , month , day , hour : hour , min : min , sec : sec , nsec : nano ) NL case SECOND =>  let year = t . year ( ) NL  let month = t . month ( ) NL  let day = t . day ( ) NL  let hour = t . hour ( ) NL  let min = t . minute ( ) NL  let sec = 0 NL  let nano = 0 NL Time ( year , month , day , hour : hour , min : min , sec : sec , nsec : nano ) NL case MINUTE =>  let year = t . year ( ) NL  let month = t . month ( ) NL  let day = t . day ( ) NL  let hour = t . hour ( ) NL  let min = 0 NL  let sec = 0 NL  let nano = 0 NL Time ( year , month , day , hour : hour , min : min , sec : sec , nsec : nano ) NL case HOUR =>  let year = t . year ( ) NL  let month = t . month ( ) NL  let day = t . day ( ) NL  let hour = 0 NL  let min = 0 NL  let sec = 0 NL  let nano = 0 NL Time ( year , month , day , hour : hour , min : min , sec : sec , nsec : nano ) NL case DAY =>  let year = t . year ( ) NL  let month = t . month ( ) NL  let day = 1 NL  let hour = 0 NL  let min = 0 NL  let sec = 0 NL  let nano = 0 NL Time ( year , month , day , hour : hour , min : min , sec : sec , nsec : nano ) NL case MONTH =>  let year = t . year ( ) NL  let month = Month . January NL  let day = 1 NL  let hour = 0 NL  let min = 0 NL  let sec = 0 NL  let nano = 0 NL Time ( year , month , day , hour : hour , min : min , sec : sec , nsec : nano ) NL case YEAR =>  let year = t . year ( ) NL  let month = Month . January NL  let day = 1 NL  let hour = 0 NL  let min = 0 NL  let sec = 0 NL  let nano = 0 NL Time ( year , month , day , hour : hour , min : min , sec : sec , nsec : nano ) NL case WEEK =>  var date = t NL  let weekday = date . weekDay ( ) . value ( ) NL date = date . addDays ( - weekday ) NL  let year = date . year ( ) NL  let month = date . month ( ) NL  let day = date . day ( ) NL  let hour = 0 NL  let min = 0 NL  let sec = 0 NL  let nano = 0 NL Time ( year , month , day , hour : hour , min : min , sec : sec , nsec : nano ) NL } NL }","func_name":"trim","docstring":""}
{"repo":"fountain","file":"TimeUnit.cj","path":"fountain/src/time/TimeUnit.cj","code_tokens":"public func ago ( duration : Int64 ) : Time {  before ( Time . now ( ) , duration ) NL }","func_name":"ago","docstring":""}
{"repo":"fountain","file":"TimeUnit.cj","path":"fountain/src/time/TimeUnit.cj","code_tokens":"public func before ( t : Time , duration : Int64 ) {  after ( t , - duration ) NL }","func_name":"before","docstring":""}
{"repo":"fountain","file":"TimeUnit.cj","path":"fountain/src/time/TimeUnit.cj","code_tokens":"public func later ( duration : Int64 ) : Time {  after ( Time . now ( ) , duration ) NL }","func_name":"later","docstring":""}
{"repo":"fountain","file":"TimeUnit.cj","path":"fountain/src/time/TimeUnit.cj","code_tokens":"public func after ( t : Time , duration : Int64 ) : Time {  match ( this ) { case YEAR => t . addDays ( duration , 0 , 0 ) NL case MONTH => t . addDays ( 0 , duration , 0 ) NL case DAY => t . addDays ( 0 , 0 , duration ) NL case WEEK => t . addDays ( 0 , 0 , duration * 7 ) NL case HOUR => t + Duration . hour ( duration ) NL case MINUTE => t + Duration . minute ( duration ) NL case SECOND => t + Duration . second ( duration ) NL case MILLISECOND => t + Duration . millisecond ( duration ) NL case MICROSECOND => t + Duration . microsecond ( duration ) NL case NANOSECOND => t + Duration . nanosecond ( duration ) NL } NL }","func_name":"after","docstring":""}
{"repo":"fountain","file":"TimeUnit.cj","path":"fountain/src/time/TimeUnit.cj","code_tokens":"public func duration ( n : Int64 ) : Option < Duration > {  match ( this ) { case NANOSECOND => Some ( Duration . nanosecond ( n ) ) NL case MICROSECOND => Some ( Duration . microsecond ( n ) ) NL case MILLISECOND => Some ( Duration . millisecond ( n ) ) NL case SECOND => Some ( Duration . second ( n ) ) NL case MINUTE => Some ( Duration . minute ( n ) ) NL case HOUR => Some ( Duration . hour ( n ) ) NL case DAY => Some ( Duration . day ( n ) ) NL case _ => None < Duration > NL } NL }","func_name":"duration","docstring":""}
{"repo":"fountain","file":"TimeUnit.cj","path":"fountain/src/time/TimeUnit.cj","code_tokens":"public func name ( ) : String {  toString ( ) NL }","func_name":"name","docstring":""}
{"repo":"fountain","file":"TimeUnit.cj","path":"fountain/src/time/TimeUnit.cj","code_tokens":"public func toString ( ) : String {  match ( this ) { case NANOSECOND => NANOSECOND NL case MICROSECOND => MICROSECOND NL case MILLISECOND => MILLISECOND NL case SECOND => SECOND NL case MINUTE => MINUTE NL case HOUR => HOUR NL case DAY => DAY NL case WEEK => WEEK NL case MONTH => MONTH NL case YEAR => YEAR NL } NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"TimeDuration.cj","path":"fountain/src/time/TimeDuration.cj","code_tokens":"public func before ( t : Time ) {  timeunit . before ( t , value ) NL }","func_name":"before","docstring":""}
{"repo":"fountain","file":"TimeDuration.cj","path":"fountain/src/time/TimeDuration.cj","code_tokens":"public func after ( t : Time ) {  timeunit . after ( t , value ) NL }","func_name":"after","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"static func day ( ) : Duration","func_name":"day","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"static func day ( n : Int64 ) : Duration","func_name":"day","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"func days ( ) : Int64","func_name":"days","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"func before ( current : Time ) : Time","func_name":"before","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"func after ( current : Time ) : Time","func_name":"after","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"static public func day ( ) : Duration {  return hour ( 24 ) NL }","func_name":"day","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"static public func day ( n : Int64 ) : Duration {  return hour ( n * 24 ) NL }","func_name":"day","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"public func days ( ) : Int64 {  return this . hours ( ) / 24 NL }","func_name":"days","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"public func before ( current : Time ) : Time {  return current - this NL }","func_name":"before","docstring":""}
{"repo":"fountain","file":"ExtendDuration.cj","path":"fountain/src/time/ExtendDuration.cj","code_tokens":"public func after ( current : Time ) : Time {  return current + this NL }","func_name":"after","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"func stopTask ( ) : Unit","func_name":"stopTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"func resetTask ( d : Duration ) : Unit","func_name":"resetTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"func resetTask ( d : Duration , fn : ( ) -> Unit ) : Unit","func_name":"resetTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"func resetTask ( d : Duration , fn : ( ) -> TimedStatus ) : Unit {  this . resetTask ( d ) { match ( fn ( ) ) { case Reset ( d ) => current . resetTask ( d , fn ) NL case Reset ( d , fn ) => current . resetTask ( d , fn ) NL case Stop => current . stopTask ( ) NL case None => ( ) NL } NL } NL }","func_name":"resetTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"func resetTask ( d : Duration , fn : ( T ) -> Unit ) : Unit {  this . resetTask ( d ) { fn ( current ) NL } NL }","func_name":"resetTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"static func start ( d : Duration , fn : ( ) -> TimedStatus ) : T","func_name":"start","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"static func start ( d : Duration , fn : ( T ) -> Unit ) : T","func_name":"start","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"public func stopTask ( ) : Unit {  stop ( ) NL }","func_name":"stopTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"public func resetTask ( d : Duration ) : Unit {  reset ( d ) NL }","func_name":"resetTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"public func resetTask ( d : Duration , fn : ( ) -> Unit ) : Unit {  reset ( d , fn ) NL }","func_name":"resetTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"static public func start ( d : Duration , fn : ( ) -> TimedStatus ) : Timer {   let timer = Timer ( Duration . nanosecond ( 0 ) ) { } NL timer . resetTask ( d , fn ) NL timer NL }","func_name":"start","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"static public func start ( d : Duration , fn : ( Timer ) -> Unit ) : Timer {   let timer = Timer ( Duration . nanosecond ( 0 ) ) { } NL timer . resetTask ( d , fn ) NL timer NL }","func_name":"start","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"public func stopTask ( ) : Unit {  stop ( ) NL }","func_name":"stopTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"public func resetTask ( d : Duration ) : Unit {  reset ( d ) NL }","func_name":"resetTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"public func resetTask ( d : Duration , fn : ( ) -> Unit ) : Unit {  reset ( d , fn ) NL }","func_name":"resetTask","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"static public func start ( d : Duration , fn : ( ) -> TimedStatus ) : Ticker {   let ticker = Ticker ( Duration . nanosecond ( 0 ) ) { } NL ticker . resetTask ( d , fn ) NL ticker NL }","func_name":"start","docstring":""}
{"repo":"fountain","file":"ExtendTimedTask.cj","path":"fountain/src/time/ExtendTimedTask.cj","code_tokens":"static public func start ( d : Duration , fn : ( Ticker ) -> Unit ) : Ticker {   let ticker = Ticker ( Duration . nanosecond ( 0 ) ) { } NL ticker . resetTask ( d , fn ) NL ticker NL }","func_name":"start","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func addYears ( years : Int64 ) : Time","func_name":"addYears","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func addMonths ( months : Int64 ) : Time","func_name":"addMonths","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func addDays ( days : Int64 ) : Time","func_name":"addDays","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func addHours ( hours : Int64 ) : Time","func_name":"addHours","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func addMinutes ( minutes : Int64 ) : Time","func_name":"addMinutes","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func addSeconds ( seconds : Int64 ) : Time","func_name":"addSeconds","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func addMillis ( millis : Int64 ) : Time","func_name":"addMillis","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func addMicros ( micros : Int64 ) : Time","func_name":"addMicros","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func addNanos ( nanos : Int64 ) : Time","func_name":"addNanos","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setYear ( year : Int64 ) : Time","func_name":"setYear","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setMonth ( month : Int64 ) : Time","func_name":"setMonth","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setMonth ( month : Month ) : Time","func_name":"setMonth","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setDay ( day : Int64 ) : Time","func_name":"setDay","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setHour ( hour : Int64 ) : Time","func_name":"setHour","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setMinute ( minute : Int64 ) : Time","func_name":"setMinute","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setSecond ( second : Int64 ) : Time","func_name":"setSecond","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setMillis ( millis : Int64 ) : Time","func_name":"setMillis","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setMicros ( micros : Int64 ) : Time","func_name":"setMicros","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"func setNanos ( nanos : Int64 ) : Time","func_name":"setNanos","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"static public func current ( timeunit : TimeUnit ) : Time {  timeunit . current NL }","func_name":"current","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func addYears ( years : Int64 ) : Time {  addDays ( years , 0 , 0 ) NL }","func_name":"addYears","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func addMonths ( months : Int64 ) : Time {  addDays ( 0 , months , 0 ) NL }","func_name":"addMonths","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func addDays ( days : Int64 ) : Time {  addDays ( 0 , 0 , days ) NL }","func_name":"addDays","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func addHours ( hours : Int64 ) : Time {  this + Duration . hour ( hours ) NL }","func_name":"addHours","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func addMinutes ( minutes : Int64 ) : Time {  this + Duration . minute ( minutes ) NL }","func_name":"addMinutes","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func addSeconds ( seconds : Int64 ) : Time {  this + Duration . second ( seconds ) NL }","func_name":"addSeconds","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func addMillis ( millis : Int64 ) : Time {  this + Duration . millisecond ( millis ) NL }","func_name":"addMillis","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func addMicros ( micros : Int64 ) : Time {  this + Duration . microsecond ( micros ) NL }","func_name":"addMicros","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func addNanos ( nanos : Int64 ) : Time {  this + Duration . nanosecond ( nanos ) NL }","func_name":"addNanos","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setYear ( year : Int64 ) : Time {   let ( y , _ , _ ) = Time . now ( ) . date ( ) NL addYears ( year - y ) NL }","func_name":"setYear","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setMonth ( month : Int64 ) : Time {   let ( _ , m , _ ) = Time . now ( ) . date ( ) NL addMonths ( month - m . value ( ) ) NL }","func_name":"setMonth","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setMonth ( month : Month ) : Time {   let ( _ , m , _ ) = Time . now ( ) . date ( ) NL addMonths ( month . value ( ) - m . value ( ) ) NL }","func_name":"setMonth","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setDay ( day : Int64 ) : Time {   let ( _ , _ , d ) = Time . now ( ) . date ( ) NL addDays ( day - d ) NL }","func_name":"setDay","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setHour ( hour : Int64 ) : Time {  addHours ( hour - this . hour ( ) ) NL }","func_name":"setHour","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setMinute ( minute : Int64 ) : Time {  addMinutes ( minute - this . minute ( ) ) NL }","func_name":"setMinute","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setSecond ( second : Int64 ) : Time {  addSeconds ( second - this . second ( ) ) NL }","func_name":"setSecond","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setMillis ( millis : Int64 ) : Time {  addMillis ( millis - nanosecond ( ) / 1000_000 ) NL }","func_name":"setMillis","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setMicros ( micros : Int64 ) : Time {  addMicros ( micros - nanosecond ( ) / 1000 ) NL }","func_name":"setMicros","docstring":""}
{"repo":"fountain","file":"ExtendTime.cj","path":"fountain/src/time/ExtendTime.cj","code_tokens":"public func setNanos ( nanos : Int64 ) : Time {  addNanos ( nanos - nanosecond ( ) ) NL }","func_name":"setNanos","docstring":""}
{"repo":"fountain","file":"CmdArgs.cj","path":"fountain/src/cmd/CmdArgs.cj","code_tokens":"public func contains ( name : String ) : Bool {  args . contains ( name ) NL }","func_name":"contains","docstring":""}
{"repo":"fountain","file":"CmdArgs.cj","path":"fountain/src/cmd/CmdArgs.cj","code_tokens":"public func getArgs ( name : String ) : Option < ArrayList < String > > {  args . get ( name ) NL }","func_name":"getArgs","docstring":""}
{"repo":"fountain","file":"CmdArgs.cj","path":"fountain/src/cmd/CmdArgs.cj","code_tokens":"public func getArg ( name : String ) : Option < String > {  if ( let Some ( list ) = getArgs ( name ) ) {  list . get ( 0 ) NL } NL None < String > NL }","func_name":"getArg","docstring":""}
{"repo":"fountain","file":"CmdArgs.cj","path":"fountain/src/cmd/CmdArgs.cj","code_tokens":"public func getAppName ( ) : String {  return appName NL }","func_name":"getAppName","docstring":""}
{"repo":"fountain","file":"CmdArgs.cj","path":"fountain/src/cmd/CmdArgs.cj","code_tokens":"public func getAppPath ( ) : String {  return appPath NL }","func_name":"getAppPath","docstring":""}
{"repo":"fountain","file":"CmdArgs.cj","path":"fountain/src/cmd/CmdArgs.cj","code_tokens":"public func getInt64Arg ( name : String ) : Option < Int64 > {  if ( let Some ( v ) = getArg ( name ) ) {  Int64 . parse ( v ) NL } NL None < Int64 > NL }","func_name":"getInt64Arg","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"func checkFn ( ) : Unit {  if ( isClosed ( ) ) {  return NL } NL queue . removeIf { o => ! checkThenDoOrDestroy ( o ) { } NL } NL  let size = currentSize . load ( ) NL if ( size < initSize ) {  creationEvent . put ( initSize - size ) NL } NL checkTimer . reset ( checkDuration , checkFn ) NL }","func_name":"checkFn","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"public func isClosed ( ) : Bool {  closed . load ( ) NL }","func_name":"isClosed","docstring":"//维持当前池有没有关闭的状态"}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"public func close ( ) : Unit {  checkTimer . stop ( ) NL closed . store ( true ) NL while ( true ) {  match ( queue . take ( timeout : 1 ) ) { case Some ( x ) => destroy ( x ) NL currentSize . fetchSub ( 1 ) NL case _ => break NL } NL } NL }","func_name":"close","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"public func getObject ( timeout ! : UInt64 = INFINITE_TIMEOUT ) : Option < T > {  if ( isClosed ( ) ) {  None < T > NL } NL  let timeoutDuration = Duration . nanosecond ( Int64 ( timeout ) ) NL  var remainder = Int64 ( timeout ) NL  let start = Time . now ( ) NL while ( ( timeout == INFINITE_TIMEOUT || remainder > 0 ) && ! isClosed ( ) ) {   let opt = queue . take ( timeout : UInt64 ( remainder ) ) NL if ( let Some ( o ) = opt ) {  if ( checker ( o ) ) {  return opt NL } else {  destroy ( o ) NL } NL } NL  let size = currentSize . load ( ) NL if ( size < initSize ) {  creationEvent . put ( initSize - size ) NL } else if ( size < maxSize ) {  creationEvent . put ( 1 ) NL } NL if ( timeout != INFINITE_TIMEOUT ) {  remainder = ( timeoutDuration - Time . since ( start ) ) . nanoseconds ( ) NL } NL } NL None < T > NL }","func_name":"getObject","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"public func returnObject ( object : T ) : Unit {  checkThenDoOrDestroy ( object ) { queue . offer ( object ) NL } NL }","func_name":"returnObject","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"public func call < R > ( timeout : UInt64 , fn : ( T ) -> ? R ) : ? R {   let o : T NL try {  o = getObject ( timeout : timeout ) . getOrThrow ( ) NL return fn ( o ) NL } finally {  returnObject ( o ) NL } NL }","func_name":"call","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"public func call < R > ( fn : ( T ) -> ? R ) : ? R {  call < R > ( INFINITE_TIMEOUT , fn ) NL }","func_name":"call","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"private func checkThenDoOrDestroy ( object : T , fn : ( ) -> Unit ) : Bool {  if ( currentSize . load ( ) < maxSize && ! closed . load ( ) && checker ( object ) ) {  fn ( ) NL true NL } else {  destroy ( object ) NL false NL } NL }","func_name":"checkThenDoOrDestroy","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"private func destroy ( object : T ) : Unit {  destroier ( object ) NL if ( logger . debugEnabled ) {  logger . debug ( One object destroied, current size of Pool is ${currentSize.subFetch(1)}. ) NL } else {  currentSize . fetchSub ( 1 ) NL } NL }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"private func make ( ) : T {   var result = None < T > NL  var retried = 0 NL while ( retried < creationRetries && ! isClosed ( ) ) {  try {   let object = creator ( ) NL if ( ! checker ( object ) ) {  destroier ( object ) NL retried ++ NL continue NL } NL if ( logger . debugEnabled ) {  logger . debug ( New object created, current size of Pool is ${currentSize.addFetch(1)}. ) NL } NL currentSize . fetchAdd ( 1 ) NL result = object NL break NL } catch ( e : Exception ) {  retried ++ NL logger . warn ( failure on initializing , e ) NL } NL } NL match ( result ) { case Some ( x ) => x NL case None < T > => throw PoolException ( object creation failed, tried ${retried} times, max attempts is ${creationRetries} and pool status is ${isClosed()}. ) NL } NL }","func_name":"make","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"func create ( ) : T","func_name":"create","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"func check ( v : T ) : Bool {  true NL }","func_name":"check","docstring":""}
{"repo":"fountain","file":"Pool.cj","path":"fountain/src/pool/Pool.cj","code_tokens":"func destroy ( v : T ) : Unit {  }","func_name":"destroy","docstring":""}
{"repo":"fountain","file":"CyclicBarrier.cj","path":"fountain/src/concurrent/CyclicBarrier.cj","code_tokens":"public func join ( timeout ! : UInt64 = INFINITE_TIMEOUT , toThrowOnTimeout ! : Bool = true ) {  synchronized ( monitor ) {  if ( count . load ( ) > 0 && count . subFetch ( 1 ) > 0 ) {  if ( ! monitor . wait ( timeout : timeout ) && toThrowOnTimeout ) {  throw TimeoutException ( ${timeout} ) NL } NL } else {  monitor . notifyAll ( ) NL } NL } NL }","func_name":"join","docstring":""}
{"repo":"fountain","file":"CyclicBarrier.cj","path":"fountain/src/concurrent/CyclicBarrier.cj","code_tokens":"public func incr ( ) {  synchronized ( monitor ) {  if ( count . load ( ) <= 0 ) {  throw ConcurrentException ( the count of CyclicBarrier has not been greater than zero. ) NL } NL count . fetchAdd ( 1 ) NL } NL }","func_name":"incr","docstring":""}
{"repo":"fountain","file":"CyclicBarrier.cj","path":"fountain/src/concurrent/CyclicBarrier.cj","code_tokens":"public func add ( quantity : Int64 ) {  if ( quantity <= 0 ) {  throw ConcurrentException ( quantity of added for CyclicBarrier must be greater than 0, but it is ${quantity} ) NL } NL synchronized ( monitor ) {  if ( count . load ( ) <= 0 ) {  throw ConcurrentException ( the count of CyclicBarrier has not been greater than zero. ) NL } NL this . count . fetchAdd ( quantity ) NL } NL }","func_name":"add","docstring":""}
{"repo":"fountain","file":"CountDownLatch.cj","path":"fountain/src/concurrent/CountDownLatch.cj","code_tokens":"public func countDown ( toThrowOnTimeout ! : Bool = true ) {  synchronized ( monitor ) {  if ( count . load ( ) <= 0 ) {  if ( toThrowOnTimeout ) {  throw ConcurrentException ( no thread is awaiting now ) NL } NL } else if ( count . subFetch ( 1 ) == 0 ) {  monitor . notifyAll ( ) NL } NL } NL }","func_name":"countDown","docstring":""}
{"repo":"fountain","file":"CountDownLatch.cj","path":"fountain/src/concurrent/CountDownLatch.cj","code_tokens":"public func await ( timeout ! : UInt64 = INFINITE_TIMEOUT , toThrowOnTimeout ! : Bool = true ) {  synchronized ( monitor ) {  if ( count . load ( ) > 0 ) {  if ( ! monitor . wait ( timeout : timeout ) && toThrowOnTimeout ) {  throw TimeoutException ( ${timeout} ) NL } NL } else {  monitor . notifyAll ( ) NL } NL return NL } NL }","func_name":"await","docstring":""}
{"repo":"fountain","file":"CountDownLatch.cj","path":"fountain/src/concurrent/CountDownLatch.cj","code_tokens":"public func incr ( ) {  synchronized ( monitor ) {  if ( count . load ( ) <= 0 ) {  throw ConcurrentException ( the count of CountDownLatch has not been greater than zero. ) NL } NL count . fetchAdd ( 1 ) NL } NL }","func_name":"incr","docstring":""}
{"repo":"fountain","file":"CountDownLatch.cj","path":"fountain/src/concurrent/CountDownLatch.cj","code_tokens":"public func add ( quantity : Int64 ) {  if ( quantity <= 0 ) {  throw ConcurrentException ( quantity of added for CountDownLatch must be greater than 0, but it is ${quantity} ) NL } NL synchronized ( monitor ) {  if ( count . load ( ) <= 0 ) {  throw ConcurrentException ( the count of CountDownLatch has not been greater than zero. ) NL } NL this . count . fetchAdd ( quantity ) NL } NL }","func_name":"add","docstring":""}
{"repo":"fountain","file":"MemoryFence.cj","path":"fountain/src/concurrent/MemoryFence.cj","code_tokens":"public func memoryFence < T > ( fn : ( ) -> T ) : T {  synchronized ( ReentrantMutex ( ) ) {  fn ( ) NL } NL }","func_name":"memoryFence","docstring":""}
{"repo":"fountain","file":"MemoryFence.cj","path":"fountain/src/concurrent/MemoryFence.cj","code_tokens":"public func memoryFence ( ) {  memoryFence < Unit > { spawn { } NL } NL }","func_name":"memoryFence","docstring":""}
{"repo":"fountain","file":"TimeoutableReentrantMutex.cj","path":"fountain/src/concurrent/TimeoutableReentrantMutex.cj","code_tokens":"public func tryLock < T > ( fn : ( ) -> T ) : T {  tryLock ( INFINITE_TIMEOUT , fn ) NL }","func_name":"tryLock","docstring":""}
{"repo":"fountain","file":"TimeoutableReentrantMutex.cj","path":"fountain/src/concurrent/TimeoutableReentrantMutex.cj","code_tokens":"public func tryLock < T > ( timeout : UInt64 , fn : ( ) -> T ) : T {   let callback : ( ) -> ExecutionStatus < T > = { => Executed < T > ( fn ( ) ) NL } NL  let executed = tryLock < T > ( timeout , true , callback ) NL match ( executed ) { case ( Some ( v ) , _ ) => v NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"tryLock","docstring":""}
{"repo":"fountain","file":"TimeoutableReentrantMutex.cj","path":"fountain/src/concurrent/TimeoutableReentrantMutex.cj","code_tokens":"public func tryLock < T > ( timeout : UInt64 , fn : ( ) -> ExecutionStatus < T > ) : Option < T > {  tryLock < T > ( timeout , true , fn ) [ 0 ] NL }","func_name":"tryLock","docstring":""}
{"repo":"fountain","file":"TimeoutableReentrantMutex.cj","path":"fountain/src/concurrent/TimeoutableReentrantMutex.cj","code_tokens":"public func tryLock < T > ( timeout : UInt64 , toThrowIfTimeout : Bool , fn : ( ) -> T ) : ( Option < T > , Bool ) {  tryLock < T > ( timeout , toThrowIfTimeout ) { Executed < T > ( fn ( ) ) NL } NL }","func_name":"tryLock","docstring":""}
{"repo":"fountain","file":"TimeoutableReentrantMutex.cj","path":"fountain/src/concurrent/TimeoutableReentrantMutex.cj","code_tokens":"public func tryLock < T > ( timeout : UInt64 , toThrowIfTimeout : Bool , fn : ( ) -> Option < T > ) : ( Option < T > , Bool ) {  tryLock < T > ( timeout , toThrowIfTimeout ) { match ( fn ( ) ) { case Some ( v ) => Executed < T > ( v ) NL case _ => Aborted NL } NL } NL }","func_name":"tryLock","docstring":""}
{"repo":"fountain","file":"TimeoutableReentrantMutex.cj","path":"fountain/src/concurrent/TimeoutableReentrantMutex.cj","code_tokens":"public func tryLock < T > ( timeout : UInt64 , toThrowIfTimeout : Bool , fn : ( ) -> ExecutionStatus < T > ) : ( Option < T > , Bool ) {   let timeoutDuration = Duration . nanosecond ( Int64 ( timeout ) ) NL  let start = Time . now ( ) NL do {  if ( locked . compareAndSwap ( false , true ) ) {  synchronized ( mutex ) {  try {  match ( fn ( ) ) { case Executed ( v ) => return ( Some ( v ) , true ) NL case Aborted => return ( None < T > , true ) NL case ToBeContinued => continue NL } NL } finally {  locked . store ( false ) NL } NL } NL } NL } while ( timeout == INFINITE_TIMEOUT || Time . since ( start ) < timeoutDuration ) NL if ( toThrowIfTimeout ) {  throw IllegalSynchronizationStateException ( to attempt locking is timeout ${timeout}ns ) NL } else {  ( None < T > , false ) NL } NL }","func_name":"tryLock","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func toString ( ) : String {  NoneState NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"func incrHoldings ( ) {  holdings . fetchAdd ( 1 ) NL }","func_name":"incrHoldings","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"func decrHoldings ( ) {  holdings . fetchSub ( 1 ) NL }","func_name":"decrHoldings","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func toString ( ) : String {  ReadingState(${holdings.load()}) NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func toString ( ) : String {  WritingState NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func compare ( other : State ) : Ordering {   let ( h1 , s1 ) = extract ( this ) NL  let ( h2 , s2 ) = extract ( other ) NL if ( s1 == 1 && s2 == 1 ) {  if ( h1 == h2 ) {  return Ordering . EQ NL } else if ( h1 < h2 ) {  return Ordering . LT NL } else {  return Ordering . GT NL } NL } else if ( s1 < s2 ) {  return Ordering . LT NL } else if ( s1 > s2 ) {  return Ordering . GT NL } else {  return Ordering . EQ NL } NL }","func_name":"compare","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"private func extract ( state : State ) : ( UInt64 , Int64 ) {  match ( state ) { case r : ReadingState => return ( r . currentHoldings , 1 ) NL case w : WritingState => return ( 0 , 2 ) NL case n : NoneState => return ( 0 , 0 ) NL case _ => throw UnreachableException ( ) NL } NL }","func_name":"extract","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"operator func == ( other : TryReadState ) {  match ( ( this , other ) ) { case ( Read , Read ) | ( NotRead , NotRead ) | ( Timeout , Timeout ) => true NL case _ => false NL } NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"private func doTryRead < T > ( retried : Int64 , timeout : UInt64 , start : ? Time , toThrowIfTimeout : Bool , callable : ( ) -> Option < T > ) : ( Option < T > , TryReadState ) {   func call ( ) : Bool {  match ( current . load ( ) ) { case r : ReadingState => r . incrHoldings ( ) NL true NL case n : NoneState => current . compareAndSwap ( n , ReadingState ( ) ) NL case _ => false NL } NL } NL  let tout = if ( retried == 0 ) {  timeout NL } else {   let since = UInt64 ( Time . since ( start . getOrThrow ( ) ) . nanoseconds ( ) ) NL if ( since < timeout ) {  timeout - since NL } else {  return ( None , Timeout ) NL } NL } NL  let asked = timeoutableMutex . tryLock < Bool > ( tout , toThrowIfTimeout , call ) NL  let canRead = match ( asked ) { case ( Some ( r ) , _ ) => r NL case ( None , x ) => return ( None , Timeout ) NL } NL if ( canRead ) {  try {  return ( callable ( ) , Read ) NL } finally {  synchronized ( mutex ) {   let currentState = current . load ( ) NL  var newState : State = State . NONE NL match ( currentState ) { case r : ReadingState => if ( r . currentHoldings > 1 ) {  r . decrHoldings ( ) NL newState = currentState NL } else if ( r . currentHoldings < 1 ) {  throw ReadWriteSyncerException ( current locked reading threads do not match ) NL } NL if ( ! current . compareAndSwap ( currentState , newState ) ) {  throw ReadWriteSyncerException ( current locked reading threads do not match ) NL } NL case _ => throw ReadWriteSyncerException ( current locked thread is not for reading ) NL } NL } NL } NL } NL return ( None < T > , NotRead ) NL }","func_name":"doTryRead","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"func call ( ) : Bool {  match ( current . load ( ) ) { case r : ReadingState => r . incrHoldings ( ) NL true NL case n : NoneState => current . compareAndSwap ( n , ReadingState ( ) ) NL case _ => false NL } NL }","func_name":"call","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryRead < T > ( callable : ( ) -> Option < T > ) : Option < T > {  tryRead < T > ( INFINITE_TIMEOUT , callable ) NL }","func_name":"tryRead","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryRead < T > ( timeout : UInt64 , callable : ( ) -> Option < T > ) : Option < T > {  tryRead < T > ( timeout , true , callable ) [ 0 ] NL }","func_name":"tryRead","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryRead < T > ( throwIfTimeout : Bool , callable : ( ) -> Option < T > ) : ( Option < T > , Bool ) {  tryRead < T > ( INFINITE_TIMEOUT , throwIfTimeout , callable ) NL }","func_name":"tryRead","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryRead < T > ( timeout : UInt64 , toThrowIfTimeout : Bool , callable : ( ) -> Option < T > ) : ( Option < T > , Bool ) {  if ( timeout == INFINITE_TIMEOUT ) {  while ( true ) {   let ( o , e ) = doTryRead ( 0 , timeout , None , toThrowIfTimeout , callable ) NL if ( e . read ) {  return ( o , true ) NL } NL } NL } NL  var retried = 0 NL  let start = Some ( Time . now ( ) ) NL while ( true ) {   let ( o , e ) = doTryRead ( retried , timeout , start , toThrowIfTimeout , callable ) NL return match ( e ) { case Read => ( o , true ) NL case NotRead => retried ++ NL continue NL case Timeout => break NL } NL } NL if ( toThrowIfTimeout ) {  throw IllegalSynchronizationStateException ( wating to read is timeout. timeout value is ${timeout}ns ) NL } else {  ( None , false ) NL } NL }","func_name":"tryRead","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryRead < T > ( defaultValue : T , callable : ( ) -> T ) : T {  tryRead ( INFINITE_TIMEOUT , defaultValue , callable ) NL }","func_name":"tryRead","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryRead < T > ( timeout : UInt64 , defaultValue : T , callable : ( ) -> T ) : T {  tryRead < T > ( timeout , true ) { Some < T > ( callable ( ) ) NL } [ 0 ] ?? defaultValue NL }","func_name":"tryRead","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryWrite ( callable : ( ) -> Unit ) : Unit {  tryWrite ( INFINITE_TIMEOUT , callable ) NL }","func_name":"tryWrite","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryWrite ( timeout : UInt64 , callable : ( ) -> Unit ) : Unit {  tryWrite < Unit > ( timeout , ( ) , callable ) NL }","func_name":"tryWrite","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryWrite < T > ( callable : ( ) -> Option < T > ) : Option < T > {  tryWrite < T > ( INFINITE_TIMEOUT , callable ) NL }","func_name":"tryWrite","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryWrite < T > ( toThrowIfTimeout : Bool , callable : ( ) -> Option < T > ) : ( Option < T > , Bool ) {  tryWrite < T > ( INFINITE_TIMEOUT , toThrowIfTimeout , callable ) NL }","func_name":"tryWrite","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryWrite < T > ( timeout : UInt64 , callable : ( ) -> Option < T > ) : Option < T > {  tryWrite < T > ( timeout , true , callable ) [ 0 ] NL }","func_name":"tryWrite","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryWrite < T > ( timeout : UInt64 , toThrowIfTimeout : Bool , callable : ( ) -> Option < T > ) : ( Option < T > , Bool ) {   let timeoutDuration = Duration . nanosecond ( Int64 ( timeout ) ) NL  var result = timeoutableMutex . tryLock < Option < T > > ( timeout , toThrowIfTimeout ) {  let state = current . load ( ) NL match ( state ) { case _ : NoneState =>  let writing = WritingState ( ) NL if ( current . compareAndSwap ( state , writing ) ) {  try {  return ExecutionStatus < Option < T > > . Executed ( callable ( ) ) NL } finally {   let currentState = current . load ( ) NL match ( currentState ) { case w : WritingState where w == writing => if ( ! current . compareAndSwap ( currentState , State . NONE ) ) {  throw ReadWriteSyncerException ( current locked thread is not for writing ) NL } NL case _ => throw ReadWriteSyncerException ( current locked thread is not for writing ) NL } NL } NL } else {  return ExecutionStatus < Option < T > > . ToBeContinued NL } NL case _ => return ExecutionStatus < Option < T > > . ToBeContinued NL } NL } NL match ( result ) { case ( Some ( opt ) , _ ) => ( opt , true ) NL case ( None , x ) => ( None , x ) NL } NL }","func_name":"tryWrite","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryWrite < T > ( defaultValue : T , callable : ( ) -> T ) : T {  return tryWrite < T > ( INFINITE_TIMEOUT , defaultValue , callable ) NL }","func_name":"tryWrite","docstring":""}
{"repo":"fountain","file":"ReadWriteSyncer.cj","path":"fountain/src/concurrent/ReadWriteSyncer.cj","code_tokens":"public func tryWrite < T > ( timeout : UInt64 , defaultValue : T , callable : ( ) -> T ) : T {  return tryWrite < T > ( timeout , true ) { Some < T > ( callable ( ) ) NL } [ 0 ] ?? defaultValue NL }","func_name":"tryWrite","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func fetchAdd ( val : N ) : N","func_name":"fetchAdd","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func fetchSub ( val : N ) : N","func_name":"fetchSub","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func fetchAnd ( val : N ) : N","func_name":"fetchAnd","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func fetchOr ( val : N ) : N","func_name":"fetchOr","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func fetchXor ( val : N ) : N","func_name":"fetchXor","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func fetchIncr ( ) : N {  fetchAdd ( N . one ) NL }","func_name":"fetchIncr","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func fetchDecr ( ) : N {  fetchSub ( N . one ) NL }","func_name":"fetchDecr","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func incrFetch ( ) : N {  addFetch ( N . one ) NL }","func_name":"incrFetch","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func decrFetch ( ) : N {  subFetch ( N . one ) NL }","func_name":"decrFetch","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func addFetch ( val : N ) : N {  fetchAdd ( val ) + val NL }","func_name":"addFetch","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func subFetch ( val : N ) : N {  fetchSub ( val ) - val NL }","func_name":"subFetch","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func andFetch ( val : N ) : N {  fetchAnd ( val ) & val NL }","func_name":"andFetch","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func orFetch ( val : N ) : N {  fetchOr ( val ) | val NL }","func_name":"orFetch","docstring":""}
{"repo":"fountain","file":"AtomicInteger.cj","path":"fountain/src/concurrent/AtomicInteger.cj","code_tokens":"func xorFetch ( val : N ) : N {  fetchXor ( val ) ^ val NL }","func_name":"xorFetch","docstring":""}
{"repo":"fountain","file":"ByteIterableInputStream.cj","path":"fountain/src/io/ByteIterableInputStream.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {   var i = 0 NL for ( b in iterator ) {  if ( i < buffer . size ) {  buffer [ i ] = b NL i ++ NL } else {  break NL } NL } NL i NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"StringToInputStream.cj","path":"fountain/src/io/StringToInputStream.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {   var i = 0 NL while ( i < buffer . size && cur < bytes . size ) {  buffer [ i ] = bytes [ cur ] NL i ++ NL cur ++ NL } NL i NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"ByteListOutputStream.cj","path":"fountain/src/io/ByteListOutputStream.cj","code_tokens":"public func write ( bytes : Array < Byte > ) : Unit {  list_ . appendAll ( bytes ) NL }","func_name":"write","docstring":""}
{"repo":"fountain","file":"ByteListOutputStream.cj","path":"fountain/src/io/ByteListOutputStream.cj","code_tokens":"public func write ( byte : Byte ) : Unit {  list_ . append ( byte ) NL }","func_name":"write","docstring":""}
{"repo":"fountain","file":"ByteListOutputStream.cj","path":"fountain/src/io/ByteListOutputStream.cj","code_tokens":"public func flush ( ) : Unit {  }","func_name":"flush","docstring":""}
{"repo":"fountain","file":"ByteListOutputStream.cj","path":"fountain/src/io/ByteListOutputStream.cj","code_tokens":"public func toArray ( ) : Array < Byte > {  list_ . toArray ( ) NL }","func_name":"toArray","docstring":""}
{"repo":"fountain","file":"ByteListOutputStream.cj","path":"fountain/src/io/ByteListOutputStream.cj","code_tokens":"public func toString ( ) : String {  String . fromUtf8 ( toArray ( ) ) NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"ByteCollectionInputStream.cj","path":"fountain/src/io/ByteCollectionInputStream.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {   let r = input . read ( buffer ) NL current += r NL r NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"StringBuilderOutputStream.cj","path":"fountain/src/io/StringBuilderOutputStream.cj","code_tokens":"public func write ( bytes : Array < Byte > ) : Unit {  builder . appendFromUtf8 ( bytes ) NL }","func_name":"write","docstring":""}
{"repo":"fountain","file":"StringBuilderOutputStream.cj","path":"fountain/src/io/StringBuilderOutputStream.cj","code_tokens":"public func toString ( ) : String {  builder . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"ByteArrayStream.cj","path":"fountain/src/io/ByteArrayStream.cj","code_tokens":"func toUtf8String ( ) : String","func_name":"toUtf8String","docstring":""}
{"repo":"fountain","file":"ByteArrayStream.cj","path":"fountain/src/io/ByteArrayStream.cj","code_tokens":"public func toUtf8String ( ) : String {  String . fromUtf8 ( this . bytes ( ) ) NL }","func_name":"toUtf8String","docstring":""}
{"repo":"fountain","file":"WrappedInputStream.cj","path":"fountain/src/io/WrappedInputStream.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {  input ( buffer ) NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"WrappedOutputStream.cj","path":"fountain/src/io/WrappedOutputStream.cj","code_tokens":"public func write ( buffer : Array < Byte > ) : Unit {  this . output ( buffer ) NL }","func_name":"write","docstring":""}
{"repo":"fountain","file":"WrappedOutputStream.cj","path":"fountain/src/io/WrappedOutputStream.cj","code_tokens":"public func flush ( ) : Unit {  this . flushFn ( ) NL }","func_name":"flush","docstring":""}
{"repo":"fountain","file":"PipeStream.cj","path":"fountain/src/io/PipeStream.cj","code_tokens":"public func pipe ( input ! : InputStream , output ! : OutputStream , bufsize ! : Int64 = 4096 , finished ! : ( ) -> Bool = { => false NL } ) {   let buf = Array < Byte > ( bufsize , item : 0 ) NL while ( true ) {   let len = input . read ( buf ) NL if ( len > 0 ) {  output . write ( buf . slice ( 0 , len ) ) NL } else if ( finished ( ) ) {  return NL } NL } NL }","func_name":"pipe","docstring":"//从input读出的数据写到output"}
{"repo":"fountain","file":"PipeStream.cj","path":"fountain/src/io/PipeStream.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {  if ( buffer . size == 0 ) {  throw IllegalArgumentException ( buffer size must not be zero ) NL } else if ( length == 0 ) {  return 0 NL } NL synchronized ( lock ) {  while ( true ) {   var len = buf . read ( buffer ) NL if ( len > 0 ) {  return len NL } NL buf . clear ( ) NL lock . notifyAll ( wcond ) NL lock . wait ( rcond ) NL } NL 0 NL } NL }","func_name":"read","docstring":""}
{"repo":"fountain","file":"PipeStream.cj","path":"fountain/src/io/PipeStream.cj","code_tokens":"public func write ( buffer : Array < Byte > ) : Unit {  write ( buffer , finished : false ) NL }","func_name":"write","docstring":""}
{"repo":"fountain","file":"PipeStream.cj","path":"fountain/src/io/PipeStream.cj","code_tokens":"public func write ( buffer : Array < Byte > , finished ! : Bool = false ) : Unit {  synchronized ( lock ) {  if ( buf . capacity ( ) - buf . length < buffer . size ) {  buf . reserve ( buffer . size ) NL } NL buf . write ( buffer ) NL isFinished = finished NL lock . notifyAll ( rcond ) NL lock . wait ( wcond ) NL } NL }","func_name":"write","docstring":""}
{"repo":"fountain","file":"LoggerFactory.cj","path":"fountain/src/log/LoggerFactory.cj","code_tokens":"private func refresh ( ) : Unit {  this . config . refresh { for ( ( _ , logger ) in loggers ) {  logger . refresh ( ) NL } NL } NL }","func_name":"refresh","docstring":""}
{"repo":"fountain","file":"LoggerFactory.cj","path":"fountain/src/log/LoggerFactory.cj","code_tokens":"static public func getLogger ( name : String ) : Logger {  instance . loggers . computeIfAbsent ( name ) { n => LoggerWrapper ( name , instance . config ) NL } . getOrThrow ( ) NL }","func_name":"getLogger","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func setOutput ( output : OutputStream ) : Unit {  throw UnsupportedAccessException ( ) NL }","func_name":"setOutput","docstring":"/*this func is implemented as to throw UnsupportedAccessException, if to invoke*/"}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"static public func register ( ) : Unit {  throw UnsupportedAccessException ( ) NL }","func_name":"register","docstring":"/*this func is implemented as to throw UnsupportedAccessException, if to invoke*/"}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"protected open func append ( level : LogLevel , message : ( ) -> String , ex : Option < Exception > ) : Unit {  append ( level , message ( ) , ex ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func log ( level : LogLevel , message : String ) : Unit {  append ( level , message ) NL }","func_name":"log","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"protected func append ( level : LogLevel , message : String ) : Unit {  append ( level , message , None < Exception > ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func append ( level : LogLevel , message : String , now : Time , ex : Option < Exception > ) : Unit","func_name":"append","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public open func append ( level : LogLevel , message : String , ex : Option < Exception > ) : Unit {  synchronized ( lock ) {  append ( level , message , Time . now ( ) , ex ) NL } NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"protected func append ( level : LogLevel , message : String , ex : Exception ) : Unit {  append ( level , message , Some ( ex ) ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func error ( message : String , ex : Exception ) : Unit {  append ( ERROR , message , ex ) NL }","func_name":"error","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func warn ( message : String , ex : Exception ) : Unit {  append ( WARN , message , ex ) NL }","func_name":"warn","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func info ( message : String , ex : Exception ) : Unit {  append ( INFO , message , ex ) NL }","func_name":"info","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func debug ( message : String , ex : Exception ) : Unit {  append ( DEBUG , message , ex ) NL }","func_name":"debug","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func trace ( message : String , ex : Exception ) : Unit {  append ( TRACE , message , ex ) NL }","func_name":"trace","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func error ( ex : Exception ) : Unit {  append ( ERROR ,  , ex ) NL }","func_name":"error","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func warn ( ex : Exception ) : Unit {  append ( WARN ,  , ex ) NL }","func_name":"warn","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func info ( ex : Exception ) : Unit {  append ( INFO ,  , ex ) NL }","func_name":"info","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func debug ( ex : Exception ) : Unit {  append ( DEBUG ,  , ex ) NL }","func_name":"debug","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func trace ( ex : Exception ) : Unit {  append ( TRACE ,  , ex ) NL }","func_name":"trace","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func error ( message : String ) : Unit {  append ( ERROR , message ) NL }","func_name":"error","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func warn ( message : String ) : Unit {  append ( WARN , message ) NL }","func_name":"warn","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func info ( message : String ) : Unit {  append ( INFO , message ) NL }","func_name":"info","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func debug ( message : String ) : Unit {  append ( DEBUG , message ) NL }","func_name":"debug","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func trace ( message : String ) : Unit {  append ( TRACE , message ) NL }","func_name":"trace","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"protected func append ( level : LogLevel , message : ( ) -> String ) : Unit {  append ( level , message ( ) , None < Exception > ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"protected func append ( level : LogLevel , message : ( ) -> String , ex : Exception ) : Unit {  append ( level , message ( ) , Some ( ex ) ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func error ( message : ( ) -> String , ex : Exception ) : Unit {  append ( ERROR , message , ex ) NL }","func_name":"error","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func warn ( message : ( ) -> String , ex : Exception ) : Unit {  append ( WARN , message , ex ) NL }","func_name":"warn","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func info ( message : ( ) -> String , ex : Exception ) : Unit {  append ( INFO , message , ex ) NL }","func_name":"info","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func debug ( message : ( ) -> String , ex : Exception ) : Unit {  append ( DEBUG , message , ex ) NL }","func_name":"debug","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func trace ( message : ( ) -> String , ex : Exception ) : Unit {  append ( TRACE , message , ex ) NL }","func_name":"trace","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func error ( message : ( ) -> String ) : Unit {  append ( ERROR , message ) NL }","func_name":"error","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func warn ( message : ( ) -> String ) : Unit {  append ( WARN , message ) NL }","func_name":"warn","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func info ( message : ( ) -> String ) : Unit {  append ( INFO , message ) NL }","func_name":"info","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func debug ( message : ( ) -> String ) : Unit {  append ( DEBUG , message ) NL }","func_name":"debug","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public func trace ( message : ( ) -> String ) : Unit {  append ( TRACE , message ) NL }","func_name":"trace","docstring":""}
{"repo":"fountain","file":"AbstractLogger.cj","path":"fountain/src/log/AbstractLogger.cj","code_tokens":"public open func logLevelEnabled ( level : LogLevel ) : Bool {  level . level ( ) <= this . level . level ( ) NL }","func_name":"logLevelEnabled","docstring":""}
{"repo":"fountain","file":"LoggerConfig.cj","path":"fountain/src/log/LoggerConfig.cj","code_tokens":"public func refresh ( fn : ( ) -> Unit ) : Unit {  cfg . refresh { fn ( ) NL } NL }","func_name":"refresh","docstring":""}
{"repo":"fountain","file":"LoggerConfig.cj","path":"fountain/src/log/LoggerConfig.cj","code_tokens":"public func getMonitorInterval ( ) : Option < Int64 > {  cfg . getMonitorInterval ( ) NL }","func_name":"getMonitorInterval","docstring":""}
{"repo":"fountain","file":"LoggerConfig.cj","path":"fountain/src/log/LoggerConfig.cj","code_tokens":"public func getAppenders ( name : String ) : Array < AbstractLogger > {  if ( let Some ( appenders ) = extractAppenders ( ) ) {  Array < AbstractLogger > ( appenders . size ) { i => LoggerAppenderCreator . create ( appender , name , this ) NL } NL } else {  [ ] NL } NL }","func_name":"getAppenders","docstring":""}
{"repo":"fountain","file":"LoggerConfig.cj","path":"fountain/src/log/LoggerConfig.cj","code_tokens":"private func extractAppenders ( ) : Option < Array < String > > {  if ( let Some ( appen ) = cfg . getConf ( appender ) ) {   let appenders = BLANK_SPLITTOR . matcher ( appen . toAsciiLower ( ) ) . split ( ) NL Some ( appenders ) NL } else {  None < Array < String > > NL } NL }","func_name":"extractAppenders","docstring":""}
{"repo":"fountain","file":"LoggerConfig.cj","path":"fountain/src/log/LoggerConfig.cj","code_tokens":"public func getConf ( appender : String , item : String ) : Option < String > {  cfg . getConf ( appender.${appender}.${item} ) NL }","func_name":"getConf","docstring":""}
{"repo":"fountain","file":"LoggerConfig.cj","path":"fountain/src/log/LoggerConfig.cj","code_tokens":"public func getLevelConf ( appender : String ) : LogLevel {  if ( let Some ( level ) = getConf ( appender , level ) ) {  return convertLevel ( level ) NL } NL return INFO NL }","func_name":"getLevelConf","docstring":""}
{"repo":"fountain","file":"LoggerConfig.cj","path":"fountain/src/log/LoggerConfig.cj","code_tokens":"public func getPatternConf ( appender : String ) : LogPattern {  if ( let Some ( p ) = getConf ( appender , pattern ) ) {  return LogPattern ( p ) NL } NL return LogPattern . default NL }","func_name":"getPatternConf","docstring":""}
{"repo":"fountain","file":"LoggerConfig.cj","path":"fountain/src/log/LoggerConfig.cj","code_tokens":"private func convertLevel ( level : String ) : LogLevel {  match ( level . toAsciiUpper ( ) ) { case OFF => OFF NL case ERROR => ERROR NL case WARN => WARN NL case INFO => INFO NL case DEBUG => DEBUG NL case TRACE => TRACE NL case ALL => ALL NL case _ => INFO NL } NL }","func_name":"convertLevel","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"static func register ( ) : Unit","func_name":"register","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func append ( level : LogLevel , message : String , ex : Option < Exception > ) : Unit","func_name":"append","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func error ( message : String , ex : Exception ) : Unit","func_name":"error","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func warn ( message : String , ex : Exception ) : Unit","func_name":"warn","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func info ( message : String , ex : Exception ) : Unit","func_name":"info","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func debug ( message : String , ex : Exception ) : Unit","func_name":"debug","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func trace ( message : String , ex : Exception ) : Unit","func_name":"trace","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func error ( ex : Exception ) : Unit","func_name":"error","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func warn ( ex : Exception ) : Unit","func_name":"warn","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func info ( ex : Exception ) : Unit","func_name":"info","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func debug ( ex : Exception ) : Unit","func_name":"debug","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func trace ( ex : Exception ) : Unit","func_name":"trace","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func error ( message : String ) : Unit","func_name":"error","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func warn ( message : String ) : Unit","func_name":"warn","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func info ( message : String ) : Unit","func_name":"info","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func debug ( message : String ) : Unit","func_name":"debug","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func trace ( message : String ) : Unit","func_name":"trace","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func error ( message : ( ) -> String , ex : Exception ) : Unit","func_name":"error","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func warn ( message : ( ) -> String , ex : Exception ) : Unit","func_name":"warn","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func info ( message : ( ) -> String , ex : Exception ) : Unit","func_name":"info","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func debug ( message : ( ) -> String , ex : Exception ) : Unit","func_name":"debug","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func trace ( message : ( ) -> String , ex : Exception ) : Unit","func_name":"trace","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func error ( message : ( ) -> String ) : Unit","func_name":"error","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func warn ( message : ( ) -> String ) : Unit","func_name":"warn","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func info ( message : ( ) -> String ) : Unit","func_name":"info","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func debug ( message : ( ) -> String ) : Unit","func_name":"debug","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func trace ( message : ( ) -> String ) : Unit","func_name":"trace","docstring":""}
{"repo":"fountain","file":"Logger.cj","path":"fountain/src/log/Logger.cj","code_tokens":"func logLevelEnabled ( level : LogLevel ) : Bool","func_name":"logLevelEnabled","docstring":""}
{"repo":"fountain","file":"FileLoggerAppender.cj","path":"fountain/src/log/FileLoggerAppender.cj","code_tokens":"static public func register ( ) : Unit {  LoggerAppenderCreator . register ( file ) { name , cfg =>  var path =  NL  var timeunit = TimeUnit . DAY NL  var size : Int64 = 0 NL if ( let Some ( p ) = cfg . getConf ( file , path ) ) {  if ( p !=  ) {  path = p NL } NL } NL if ( let Some ( d ) = cfg . getConf ( file , rotate.duration ) ) {  if ( let Some ( u ) = TimeUnit . parse ( d ) ) {  timeunit = u NL } NL } NL if ( let Some ( s ) = cfg . getConf ( file , rotate.size ) ) {  if ( s !=  ) {  size = computeBytes ( s ) ?? 0 NL } NL } NL FileLoggerAppender ( name : name , level : cfg . getLevelConf ( file ) , pattern : cfg . getPatternConf ( file ) , directory : path , timeunit : timeunit , fileSize : size ) NL } NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"FileLoggerAppender.cj","path":"fountain/src/log/FileLoggerAppender.cj","code_tokens":"static private func createFileStream ( directory : String , timeunit : TimeUnit , current ! : Time = Time . now ( ) ) : File {   let path = genPath ( directory , timeunit , current : current ) NL  let out = File ( path , OpenOption . CreateOrAppend ) NL Process . atexit { out . close ( ) NL } NL return out NL }","func_name":"createFileStream","docstring":""}
{"repo":"fountain","file":"FileLoggerAppender.cj","path":"fountain/src/log/FileLoggerAppender.cj","code_tokens":"static private func genPath ( directory : String , timeunit : TimeUnit , current ! : Time = Time . now ( ) ) : String {  if ( directory . endsWith ( / ) ) {  return directory + CmdArgs . instance . getAppName ( ) + - + genTime ( timeunit , current ) + .log NL } else {  return directory + / + CmdArgs . instance . getAppName ( ) + - + genTime ( timeunit , current ) + .log NL } NL }","func_name":"genPath","docstring":""}
{"repo":"fountain","file":"FileLoggerAppender.cj","path":"fountain/src/log/FileLoggerAppender.cj","code_tokens":"static private func genTime ( timeunit : TimeUnit , current : Time ) : String {  match ( timeunit ) { case DAY => current . toString ( yyyyMMdd ) NL case HOUR => current . toString ( yyyyMMddHH ) NL case WEEK => current . toString ( yyyyMMddWW ) NL case MINUTE => current . toString ( yyyyMMddHHmm ) NL case MONTH => current . toString ( yyyyMM ) NL case YEAR => current . toString ( yyyy ) NL case SECOND => current . toString ( yyyyMMddHHMMss ) NL case _ => current . toString ( yyyyMMddHHmmssSSS ) NL } NL }","func_name":"genTime","docstring":""}
{"repo":"fountain","file":"FileLoggerAppender.cj","path":"fountain/src/log/FileLoggerAppender.cj","code_tokens":"public func append ( level : LogLevel , message : String , now : Time , ex : Option < Exception > ) : Unit {  if ( logLevelEnabled ( level ) ) {   let msg = pattern . generate ( name , level , message , now ) NL  let current = timeunit . trim ( now ) NL  var file = this . file . load ( ) NL  let fileInfo = file . info NL  var rotate = ( false , timeunit ) NL if ( fileInfo . creationTime < current ) {  rotate = ( true , timeunit ) NL } else if ( fileInfo . length > = fileSize ) {  rotate = ( true , TimeUnit . SECOND ) NL } NL if ( rotate [ 0 ] ) {  try {  file = createFileStream ( directory , rotate [ 1 ] , current : current ) NL this . file . swap ( file ) . close ( ) NL } catch ( e : Exception ) {  e . printStackTrace ( ) NL } NL } NL file . write ( message . toUtf8Array ( ) ) NL if ( let Some ( e ) = ex ) {  if ( let Some ( c ) = e as BaseException ) {  c . printStackTrace ( file ) NL } else {  printStackTrace ( e , file ) NL } NL } NL } NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"LogRotatePolicy.cj","path":"fountain/src/log/LogRotatePolicy.cj","code_tokens":"func rotate ( ) : Unit","func_name":"rotate","docstring":""}
{"repo":"fountain","file":"LogRotatePolicy.cj","path":"fountain/src/log/LogRotatePolicy.cj","code_tokens":"public func rotate ( ) : Unit {  }","func_name":"rotate","docstring":""}
{"repo":"fountain","file":"LoggerAppenderFacade.cj","path":"fountain/src/log/LoggerAppenderFacade.cj","code_tokens":"public func logLevelEnabled ( level : LogLevel ) : Bool {   var i = 0 NL  let s = appenders . size NL  var enabled = false NL while ( i < s && ! enabled ) {  enabled ||= appenders [ i ] . logLevelEnabled ( level ) NL i ++ NL } NL return enabled NL }","func_name":"logLevelEnabled","docstring":""}
{"repo":"fountain","file":"LoggerAppenderFacade.cj","path":"fountain/src/log/LoggerAppenderFacade.cj","code_tokens":"public func append ( level : LogLevel , message : String , now : Time , ex : Option < Exception > ) : Unit {   var i = 0 NL  let size = appenders . size NL while ( i < size ) {  appenders [ i ] . append ( level , message , now , ex ) NL i ++ NL } NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"LoggerAppenderCreator.cj","path":"fountain/src/log/LoggerAppenderCreator.cj","code_tokens":"static func register ( kind : String , creator : ( String , LoggerConfig ) -> AbstractLogger ) {  creators . put ( kind , creator ) NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"LoggerAppenderCreator.cj","path":"fountain/src/log/LoggerAppenderCreator.cj","code_tokens":"static func create ( kind : String , name : String , config : LoggerConfig ) : AbstractLogger {  creators [ kind ] ( name , config ) NL }","func_name":"create","docstring":""}
{"repo":"fountain","file":"LoggerWrapper.cj","path":"fountain/src/log/LoggerWrapper.cj","code_tokens":"static private func createFacade ( name : String , config : LoggerConfig ) {  LoggerAppenderFacade ( config . getAppenders ( name ) ) NL }","func_name":"createFacade","docstring":""}
{"repo":"fountain","file":"LoggerWrapper.cj","path":"fountain/src/log/LoggerWrapper.cj","code_tokens":"public func logLevelEnabled ( level : LogLevel ) : Bool {  facade . load ( ) . logLevelEnabled ( level ) NL }","func_name":"logLevelEnabled","docstring":""}
{"repo":"fountain","file":"LoggerWrapper.cj","path":"fountain/src/log/LoggerWrapper.cj","code_tokens":"public func append ( level : LogLevel , message : String , now : Time , ex : Option < Exception > ) : Unit {  facade . load ( ) . append ( level , message , now , ex ) NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"LoggerWrapper.cj","path":"fountain/src/log/LoggerWrapper.cj","code_tokens":"public func refresh ( ) {  this . facade . store ( createFacade ( name , config ) ) NL }","func_name":"refresh","docstring":""}
{"repo":"fountain","file":"ConsoleLoggerAppender.cj","path":"fountain/src/log/ConsoleLoggerAppender.cj","code_tokens":"static public func register ( ) : Unit {  LoggerAppenderCreator . register ( console ) { name , cfg => ConsoleLoggerAppender ( name : name , level : cfg . getLevelConf ( console ) , pattern : cfg . getPatternConf ( console ) ) NL } NL }","func_name":"register","docstring":""}
{"repo":"fountain","file":"ConsoleLoggerAppender.cj","path":"fountain/src/log/ConsoleLoggerAppender.cj","code_tokens":"public func append ( level : LogLevel , message : String , now : Time , ex : Option < Exception > ) : Unit {  if ( logLevelEnabled ( level ) ) {   let msg = pattern . generate ( name , level , message , now ) NL console . write ( msg ) NL if ( let Some ( e ) = ex ) {  if ( let Some ( c ) = e as BaseException ) {  c . printStackTrace ( console ) NL } else {  printStackTrace ( e , console ) NL } NL } NL } NL }","func_name":"append","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"static private func compile ( pattern : String ) : ArrayList < LogPart > {   let patterns = ArrayList < LogPart > ( ) NL  var origin = StringBuilder ( ) NL  func appendOrigin ( ) {  if ( origin . size > 0 ) {  patterns . append ( OriginLogPart ( origin . toString ( ) ) ) NL origin . clear ( ) NL } NL } NL  var i = 1 NL  let size = pattern . size NL while ( i < size ) {   let c = pattern [ i ] NL if ( c == % ) {  if ( pattern . substring ( i + 1 , 5 ) == level ) {  appendOrigin ( ) NL patterns . append ( levelLogPart ) NL i += 6 NL } else if ( pattern . substring ( i + 1 , 3 ) == app ) {  appendOrigin ( ) NL patterns . append ( AppLogPart ( ) ) NL i += 4 NL } else if ( pattern . substring ( i + 1 , 4 ) == name ) {  appendOrigin ( ) NL patterns . append ( nameLogPart ) NL i += 5 NL } else if ( pattern . substring ( i + 1 , 2 ) == d{ ) {   let ds = i + 3 NL  var di = ds NL while ( di < size && pattern [ di ] != } ) {  di ++ NL } NL if ( di < size ) {  appendOrigin ( ) NL patterns . append ( TimeLogPart ( pattern . substring ( ds , di - ds ) ) ) NL i = di + 1 NL } else {  origin . append ( c ) NL i ++ NL } NL } else if ( pattern [ i + 1 ] == m ) {  appendOrigin ( ) NL patterns . append ( MessageLogPart ( ) ) NL i += 2 NL } else {  origin . append ( c ) NL i ++ NL } NL } else {  origin . append ( c ) NL i ++ NL } NL } NL appendOrigin ( ) NL patterns NL }","func_name":"compile","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"func appendOrigin ( ) {  if ( origin . size > 0 ) {  patterns . append ( OriginLogPart ( origin . toString ( ) ) ) NL origin . clear ( ) NL } NL }","func_name":"appendOrigin","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"public func generate ( name : String , level : LogLevel , message : ToString , current : Time ) : String {   var builder = StringBuilder ( ) NL for ( p in patterns ) {  builder . append ( p . generate ( name , level , message , current ) ) NL } NL builder . append ( \\n ) NL return builder . toString ( ) NL }","func_name":"generate","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"func generate ( name : String , level : LogLevel , message : ToString , current : Time ) : String","func_name":"generate","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"public func generate ( name : String , level : LogLevel , message : ToString , current : Time ) : String {  return txt NL }","func_name":"generate","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"public func generate ( name : String , level : LogLevel , message : ToString , current : Time ) : String {  return level . toString ( ) NL }","func_name":"generate","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"public func generate ( name : String , level : LogLevel , message : ToString , current : Time ) : String {  return name NL }","func_name":"generate","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"public func generate ( name : String , level : LogLevel , message : ToString , current : Time ) : String {  return app NL }","func_name":"generate","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"public func generate ( name : String , level : LogLevel , message : ToString , datetime : Time ) : String {  return datetime . toString ( format ) NL }","func_name":"generate","docstring":""}
{"repo":"fountain","file":"LogPattern.cj","path":"fountain/src/log/LogPattern.cj","code_tokens":"public func generate ( name : String , level : LogLevel , message : ToString , current : Time ) : String {  return message . toString ( ) NL }","func_name":"generate","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"static func builder ( ) : RegexBuilder","func_name":"builder","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"static func builder ( callback : ( RegexBuilder ) -> Unit ) : Regex","func_name":"builder","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"func matched ( input : String ) : Bool","func_name":"matched","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"func split ( input : String ) : Array < String >","func_name":"split","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"func replace ( input : String , replacement : String ) : String","func_name":"replace","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"func replaceAll ( input : String , replacement : String ) : String","func_name":"replaceAll","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"static public func builder ( ) : RegexBuilder {  RegexBuilder ( ) NL }","func_name":"builder","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"static public func builder ( callback : ( RegexBuilder ) -> Unit ) : Regex {   var builder = builder ( ) NL callback ( builder ) NL builder . build ( ) NL }","func_name":"builder","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"public func matched ( input : String ) : Bool {  matches ( input ) . some NL }","func_name":"matched","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"public func split ( input : String ) : Array < String > {  this . matcher ( input ) . split ( ) NL }","func_name":"split","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"public func replace ( input : String , replacement : String ) : String {  this . matcher ( input ) . replace ( replacement ) NL }","func_name":"replace","docstring":""}
{"repo":"fountain","file":"ExtendRegex.cj","path":"fountain/src/regex/ExtendRegex.cj","code_tokens":"public func replaceAll ( input : String , replacement : String ) : String {  this . matcher ( input ) . replaceAll ( replacement ) NL }","func_name":"replaceAll","docstring":""}
{"repo":"fountain","file":"RegexFromString.cj","path":"fountain/src/regex/RegexFromString.cj","code_tokens":"func regex ( option ! : RegexOption , solid ! : Bool ) : Regex","func_name":"regex","docstring":""}
{"repo":"fountain","file":"RegexFromString.cj","path":"fountain/src/regex/RegexFromString.cj","code_tokens":"public func regex ( option ! : RegexOption = RegexOption ( ) , solid ! : Bool = false ) : Regex {   let key = /${this}/${option.toString()} NL if ( solid ) {  return SOLID . computeIfAbsent ( key ) { k => CACHE . get ( key ) ?? Regex ( this , option ) NL } . getOrThrow ( ) NL } else {  CACHE . getOrCompute ( key ) { SOLID . get ( key ) ?? Regex ( this , option ) NL } . getOrThrow ( ) NL } NL }","func_name":"regex","docstring":""}
{"repo":"fountain","file":"ExtendMatcher.cj","path":"fountain/src/regex/ExtendMatcher.cj","code_tokens":"func matches ( ) : Bool","func_name":"matches","docstring":""}
{"repo":"fountain","file":"ExtendMatcher.cj","path":"fountain/src/regex/ExtendMatcher.cj","code_tokens":"public func matches ( ) : Bool {  allCount ( ) > 0 NL }","func_name":"matches","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public operator func == ( other : RegexBuilder ) {  pattern . toCharArray ( ) == other . pattern . toCharArray ( ) NL }","func_name":"==","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public operator func != ( other : RegexBuilder ) {  return ! ( this == other ) NL }","func_name":"!=","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func build ( option ! : RegexOption = RegexOption ( ) , solid ! : Bool = false ) : Regex {  return toString ( ) . regex ( option : option , solid : solid ) NL }","func_name":"build","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func toString ( ) : String {  return pattern . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func text ( part : ToString ) : RegexBuilder {  pattern . append ( part ) NL return this NL }","func_name":"text","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"private func group_ ( notCapture : Bool , part : ToString ) : RegexBuilder {  if ( notCapture ) {  return lparan . notCapture . text ( part ) . rparan NL } NL return lparan . text ( part ) . rparan NL }","func_name":"group_","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public operator func ( ) ( notCapture : Bool , part : ToString ) : RegexBuilder {  return group_ ( notCapture , part ) NL }","func_name":"()","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func group ( notCapture : Bool , part : ToString ) : RegexBuilder {  return RegexBuilder ( ) . group_ ( notCapture , part ) NL }","func_name":"group","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public operator func ( ) ( part : ToString ) : RegexBuilder {  return group_ ( false , part ) NL }","func_name":"()","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func group ( part : ToString ) : RegexBuilder {  return RegexBuilder ( ) . group_ ( false , part ) NL }","func_name":"group","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"private func group_ ( dir : SearchDirection , part : ToString ) : RegexBuilder {  match ( dir ) { case FORWARD => lparan . forward . text ( part ) . rparan NL case BACKWARD => lparan . backward . text ( part ) . rparan NL } NL }","func_name":"group_","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public operator func ( ) ( dir : SearchDirection , part : ToString ) : RegexBuilder {  group_ ( dir , part ) NL }","func_name":"()","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func group ( dir : SearchDirection , part : ToString ) : RegexBuilder {  RegexBuilder ( ) . group_ ( dir , part ) NL }","func_name":"group","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"private func mORn ( cmd : Char ) : RegexBuilder {  pattern . append ( cmd ) NL return this NL }","func_name":"mORn","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func startRange ( min : Int64 ) : RegexBuilder {  range ( min , - 1 ) NL }","func_name":"startRange","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func endRange ( max : Int64 ) : RegexBuilder {  range ( - 1 , max ) NL }","func_name":"endRange","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func range ( min : Int64 , max : Int64 ) : RegexBuilder {  if ( ( min < 0 && max < 0 ) || ( min > 0 && max > 0 && min < max ) ) {  throw RegexBuilderException ( min must less or equals to max and both are larger than 0, or one of min and max should be larger than 0 and the other must be ignored ) NL } NL pattern . append ( { ) NL if ( min > = 0 ) {  pattern . append ( min ) NL } NL pattern . append ( , ) NL if ( max > = 0 ) {  pattern . append ( max ) NL } NL pattern . append ( } ) NL return this NL }","func_name":"range","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public operator func [ ] ( notIn : Bool , parts : Iterable < ToString > ) : RegexBuilder {  pattern . append ( [ ) NL if ( notIn ) {  pattern . append ( ^ ) NL } NL for ( p in parts ) {  pattern . append ( p ) NL } NL pattern . append ( ] ) NL return this NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public operator func [ ] ( parts : Iterable < ToString > ) : RegexBuilder {  return this [ false , parts ] NL }","func_name":"[]","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func oneOf < T > ( parts : Iterable < T > ) : RegexBuilder where T <: ToString {  return RegexBuilder ( ) [ false , IterableConverter < T , ToString > ( parts ) ] NL }","func_name":"oneOf","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public func notOneOf < T > ( parts : Iterable < T > ) : RegexBuilder where T <: ToString {  return RegexBuilder ( ) [ true , IterableConverter < T , ToString > ( parts ) ] NL }","func_name":"notOneOf","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"public operator func | ( part : ToString ) : RegexBuilder {  return or . append ( part ) NL }","func_name":"|","docstring":""}
{"repo":"fountain","file":"RegexBuilder.cj","path":"fountain/src/regex/RegexBuilder.cj","code_tokens":"private func append ( part : ToString ) : RegexBuilder {  pattern . append ( part . toString ( ) ) NL return this NL }","func_name":"append","docstring":""}
