{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func isEmpty ( ) {  size_ == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func clear ( ) {  root = None NL size_ = 0 NL }","func_name":"clear","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func clone ( ) {  TreeSet ( root ? . clone ( ) , size_ ) NL }","func_name":"clone","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func contains ( key : K ) : Bool {  match ( search ( root , key ) ) { case None => return false NL case _ => return true NL } NL }","func_name":"contains","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  for ( key in keys ) {  match ( search ( root , key ) ) { case None => return false NL case _ => continue NL } NL } NL return true NL }","func_name":"containsAll","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func subsetOf ( other : Set < K > ) : Bool {  other . containsAll ( this ) NL }","func_name":"subsetOf","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func put ( key : K ) : Bool {  insert ( key ) NL }","func_name":"put","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func putAll ( elements : Collection < K > ) : Unit {  for ( ele in elements ) {  insert ( ele ) NL } NL }","func_name":"putAll","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"@ overflowWrapping   private func insert ( data : K ) : Bool {  if ( size_ == 0 ) {  root = TreeSetNode ( data , black : true ) NL size_ = 1 NL return true NL } NL  var parent = root . getOrThrow ( ) NL  var order = Ordering . EQ NL do {  order = data . compare ( parent . data ) NL } while ( match ( match ( order ) { case EQ => return false NL case LT => parent . left NL case GT => parent . right NL } ) { case Some ( node ) => parent = node NL true NL case _ => false NL } ) NL  let cur = TreeMapNode ( data , parent : parent ) NL match ( order ) { case LT => parent . left = cur NL case _ => parent . right = cur NL } NL if ( parent . black == false ) {  insertFixUp ( cur ) NL } NL size_ ++ NL return true NL }","func_name":"insert","docstring":"/* insert data to rb-tree, return false if the key of data exists */"}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"private func leftRotate ( x : TreeSetNode < K > ) : Unit {   let y = x . right . getOrThrow ( ) NL x . right = y . left NL if ( let Some ( left ) = y . left ) {  left . parent = x NL } NL y . parent = x . parent NL if ( let Some ( parent ) = x . parent ) {  if ( nodeEq ( x , parent . left ) ) {  parent . left = y NL } else {  parent . right = y NL } NL } else {  root = y NL } NL y . left = x NL x . parent = y NL }","func_name":"leftRotate","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"private func rightRotate ( y : TreeSetNode < K > ) : Unit {   let x = y . left . getOrThrow ( ) NL y . left = x . right NL if ( let Some ( right ) = x . right ) {  right . parent = y NL } NL x . parent = y . parent NL if ( let Some ( parent ) = y . parent ) {  if ( nodeEq ( y , parent . right ) ) {  parent . right = x NL } else {  parent . left = x NL } NL } else {  root = x NL } NL x . right = y NL y . parent = x NL }","func_name":"rightRotate","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"private func insertFixUp ( cur : TreeSetNode < K > ) : Unit {   var node = cur NL  var parent = node . parent . getOrThrow ( ) NL do {   var grandParent = parent . parent . getOrThrow ( ) NL if ( nodeEq ( parent , grandParent . left ) ) {  if ( let Some ( uncle ) = grandParent . right ) {  if ( uncle . black == false ) {  uncle . black = true NL parent . black = true NL grandParent . black = false NL node = grandParent NL continue NL } NL } NL if ( nodeEq ( node , parent . right ) ) {  leftRotate ( parent ) NL  let tmp = parent NL parent = node NL node = tmp NL } NL parent . black = true NL grandParent . black = false NL rightRotate ( grandParent ) NL } else {  if ( let Some ( uncle ) = grandParent . left ) {  if ( uncle . black == false ) {  uncle . black = true NL parent . black = true NL grandParent . black = false NL node = grandParent NL continue NL } NL } NL if ( nodeEq ( node , parent . left ) ) {  rightRotate ( parent ) NL  let tmp = parent NL parent = node NL node = tmp NL } NL parent . black = true NL grandParent . black = false NL leftRotate ( grandParent ) NL } NL } while ( match ( node . parent ) { case Some ( n ) => parent = n NL parent . black == false NL case _ => false NL } ) NL root ? . black = true NL }","func_name":"insertFixUp","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"static private func search ( x : ? TreeSetNode < K > , key : K ) : ? TreeSetNode < K > {   var node = x ?? return None NL while ( true ) {  match ( key . compare ( node . data ) ) { case EQ => return node NL case LT => node = node . left ?? return None NL case GT => node = node . right ?? return None NL } NL } NL return None NL }","func_name":"search","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func remove ( key : K ) : Bool {  if ( let Some ( node ) = search ( root , key ) ) {  remove ( node ) NL return true NL } NL return false NL }","func_name":"remove","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  for ( key in keys ) {  if ( let Some ( node ) = search ( root , key ) ) {  remove ( node ) NL } NL } NL }","func_name":"removeAll","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func removeIf ( predicate : ( K ) -> Bool ) : Unit {  if ( size_ == 0 ) {  return NL } NL  var node = root . getOrThrow ( ) NL while ( match ( node . left ) { case Some ( left ) => node = left NL true NL case _ => false NL } ) {  } NL while ( true ) {   let next = node . increment ( ) NL if ( predicate ( node . data ) ) {  remove ( node ) NL } NL match ( next ) { case Some ( n ) => node = n NL case _ => break NL } NL } NL }","func_name":"removeIf","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func retainAll ( set : Set < K > ) : Unit {  removeIf { key => ! set . contains ( key ) NL } NL }","func_name":"retainAll","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"@ overflowWrapping   private func remove ( node : TreeSetNode < K > ) : Unit {  if ( let ( Some ( left ) , Some ( right ) ) = ( node . left , node . right ) ) {   var replace = right NL while ( match ( replace . left ) { case Some ( n ) => replace = n NL true NL case _ => false NL } ) {  } NL match ( node . parent ) { case Some ( parent ) => if ( nodeEq ( node , parent . left ) ) {  parent . left = replace NL } else {  parent . right = replace NL } NL case _ => root = replace NL } NL  var child = replace . right NL  var parent = replace . parent . getOrThrow ( ) NL  let black = replace . black NL if ( nodeEq ( node , parent ) ) {  parent = replace NL } else {  child ? . parent = parent NL parent . left = child NL replace . right = node . right NL node . right ? . parent = replace NL } NL replace . parent = node . parent NL replace . black = node . black NL replace . left = node . left NL node . left ? . parent = replace NL if ( black ) {  removeFixUp ( child , parent ) NL } NL size_ -- NL return NL } NL  let child : ? TreeSetNode < K > = node . left ?? node . right NL  let black = node . black NL child ? . parent = node . parent NL match ( node . parent ) { case Some ( parent ) => if ( nodeEq ( node , parent . left ) ) {  parent . left = child NL } else {  parent . right = child NL } NL case _ => root = child NL } NL if ( black ) {  removeFixUp ( child , node . parent . getOrThrow ( ) ) NL } NL size_ -- NL }","func_name":"remove","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"private func removeFixUp ( child : ? TreeSetNode < K > , np : TreeSetNode < K > ) {   var node = child NL  var opti : ? TreeSetNode < K > = np NL  var other : TreeSetNode < K > NL while ( ( node ? . black ?? true ) && ! nodeEq ( node , root ) ) {   let parent = opti . getOrThrow ( ) NL if ( nodeEq ( node , parent . left ) ) {  other = parent . right . getOrThrow ( ) NL if ( other . black == false ) {  other . black = true NL parent . black = false NL leftRotate ( parent ) NL other = parent . right . getOrThrow ( ) NL } NL if ( ( other . left ? . black ?? true ) && ( other . right ? . black ?? true ) ) {  other . black = false NL node = opti NL opti = parent . parent NL } else {  if ( other . right ? . black ?? true ) {  other . left ? . black = true NL other . black = false NL rightRotate ( other ) NL other = parent . right . getOrThrow ( ) NL } NL other . black = parent . black NL parent . black = true NL other . right ? . black = true NL leftRotate ( parent ) NL node = root NL break NL } NL } else {  other = parent . left . getOrThrow ( ) NL if ( other . black == false ) {  other . black = true NL parent . black = false NL rightRotate ( parent ) NL other = parent . left . getOrThrow ( ) NL } NL if ( ( other . left ? . black ?? true ) && ( other . right ? . black ?? true ) ) {  other . black = false NL node = opti NL opti = parent . parent NL } else {  if ( other . left ? . black ?? true ) {  other . right ? . black = true NL other . black = false NL leftRotate ( other ) NL other = parent . left . getOrThrow ( ) NL } NL other . black = parent . black NL parent . black = true NL other . left ? . black = true NL rightRotate ( parent ) NL node = root NL break NL } NL } NL } NL node ? . black = true NL }","func_name":"removeFixUp","docstring":""}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"private func leftMost ( ) : ? TreeSetNode < K > {   var left = root ?? return None NL while ( match ( left . left ) { case Some ( node ) => left = node NL true NL case _ => false NL } ) {  } NL return left NL }","func_name":"leftMost","docstring":"/* left most node */"}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"private func rightMost ( ) : ? TreeSetNode < K > {   var right = root ?? return None NL while ( match ( right . right ) { case Some ( node ) => right = node NL true NL case _ => false NL } ) {  } NL return right NL }","func_name":"rightMost","docstring":"/* right most node */"}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func iterator ( ) : TreeSetIterator < K > {  return TreeSetIterator < K > ( leftMost ( ) ) NL }","func_name":"iterator","docstring":"/* itearator */"}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func reverse ( ) : TreeSetIterator < K > {  return TreeSetIterator < K > ( rightMost ( ) , true ) NL }","func_name":"reverse","docstring":"/* reversed iterator */"}
{"repo":"rbtree","file":"set.cj","path":"rbtree/src/tree/set.cj","code_tokens":"public func toString ( ) {  this . toArray ( ) . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"rbtree","file":"node.cj","path":"rbtree/src/tree/node.cj","code_tokens":"func clone ( ) : RBTreeNode < E > {  RBTreeNode < E > ( data , left ? . clone ( ) , right ? . clone ( ) , black ) NL }","func_name":"clone","docstring":""}
{"repo":"rbtree","file":"node.cj","path":"rbtree/src/tree/node.cj","code_tokens":"func increment ( ) : ? RBTreeNode < E > {  if ( let Some ( right ) = this . right ) {   var node = right NL while ( match ( node . left ) { case Some ( n ) => node = n NL true NL case _ => false NL } ) {  } NL return node NL } NL  var node = this NL while ( match ( node . parent ) { case Some ( parent ) where nodeEq ( node , parent . right ) => node = parent NL true NL case _ => false NL } ) {  } NL return node . parent NL }","func_name":"increment","docstring":""}
{"repo":"rbtree","file":"node.cj","path":"rbtree/src/tree/node.cj","code_tokens":"func decrement ( ) : ? RBTreeNode < E > {  if ( let Some ( left ) = this . left ) {   var node = left NL while ( match ( node . right ) { case Some ( n ) => node = n NL true NL case _ => false NL } ) {  } NL return node NL } NL  var node = this NL while ( match ( node . parent ) { case Some ( parent ) where nodeEq ( node , parent . left ) => node = parent NL true NL case _ => false NL } ) {  } NL return node . parent NL }","func_name":"decrement","docstring":""}
{"repo":"rbtree","file":"node.cj","path":"rbtree/src/tree/node.cj","code_tokens":"public func reverse ( ) {  reversed_ = ! reversed_ NL return this NL }","func_name":"reverse","docstring":""}
{"repo":"rbtree","file":"node.cj","path":"rbtree/src/tree/node.cj","code_tokens":"public func iterator ( ) {  return this NL }","func_name":"iterator","docstring":""}
{"repo":"rbtree","file":"node.cj","path":"rbtree/src/tree/node.cj","code_tokens":"public func next ( ) : ? E {  if ( let Some ( node ) = node_ ) {   let data = node . data NL node_ = if ( reversed_ ) {  node . decrement ( ) NL } else {  node . increment ( ) NL } NL return data NL } NL return None NL }","func_name":"next","docstring":""}
{"repo":"rbtree","file":"node.cj","path":"rbtree/src/tree/node.cj","code_tokens":"func nodeEq < E > ( a : RBTreeNode < E > , b : ? RBTreeNode < E > ) {  if ( let Some ( n ) = b ) {  return refEq ( a , n ) NL } NL return false NL }","func_name":"nodeEq","docstring":""}
{"repo":"rbtree","file":"node.cj","path":"rbtree/src/tree/node.cj","code_tokens":"func nodeEq < E > ( a : ? RBTreeNode < E > , b : ? RBTreeNode < E > ) {  match ( ( a , b ) ) { case ( Some ( a_ ) , Some ( b_ ) ) => refEq ( a_ , b_ ) NL case ( None , None ) => true NL case _ => false NL } NL }","func_name":"nodeEq","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func iterator ( ) {  this NL }","func_name":"iterator","docstring":"/* itearator */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func next ( ) {  iter . next ( ) ? [ 0 ] NL }","func_name":"next","docstring":"/* the next entryView */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func iterator ( ) {  this NL }","func_name":"iterator","docstring":"/* itearator */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func next ( ) {  iter . next ( ) ? [ 1 ] NL }","func_name":"next","docstring":"/* the next entryView */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func isEmpty ( ) {  size_ == 0 NL }","func_name":"isEmpty","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func clear ( ) {  root = None NL size_ = 0 NL }","func_name":"clear","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func clone ( ) {  TreeMap ( root ? . clone ( ) , size_ ) NL }","func_name":"clone","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public operator func [ ] ( key : K ) {  get ( key ) . getOrThrow ( ) NL }","func_name":"[]","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func get ( key : K ) : ? V {  return search ( root , key ) ? . data [ 1 ] NL }","func_name":"get","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func contains ( key : K ) : Bool {  match ( search ( root , key ) ) { case None => return false NL case _ => return true NL } NL }","func_name":"contains","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) : Bool {  for ( key in keys ) {  match ( search ( root , key ) ) { case None => return false NL case _ => continue NL } NL } NL return true NL }","func_name":"containsAll","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func put ( key : K , val : V ) : ? V {  if ( let Some ( node ) = insert ( ( key , val ) ) ) {   let old = node . data [ 1 ] NL node . data = ( key , val ) NL return old NL } NL return None NL }","func_name":"put","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func putAll ( elements : Collection < ( K , V ) > ) : Unit {  for ( ele in elements ) {  if ( let Some ( node ) = insert ( ele ) ) {  node . data = ele NL } NL } NL }","func_name":"putAll","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public operator func [ ] ( key : K , value ! : V ) : Unit {  if ( let Some ( node ) = insert ( ( key , value ) ) ) {  node . data = ( key , value ) NL } NL }","func_name":"[]","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"@ overflowWrapping   private func insert ( data : ( K , V ) ) : ? TreeMapNode < K , V > {  if ( size_ == 0 ) {  root = TreeMapNode ( data , black : true ) NL size_ = 1 NL return None NL } NL  var parent = root . getOrThrow ( ) NL  var order = Ordering . EQ NL do {  order = data [ 0 ] . compare ( parent . data [ 0 ] ) NL } while ( match ( match ( order ) { case EQ => return parent NL case LT => parent . left NL case GT => parent . right NL } ) { case Some ( node ) => parent = node NL true NL case _ => false NL } ) NL  let cur = TreeMapNode ( data , parent : parent ) NL match ( order ) { case LT => parent . left = cur NL case _ => parent . right = cur NL } NL if ( parent . black == false ) {  insertFixUp ( cur ) NL } NL size_ ++ NL return None NL }","func_name":"insert","docstring":"/* insert data to rb-tree, return the node if the key of data exists */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"private func leftRotate ( x : TreeMapNode < K , V > ) : Unit {   let y = x . right . getOrThrow ( ) NL x . right = y . left NL if ( let Some ( left ) = y . left ) {  left . parent = x NL } NL y . parent = x . parent NL if ( let Some ( parent ) = x . parent ) {  if ( nodeEq ( x , parent . left ) ) {  parent . left = y NL } else {  parent . right = y NL } NL } else {  root = y NL } NL y . left = x NL x . parent = y NL }","func_name":"leftRotate","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"private func rightRotate ( y : TreeMapNode < K , V > ) : Unit {   let x = y . left . getOrThrow ( ) NL y . left = x . right NL if ( let Some ( right ) = x . right ) {  right . parent = y NL } NL x . parent = y . parent NL if ( let Some ( parent ) = y . parent ) {  if ( nodeEq ( y , parent . right ) ) {  parent . right = x NL } else {  parent . left = x NL } NL } else {  root = x NL } NL x . right = y NL y . parent = x NL }","func_name":"rightRotate","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"private func insertFixUp ( cur : TreeMapNode < K , V > ) : Unit {   var node = cur NL  var parent = node . parent . getOrThrow ( ) NL do {   var grandParent = parent . parent . getOrThrow ( ) NL if ( nodeEq ( parent , grandParent . left ) ) {  if ( let Some ( uncle ) = grandParent . right ) {  if ( uncle . black == false ) {  uncle . black = true NL parent . black = true NL grandParent . black = false NL node = grandParent NL continue NL } NL } NL if ( nodeEq ( node , parent . right ) ) {  leftRotate ( parent ) NL  let tmp = parent NL parent = node NL node = tmp NL } NL parent . black = true NL grandParent . black = false NL rightRotate ( grandParent ) NL } else {  if ( let Some ( uncle ) = grandParent . left ) {  if ( uncle . black == false ) {  uncle . black = true NL parent . black = true NL grandParent . black = false NL node = grandParent NL continue NL } NL } NL if ( nodeEq ( node , parent . left ) ) {  rightRotate ( parent ) NL  let tmp = parent NL parent = node NL node = tmp NL } NL parent . black = true NL grandParent . black = false NL leftRotate ( grandParent ) NL } NL } while ( match ( node . parent ) { case Some ( n ) => parent = n NL parent . black == false NL case _ => false NL } ) NL root ? . black = true NL }","func_name":"insertFixUp","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"static private func search ( x : ? TreeMapNode < K , V > , key : K ) : ? TreeMapNode < K , V > {   var node = x ?? return None NL while ( true ) {  match ( key . compare ( node . data [ 0 ] ) ) { case EQ => return node NL case LT => node = node . left ?? return None NL case GT => node = node . right ?? return None NL } NL } NL return None NL }","func_name":"search","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func remove ( key : K ) : ? V {  if ( let Some ( node ) = search ( root , key ) ) {   let old = node . data [ 1 ] NL remove ( node ) NL return old NL } NL return None NL }","func_name":"remove","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) : Unit {  for ( key in keys ) {  if ( let Some ( node ) = search ( root , key ) ) {  remove ( node ) NL } NL } NL }","func_name":"removeAll","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func removeIf ( predicate : ( K , V ) -> Bool ) : Unit {  if ( size_ == 0 ) {  return NL } NL  var node = root . getOrThrow ( ) NL while ( match ( node . left ) { case Some ( left ) => node = left NL true NL case _ => false NL } ) {  } NL while ( true ) {   let next = node . increment ( ) NL if ( predicate ( node . data [ 0 ] , node . data [ 1 ] ) ) {  remove ( node ) NL } NL match ( next ) { case Some ( n ) => node = n NL case _ => break NL } NL } NL }","func_name":"removeIf","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"@ overflowWrapping   private func remove ( node : TreeMapNode < K , V > ) : Unit {  if ( let ( Some ( left ) , Some ( right ) ) = ( node . left , node . right ) ) {   var replace = right NL while ( match ( replace . left ) { case Some ( n ) => replace = n NL true NL case _ => false NL } ) {  } NL match ( node . parent ) { case Some ( parent ) => if ( nodeEq ( node , parent . left ) ) {  parent . left = replace NL } else {  parent . right = replace NL } NL case _ => root = replace NL } NL  var child = replace . right NL  var parent = replace . parent . getOrThrow ( ) NL  let black = replace . black NL if ( nodeEq ( node , parent ) ) {  parent = replace NL } else {  child ? . parent = parent NL parent . left = child NL replace . right = node . right NL node . right ? . parent = replace NL } NL replace . parent = node . parent NL replace . black = node . black NL replace . left = node . left NL node . left ? . parent = replace NL if ( black ) {  removeFixUp ( child , parent ) NL } NL size_ -- NL return NL } NL  let child : ? TreeMapNode < K , V > = node . left ?? node . right NL  let black = node . black NL child ? . parent = node . parent NL match ( node . parent ) { case Some ( parent ) => if ( nodeEq ( node , parent . left ) ) {  parent . left = child NL } else {  parent . right = child NL } NL case _ => root = child NL } NL if ( black ) {  removeFixUp ( child , node . parent . getOrThrow ( ) ) NL } NL size_ -- NL }","func_name":"remove","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"private func removeFixUp ( child : ? TreeMapNode < K , V > , np : TreeMapNode < K , V > ) {   var node = child NL  var opti : ? TreeMapNode < K , V > = np NL  var other : TreeMapNode < K , V > NL while ( ( node ? . black ?? true ) && ! nodeEq ( node , root ) ) {   let parent = opti . getOrThrow ( ) NL if ( nodeEq ( node , parent . left ) ) {  other = parent . right . getOrThrow ( ) NL if ( other . black == false ) {  other . black = true NL parent . black = false NL leftRotate ( parent ) NL other = parent . right . getOrThrow ( ) NL } NL if ( ( other . left ? . black ?? true ) && ( other . right ? . black ?? true ) ) {  other . black = false NL node = opti NL opti = parent . parent NL } else {  if ( other . right ? . black ?? true ) {  other . left ? . black = true NL other . black = false NL rightRotate ( other ) NL other = parent . right . getOrThrow ( ) NL } NL other . black = parent . black NL parent . black = true NL other . right ? . black = true NL leftRotate ( parent ) NL node = root NL break NL } NL } else {  other = parent . left . getOrThrow ( ) NL if ( other . black == false ) {  other . black = true NL parent . black = false NL rightRotate ( parent ) NL other = parent . left . getOrThrow ( ) NL } NL if ( ( other . left ? . black ?? true ) && ( other . right ? . black ?? true ) ) {  other . black = false NL node = opti NL opti = parent . parent NL } else {  if ( other . left ? . black ?? true ) {  other . right ? . black = true NL other . black = false NL leftRotate ( other ) NL other = parent . left . getOrThrow ( ) NL } NL other . black = parent . black NL parent . black = true NL other . left ? . black = true NL rightRotate ( parent ) NL node = root NL break NL } NL } NL } NL node ? . black = true NL }","func_name":"removeFixUp","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"private func leftMost ( ) : ? TreeMapNode < K , V > {   var left = root ?? return None NL while ( match ( left . left ) { case Some ( node ) => left = node NL true NL case _ => false NL } ) {  } NL return left NL }","func_name":"leftMost","docstring":"/* left most node */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"private func rightMost ( ) : ? TreeMapNode < K , V > {   var right = root ?? return None NL while ( match ( right . right ) { case Some ( node ) => right = node NL true NL case _ => false NL } ) {  } NL return right NL }","func_name":"rightMost","docstring":"/* right most node */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func iterator ( ) : TreeMapIterator < K , V > {  return TreeMapIterator < K , V > ( leftMost ( ) ) NL }","func_name":"iterator","docstring":"/* itearator */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func reverse ( ) : TreeMapIterator < K , V > {  return TreeMapIterator < K , V > ( rightMost ( ) , true ) NL }","func_name":"reverse","docstring":"/* reversed iterator */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func keys ( ) {  TreeMapKeys ( this ) NL }","func_name":"keys","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func values ( ) {  TreeMapValues ( this ) NL }","func_name":"values","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func firstEntry ( ) : ? TreeMapEntryView < K , V > {  return TreeMapEntryView < K , V > ( leftMost ( ) ?? return None ) NL }","func_name":"firstEntry","docstring":"/* first entry view, return `None` if map is empty. */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func lastEntry ( ) : ? TreeMapEntryView < K , V > {  return TreeMapEntryView < K , V > ( rightMost ( ) ?? return None ) NL }","func_name":"lastEntry","docstring":"/* last entry view, return `None` if map is empty. */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func ceilingEntry ( key : K ) : ? TreeMapEntryView < K , V > {   var node = root . getOrThrow ( ) NL while ( match ( key . compare ( node . data [ 0 ] ) ) { case EQ => return TreeMapEntryView ( node ) NL case LT => node = node . left ?? return TreeMapEntryView ( node ) NL true NL case GT => node = node . right ?? return TreeMapEntryView ( node . increment ( ) ?? return None ) NL true NL } ) {  } NL return None NL }","func_name":"ceilingEntry","docstring":"/*\n     * return the minimum entry view greater than or equal to the key.\n     * return `None` if it does not exist.\n     */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func floorEntry ( key : K ) : ? TreeMapEntryView < K , V > {   var node = root . getOrThrow ( ) NL while ( match ( key . compare ( node . data [ 0 ] ) ) { case EQ => return TreeMapEntryView ( node ) NL case GT => node = node . right ?? return TreeMapEntryView ( node ) NL true NL case LT => node = node . left ?? return TreeMapEntryView ( node . decrement ( ) ?? return None ) NL true NL } ) {  } NL return None NL }","func_name":"floorEntry","docstring":"/*\n     * return the maximum entry view less than or equal to the key.\n     * return `None` if it does not exist.\n     */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func findEntry ( key : K ) : ? TreeMapEntryView < K , V > {  return TreeMapEntryView < K , V > ( search ( root , key ) ?? return None ) NL }","func_name":"findEntry","docstring":"/*\n     * find the entry view by key.\n     * return `None` if it does not exist.\n     */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func setValue ( v : V ) {  node . data = ( key , v ) NL }","func_name":"setValue","docstring":"/* set the value */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func iterator ( ) : Iterator < TreeMapEntryView < K , V > > {  this NL }","func_name":"iterator","docstring":"/* itearator */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func next ( ) : ? TreeMapEntryView < K , V > {  TreeMapEntryView ( node . increment ( ) ?? return None ) NL }","func_name":"next","docstring":"/* the next entryView */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func previous ( ) : ? TreeMapEntryView < K , V > {  TreeMapEntryView ( node . decrement ( ) ?? return None ) NL }","func_name":"previous","docstring":"/* the previous entryView */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func distance ( rhs : TreeMapEntryView < K , V > ) : ? Int64 {   let nodeDistance : ( TreeMapNode < K , V > , TreeMapNode < K , V > ) -> ? Int64 = { a , b =>  var cur = a NL  var cnt = 0 NL do {  cur = cur . increment ( ) ?? return None NL cnt ++ NL } while ( cur . data [ 0 ] < b . data [ 0 ] ) NL return if ( refEq ( cur , b ) ) {  cnt NL } else {  None NL } NL } NL  let negate : ( ? Int64 ) -> ? Int64 = { num => return match ( num ) { case Some ( n ) => - n NL case _ => None NL } NL } NL return match ( key . compare ( rhs . key ) ) { case EQ => if ( this == rhs ) {  0 NL } else {  None NL } NL case LT => nodeDistance ( node , rhs . node ) NL case GT => negate ( nodeDistance ( rhs . node , node ) ) NL } NL }","func_name":"distance","docstring":"/*\n     * Return the distance from another entryView.\n     * @Return `None` if they are not belong to the same tree.\n     * @Return `0`    if they are same.\n     * @Return        the `next` count from this to the another.\n     */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public operator func == ( rhs : TreeMapEntryView < K , V > ) {  refEq ( node , rhs . node ) NL }","func_name":"==","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public operator func != ( rhs : TreeMapEntryView < K , V > ) {  ! refEq ( node , rhs . node ) NL }","func_name":"!=","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public operator func + ( d : Int64 ) : TreeMapEntryView < K , V > {  if ( d == 0 ) {  return this NL } NL if ( d < 0 ) {  return this - - d NL } NL  var c = node NL for ( i in 0 .. d ) {  c = c . increment ( ) ?? throw OverflowException ( The Next `${d}` Is Out Of Range, `${i}` In Actual. ) NL } NL return TreeMapEntryView ( c ) NL }","func_name":"+","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public operator func - ( d : Int64 ) : TreeMapEntryView < K , V > {  if ( d == 0 ) {  return this NL } NL if ( d < 0 ) {  return this + - d NL } NL  var c = node NL for ( i in 0 .. d ) {  c = c . decrement ( ) ?? throw OverflowException ( The Previous `${d}` Is Out Of Range, `${i}` In Actual. ) NL } NL return TreeMapEntryView ( c ) NL }","func_name":"-","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public operator func - ( rhs : TreeMapEntryView < K , V > ) : Int64 {  - ( distance ( rhs ) ?? throw IllegalArgumentException ( Not The Entries In The Same Tree ) ) NL }","func_name":"-","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func isEmpty ( ) {  map . isEmpty ( ) NL }","func_name":"isEmpty","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func contains ( key : K ) {  map . contains ( key ) NL }","func_name":"contains","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func containsAll ( keys : Collection < K > ) {  map . containsAll ( keys ) NL }","func_name":"containsAll","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func remove ( key : K ) {  match ( map . remove ( key ) ) { case None => false NL case _ => true NL } NL }","func_name":"remove","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func removeAll ( keys : Collection < K > ) {  map . removeAll ( keys ) NL }","func_name":"removeAll","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func removeIf ( predicate : ( K ) -> Bool ) {  map . removeIf { key , val => predicate ( key ) NL } NL }","func_name":"removeIf","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func clear ( ) {  map . clear ( ) NL }","func_name":"clear","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func iterator ( ) {  TreeMapKeysIterator ( map . iterator ( ) ) NL }","func_name":"iterator","docstring":"/* itearator */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func reverse ( ) {  TreeMapKeysIterator ( map . reverse ( ) ) NL }","func_name":"reverse","docstring":"/* reversed iterator */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func isEmpty ( ) {  map . isEmpty ( ) NL }","func_name":"isEmpty","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func removeIf ( predicate : ( V ) -> Bool ) {  map . removeIf { key , val => predicate ( val ) NL } NL }","func_name":"removeIf","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func clear ( ) {  map . clear ( ) NL }","func_name":"clear","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func iterator ( ) {  TreeMapValuesIterator ( map . iterator ( ) ) NL }","func_name":"iterator","docstring":"/* itearator */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func reverse ( ) {  TreeMapValuesIterator ( map . reverse ( ) ) NL }","func_name":"reverse","docstring":"/* reversed iterator */"}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"static private func iterString ( iter : TreeMapIterator < K , V > ) {   let buff = StringBuilder ( [ ) NL  var sep = false NL for ( ( k , v ) in iter ) {  if ( sep ) {  buff . append ( ,  ) NL } else {  sep = true NL } NL buff . append ( (${k}, ${v}) ) NL } NL buff . append ( ] ) . toString ( ) NL }","func_name":"iterString","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func toString ( ) {  return iterString ( this . iterator ( ) ) NL }","func_name":"toString","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func toString ( ) {  return (${key}, ${value}) NL }","func_name":"toString","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func toString ( ) {  return this . toArray ( ) . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"rbtree","file":"map.cj","path":"rbtree/src/tree/map.cj","code_tokens":"public func toString ( ) {  return this . toArray ( ) . toString ( ) NL }","func_name":"toString","docstring":""}
