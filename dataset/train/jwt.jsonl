{"repo":"jwt","file":"jwt.cj","path":"jwt/src/jwt/jwt.cj","code_tokens":"public func decodeJwt ( token : String ) : DecodedJWT {  JWTDecoder ( parser , token ) NL }","func_name":"decodeJwt","docstring":""}
{"repo":"jwt","file":"jwt.cj","path":"jwt/src/jwt/jwt.cj","code_tokens":"static public func decode ( token : String ) : DecodedJWT {  JWTDecoder ( token ) NL }","func_name":"decode","docstring":""}
{"repo":"jwt","file":"jwt.cj","path":"jwt/src/jwt/jwt.cj","code_tokens":"static public func require ( algorithm : Algorithm ) : Verification {  BaseJWTVerifier . builder ( algorithm ) NL }","func_name":"require","docstring":""}
{"repo":"jwt","file":"jwt.cj","path":"jwt/src/jwt/jwt.cj","code_tokens":"static public func create ( ) : Builder {  JWTCreator . builder ( ) NL }","func_name":"create","docstring":"/*\n     * Returns a Json Web Token builder used to create and sign tokens.\n     *\n     * @return a token builder.\n     */"}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getToken ( ) : String {  token NL }","func_name":"getToken","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getHeader ( ) : String {  parts [ 0 ] NL }","func_name":"getHeader","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getPayload ( ) : String {  parts [ 1 ] NL }","func_name":"getPayload","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getSignature ( ) : String {  parts [ 2 ] NL }","func_name":"getSignature","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getAlgorithm ( ) : String {  header . getAlgorithm ( ) NL }","func_name":"getAlgorithm","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getType ( ) : String {  header . getType ( ) NL }","func_name":"getType","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getContentType ( ) : String {  header . getContentType ( ) NL }","func_name":"getContentType","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getKeyId ( ) : String {  header . getKeyId ( ) NL }","func_name":"getKeyId","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getHeaderClaim ( name : String ) : Claim {  header . getHeaderClaim ( name ) NL }","func_name":"getHeaderClaim","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getIssuer ( ) : String {  payload . getIssuer ( ) NL }","func_name":"getIssuer","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getSubject ( ) : String {  payload . getSubject ( ) NL }","func_name":"getSubject","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getAudience ( ) : ArrayList < String > {  payload . getAudience ( ) NL }","func_name":"getAudience","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getExpiresAt ( ) : Time {  payload . getExpiresAt ( ) NL }","func_name":"getExpiresAt","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getNotBefore ( ) : Time {  payload . getNotBefore ( ) NL }","func_name":"getNotBefore","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getIssuedAt ( ) : Time {  payload . getIssuedAt ( ) NL }","func_name":"getIssuedAt","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getId ( ) : String {  payload . getId ( ) NL }","func_name":"getId","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getClaim ( name : String ) : Claim {  payload . getClaim ( name ) NL }","func_name":"getClaim","docstring":""}
{"repo":"jwt","file":"jwt_decoder.cj","path":"jwt/src/jwt/jwt_decoder.cj","code_tokens":"public func getClaims ( ) : Map < String , Claim > {  payload . getClaims ( ) NL }","func_name":"getClaims","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func getExpectedChecks ( ) : ArrayList < ExpectedCheckHolder > {  return expectedChecks NL }","func_name":"getExpectedChecks","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withAnyOfAudience ( audience : Array < String > ) : Verification {   let value : ArrayList < String > = ArrayList < String > ( audience ) NL return withAnyOfAudience ( value ) NL }","func_name":"withAnyOfAudience","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withArrayClaim ( name : String , items : Array < String > ) : Verification {   let value : ArrayList < String > = ArrayList < String > ( items ) NL return withArrayClaim ( name , value ) NL }","func_name":"withArrayClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withAudience ( audience : Array < String > ) : Verification {   let value : ArrayList < String > = ArrayList < String > ( audience ) NL return withAudience ( value ) NL }","func_name":"withAudience","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withArrayClaim ( name : String , items : Array < Int64 > ) : Verification {   let value : ArrayList < Int64 > = ArrayList < Int64 > ( items ) NL return withArrayClaim ( name , value ) NL }","func_name":"withArrayClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withIssuer ( issuer : Array < String > ) : Verification {   let value : ArrayList < String > = ArrayList < String > ( issuer ) NL  let fun = { claim : Claim , decodedJWT : DecodedJWT => if ( claim . isMissing ( ) ) {  return false NL } NL try {   let issure : String = claim . asString ( ) NL } catch ( e : Exception ) {  return false NL } NL if ( value . size == 0 || ! value . contains ( claim . asString ( ) ) ) {  throw IncorrectClaimException ( The Claim 'iss' value doesn't match the required issuer. , RegisteredClaims . ISSUER , claim ) NL } NL return true NL } NL addCheck ( RegisteredClaims . ISSUER , fun ) NL return this NL }","func_name":"withIssuer","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withIssuer ( issuer : String ) : Verification {  return withIssuer ( [ issuer ] ) NL }","func_name":"withIssuer","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withSubject ( subject : String ) : Verification {   let fun = extractFun ( { claim : Claim => subject == claim . asString ( ) NL } ) NL addCheck ( RegisteredClaims . SUBJECT , fun ) NL return this NL }","func_name":"withSubject","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withAudience ( audience : ArrayList < String > ) : Verification {   let value : ArrayList < String > = audience NL  let fun = { claim : Claim , decodedJWT : DecodedJWT => if ( claim . isMissing ( ) ) {  return false NL } NL if ( ! assertValidAudienceClaim ( decodedJWT . getAudience ( ) , value , true ) ) {  throw IncorrectClaimException ( The Claim 'aud' value doesn't contain the required audience. , RegisteredClaims . AUDIENCE , claim ) NL } NL return true NL } NL addCheck ( RegisteredClaims . AUDIENCE , fun ) NL return this NL }","func_name":"withAudience","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withAnyOfAudience ( audience : ArrayList < String > ) : Verification {   let value : ArrayList < String > = audience NL  let fun = { claim : Claim , decodedJWT : DecodedJWT => if ( claim . isMissing ( ) ) {  return false NL } NL if ( ! assertValidAudienceClaim ( decodedJWT . getAudience ( ) , value , false ) ) {  throw IncorrectClaimException ( The Claim 'aud' value doesn't contain the required audience. , RegisteredClaims . AUDIENCE , claim ) NL } NL return true NL } NL addCheck ( RegisteredClaims . AUDIENCE , fun ) NL return this NL }","func_name":"withAnyOfAudience","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func acceptLeeway ( leeway : Int64 ) : Verification {  assertPositive ( leeway ) NL this . defaultLeeway = leeway NL return this NL }","func_name":"acceptLeeway","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func acceptExpiresAt ( leeway : Int64 ) : Verification {  assertPositive ( leeway ) NL customLeeways . put ( RegisteredClaims . EXPIRES_AT , leeway ) NL return this NL }","func_name":"acceptExpiresAt","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func acceptNotBefore ( leeway : Int64 ) : Verification {  assertPositive ( leeway ) NL customLeeways . put ( RegisteredClaims . NOT_BEFORE , leeway ) NL return this NL }","func_name":"acceptNotBefore","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func acceptIssuedAt ( leeway : Int64 ) : Verification {  assertPositive ( leeway ) NL customLeeways . put ( RegisteredClaims . ISSUED_AT , leeway ) NL return this NL }","func_name":"acceptIssuedAt","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func ignoreIssuedAt ( ) : Verification {  this . ignoreIssuedAt1 = true NL return this NL }","func_name":"ignoreIssuedAt","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withJWTId ( jwtId : String ) : Verification {   let fun = extractFun ( { claim : Claim => jwtId . equals ( claim . asString ( ) ) NL } ) NL addCheck ( RegisteredClaims . JWT_ID , fun ) NL return this NL }","func_name":"withJWTId","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withClaimPresence ( name : String ) : Verification {   let fun = { claim : Claim , decodedJWT : DecodedJWT => return true NL } NL withClaim ( name , fun ) NL return this NL }","func_name":"withClaimPresence","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withNullClaim ( name : String ) : Verification {   let fun = { claim : Claim , decodedJWT : DecodedJWT => claim . isNull ( ) NL } NL withClaim ( name , fun ) NL return this NL }","func_name":"withNullClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withClaim ( name : String , value : Bool ) : Verification {   let fun = extractFun ( { claim : Claim => value == claim . asBool ( ) NL } ) NL addCheck ( name , fun ) NL return this NL }","func_name":"withClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"func extractFun ( fun : ( Claim ) -> Bool ) : ( Claim , DecodedJWT ) -> Bool {  { claim : Claim , decodedJWT : DecodedJWT => if ( claim . isMissing ( ) ) {  return false NL } NL try {  return fun ( claim ) NL } catch ( e : Exception ) {  return false NL } NL } NL }","func_name":"extractFun","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withClaim ( name : String , value : Int64 ) : Verification {   let fun = extractFun ( { claim : Claim => value == claim . asInt ( ) NL } ) NL addCheck ( name , fun ) NL return this NL }","func_name":"withClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withClaim ( name : String , value : Float64 ) : Verification {   let fun = extractFun ( { claim : Claim => value == claim . asFloat ( ) NL } ) NL addCheck ( name , fun ) NL return this NL }","func_name":"withClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withClaim ( name : String , value : String ) : Verification {   let fun = extractFun ( { claim : Claim => value . equals ( claim . asString ( ) ) NL } ) NL addCheck ( name , fun ) NL return this NL }","func_name":"withClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withClaim ( name : String , value : Time ) : Verification {   let fun = extractFun ( { claim : Claim => value == claim . asTime ( ) NL } ) NL addCheck ( name , fun ) NL return this NL }","func_name":"withClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withClaim ( name : String , predicate : ( Claim , DecodedJWT ) -> Bool ) : Verification {  expectedChecks . append ( constructExpectedCheck ( name , predicate ) ) NL return this NL }","func_name":"withClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withArrayClaim ( name : String , items : ArrayList < String > ) : Verification {   let fun = { claim : Claim , decodedJWT : DecodedJWT => assertValidCollectionClaim ( claim , items ) NL } NL addCheck ( name , fun ) NL return this NL }","func_name":"withArrayClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func withArrayClaim ( name : String , items : ArrayList < Int64 > ) : Verification {   let fun = { claim : Claim , decodedJWT : DecodedJWT => assertValidCollectionClaim ( claim , items ) NL } NL addCheck ( name , fun ) NL return this NL }","func_name":"withArrayClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"public func build ( ) : JWTVerifier {  return this . build ( Time . now ( ) ) NL }","func_name":"build","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func build ( time : Time ) : JWTVerifier {  this . time = time NL addMandatoryClaimChecks ( ) NL return BaseJWTVerifier ( algorithm , expectedChecks ) NL }","func_name":"build","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func getLeewayFor ( name : String ) : Int64 {  if ( customLeeways . contains ( name ) ) {  return customLeeways . get ( name ) . getOrThrow ( ) NL } else {  return defaultLeeway NL } NL }","func_name":"getLeewayFor","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func addMandatoryClaimChecks ( ) {   let expiresAtLeeway : Int64 = getLeewayFor ( RegisteredClaims . EXPIRES_AT ) NL  let notBeforeLeeway : Int64 = getLeewayFor ( RegisteredClaims . NOT_BEFORE ) NL  let issuedAtLeeway : Int64 = getLeewayFor ( RegisteredClaims . ISSUED_AT ) NL  let fun = { claim : Claim , decodedJWT : DecodedJWT => assertValidInstantClaim ( RegisteredClaims . EXPIRES_AT , claim , expiresAtLeeway , true ) NL } NL  let fun1 = { claim : Claim , decodedJWT : DecodedJWT => assertValidInstantClaim ( RegisteredClaims . NOT_BEFORE , claim , notBeforeLeeway , false ) NL } NL  let fun2 = { claim : Claim , decodedJWT : DecodedJWT => assertValidInstantClaim ( RegisteredClaims . ISSUED_AT , claim , issuedAtLeeway , false ) NL } NL expectedChecks . append ( constructExpectedCheck ( RegisteredClaims . EXPIRES_AT , fun ) ) NL expectedChecks . append ( constructExpectedCheck ( RegisteredClaims . NOT_BEFORE , fun1 ) ) NL if ( ! ignoreIssuedAt1 ) {  expectedChecks . append ( constructExpectedCheck ( RegisteredClaims . ISSUED_AT , fun2 ) ) NL } NL }","func_name":"addMandatoryClaimChecks","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func assertValidCollectionClaim ( claim : Claim , expectedClaimValue : ArrayList < String > ) : Bool {  if ( claim . isMissing ( ) ) {  return false NL } NL  let claimArr = asStringList ( claim ) NL for ( pattern in expectedClaimValue ) {  if ( ! claimArr . contains ( pattern ) ) {  return false NL } NL } NL return true NL }","func_name":"assertValidCollectionClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func assertValidCollectionClaim ( claim : Claim , expectedClaimValue : ArrayList < Int64 > ) : Bool {  if ( claim . isMissing ( ) ) {  return false NL } NL  let claimArrInt = asIntList ( claim ) NL for ( pattern in expectedClaimValue ) {  if ( ! claimArrInt . contains ( pattern ) ) {  return false NL } NL } NL return true NL }","func_name":"assertValidCollectionClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func assertValidInstantClaim ( claimName : String , claim : Claim , leeway : Int64 , shouldBeFuture : Bool ) : Bool {  if ( claim . isMissing ( ) ) {  return true NL } NL  var claimVal : Time = claim . asTime ( ) NL  var now : Time = time NL  var isValid : Bool NL if ( shouldBeFuture ) {  isValid = assertInstantIsFuture ( claimVal , leeway , now ) NL if ( ! isValid ) {  println ( 22 ) NL throw TokenExpiredException ( The Token has expired on ${claimVal}. , claimVal ) NL } NL } else {  isValid = assertInstantIsPast ( claimVal , leeway , now ) NL print ( isValid ) NL if ( ! isValid ) {  throw IncorrectClaimException ( The Token can't be used before ${claimVal}. , claimName , claim ) NL } NL } NL return true NL }","func_name":"assertValidInstantClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func assertInstantIsFuture ( claimVal : Time , leeway : Int64 , now : Time ) : Bool {   var between = Duration . second ( leeway ) NL return ! ( ( now - between ) > claimVal ) NL }","func_name":"assertInstantIsFuture","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func assertInstantIsPast ( claimVal : Time , leeway : Int64 , now : Time ) : Bool {   var between = Duration . second ( leeway ) NL return ! ( ( now + between ) < claimVal ) NL }","func_name":"assertInstantIsPast","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func assertValidAudienceClaim ( audience : ArrayList < String > , values : ArrayList < String > , shouldContainAll : Bool ) : Bool {   var containsAll : Bool = true NL for ( value in values ) {  if ( ! audience . contains ( value ) ) {  containsAll = false NL break NL } NL } NL  var disjoint : Bool = true NL for ( value in values ) {  if ( audience . contains ( value ) ) {  disjoint = false NL break NL } NL } NL return ! ( ( shouldContainAll && ! containsAll ) || ( ! shouldContainAll && disjoint ) ) NL }","func_name":"assertValidAudienceClaim","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func assertPositive ( leeway : Int64 ) {  if ( leeway < 0 ) {  throw IllegalArgumentException ( Leeway value can't be negative. ) NL } NL }","func_name":"assertPositive","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func addCheck ( name : String , predicate : ( Claim , DecodedJWT ) -> Bool ) {   let fun = { claim : Claim , decodedJWT : DecodedJWT => if ( claim . isMissing ( ) ) {  throw MissingClaimException ( name ) NL } NL return predicate ( claim , decodedJWT ) NL } NL expectedChecks . append ( constructExpectedCheck ( name , fun ) ) NL }","func_name":"addCheck","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func constructExpectedCheck ( claimName : String , check : ( Claim , DecodedJWT ) -> Bool ) : ExpectedCheckHolder {  return ExpectedCheckHolderImpl ( claimName , check ) NL }","func_name":"constructExpectedCheck","docstring":""}
{"repo":"jwt","file":"base_verification.cj","path":"jwt/src/jwt/base_verification.cj","code_tokens":"private func isNullOrEmpty ( args : ArrayList < String > ) : Bool {  return args . isEmpty ( ) NL }","func_name":"isNullOrEmpty","docstring":""}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"protected func sign ( ) : String {   let headerB64 = Base64Util . urlEncode ( headerJson ) NL  let payloadB64 = Base64Util . urlEncode ( payloadJson ) NL  let signatureBytes = algorithm . sign ( ${headerB64}.${payloadB64} . toUtf8Array ( ) ) NL  let signature = Base64Util . urlEncode ( signatureBytes ) NL return ${headerB64}.${payloadB64}.${signature} NL }","func_name":"sign","docstring":"/*\n     * Creates a  JWT and signs is with the given algorithm.\n     *\n     * @param algorithm used to sign the JWT\n     * @return a  JWT token\n     * @throws IllegalArgumentException if the provided algorithm is null.\n     * @throws JWTCreationException     if the claims could not be converted to a valid JSON\n     * or there was a problem with the signing key.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"static func builder ( ) : Builder {  Builder ( ) NL }","func_name":"builder","docstring":""}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withHeader ( headerClaims : Map < String , Any > ) : Builder {  for ( ( key , value ) in headerClaims ) {  this . headerClaims . put ( key , value ) NL } NL return this NL }","func_name":"withHeader","docstring":"/*\n     * Add specific Claims to set as the Header.\n     * If provided map is null then nothing is changed\n     *\n     * @param headerClaims the values to use as Claims in the token's Header.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withKeyId ( keyId : String ) : Builder {  this . headerClaims . put ( HeaderParams . KEY_ID , keyId ) NL return this NL }","func_name":"withKeyId","docstring":"/*\n     * Add a specific Key Id (\"kid\") claim to the Header.\n     * If the {@link Algorithm} used to sign this token was instantiated with a KeyProvider,\n     * the 'kid' value will be taken from that provider and this one will be ignored.\n     *\n     * @param keyId the Key Id value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withIssuer ( issuer : String ) : Builder {  addClaim ( RegisteredClaims . ISSUER , issuer ) NL return this NL }","func_name":"withIssuer","docstring":"/*\n     * Add a specific Issuer (\"iss\") claim to the Payload.\n     *\n     * @param issuer the Issuer value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withSubject ( subject : String ) : Builder {  addClaim ( RegisteredClaims . SUBJECT , subject ) NL return this NL }","func_name":"withSubject","docstring":"/*\n     * Add a specific Subject (\"sub\") claim to the Payload.\n     *\n     * @param subject the Subject value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withAudience ( audience : Array < String > ) : Builder {  addClaim ( RegisteredClaims . AUDIENCE , audience ) NL return this NL }","func_name":"withAudience","docstring":"/*\n     * Add a specific Audience (\"aud\") claim to the Payload.\n     *\n     * @param audience the Audience value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withExpiresAt ( expiresAt : Time ) : Builder {  addClaim ( RegisteredClaims . EXPIRES_AT , expiresAt ) NL return this NL }","func_name":"withExpiresAt","docstring":"/*\n     * Add a specific Expires At (\"exp\") claim to the payload. The claim will be written as seconds since the epoch.\n     * Milliseconds will be truncated by rounding down to the nearest second.\n     *\n     * @param expiresAt the Expires At value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withNotBefore ( notBefore : Time ) : Builder {  addClaim ( RegisteredClaims . NOT_BEFORE , notBefore ) NL return this NL }","func_name":"withNotBefore","docstring":"/*\n     * Add a specific Not Before (\"nbf\") claim to the Payload. The claim will be written as seconds since the epoch:\n     * Milliseconds will be truncated by rounding down to the nearest second.\n     *\n     * @param notBefore the Not Before value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withIssuedAt ( issuedAt : Time ) : Builder {  addClaim ( RegisteredClaims . ISSUED_AT , issuedAt ) NL return this NL }","func_name":"withIssuedAt","docstring":"/*\n     * Add a specific Issued At (\"iat\") claim to the Payload. The claim will be written as seconds since the epoch:\n     * Milliseconds will be truncated by rounding down to the nearest second.\n     *\n     * @param issuedAt the Issued At value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withJWTId ( jwtId : String ) : Builder {  addClaim ( RegisteredClaims . JWT_ID , jwtId ) NL return this NL }","func_name":"withJWTId","docstring":"/*\n     * Add a specific JWT Id (\"jti\") claim to the Payload.\n     *\n     * @param jwtId the Token Id value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withClaim ( name : String , value : Bool ) : Builder {  addClaim ( name , value ) NL return this NL }","func_name":"withClaim","docstring":"/*\n     * Add a custom Claim value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withClaim ( name : String , value : Int64 ) : Builder {  addClaim ( name , value ) NL return this NL }","func_name":"withClaim","docstring":"/*\n     * Add a custom Claim value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withClaim ( name : String , value : Float64 ) : Builder {  addClaim ( name , value ) NL return this NL }","func_name":"withClaim","docstring":"/*\n     * Add a custom Claim value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withClaim ( name : String , value : String ) : Builder {  addClaim ( name , value ) NL return this NL }","func_name":"withClaim","docstring":"/*\n     * Add a custom Claim value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withClaim ( name : String , value : Time ) : Builder {  addClaim ( name , value ) NL return this NL }","func_name":"withClaim","docstring":"/*\n     * Add a custom Claim value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withClaim ( name : String , map : Map < String , Any > ) : Builder {  if ( ! validateClaim ( map ) ) {  throw IllegalArgumentException ( Expected map containing Map, List, Bool, Int64,  + Float64, String and Time ) NL } NL addClaim ( name , map ) NL return this NL }","func_name":"withClaim","docstring":"/*\n     * Add a custom Claim value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withClaim ( name : String , list : ArrayList < Any > ) : Builder {  if ( ! validateClaim ( list ) ) {  throw IllegalArgumentException ( Expected list containing Map, List, Bool, Int64,  + Float64, String and Time ) NL } NL addClaim ( name , list ) NL return this NL }","func_name":"withClaim","docstring":"/*\n     * Add a custom Claim value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withNullClaim ( name : String ) : Builder {  addClaim ( name , NULL_NODE ) NL return this NL }","func_name":"withNullClaim","docstring":"/*\n     * Add a custom claim with null value.\n     *\n     * @param name the Claim's name.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withArrayClaim ( name : String , items : Array < String > ) : Builder {  addClaim ( name , items ) NL return this NL }","func_name":"withArrayClaim","docstring":"/*\n     * Add a custom Array Claim with the given items.\n     *\n     * @param name  the Claim's name.\n     * @param items the Claim's value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withArrayClaim ( name : String , items : Array < Int64 > ) : Builder {  addClaim ( name , items ) NL return this NL }","func_name":"withArrayClaim","docstring":"/*\n     * Add a custom Array Claim with the given items.\n     *\n     * @param name  the Claim's name.\n     * @param items the Claim's value.\n     * @return this same Builder instance.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func withPayload ( payloadClaims : Map < String , Any > ) : Builder {  if ( ! validatePayload ( payloadClaims ) ) {  throw IllegalArgumentException ( Claim values must only be of types Map, List, Bool, Int64,  + Float64, String, Time, and Null ) NL } NL for ( ( key , value ) in payloadClaims ) {  addClaim ( key , value ) NL } NL return this NL }","func_name":"withPayload","docstring":"/*\n     * Add specific Claims to set as the Payload. If the provided map is null then\n     * nothing is changed.\n     *\n     * Accepted types are Map and List with basic types\n     * Bool, Int64, Float64,\n     * String and Time.\n     * Maps and Lists can contain null elements.\n     *\n     * If any of the claims are invalid, none will be added.\n     *\n     * @param payloadClaims the values to use as Claims in the token's payload.\n     * @return this same Builder instance.\n     * @throws IllegalArgumentException if any of the claim keys or null,\n     * or if the values are not of a supported type.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"private func validatePayload ( payload : Map < String , Any > ) : Bool {  for ( ( key , value ) in payload ) {  if ( value is ArrayList < Any > && ! validateClaim ( ( value as ArrayList < Any > ) . getOrThrow ( ) ) ) {  return false NL } else if ( value is Map < String , Any > && ! validateClaim ( ( value as Map < String , Any > ) . getOrThrow ( ) ) ) {  return false NL } else if ( ! isSupportedType ( value ) ) {  return false NL } NL } NL return true NL }","func_name":"validatePayload","docstring":""}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"static private func validateClaim ( map : Map < String , Any > ) : Bool {  for ( ( key , value ) in map ) {  if ( ! isSupportedType ( value ) ) {  return false NL } NL if ( ! ( key is String ) ) {  return false NL } NL } NL return true NL }","func_name":"validateClaim","docstring":""}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"static private func validateClaim ( list : ArrayList < Any > ) : Bool {  for ( object in list ) {  if ( ! isSupportedType ( object ) ) {  return false NL } NL } NL return true NL }","func_name":"validateClaim","docstring":""}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"static private func isSupportedType ( value : Any ) : Bool {  match ( value ) { case value : ArrayList < Any > => println ( got ArrayList<Any> ) NL validateClaim ( value ) NL case value : Map < String , Any > => println ( got Map<String, Any> ) NL validateClaim ( value ) NL case _ => isBasicType ( value ) NL } NL }","func_name":"isSupportedType","docstring":""}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"static private func isBasicType ( value : Any ) : Bool {  match ( value ) { case value : Bool => println ( got Bool ) NL true NL case value : Int64 => println ( got Int64 ) NL true NL case value : Float64 => println ( got Float64 ) NL true NL case value : Time => println ( got Time ) NL true NL case value : String => println ( got String ) NL true NL case value : Array < Int64 > => println ( got Array ) NL true NL case value : Array < String > => println ( got Array ) NL true NL case value : NodeType => println ( got NodeType ) NL true NL case _ => println ( got BasicType other ) NL false NL } NL }","func_name":"isBasicType","docstring":""}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"public func sign ( algorithm : Algorithm ) : String {  headerClaims . put ( HeaderParams . ALGORITHM , algorithm . getName ( ) ) NL if ( ! headerClaims . contains ( HeaderParams . TYPE ) ) {  headerClaims . put ( HeaderParams . TYPE , JWT ) NL } NL return JWTCreator ( algorithm , headerClaims , payloadClaims ) . sign ( ) NL }","func_name":"sign","docstring":"/*\n     * Creates a  JWT and signs is with the given algorithm.\n     *\n     * @param algorithm used to sign the JWT\n     * @return a  JWT token\n     * @throws IllegalArgumentException if the provided algorithm is null.\n     * @throws JWTCreationException     if the claims could not be converted to a valid JSON\n     * or there was a problem with the signing key.\n     */"}
{"repo":"jwt","file":"jwt_creator.cj","path":"jwt/src/jwt/jwt_creator.cj","code_tokens":"private func addClaim ( name : String , value : Any ) {  payloadClaims . put ( name , value ) NL }","func_name":"addClaim","docstring":""}
{"repo":"jwt","file":"jwt_verifier.cj","path":"jwt/src/jwt/jwt_verifier.cj","code_tokens":"static func builder ( algorithm : Algorithm ) : Verification {  try {  return BaseVerification ( algorithm ) NL } catch ( e : IllegalArgumentException ) {  throw IllegalArgumentException ( Illegal Argument  + algorithm . toString ( ) ) NL } NL }","func_name":"builder","docstring":""}
{"repo":"jwt","file":"jwt_verifier.cj","path":"jwt/src/jwt/jwt_verifier.cj","code_tokens":"public func verify ( token : String ) : DecodedJWT {   var jwt : DecodedJWT = JWTDecoder ( parser , token ) NL return verify ( jwt ) NL }","func_name":"verify","docstring":"/**\n     * Perform the verification against the given decoded JWT, using any previous configured options.\n     *\n     * @param jwt to verify.\n     * @return a verified and decoded JWT.\n     * @throws AlgorithmMismatchException     if the algorithm stated in the token's header is not equal to\n     *                                        the one defined in the {@link JWTVerifier}.\n     * @throws SignatureVerificationException if the signature is invalid.\n     * @throws TokenExpiredException          if the token has expired.\n     * @throws MissingClaimException          if a claim to be verified is missing.\n     * @throws IncorrectClaimException        if a claim contained a different value than the expected one.\n     */"}
{"repo":"jwt","file":"jwt_verifier.cj","path":"jwt/src/jwt/jwt_verifier.cj","code_tokens":"public func verify ( jwt : DecodedJWT ) : DecodedJWT {  verifyAlgorithm ( jwt , algorithm ) NL algorithm . verify ( jwt ) NL verifyClaims ( jwt , expectedChecks ) NL return jwt NL }","func_name":"verify","docstring":"/**\n     * Perform the verification against the given decoded JWT, using any previous configured options.\n     *\n     * @param jwt to verify.\n     * @return a verified and decoded JWT.\n     * @throws AlgorithmMismatchException     if the algorithm stated in the token's header is not equal to\n     *                                        the one defined in the {@link JWTVerifier}.\n     * @throws SignatureVerificationException if the signature is invalid.\n     * @throws TokenExpiredException          if the token has expired.\n     * @throws MissingClaimException          if a claim to be verified is missing.\n     * @throws IncorrectClaimException        if a claim contained a different value than the expected one.\n     */"}
{"repo":"jwt","file":"jwt_verifier.cj","path":"jwt/src/jwt/jwt_verifier.cj","code_tokens":"private func verifyAlgorithm ( jwt : DecodedJWT , expectedAlgorithm : Algorithm ) {  if ( ! expectedAlgorithm . getName ( ) . equals ( jwt . getAlgorithm ( ) ) ) {  throw AlgorithmMismatchException ( The provided Algorithm doesn't match the one defined in the JWT's Header. ) NL } NL }","func_name":"verifyAlgorithm","docstring":""}
{"repo":"jwt","file":"jwt_verifier.cj","path":"jwt/src/jwt/jwt_verifier.cj","code_tokens":"private func verifyClaims ( jwt : DecodedJWT , expectedChecks : ArrayList < ExpectedCheckHolder > ) {  for ( expectedCheck in expectedChecks ) {   var isValid : Bool NL  var claimName : String = expectedCheck . getClaimName ( ) NL  var claim : Claim = jwt . getClaim ( claimName ) NL isValid = expectedCheck . verify ( claim , jwt ) NL if ( ! isValid ) {  throw IncorrectClaimException ( The Claim '${claimName}' value doesn't match the required one. , claimName , claim ) NL } NL } NL }","func_name":"verifyClaims","docstring":""}
{"repo":"jwt","file":"token_utils.cj","path":"jwt/src/jwt/token_utils.cj","code_tokens":"static func splitToken ( token : String ) : Array < String > {   let arr = token . split ( . ) NL if ( arr . size != 3 ) {  throw wrongNumberOfParts ( arr . size ) NL } NL arr NL }","func_name":"splitToken","docstring":""}
{"repo":"jwt","file":"token_utils.cj","path":"jwt/src/jwt/token_utils.cj","code_tokens":"static private func wrongNumberOfParts ( partCount : ToString ) {  JWTDecodeException ( The token was expected to have 3 parts, but got ${partCount}. ) NL }","func_name":"wrongNumberOfParts","docstring":""}
{"repo":"jwt","file":"missing_claim_exception.cj","path":"jwt/src/jwt/exception/missing_claim_exception.cj","code_tokens":"public func getClaimName ( ) : String {  return this . claimName NL }","func_name":"getClaimName","docstring":""}
{"repo":"jwt","file":"TokenExpiredException.cj","path":"jwt/src/jwt/exception/TokenExpiredException.cj","code_tokens":"public func getExpiredOn ( ) : Time {  return this . time NL }","func_name":"getExpiredOn","docstring":""}
{"repo":"jwt","file":"incorrect_claim_exception.cj","path":"jwt/src/jwt/exception/incorrect_claim_exception.cj","code_tokens":"public func getClaimName ( ) : String {  return this . claimName NL }","func_name":"getClaimName","docstring":""}
{"repo":"jwt","file":"incorrect_claim_exception.cj","path":"jwt/src/jwt/exception/incorrect_claim_exception.cj","code_tokens":"public func getClaimValue ( ) : Claim {  return this . claimValue NL }","func_name":"getClaimValue","docstring":""}
{"repo":"jwt","file":"claims_holder.cj","path":"jwt/src/jwt/impl/claims_holder.cj","code_tokens":"func getClaims ( ) : Map < String , Any > {  return claims NL }","func_name":"getClaims","docstring":""}
{"repo":"jwt","file":"claims_serializer.cj","path":"jwt/src/jwt/impl/claims_serializer.cj","code_tokens":"public func serialize ( holder : ClaimsHolder ) : String {   let claims = holder . getClaims ( ) NL for ( ( key , value ) in claims ) {  put ( key , value ) NL } NL toString ( ) NL }","func_name":"serialize","docstring":""}
{"repo":"jwt","file":"expected_check_holder_impl.cj","path":"jwt/src/jwt/impl/expected_check_holder_impl.cj","code_tokens":"public func getClaimName ( ) : String {  return claimName NL }","func_name":"getClaimName","docstring":"/**\n     * The claim name that will be checked.\n     *\n     * @return the claim name\n     */"}
{"repo":"jwt","file":"expected_check_holder_impl.cj","path":"jwt/src/jwt/impl/expected_check_holder_impl.cj","code_tokens":"public func verify ( claim : Claim , decodedJWT : DecodedJWT ) : Bool {  predicate ( claim , decodedJWT ) NL }","func_name":"verify","docstring":"/**\n     * The verification that will be run.\n     *\n     * @param claim the claim for which verification is done\n     * @param decodedJWT the JWT on which verification is done\n     * @return whether the verification passed or not\n     */"}
{"repo":"jwt","file":"header_deserializer.cj","path":"jwt/src/jwt/impl/header_deserializer.cj","code_tokens":"func doDeserialize ( jsonStr : String ) : Header {   let map = super . deserialize ( jsonStr ) NL  let algorithm : ? String = asString ( HeaderParams . ALGORITHM , map ) NL  let typ : ? String = asString ( HeaderParams . TYPE , map ) NL  let contentType : ? String = asString ( HeaderParams . CONTENT_TYPE , map ) NL  let keyId : ? String = asString ( HeaderParams . KEY_ID , map ) NL BaseHeader ( algorithm , typ , contentType , keyId , map ) NL }","func_name":"doDeserialize","docstring":""}
{"repo":"jwt","file":"base_header.cj","path":"jwt/src/jwt/impl/base_header.cj","code_tokens":"public func getAlgorithm ( ) : String {  algorithm . getOrThrow ( ) NL }","func_name":"getAlgorithm","docstring":""}
{"repo":"jwt","file":"base_header.cj","path":"jwt/src/jwt/impl/base_header.cj","code_tokens":"public func getType ( ) : String {  typ . getOrThrow ( ) NL }","func_name":"getType","docstring":""}
{"repo":"jwt","file":"base_header.cj","path":"jwt/src/jwt/impl/base_header.cj","code_tokens":"public func getContentType ( ) : String {  contentType . getOrThrow ( ) NL }","func_name":"getContentType","docstring":""}
{"repo":"jwt","file":"base_header.cj","path":"jwt/src/jwt/impl/base_header.cj","code_tokens":"public func getKeyId ( ) : String {  keyId . getOrThrow ( ) NL }","func_name":"getKeyId","docstring":""}
{"repo":"jwt","file":"base_header.cj","path":"jwt/src/jwt/impl/base_header.cj","code_tokens":"public func getHeaderClaim ( name : String ) : Claim {  tree . get ( name ) ?? MISSING_CLAIM NL }","func_name":"getHeaderClaim","docstring":""}
{"repo":"jwt","file":"payload_deserializer.cj","path":"jwt/src/jwt/impl/payload_deserializer.cj","code_tokens":"func doDeserialize ( jsonStr : String ) : Payload {   let map = super . deserialize ( jsonStr ) NL  let issuer : ? String = asString ( RegisteredClaims . ISSUER , map ) NL  let subject : ? String = asString ( RegisteredClaims . SUBJECT , map ) NL  let audience : ? ArrayList < String > = getStringOrArray ( RegisteredClaims . AUDIENCE , map ) NL  let expiresAt : ? Time = asTime ( RegisteredClaims . EXPIRES_AT , map ) NL  let notBefore : ? Time = asTime ( RegisteredClaims . NOT_BEFORE , map ) NL  let issuedAt : ? Time = asTime ( RegisteredClaims . ISSUED_AT , map ) NL  let jwtId : ? String = asString ( RegisteredClaims . JWT_ID , map ) NL BasePayload ( issuer , subject , audience , expiresAt , notBefore , issuedAt , jwtId , map ) NL }","func_name":"doDeserialize","docstring":""}
{"repo":"jwt","file":"base_payload.cj","path":"jwt/src/jwt/impl/base_payload.cj","code_tokens":"public func getIssuer ( ) : String {  issuer . getOrThrow ( ) NL }","func_name":"getIssuer","docstring":""}
{"repo":"jwt","file":"base_payload.cj","path":"jwt/src/jwt/impl/base_payload.cj","code_tokens":"public func getSubject ( ) : String {  subject . getOrThrow ( ) NL }","func_name":"getSubject","docstring":""}
{"repo":"jwt","file":"base_payload.cj","path":"jwt/src/jwt/impl/base_payload.cj","code_tokens":"public func getAudience ( ) : ArrayList < String > {  audience . getOrThrow ( ) NL }","func_name":"getAudience","docstring":""}
{"repo":"jwt","file":"base_payload.cj","path":"jwt/src/jwt/impl/base_payload.cj","code_tokens":"public func getExpiresAt ( ) : Time {  expiresAt . getOrThrow ( ) NL }","func_name":"getExpiresAt","docstring":""}
{"repo":"jwt","file":"base_payload.cj","path":"jwt/src/jwt/impl/base_payload.cj","code_tokens":"public func getNotBefore ( ) : Time {  notBefore . getOrThrow ( ) NL }","func_name":"getNotBefore","docstring":""}
{"repo":"jwt","file":"base_payload.cj","path":"jwt/src/jwt/impl/base_payload.cj","code_tokens":"public func getIssuedAt ( ) : Time {  issuedAt . getOrThrow ( ) NL }","func_name":"getIssuedAt","docstring":""}
{"repo":"jwt","file":"base_payload.cj","path":"jwt/src/jwt/impl/base_payload.cj","code_tokens":"public func getId ( ) : String {  jwtId . getOrThrow ( ) NL }","func_name":"getId","docstring":""}
{"repo":"jwt","file":"base_payload.cj","path":"jwt/src/jwt/impl/base_payload.cj","code_tokens":"public func getClaim ( name : String ) : Claim {  tree . get ( name ) ?? MISSING_CLAIM NL }","func_name":"getClaim","docstring":""}
{"repo":"jwt","file":"base_payload.cj","path":"jwt/src/jwt/impl/base_payload.cj","code_tokens":"public func getClaims ( ) : Map < String , Claim > {  tree NL }","func_name":"getClaims","docstring":""}
{"repo":"jwt","file":"jwt_parser.cj","path":"jwt/src/jwt/impl/jwt_parser.cj","code_tokens":"public override func parseHeader ( jsons : String ) : Header {  try {  headerReader . doDeserialize ( jsons ) NL } catch ( e : JsonException ) {  throw JWTDecodeException ( The string '${jsons}' doesn't have a valid JSON format. ) NL } NL }","func_name":"parseHeader","docstring":""}
{"repo":"jwt","file":"jwt_parser.cj","path":"jwt/src/jwt/impl/jwt_parser.cj","code_tokens":"public override func parsePayload ( jsons : String ) : Payload {  try {  payloadReader . doDeserialize ( jsons ) NL } catch ( e : JsonException ) {  throw JWTDecodeException ( The string '${jsons}' doesn't have a valid JSON format. ) NL } NL }","func_name":"parsePayload","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"func createClaim ( data : JsonValue ) : Claim {  JsonNodeClaim ( data ) NL }","func_name":"createClaim","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func isNull ( ) : Bool {  ! isMissing ( ) && data . kind ( ) == JsonKind . JsNull NL }","func_name":"isNull","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func isMissing ( ) : Bool {  missing NL }","func_name":"isMissing","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func asBool ( ) : Bool {  data . asBool ( ) . getValue ( ) NL }","func_name":"asBool","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func asInt ( ) : Int64 {  data . asInt ( ) . getValue ( ) NL }","func_name":"asInt","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func asFloat ( ) : Float64 {  data . asFloat ( ) . getValue ( ) NL }","func_name":"asFloat","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func asString ( ) : String {  data . asString ( ) . getValue ( ) NL }","func_name":"asString","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func asTime ( ) : Time {  Time ( data . asInt ( ) . getValue ( ) , 0 ) NL }","func_name":"asTime","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func asArray ( ) : Array < JsonValue > {  asList ( ) . toArray ( ) NL }","func_name":"asArray","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func asList ( ) : ArrayList < JsonValue > {  data . asArray ( ) . getItems ( ) NL }","func_name":"asList","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func asMap ( ) : Map < String , JsonValue > {  data . asObject ( ) . getFields ( ) NL }","func_name":"asMap","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func getValue ( ) : JsonValue {  return data NL }","func_name":"getValue","docstring":""}
{"repo":"jwt","file":"json_node_claim.cj","path":"jwt/src/jwt/impl/json/json_node_claim.cj","code_tokens":"public func toString ( ) : String {  if ( missing ) {  throw MissingClaimException ( ) NL } else {  data . toStr ( ) NL } NL }","func_name":"toString","docstring":""}
{"repo":"jwt","file":"deserializer.cj","path":"jwt/src/jwt/impl/json/deserializer.cj","code_tokens":"protected func deserialize ( jsonStr : String ) : Map < String , Claim > {  JsonValue . fromStr ( jsonStr ) . asObject ( ) . getFields ( ) |> map { kv : ( String , JsonValue ) => ( kv [ 0 ] , createClaim ( kv [ 1 ] ) ) NL } |> collectHashMap NL }","func_name":"deserialize","docstring":""}
{"repo":"jwt","file":"deserializer.cj","path":"jwt/src/jwt/impl/json/deserializer.cj","code_tokens":"protected func getStringOrArray ( key : String , map : Map < String , Claim > ) : ? ArrayList < String > {   let claim = map . get ( key ) NL match ( claim ? . getValue ( ) ) { case Some ( v : JsonString ) => ArrayList ( [ v . getValue ( ) ] ) NL case Some ( v : JsonArray ) => asStringList ( claim . getOrThrow ( ) ) NL case None => None NL case _ => throw JWTDecodeException ( The claim '${key}' is not string or array. ) NL } NL }","func_name":"getStringOrArray","docstring":""}
{"repo":"jwt","file":"deserializer.cj","path":"jwt/src/jwt/impl/json/deserializer.cj","code_tokens":"protected func asString ( key : String , map : Map < String , Claim > ) : ? String {  try {  map . get ( key ) ? . asString ( ) NL } catch ( e : JsonException ) {  throw JWTDecodeException ( The claim '${key}' is not string. ) NL } NL }","func_name":"asString","docstring":""}
{"repo":"jwt","file":"deserializer.cj","path":"jwt/src/jwt/impl/json/deserializer.cj","code_tokens":"protected func asTime ( key : String , map : Map < String , Claim > ) : ? Time {  try {  map . get ( key ) ? . asTime ( ) NL } catch ( e : JsonException ) {  throw JWTDecodeException ( The claim '${key}' is not time. ) NL } NL }","func_name":"asTime","docstring":""}
{"repo":"jwt","file":"deserializer.cj","path":"jwt/src/jwt/impl/json/deserializer.cj","code_tokens":"public func asIntList ( claim : Claim ) : ArrayList < Int64 > {  claim . asList ( ) |> map { a : JsonValue => a . asInt ( ) . getValue ( ) NL } |> collectArrayList NL }","func_name":"asIntList","docstring":""}
{"repo":"jwt","file":"deserializer.cj","path":"jwt/src/jwt/impl/json/deserializer.cj","code_tokens":"public func asStringList ( claim : Claim ) : ArrayList < String > {  claim . asList ( ) |> map { a : JsonValue => a . asString ( ) . getValue ( ) NL } |> collectArrayList NL }","func_name":"asStringList","docstring":""}
{"repo":"jwt","file":"serializer.cj","path":"jwt/src/jwt/impl/json/serializer.cj","code_tokens":"protected func put ( key : String , value : Any ) {   let jv = parse ( value ) NL data . put ( key , jv ) NL }","func_name":"put","docstring":""}
{"repo":"jwt","file":"serializer.cj","path":"jwt/src/jwt/impl/json/serializer.cj","code_tokens":"public func toString ( ) : String {  data . toJsonString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"jwt","file":"serializer.cj","path":"jwt/src/jwt/impl/json/serializer.cj","code_tokens":"func parse ( value : Any ) : JsonValue {  return match ( value ) { case value : Bool => bool2jv ( value ) NL case value : Int64 => int2jv ( value ) NL case value : Float64 => float2jv ( value ) NL case value : String => str2jv ( value ) NL case value : Time => time2jv ( value ) NL case value : Array < Bool > => value |> map ( bool2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : Array < Int64 > => value |> map ( int2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : Array < Float64 > => value |> map ( float2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : Array < String > => value |> map ( str2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : Array < Time > => value |> map ( time2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : Array < Any > => value |> map ( parse ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : ArrayList < Bool > => value |> map ( bool2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : ArrayList < Int64 > => value |> map ( int2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : ArrayList < Float64 > => value |> map ( float2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : ArrayList < String > => value |> map ( str2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : ArrayList < Time > => value |> map ( time2jv ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : ArrayList < Any > => value |> map ( parse ) |> reduce ( JsonArray ( ) , jv2arr ) NL case value : Map < String , Any > => value |> map { kv : ( String , Any ) => ( kv [ 0 ] , parse ( kv [ 1 ] ) ) NL } |> reduce ( JsonObject ( ) , jv2obj ) NL case value : JsonValue => value NL case _ => throw JWTCreationException ( value type not support ) NL } NL }","func_name":"parse","docstring":""}
{"repo":"jwt","file":"json_extend.cj","path":"jwt/src/jwt/impl/json/json_extend.cj","code_tokens":"func toStr ( ) : String {  match ( this . kind ( ) ) { case JsString => this . asString ( ) . getValue ( ) NL case _ => toString ( ) NL } NL }","func_name":"toStr","docstring":""}
{"repo":"jwt","file":"json_extend.cj","path":"jwt/src/jwt/impl/json/json_extend.cj","code_tokens":"private func toFlag ( ) : Int64 {  match ( this ) { case JsNull => 0 NL case JsBool => 1 NL case JsInt => 2 NL case JsFloat => 3 NL case JsString => 4 NL case JsArray => 5 NL case JsObject => 6 NL } NL }","func_name":"toFlag","docstring":""}
{"repo":"jwt","file":"json_extend.cj","path":"jwt/src/jwt/impl/json/json_extend.cj","code_tokens":"operator func == ( other : JsonKind ) : Bool {  this . toFlag ( ) == other . toFlag ( ) NL }","func_name":"==","docstring":""}
{"repo":"jwt","file":"base64_util.cj","path":"jwt/src/jwt/utils/base64_util.cj","code_tokens":"static public func urlEncode ( content : Array < UInt8 > ) : String {  return toBase64String ( content ) . replace ( + , - ) . replace ( / , _ ) . replace ( = ,  ) NL }","func_name":"urlEncode","docstring":""}
{"repo":"jwt","file":"base64_util.cj","path":"jwt/src/jwt/utils/base64_util.cj","code_tokens":"static public func urlEncode ( content : String ) : String {  return toBase64String ( content . toUtf8Array ( ) ) . replace ( + , - ) . replace ( / , _ ) . replace ( = ,  ) NL }","func_name":"urlEncode","docstring":""}
{"repo":"jwt","file":"base64_util.cj","path":"jwt/src/jwt/utils/base64_util.cj","code_tokens":"static public func urlDecode2Byte ( content : String ) : Array < UInt8 > {   var c = content . replace ( - , + ) . replace ( _ , / ) NL for ( i in 0 .. 4 - c . size & 3 ) {  c += = NL } NL return fromBase64String ( c ) . getOrThrow ( ) NL }","func_name":"urlDecode2Byte","docstring":""}
{"repo":"jwt","file":"base64_util.cj","path":"jwt/src/jwt/utils/base64_util.cj","code_tokens":"static public func urlDecode ( content : String ) : String {   var c = content . replace ( - , + ) . replace ( _ , / ) NL for ( i in 0 .. 4 - c . size & 3 ) {  c += = NL } NL return String . fromUtf8 ( fromBase64String ( c ) . getOrThrow ( ) ) NL }","func_name":"urlDecode","docstring":""}
{"repo":"jwt","file":"header.cj","path":"jwt/src/jwt/interfaces/header.cj","code_tokens":"func getAlgorithm ( ) : String","func_name":"getAlgorithm","docstring":"/*\n     * Getter for the Algorithm \"alg\" claim defined in the JWT's Header. If the claim is missing it will return None.\n     *\n     * @return the Algorithm defined or None.\n     */"}
{"repo":"jwt","file":"header.cj","path":"jwt/src/jwt/interfaces/header.cj","code_tokens":"func getType ( ) : String","func_name":"getType","docstring":"/*\n     * Getter for the Type \"typ\" claim defined in the JWT's Header. If the claim is missing it will return None.\n     *\n     * @return the Type defined or None.\n     */"}
{"repo":"jwt","file":"header.cj","path":"jwt/src/jwt/interfaces/header.cj","code_tokens":"func getContentType ( ) : String","func_name":"getContentType","docstring":"/*\n     * Getter for the Content Type \"cty\" claim defined in the JWT's Header. If the claim is missing it will return None.\n     *\n     * @return the Content Type defined or None.\n     */"}
{"repo":"jwt","file":"header.cj","path":"jwt/src/jwt/interfaces/header.cj","code_tokens":"func getKeyId ( ) : String","func_name":"getKeyId","docstring":"/*\n     * Get the value of the \"kid\" claim, or None if it's not available.\n     *\n     * @return the Key ID value or None.\n     */"}
{"repo":"jwt","file":"header.cj","path":"jwt/src/jwt/interfaces/header.cj","code_tokens":"func getHeaderClaim ( name : String ) : Claim","func_name":"getHeaderClaim","docstring":"/*\n     * Get a Private Claim given it's name. If the Claim wasn't specified in the Header, a 'null claim' will be\n     * returned. All the methods of that claim will return None.\n     *\n     * @param name the name of the Claim to retrieve.\n     * @return a non-null Claim.\n     */"}
{"repo":"jwt","file":"decoded_jwt.cj","path":"jwt/src/jwt/interfaces/decoded_jwt.cj","code_tokens":"func getToken ( ) : String","func_name":"getToken","docstring":"/*\n     * Getter for the String Token used to create this JWT instance.\n     *\n     * @return the String Token.\n     */"}
{"repo":"jwt","file":"decoded_jwt.cj","path":"jwt/src/jwt/interfaces/decoded_jwt.cj","code_tokens":"func getHeader ( ) : String","func_name":"getHeader","docstring":"/*\n     * Getter for the Header contained in the JWT as a Base64 encoded String.\n     * This represents the first part of the token.\n     *\n     * @return the Header of the JWT.\n     */"}
{"repo":"jwt","file":"decoded_jwt.cj","path":"jwt/src/jwt/interfaces/decoded_jwt.cj","code_tokens":"func getPayload ( ) : String","func_name":"getPayload","docstring":"/*\n     * Getter for the Payload contained in the JWT as a Base64 encoded String.\n     * This represents the second part of the token.\n     *\n     * @return the Payload of the JWT.\n     */"}
{"repo":"jwt","file":"decoded_jwt.cj","path":"jwt/src/jwt/interfaces/decoded_jwt.cj","code_tokens":"func getSignature ( ) : String","func_name":"getSignature","docstring":"/*\n     * Getter for the Signature contained in the JWT as a Base64 encoded String.\n     * This represents the third part of the token.\n     *\n     * @return the Signature of the JWT.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withIssuer ( issuer : String ) : Verification {  return withIssuer ( [ issuer ] ) NL }","func_name":"withIssuer","docstring":"/*\n     * Verifies whether the JWT contains an Issuer (\"iss\") claim that equals to the value provided.\n     * This check is case-sensitive.\n     *\n     * @param issuer the required Issuer value.\n     * @return this same Verification instance.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withIssuer ( issuer : Array < String > ) : Verification","func_name":"withIssuer","docstring":"/*\n     * Verifies whether the JWT contains an Issuer (\"iss\") claim that equals to the value provided.\n     * This check is case-sensitive.\n     *\n     * @param issuer the required Issuer value.\n     * @return this same Verification instance.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withSubject ( subject : String ) : Verification","func_name":"withSubject","docstring":"/*\n     * Verifies whether the JWT contains a Subject (\"sub\") claim that equals to the value provided.\n     * This check is case-sensitive.\n     *\n     * @param subject the required Subject value\n     * @return this same Verification instance.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withAudience ( audience : Array < String > ) : Verification","func_name":"withAudience","docstring":"/*\n     * Verifies whether the JWT contains an Audience (\"aud\") claim that contains all the values provided.\n     * This check is case-sensitive. An empty array is considered as a None.\n     *\n     * @param audience the required Audience value\n     * @return this same Verification instance.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withAnyOfAudience ( audience : Array < String > ) : Verification","func_name":"withAnyOfAudience","docstring":"/*\n     * Verifies whether the JWT contains an Audience (\"aud\") claim contain at least one of the specified audiences.\n     * This check is case-sensitive. An empty array is considered as a None.\n     *\n     * @param audience the required Audience value for which the \"aud\" claim must contain at least one value.\n     * @return this same Verification instance.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withAnyOfAudience ( audience : ArrayList < String > ) : Verification","func_name":"withAnyOfAudience","docstring":"/*\n     * Verifies whether the JWT contains an Audience (\"aud\") claim contain at least one of the specified audiences.\n     * This check is case-sensitive. An empty array is considered as a None.\n     *\n     * @param audience the required Audience value for which the \"aud\" claim must contain at least one value.\n     * @return this same Verification instance.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func acceptLeeway ( leeway : Int64 ) : Verification","func_name":"acceptLeeway","docstring":"/*\n     * Define the default window in seconds in which the Not Before, Issued At and Expires At Claims\n     * will still be valid. Setting a specific leeway value on a given Claim will override this value for that Claim.\n     *\n     * @param leeway the window in seconds in which the Not Before, Issued At and Expires At Claims will still be valid.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException leeway is negative.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func acceptExpiresAt ( leeway : Int64 ) : Verification","func_name":"acceptExpiresAt","docstring":"/*\n     * Set a specific leeway window in seconds in which the Expires At (\"exp\") Claim will still be valid.\n     * Expiration Date is always verified when the value is present.\n     * This method overrides the value set with acceptLeeway\n     *\n     * @param leeway the window in seconds in which the Expires At Claim will still be valid.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException leeway is negative.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func acceptNotBefore ( leeway : Int64 ) : Verification","func_name":"acceptNotBefore","docstring":"/*\n     * Set a specific leeway window in seconds in which the Not Before (\"nbf\") Claim will still be valid.\n     * Not Before Date is always verified when the value is present.\n     * This method overrides the value set with acceptLeeway\n     *\n     * @param leeway the window in seconds in which the Not Before Claim will still be valid.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException leeway is negative.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func acceptIssuedAt ( leeway : Int64 ) : Verification","func_name":"acceptIssuedAt","docstring":"/*\n     * Set a specific leeway window in seconds in which the Issued At (\"iat\") Claim will still be valid.\n     * This method overrides the value set with {@link #acceptLeeway(long)}.\n     * By default, the Issued At claim is always verified when the value is present,\n     * unless disabled with {@link #ignoreIssuedAt()}.\n     * If Issued At Verification has been disabled, no Verification of the Issued At claim will be performed,\n     * and this method has no effect.\n     *\n     * @param leeway the window in seconds in which the Issued At Claim will still be valid.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException leeway is negative.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withJWTId ( jwtId : String ) : Verification","func_name":"withJWTId","docstring":"/*\n     * Verifies whether the JWT contains a JWT ID (\"jti\") claim that equals to the value provided.\n     * This check is case-sensitive.\n     *\n     * @param jwtId the required ID value\n     * @return this same Verification instance.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withClaimPresence ( name : String ) : Verification","func_name":"withClaimPresence","docstring":"/*\n     * Verifies whether the claim is present in the JWT, with any value including None.\n     *\n     * @param name the Claim's name.\n     * @return this same Verification instance\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withNullClaim ( name : String ) : Verification","func_name":"withNullClaim","docstring":"/*\n     * Verifies whether the claim is present with a None value.\n     *\n     * @param name the Claim's name.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withClaim ( name : String , value : Bool ) : Verification","func_name":"withClaim","docstring":"/*\n     * Verifies whether the claim is equal to the given Boolean value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withClaim ( name : String , predicate : ( Claim , DecodedJWT ) -> Bool ) : Verification","func_name":"withClaim","docstring":"/*\n     * Verifies whether the claim is equal to the given Boolean value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withClaim ( name : String , value : Int64 ) : Verification","func_name":"withClaim","docstring":"/*\n     * Verifies whether the claim is equal to the given Boolean value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withClaim ( name : String , value : Float64 ) : Verification","func_name":"withClaim","docstring":"/*\n     * Verifies whether the claim is equal to the given Boolean value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withClaim ( name : String , value : String ) : Verification","func_name":"withClaim","docstring":"/*\n     * Verifies whether the claim is equal to the given Boolean value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withClaim ( name : String , value : Time ) : Verification","func_name":"withClaim","docstring":"/*\n     * Verifies whether the claim is equal to the given Boolean value.\n     *\n     * @param name  the Claim's name.\n     * @param value the Claim's value.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withArrayClaim ( name : String , items : Array < String > ) : Verification","func_name":"withArrayClaim","docstring":"/*\n     * Verifies whether the claim contain at least the given String items.\n     *\n     * @param name  the Claim's name.\n     * @param items the items the Claim must contain.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func withArrayClaim ( name : String , items : Array < Int64 > ) : Verification","func_name":"withArrayClaim","docstring":"/*\n     * Verifies whether the claim contain at least the given String items.\n     *\n     * @param name  the Claim's name.\n     * @param items the items the Claim must contain.\n     * @return this same Verification instance.\n     * @throws IllegalArgumentException the name is None.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func ignoreIssuedAt ( ) : Verification","func_name":"ignoreIssuedAt","docstring":"/*\n     * Skip the Issued At (\"iat\") claim Verification. By default, the Verification is performed.\n     *\n     * @return this same Verification instance.\n     */"}
{"repo":"jwt","file":"verification.cj","path":"jwt/src/jwt/interfaces/verification.cj","code_tokens":"func build ( ) : JWTVerifier","func_name":"build","docstring":"/*\n     * Creates a new and reusable instance of the JWTVerifier with the configuration already provided.\n     *\n     * @return a new jwt.interfaces.JWTVerifier instance.\n     */"}
{"repo":"jwt","file":"expected_check_holder.cj","path":"jwt/src/jwt/interfaces/expected_check_holder.cj","code_tokens":"func getClaimName ( ) : String","func_name":"getClaimName","docstring":"/**\n     * The claim name that will be checked.\n     *\n     * @return the claim name\n     */"}
{"repo":"jwt","file":"expected_check_holder.cj","path":"jwt/src/jwt/interfaces/expected_check_holder.cj","code_tokens":"func verify ( claim : Claim , decodedJWT : DecodedJWT ) : Bool","func_name":"verify","docstring":"/**\n     * The verification that will be run.\n     *\n     * @param claim the claim for which verification is done\n     * @param decodedJWT the JWT on which verification is done\n     * @return whether the verification passed or not\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func isNull ( ) : Bool","func_name":"isNull","docstring":"/*\n     * Whether this Claim has a null value or not.\n     * If the claim is not present, it will return false hence checking isMissing is advised as well\n     *\n     * @return whether this Claim has a null value or not.\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func isMissing ( ) : Bool","func_name":"isMissing","docstring":"/*\n     * Can be used to verify whether the Claim is found or not.\n     * This will be true even if the Claim has None value associated to it.\n     *\n     * @return whether this Claim is present or not\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func asBool ( ) : Bool","func_name":"asBool","docstring":"/*\n     * Get this Claim as a Boolean.\n     * If the value isn't of type Boolean or it can't be converted to a Boolean, None will be returned.\n     *\n     * @return the value as a Boolean or None.\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func asInt ( ) : Int64","func_name":"asInt","docstring":"/*\n     * Get this Claim as an Int64.\n     * If the value isn't of type Integer or it can't be converted to an Integer, None will be returned.\n     *\n     * @return the value as an Int64 or None.\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func asFloat ( ) : Float64","func_name":"asFloat","docstring":"/*\n     * Get this Claim as a Float64.\n     * If the value isn't of type Float or it can't be converted to a Float, None will be returned.\n     *\n     * @return the value as a Int64 or None.\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func asString ( ) : String","func_name":"asString","docstring":"/*\n     * Get this Claim as a String.\n     * If the value isn't of type String, None will be returned. For a String representation of non-textual\n     * claim types, clients can call toString().\n     *\n     * @return the value as a String or None if the underlying value is not a string.\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func asTime ( ) : Time","func_name":"asTime","docstring":"/*\n     * Get this Claim as a Date.\n     * If the value can't be converted to a Date, {@code None} will be returned.\n     *\n     * @return the value as a Date or None.\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func asArray ( ) : Array < NodeType >","func_name":"asArray","docstring":"/*\n     * Get this Claim as an Array .\n     * If the value isn't an Array, None will be returned.\n     *\n     * @return the value as an Array or None.\n     * @throws JWTDecodeException if the values inside the Array can't be converted to a NodeType.\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func asList ( ) : ArrayList < NodeType >","func_name":"asList","docstring":"/*\n     * Get this Claim as a List.\n     * If the value isn't an Array, None will be returned.\n     *\n     * @return the value as a List or None.\n     * @throws JWTDecodeException if the values inside the List can't be converted to a NodeType.\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func asMap ( ) : Map < String , NodeType >","func_name":"asMap","docstring":"/*\n     * Get this Claim as a generic Map of values.\n     *\n     * @return the value as instance of Map.\n     * @throws JWTDecodeException if the value can't be converted to a Map.\n     */"}
{"repo":"jwt","file":"claim.cj","path":"jwt/src/jwt/interfaces/claim.cj","code_tokens":"func getValue ( ) : NodeType","func_name":"getValue","docstring":"/*\n     * Get this Claim node value.\n     *\n     * @return the value as NodeType.\n     */"}
{"repo":"jwt","file":"payload.cj","path":"jwt/src/jwt/interfaces/payload.cj","code_tokens":"func getIssuer ( ) : String","func_name":"getIssuer","docstring":"/*\n     * Get the value of the \"iss\" claim, or None if it's not available.\n     *\n     * @return the Issuer value or None.\n     */"}
{"repo":"jwt","file":"payload.cj","path":"jwt/src/jwt/interfaces/payload.cj","code_tokens":"func getSubject ( ) : String","func_name":"getSubject","docstring":"/*\n     * Get the value of the \"sub\" claim, or None if it's not available.\n     *\n     * @return the Subject value or None.\n     */"}
{"repo":"jwt","file":"payload.cj","path":"jwt/src/jwt/interfaces/payload.cj","code_tokens":"func getAudience ( ) : ArrayList < String >","func_name":"getAudience","docstring":"/*\n     * Get the value of the \"aud\" claim, or None if it's not available.\n     *\n     * @return the Audience value or None.\n     */"}
{"repo":"jwt","file":"payload.cj","path":"jwt/src/jwt/interfaces/payload.cj","code_tokens":"func getExpiresAt ( ) : Time","func_name":"getExpiresAt","docstring":"/*\n     * Get the value of the \"exp\" claim, or None if it's not available.\n     *\n     * @return the Expiration Time value or None.\n     */"}
{"repo":"jwt","file":"payload.cj","path":"jwt/src/jwt/interfaces/payload.cj","code_tokens":"func getNotBefore ( ) : Time","func_name":"getNotBefore","docstring":"/*\n     * Get the value of the \"nbf\" claim, or None if it's not available.\n     *\n     * @return the Not Before value or None.\n     */"}
{"repo":"jwt","file":"payload.cj","path":"jwt/src/jwt/interfaces/payload.cj","code_tokens":"func getIssuedAt ( ) : Time","func_name":"getIssuedAt","docstring":"/*\n     * Get the value of the \"iat\" claim, or None if it's not available.\n     *\n     * @return the Issued At value or None.\n     */"}
{"repo":"jwt","file":"payload.cj","path":"jwt/src/jwt/interfaces/payload.cj","code_tokens":"func getId ( ) : String","func_name":"getId","docstring":"/*\n     * Get the value of the \"jti\" claim, or None if it's not available.\n     *\n     * @return the JWT ID value or None.\n     */"}
{"repo":"jwt","file":"payload.cj","path":"jwt/src/jwt/interfaces/payload.cj","code_tokens":"func getClaim ( name : String ) : Claim","func_name":"getClaim","docstring":"/*\n     * Get a Claim given its name. If the Claim wasn't specified in the Payload, a 'null claim'\n     * will be returned. All the methods of that claim will return None.\n     *\n     * @param name the name of the Claim to retrieve.\n     * @return a non-null Claim.\n     */"}
{"repo":"jwt","file":"payload.cj","path":"jwt/src/jwt/interfaces/payload.cj","code_tokens":"func getClaims ( ) : Map < String , Claim >","func_name":"getClaims","docstring":"/*\n     * Get the Claims defined in the Token.\n     *\n     * @return a non-null Map containing the Claims defined in the Token.\n     */"}
{"repo":"jwt","file":"jwt_verifier.cj","path":"jwt/src/jwt/interfaces/jwt_verifier.cj","code_tokens":"func verify ( token : String ) : DecodedJWT","func_name":"verify","docstring":"/*\n     * Performs the verification against the given Token.\n     *\n     * @param token to verify.\n     * @return a verified and decoded JWT.\n     * @throws JWTVerificationException if any of the verification steps fail\n     */"}
{"repo":"jwt","file":"jwt_verifier.cj","path":"jwt/src/jwt/interfaces/jwt_verifier.cj","code_tokens":"func verify ( jwt : DecodedJWT ) : DecodedJWT","func_name":"verify","docstring":"/*\n     * Performs the verification against the given Token.\n     *\n     * @param token to verify.\n     * @return a verified and decoded JWT.\n     * @throws JWTVerificationException if any of the verification steps fail\n     */"}
{"repo":"jwt","file":"key_provider.cj","path":"jwt/src/jwt/interfaces/key_provider.cj","code_tokens":"func getPublicKey ( ) : U","func_name":"getPublicKey","docstring":"/*\n     * Getter for the Public Key instance with the given Id. Used to verify the signature on the JWT verification stage.\n     *\n     * @param keyId the Key Id specified in the Token's Header or null if none is available.\n     * Provides a hint on which Public Key to use to verify the token's signature.\n     * @return the Public Key instance\n     */"}
{"repo":"jwt","file":"key_provider.cj","path":"jwt/src/jwt/interfaces/key_provider.cj","code_tokens":"func getPrivateKey ( ) : R","func_name":"getPrivateKey","docstring":"/*\n     * Getter for the Private Key instance. Used to sign the content on the JWT signing stage.\n     *\n     * @return the Private Key instance\n     */"}
{"repo":"jwt","file":"jwt_parts_parser.cj","path":"jwt/src/jwt/interfaces/jwt_parts_parser.cj","code_tokens":"func parsePayload ( jsons : String ) : Payload","func_name":"parsePayload","docstring":"/*\n     * Parses the given JSON into a Payload instance.\n     *\n     * @param json the content of the Payload in a JSON representation.\n     * @return the Payload.\n     * @throws JWTDecodeException if the json doesn't have a proper JSON format.\n     */"}
{"repo":"jwt","file":"jwt_parts_parser.cj","path":"jwt/src/jwt/interfaces/jwt_parts_parser.cj","code_tokens":"func parseHeader ( jsons : String ) : Header","func_name":"parseHeader","docstring":"/*\n     * Parses the given JSON into a Header instance.\n     *\n     * @param json the content of the Header in a JSON representation.\n     * @return the Header.\n     * @throws JWTDecodeException if the json doesn't have a proper JSON format.\n     */"}
{"repo":"jwt","file":"ecdsa_key_provider_file_impl.cj","path":"jwt/src/jwt/algorithms/ecdsa_key_provider_file_impl.cj","code_tokens":"public func getPublicKey ( ) : String {  return publicKeyFile NL }","func_name":"getPublicKey","docstring":""}
{"repo":"jwt","file":"ecdsa_key_provider_file_impl.cj","path":"jwt/src/jwt/algorithms/ecdsa_key_provider_file_impl.cj","code_tokens":"public func getPrivateKey ( ) : String {  return privateKeyFile NL }","func_name":"getPrivateKey","docstring":""}
{"repo":"jwt","file":"hmac_algorithm.cj","path":"jwt/src/jwt/algorithms/hmac_algorithm.cj","code_tokens":"static func getSecretBytes ( secretStr : String ) : Array < UInt8 > {  return secretStr . toUtf8Array ( ) NL }","func_name":"getSecretBytes","docstring":""}
{"repo":"jwt","file":"hmac_algorithm.cj","path":"jwt/src/jwt/algorithms/hmac_algorithm.cj","code_tokens":"public func verify ( jwt : DecodedJWT ) : Unit {  try {   var signatureBytes : Array < UInt8 > = Base64Util . urlDecode2Byte ( jwt . getSignature ( ) ) NL  var valid : Bool = verifySignatureFor ( getDescription ( ) , secret , jwt . getHeader ( ) , jwt . getPayload ( ) , signatureBytes ) NL if ( ! valid ) {  throw SignatureVerificationException ( HMAC exception ) NL } NL } catch ( e : IllegalArgumentException ) {  throw SignatureVerificationException ( HMAC Algorithm exception ) NL } NL }","func_name":"verify","docstring":""}
{"repo":"jwt","file":"hmac_algorithm.cj","path":"jwt/src/jwt/algorithms/hmac_algorithm.cj","code_tokens":"public func sign ( headerBytes : Array < UInt8 > , payloadBytes : Array < UInt8 > ) : Array < UInt8 > {  try {  return createSignatureFor ( getDescription ( ) , secret , headerBytes , payloadBytes ) NL } catch ( e : SignatureVerificationException ) {  throw SignatureVerificationException ( sign fail ) NL } NL }","func_name":"sign","docstring":""}
{"repo":"jwt","file":"hmac_algorithm.cj","path":"jwt/src/jwt/algorithms/hmac_algorithm.cj","code_tokens":"public func sign ( contentBytes : Array < UInt8 > ) : Array < UInt8 > {  try {  return createSignatureFor ( getDescription ( ) , secret , contentBytes ) NL } catch ( e : SignatureVerificationException ) {  throw SignatureVerificationException ( sign fail ) NL } NL }","func_name":"sign","docstring":""}
{"repo":"jwt","file":"hmac_algorithm.cj","path":"jwt/src/jwt/algorithms/hmac_algorithm.cj","code_tokens":"func verifySignatureFor ( algorithm : String , secretBytes : Array < UInt8 > , header : String , payload : String , signatureBytes : Array < UInt8 > ) : Bool {  return verifySignatureFor ( algorithm , secretBytes , header . toUtf8Array ( ) , payload . toUtf8Array ( ) , signatureBytes ) NL }","func_name":"verifySignatureFor","docstring":""}
{"repo":"jwt","file":"hmac_algorithm.cj","path":"jwt/src/jwt/algorithms/hmac_algorithm.cj","code_tokens":"func verifySignatureFor ( algorithm : String , secretBytes : Array < UInt8 > , headerBytes : Array < UInt8 > , payloadBytes : Array < UInt8 > , signatureBytes : Array < UInt8 > ) : Bool {  return createSignatureFor ( algorithm , secretBytes , headerBytes , payloadBytes ) == signatureBytes NL }","func_name":"verifySignatureFor","docstring":""}
{"repo":"jwt","file":"hmac_algorithm.cj","path":"jwt/src/jwt/algorithms/hmac_algorithm.cj","code_tokens":"func createSignatureFor ( algorithm : String , privateKey : Array < UInt8 > , headerBytes : Array < UInt8 > , payloadBytes : Array < UInt8 > ) : Array < UInt8 > {   var hmac : HMACCJ = HMACCJ ( ) NL  var arr : Array < UInt8 > = Array < UInt8 > ( ) NL  var contentBytes : Array < UInt8 > = Array < UInt8 > ( ( headerBytes . size + payloadBytes . size + 1 ) , item : 0 ) NL headerBytes . copyTo ( contentBytes , 0 , 0 , headerBytes . size ) NL contentBytes [ headerBytes . size ] = b'.' NL payloadBytes . copyTo ( contentBytes , 0 , ( headerBytes . size + 1 ) , payloadBytes . size ) NL match ( algorithm ) { case HmacSHA256 => hmac . hmacInit ( privateKey , AlgorithmType . Sha256 ) NL arr = Array < UInt8 > ( Int64 ( AlgorithmType . Sha256 . getBits ( ) ) , item : 0 ) NL case HmacSHA384 => hmac . hmacInit ( privateKey , AlgorithmType . Sha384 ) NL arr = Array < UInt8 > ( Int64 ( AlgorithmType . Sha384 . getBits ( ) ) , item : 0 ) NL case HmacSHA512 => hmac . hmacInit ( privateKey , AlgorithmType . Sha512 ) NL arr = Array < UInt8 > ( Int64 ( AlgorithmType . Sha512 . getBits ( ) ) , item : 0 ) NL case _ => ( ) NL } NL hmac . hmacUpdate ( contentBytes ) NL hmac . hmacFinal ( arr ) NL return arr NL }","func_name":"createSignatureFor","docstring":""}
{"repo":"jwt","file":"hmac_algorithm.cj","path":"jwt/src/jwt/algorithms/hmac_algorithm.cj","code_tokens":"func createSignatureFor ( algorithm : String , privateKey : Array < UInt8 > , contentBytes : Array < UInt8 > ) : Array < UInt8 > {   var hmac : HMACCJ = HMACCJ ( ) NL  var arr : Array < UInt8 > = Array < UInt8 > ( ) NL match ( algorithm ) { case HmacSHA256 => hmac . hmacInit ( privateKey , AlgorithmType . Sha256 ) NL arr = Array < UInt8 > ( Int64 ( AlgorithmType . Sha256 . getBits ( ) ) , item : 0 ) NL case HmacSHA384 => hmac . hmacInit ( privateKey , AlgorithmType . Sha384 ) NL arr = Array < UInt8 > ( Int64 ( AlgorithmType . Sha384 . getBits ( ) ) , item : 0 ) NL case HmacSHA512 => hmac . hmacInit ( privateKey , AlgorithmType . Sha512 ) NL arr = Array < UInt8 > ( Int64 ( AlgorithmType . Sha512 . getBits ( ) ) , item : 0 ) NL case _ => ( ) NL } NL hmac . hmacUpdate ( contentBytes ) NL hmac . hmacFinal ( arr ) NL return arr NL }","func_name":"createSignatureFor","docstring":""}
{"repo":"jwt","file":"ecdsa_algorithm.cj","path":"jwt/src/jwt/algorithms/ecdsa_algorithm.cj","code_tokens":"public func verify ( jwt : DecodedJWT ) : Unit {  try {   let content = buildContent ( jwt . getHeader ( ) , jwt . getPayload ( ) ) NL  let signature = Base64Util . urlDecode2Byte ( jwt . getSignature ( ) ) NL  let valid = verify ( content , signature ) NL if ( ! valid ) {  throw SignatureGenerationException ( SignatureGenerationException.. ) NL } NL } catch ( e : IllegalArgumentException ) {  throw SignatureVerificationException ( SignatureVerificationException.. ) NL } NL }","func_name":"verify","docstring":""}
{"repo":"jwt","file":"ecdsa_algorithm.cj","path":"jwt/src/jwt/algorithms/ecdsa_algorithm.cj","code_tokens":"func verify ( content : Array < UInt8 > , signature : Array < UInt8 > ) : Bool {  match ( getDescription ( ) ) { case SHA256withECDSA => verify ( content , signature , sha256Func ) NL case SHA384withECDSA => verify ( content , signature , sha384Func ) NL case SHA512withECDSA => verify ( content , signature , sha512Func ) NL case _ => false NL } NL }","func_name":"verify","docstring":""}
{"repo":"jwt","file":"ecdsa_algorithm.cj","path":"jwt/src/jwt/algorithms/ecdsa_algorithm.cj","code_tokens":"private func verify ( content : Array < UInt8 > , signature : Array < UInt8 > , shaFunc : ( Array < UInt8 > ) -> Array < UInt8 > ) : Bool {   let uchash = shaFunc ( content ) NL  var keyPub : EC_KEY = ecKeyNew ( ) NL keyPub = pemReadEcPub ( keyProviderFile . getPublicKey ( ) ) NL  let sinStr : SINSTR = SINSTR ( signature , Int32 ( signature . size ) ) NL  let ret = ecdsaVerify ( uchash , sinStr , keyPub ) NL ecKeyFree ( keyPub ) NL ret == 1 NL }","func_name":"verify","docstring":""}
{"repo":"jwt","file":"ecdsa_algorithm.cj","path":"jwt/src/jwt/algorithms/ecdsa_algorithm.cj","code_tokens":"public func sign ( content : Array < UInt8 > ) : Array < UInt8 > {  try {  match ( getDescription ( ) ) { case SHA256withECDSA => sign ( content , sha256Func ) NL case SHA384withECDSA => sign ( content , sha384Func ) NL case SHA512withECDSA => sign ( content , sha512Func ) NL case _ => return Array < UInt8 > ( ) NL } NL } catch ( e : SignatureGenerationException ) {  throw SignatureGenerationException ( SignatureGenerationException.. ) NL } NL }","func_name":"sign","docstring":""}
{"repo":"jwt","file":"ecdsa_algorithm.cj","path":"jwt/src/jwt/algorithms/ecdsa_algorithm.cj","code_tokens":"private func sign ( content : Array < UInt8 > , shaFunc : ( Array < UInt8 > ) -> Array < UInt8 > ) : Array < UInt8 > {   let uchash = shaFunc ( content ) NL  var keyPri : EC_KEY = ecKeyNew ( ) NL keyPri = pemReadEcPri ( keyProviderFile . getPrivateKey ( ) ) NL  let buf_len : Int32 = ecdsaSize ( keyPri ) NL  let sigbuf : SIN_MALLOC = SIN_MALLOC ( buf_len ) NL  let sin : SINSTR = ecdsaSign ( uchash , sigbuf , keyPri ) NL sin . getSinStr ( ) NL }","func_name":"sign","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func RSA256 ( keyProvider : RSAKeyProviderFileImpl ) : Algorithm {  return RSAAlgorithm ( RS256 , SHA256withRSA , keyProvider ) NL }","func_name":"RSA256","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func RSA384 ( keyProvider : RSAKeyProviderFileImpl ) : Algorithm {  return RSAAlgorithm ( RS384 , SHA384withRSA , keyProvider ) NL }","func_name":"RSA384","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func RSA512 ( keyProvider : RSAKeyProviderFileImpl ) : Algorithm {  return RSAAlgorithm ( RS512 , SHA512withRSA , keyProvider ) NL }","func_name":"RSA512","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func HMAC256 ( secret : String ) : Algorithm {  return HMACAlgorithm ( HS256 , HmacSHA256 , secret ) NL }","func_name":"HMAC256","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func HMAC256 ( secret : Array < UInt8 > ) : Algorithm {  return HMACAlgorithm ( HS256 , HmacSHA256 , secret ) NL }","func_name":"HMAC256","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func HMAC384 ( secret : String ) : Algorithm {  return HMACAlgorithm ( HS384 , HmacSHA384 , secret ) NL }","func_name":"HMAC384","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func HMAC384 ( secret : Array < UInt8 > ) : Algorithm {  return HMACAlgorithm ( HS384 , HmacSHA384 , secret ) NL }","func_name":"HMAC384","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func HMAC512 ( secret : String ) : Algorithm {  return HMACAlgorithm ( HS512 , HmacSHA512 , secret ) NL }","func_name":"HMAC512","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func HMAC512 ( secret : Array < UInt8 > ) : Algorithm {  return HMACAlgorithm ( HS512 , HmacSHA512 , secret ) NL }","func_name":"HMAC512","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func ECDSA256 ( keyProvider : ECDSAKeyProviderFileImpl ) : Algorithm {  return ECDSAAlgorithm ( ES256 , SHA256withECDSA , 32 , keyProvider ) NL }","func_name":"ECDSA256","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func ECDSA384 ( keyProvider : ECDSAKeyProviderFileImpl ) : Algorithm {  return ECDSAAlgorithm ( ES384 , SHA384withECDSA , 32 , keyProvider ) NL }","func_name":"ECDSA384","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func ECDSA512 ( keyProvider : ECDSAKeyProviderFileImpl ) : Algorithm {  return ECDSAAlgorithm ( ES512 , SHA512withECDSA , 32 , keyProvider ) NL }","func_name":"ECDSA512","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"func getDescription ( ) : String {  return description NL }","func_name":"getDescription","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"static public func none ( ) : Algorithm {  return NoneAlgorithm ( ) NL }","func_name":"none","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"public open func getSigningKeyId ( ) : String {  return  NL }","func_name":"getSigningKeyId","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"public func getName ( ) : String {  return name NL }","func_name":"getName","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"public func toString ( ) : String {  return description NL }","func_name":"toString","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"public func verify ( jwt : DecodedJWT ) : Unit","func_name":"verify","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"public open func sign ( headerBytes : Array < UInt8 > , payloadBytes : Array < UInt8 > ) : Array < UInt8 > {  return sign ( buildContent ( headerBytes , payloadBytes ) ) NL }","func_name":"sign","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"public func sign ( contentBytes : Array < UInt8 > ) : Array < UInt8 >","func_name":"sign","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"func buildContent ( header : String , payload : String ) : Array < UInt8 > {  ${header}.${payload} . toUtf8Array ( ) NL }","func_name":"buildContent","docstring":""}
{"repo":"jwt","file":"algorithm.cj","path":"jwt/src/jwt/algorithms/algorithm.cj","code_tokens":"func buildContent ( header : Array < UInt8 > , payload : Array < UInt8 > ) : Array < UInt8 > {   let content : Array < UInt8 > = Array < UInt8 > ( ( header . size + payload . size + 1 ) , item : 0 ) NL header . copyTo ( content , 0 , 0 , header . size ) NL content [ header . size ] = b'.' NL payload . copyTo ( content , 0 , ( header . size + 1 ) , payload . size ) NL content NL }","func_name":"buildContent","docstring":""}
{"repo":"jwt","file":"rsa_algorithm.cj","path":"jwt/src/jwt/algorithms/rsa_algorithm.cj","code_tokens":"public func verify ( jwt : DecodedJWT ) : Unit {  try {   let content = buildContent ( jwt . getHeader ( ) , jwt . getPayload ( ) ) NL  let signature : Array < UInt8 > = Base64Util . urlDecode2Byte ( jwt . getSignature ( ) ) NL  let valid : Bool = verify ( content , signature ) NL if ( ! valid ) {  throw SignatureGenerationException ( exception func in verify ) NL } NL } catch ( e : SignatureGenerationException ) {  throw SignatureVerificationException ( SignatureVerificationException.. ) NL } NL }","func_name":"verify","docstring":""}
{"repo":"jwt","file":"rsa_algorithm.cj","path":"jwt/src/jwt/algorithms/rsa_algorithm.cj","code_tokens":"func verify ( content : Array < UInt8 > , signature : Array < UInt8 > ) : Bool {  match ( getDescription ( ) ) { case SHA256withRSA => verify ( content , signature , sha256Func , RsaTypeId . NID_sha256 ) NL case SHA384withRSA => verify ( content , signature , sha384Func , RsaTypeId . NID_sha384 ) NL case SHA512withRSA => verify ( content , signature , sha512Func , RsaTypeId . NID_sha512 ) NL case _ => false NL } NL }","func_name":"verify","docstring":""}
{"repo":"jwt","file":"rsa_algorithm.cj","path":"jwt/src/jwt/algorithms/rsa_algorithm.cj","code_tokens":"private func verify ( content : Array < UInt8 > , signature : Array < UInt8 > , shaFunc : ( Array < UInt8 > ) -> Array < UInt8 > , rsaTypeId : RsaTypeId ) : Bool {   var uchash = shaFunc ( content ) NL  let rsa : RSA = pemReadRsaPub ( keyProviderFile . getPublicKey ( ) , false , 1 ) NL  let ret = rsaVerify ( rsaTypeId , uchash , UInt32 ( uchash . size ) , signature , rsa ) NL rsaFree ( rsa ) NL ret == 1 NL }","func_name":"verify","docstring":""}
{"repo":"jwt","file":"rsa_algorithm.cj","path":"jwt/src/jwt/algorithms/rsa_algorithm.cj","code_tokens":"public func sign ( content : Array < UInt8 > ) : Array < UInt8 > {  try {  match ( getDescription ( ) ) { case SHA256withRSA => sign ( content , sha256Func , RsaTypeId . NID_sha256 ) NL case SHA384withRSA => sign ( content , sha384Func , RsaTypeId . NID_sha384 ) NL case SHA512withRSA => sign ( content , sha512Func , RsaTypeId . NID_sha512 ) NL case _ => Array < UInt8 > ( ) NL } NL } catch ( e : SignatureGenerationException ) {  throw SignatureVerificationException ( SignatureVerificationException.. ) NL } NL }","func_name":"sign","docstring":""}
{"repo":"jwt","file":"rsa_algorithm.cj","path":"jwt/src/jwt/algorithms/rsa_algorithm.cj","code_tokens":"private func sign ( content : Array < UInt8 > , shaFunc : ( Array < UInt8 > ) -> Array < UInt8 > , rsaTypeId : RsaTypeId ) : Array < UInt8 > {   let uchash = shaFunc ( content ) NL  let rsa : RSA = pemReadRsaPri ( keyProviderFile . getPrivateKey ( ) , false ) NL  let ( ret , signret ) = rsaSign ( rsaTypeId , uchash , UInt32 ( uchash . size ) , rsa ) NL rsaFree ( rsa ) NL signret NL }","func_name":"sign","docstring":""}
{"repo":"jwt","file":"rsa_key_provider_file_impl.cj","path":"jwt/src/jwt/algorithms/rsa_key_provider_file_impl.cj","code_tokens":"public func getPublicKey ( ) : String {  return publicKeyFile NL }","func_name":"getPublicKey","docstring":""}
{"repo":"jwt","file":"rsa_key_provider_file_impl.cj","path":"jwt/src/jwt/algorithms/rsa_key_provider_file_impl.cj","code_tokens":"public func getPrivateKey ( ) : String {  return privateKeyFile NL }","func_name":"getPrivateKey","docstring":""}
{"repo":"jwt","file":"none_algorithm.cj","path":"jwt/src/jwt/algorithms/none_algorithm.cj","code_tokens":"public func verify ( jwt : DecodedJWT ) : Unit {  if ( jwt . getSignature ( ) !=  ) {  throw SignatureVerificationException ( noneAlgorithm exception! ) NL } NL }","func_name":"verify","docstring":""}
{"repo":"jwt","file":"none_algorithm.cj","path":"jwt/src/jwt/algorithms/none_algorithm.cj","code_tokens":"public func sign ( headerBytes : Array < UInt8 > , payloadBytes : Array < UInt8 > ) : Array < UInt8 > {   let headerBytesArray : Array < UInt8 > = headerBytes NL  let payloadBytesArray : Array < UInt8 > = payloadBytes NL return Array < UInt8 > ( ) NL }","func_name":"sign","docstring":""}
{"repo":"jwt","file":"none_algorithm.cj","path":"jwt/src/jwt/algorithms/none_algorithm.cj","code_tokens":"public func sign ( contentBytes : Array < UInt8 > ) : Array < UInt8 > {   let contentBytesArray : Array < UInt8 > = contentBytes NL return Array < UInt8 > ( ) NL }","func_name":"sign","docstring":""}
