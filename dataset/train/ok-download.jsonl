{"repo":"ok-download","file":"BlockInfo.cj","path":"ok-download/src/BlockInfo.cj","code_tokens":"func getCurrentOffset ( ) : Int64 {  return this . currentOffset . load ( ) NL }","func_name":"getCurrentOffset","docstring":""}
{"repo":"ok-download","file":"BlockInfo.cj","path":"ok-download/src/BlockInfo.cj","code_tokens":"func getRangeLeft ( ) : Int64 {  return startOffset + currentOffset . load ( ) NL }","func_name":"getRangeLeft","docstring":""}
{"repo":"ok-download","file":"BlockInfo.cj","path":"ok-download/src/BlockInfo.cj","code_tokens":"func getContentLength ( ) : Int64 {  return contentLength NL }","func_name":"getContentLength","docstring":""}
{"repo":"ok-download","file":"BlockInfo.cj","path":"ok-download/src/BlockInfo.cj","code_tokens":"func getRangeRight ( ) : Int64 {  return startOffset + contentLength - 1 NL }","func_name":"getRangeRight","docstring":""}
{"repo":"ok-download","file":"BlockInfo.cj","path":"ok-download/src/BlockInfo.cj","code_tokens":"func resetBlock ( ) : Unit {  this . currentOffset . store ( 0 ) NL }","func_name":"resetBlock","docstring":""}
{"repo":"ok-download","file":"BlockInfo.cj","path":"ok-download/src/BlockInfo.cj","code_tokens":"func increaseCurrentOffset ( increaseLength : Int64 ) : Unit {  this . currentOffset . fetchAdd ( increaseLength ) NL }","func_name":"increaseCurrentOffset","docstring":""}
{"repo":"ok-download","file":"MultiPointOutputStream.cj","path":"ok-download/src/MultiPointOutputStream.cj","code_tokens":"func write ( blockIndex : Int64 , bytes : Array < UInt8 > , length : Int64 ) {  synchronized ( m ) {  if ( canceled ) {  return NL } NL outputStream ( blockIndex ) . write ( bytes , 0 , length ) NL outputStreamMap . get ( blockIndex ) . getOrThrow ( ) . flushAndSync ( ) NL } NL }","func_name":"write","docstring":""}
{"repo":"ok-download","file":"MultiPointOutputStream.cj","path":"ok-download/src/MultiPointOutputStream.cj","code_tokens":"func done ( blockIndex : Int64 ) : Unit {  close ( blockIndex ) NL }","func_name":"done","docstring":""}
{"repo":"ok-download","file":"MultiPointOutputStream.cj","path":"ok-download/src/MultiPointOutputStream.cj","code_tokens":"func close ( blockIndex : Int64 ) : Unit {  synchronized ( m ) {   let outputStream : Option < DownloadOutputStream > = outputStreamMap . get ( blockIndex ) NL if ( let Some ( i ) = outputStream ) {  outputStream . getOrThrow ( ) . close ( ) NL outputStreamMap . remove ( blockIndex ) NL Util . d ( TAG , OutputStream close task[ + task . getId ( ) . toString ( ) + ] block[ + blockIndex . toString ( ) + ] ) NL } NL } NL }","func_name":"close","docstring":""}
{"repo":"ok-download","file":"MultiPointOutputStream.cj","path":"ok-download/src/MultiPointOutputStream.cj","code_tokens":"func setRequireStreamBlocks ( requireStreamBlocks : ArrayList < Int64 > ) : Unit {  this . requireStreamBlocks = requireStreamBlocks NL }","func_name":"setRequireStreamBlocks","docstring":""}
{"repo":"ok-download","file":"MultiPointOutputStream.cj","path":"ok-download/src/MultiPointOutputStream.cj","code_tokens":"func outputStream ( blockIndex : Int64 ) : DownloadOutputStream {  synchronized ( m ) {   var outputStream : Option < DownloadOutputStream > = outputStreamMap . get ( blockIndex ) NL if ( let Some ( i ) = outputStream ) {  } else {   var uri : String NL  let isFileScheme : Bool = Util . isUriFileScheme ( task . getUri ( ) ) NL if ( ! isFileScheme ) {   let file : Option < File > = task . getFile ( ) NL if ( let Some ( j ) = file ) {  } else {  throw FileNotFoundException ( Filename is not ready! ) NL } NL  let parentFile : Directory = task . getParentFile ( ) NL if ( ! Directory . exists ( parentFile . info . path ) ) {  try {  Directory . create ( parentFile . info . path ) NL } catch ( e : ReadWriteException ) {  throw ReadWriteException ( Create parent folder failed! ) NL } NL } NL try {  parentFile . createFile ( file . getOrThrow ( ) . info . path . fileName . getOrThrow ( ) ) NL Util . d ( TAG , Create new file:  + file . getOrThrow ( ) . info . path . fileName . getOrThrow ( ) ) NL } catch ( e : Exception ) {  } NL uri = file . getOrThrow ( ) . info . path . toString ( ) NL } else {  uri = task . getUri ( ) NL } NL outputStream = OkDownload . withs ( ) . outputStreamFactory ( ) . create ( uri , flushBufferSize ) NL if ( supportSeek ) {   let seekPoint : Int64 = info . getBlock ( blockIndex ) . getOrThrow ( ) . getRangeLeft ( ) NL if ( seekPoint > 0 ) {  outputStream . getOrThrow ( ) . seek ( seekPoint ) NL Util . d ( TAG , Create output stream write from ( + task . getId ( ) . toString ( ) + ) block( + blockIndex . toString ( ) + )  + seekPoint . toString ( ) ) NL } NL } NL if ( firstOutputStream ) {  store . markFileDirty ( task . getId ( ) ) NL } NL if ( ! info . isChunked ( ) && firstOutputStream && isPreAllocateLength ) {   let totalLength : Int64 = info . getTotalLength ( ) NL if ( ! isFileScheme ) {   let file : Option < File > = task . getFile ( ) NL  let requireSpace : Int64 = totalLength - file . getOrThrow ( ) . info . length NL if ( requireSpace > 0 ) {  outputStream . getOrThrow ( ) . setLength ( totalLength ) NL } NL } else {  outputStream . getOrThrow ( ) . setLength ( totalLength ) NL } NL } NL synchronized ( m2 ) {  outputStreamMap . put ( blockIndex , outputStream . getOrThrow ( ) ) NL noSyncLengthMap . put ( blockIndex , AtomicInt64 ( 0 ) ) NL } NL firstOutputStream = false NL } NL return outputStream . getOrThrow ( ) NL } NL }","func_name":"outputStream","docstring":""}
{"repo":"ok-download","file":"InterceptorFetch.cj","path":"ok-download/src/InterceptorFetch.cj","code_tokens":"func interceptFetch ( chain : DownloadChain ) : Int64","func_name":"interceptFetch","docstring":""}
{"repo":"ok-download","file":"DownloadMonitor.cj","path":"ok-download/src/DownloadMonitor.cj","code_tokens":"func taskStart ( task : DownloadTask ) : Unit","func_name":"taskStart","docstring":""}
{"repo":"ok-download","file":"DownloadMonitor.cj","path":"ok-download/src/DownloadMonitor.cj","code_tokens":"func taskDownloadFromBreakpoint ( task : DownloadTask , info : BreakpointInfo ) : Unit","func_name":"taskDownloadFromBreakpoint","docstring":""}
{"repo":"ok-download","file":"DownloadMonitor.cj","path":"ok-download/src/DownloadMonitor.cj","code_tokens":"func taskDownloadFromBeginning ( task : DownloadTask , info : BreakpointInfo , cause : ResumeFailedCause ) : Unit","func_name":"taskDownloadFromBeginning","docstring":""}
{"repo":"ok-download","file":"DownloadMonitor.cj","path":"ok-download/src/DownloadMonitor.cj","code_tokens":"func taskEnd ( task : DownloadTask , cause : EndCause , realCause : Exception ) : Unit","func_name":"taskEnd","docstring":""}
{"repo":"ok-download","file":"CallbackDispatcher.cj","path":"ok-download/src/CallbackDispatcher.cj","code_tokens":"func isFetchProcessMoment ( task : DownloadTask ) : Bool {   let minInterval : Int64 = task . getMinIntervalMillisCallbackProcess ( ) NL  let now : Int64 = Time . now ( ) . unixTimeStamp ( ) . nanoseconds ( ) NL return ( minInterval <= 0 ) || ( ( now - TaskHideWrapper . getLastCallbackProcessTs ( task ) ) > = minInterval ) NL }","func_name":"isFetchProcessMoment","docstring":""}
{"repo":"ok-download","file":"CallbackDispatcher.cj","path":"ok-download/src/CallbackDispatcher.cj","code_tokens":"func endTasks ( completedTaskCollection : ArrayList < DownloadTask > , sameTaskConflictCollection : ArrayList < DownloadTask > , fileBusyCollection : ArrayList < DownloadTask > ) {  if ( completedTaskCollection . size == 0 && sameTaskConflictCollection . size == 0 && fileBusyCollection . size == 0 ) {  return NL } NL for ( task in completedTaskCollection ) {  task . getListener ( ) . taskEnd ( task , Option < Exception > . None ) NL } NL for ( task in sameTaskConflictCollection ) {  task . getListener ( ) . taskEnd ( task , Option < Exception > . None ) NL } NL for ( task in fileBusyCollection ) {  task . getListener ( ) . taskEnd ( task , Option < Exception > . None ) NL } NL }","func_name":"endTasks","docstring":""}
{"repo":"ok-download","file":"CallbackDispatcher.cj","path":"ok-download/src/CallbackDispatcher.cj","code_tokens":"func dispatch ( ) : DownloadListener {  return transmit NL }","func_name":"dispatch","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func isUriFileScheme ( uri : String ) : Bool {  return uri . startsWith ( file ) NL }","func_name":"isUriFileScheme","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func isEmpty ( str : Option < String > ) : Bool {  if ( let Some ( v ) = str ) {  if ( v . size == 0 ) {  return true NL } else {  return false NL } NL } else {  return true NL } NL }","func_name":"isEmpty","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func d ( tag : String , msg : String ) : Unit {   let logger : SimpleLogger = SimpleLogger ( ) NL logger . log ( LogLevel . DEBUG , tag + -- + msg ) NL }","func_name":"d","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func assembleBlock ( task : DownloadTask , info : BreakpointInfo , instanceLength : Int64 , isAcceptRange : Bool ) : Unit {   let blockCount : Int64 NL if ( OkDownload . withs ( ) . downloadStrategy ( ) . isUseMultiBlock ( isAcceptRange ) ) {  blockCount = OkDownload . withs ( ) . downloadStrategy ( ) . determineBlockCount ( task , instanceLength ) NL } else {  blockCount = 1 NL } NL info . resetBlockInfos ( ) NL  let eachLength : Int64 = instanceLength / blockCount NL  var startOffset : Int64 = 0 NL  var contentLength : Int64 = 0 NL for ( i in 0 .. blockCount ) {  startOffset = startOffset + contentLength NL if ( i == 0 ) {   let remainLength : Int64 = instanceLength % blockCount NL contentLength = eachLength + remainLength NL } else {  contentLength = eachLength NL } NL  let blockInfo : BlockInfo = BlockInfo ( startOffset , contentLength ) NL info . addBlock ( blockInfo ) NL } NL }","func_name":"assembleBlock","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func parseContentLength ( contentLength : Option < String > ) : Int64 {  if ( let Some ( i ) = contentLength ) {  } else {  return CHUNKED_CONTENT_LENGTH NL } NL try {  return Int64 . parse ( contentLength . getOrThrow ( ) ) NL } catch ( ignored : Exception ) {  Util . d ( Util , parseContentLength failed parse for ' + contentLength . getOrThrow ( ) + ' ) NL } NL return CHUNKED_CONTENT_LENGTH NL }","func_name":"parseContentLength","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func inspectUserHeader ( headerField : HashMap < String , ArrayList < String > > ) : Unit {  if ( headerField . contains ( IF_MATCH ) || headerField . contains ( RANGE ) ) {  throw ReadWriteException ( IF_MATCH +  and  + RANGE +  only can be handle by internal! ) NL } NL }","func_name":"inspectUserHeader","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func addUserRequestHeaderField ( userHeaderField : HashMap < String , ArrayList < String > > , connection : DownloadConnection ) : Unit {  inspectUserHeader ( userHeaderField ) NL addRequestHeaderFields ( userHeaderField , connection ) NL }","func_name":"addUserRequestHeaderField","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func addRequestHeaderFields ( userHeaderField : HashMap < String , ArrayList < String > > , connection : DownloadConnection ) : Unit {   var mapKeys : Keys < String > = userHeaderField . keys ( ) NL  var itera : Iterator < String > = mapKeys . iterator ( ) NL while ( true ) {   var optKey : Option < String > = itera . next ( ) NL match ( optKey ) { case Some ( v ) =>  let values : ArrayList < String > = userHeaderField . get ( v ) . getOrThrow ( ) NL for ( value in values ) {  connection . addHeader ( v , value ) NL } NL case None => break NL } NL } NL }","func_name":"addRequestHeaderFields","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func addDefaultUserAgent ( connection : DownloadConnection ) : Unit {   let userAgent : String = OkDownload/ + VERSION_NAME NL connection . addHeader ( USER_AGENT , userAgent ) NL }","func_name":"addDefaultUserAgent","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func isCorrectFull ( fetchedLength : Int64 , contentLength : Int64 ) : Bool {  return fetchedLength == contentLength NL }","func_name":"isCorrectFull","docstring":""}
{"repo":"ok-download","file":"Util.cj","path":"ok-download/src/Util.cj","code_tokens":"static func resetBlockIfDirty ( info : BlockInfo ) : Unit {   var isDirty : Bool = false NL if ( info . getCurrentOffset ( ) < 0 ) {  isDirty = true NL } else if ( info . getCurrentOffset ( ) > info . getContentLength ( ) ) {  isDirty = true NL } NL if ( isDirty ) {  info . resetBlock ( ) NL } NL }","func_name":"resetBlockIfDirty","docstring":""}
{"repo":"ok-download","file":"DownloadConnectionFactory.cj","path":"ok-download/src/DownloadConnectionFactory.cj","code_tokens":"func create ( url : String ) : DownloadConnection","func_name":"create","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"func downloadDispatcher ( ) : DownloadDispatcher {  return downloadDispatchers NL }","func_name":"downloadDispatcher","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"func callbackDispatcher ( ) : CallbackDispatcher {  return callbackDispatchers NL }","func_name":"callbackDispatcher","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"func breakpointStore ( ) : BreakpointStore {  return breakpointStores NL }","func_name":"breakpointStore","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"func connectionFactory ( ) : DownloadConnectionFactory {  return connectionFactorys NL }","func_name":"connectionFactory","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"func outputStreamFactory ( ) : DownloadOutputStreamFactory {  return outputStreamFactorys NL }","func_name":"outputStreamFactory","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"func processFileStrategy ( ) : ProcessFileStrategy {  return processFileStrategys NL }","func_name":"processFileStrategy","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"func downloadStrategy ( ) : DownloadStrategy {  return downloadStrategys NL }","func_name":"downloadStrategy","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"func setMonitor ( monitor : Option < DownloadMonitor > ) : Unit {  this . monitor = monitor NL }","func_name":"setMonitor","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"func getMonitor ( ) : Option < DownloadMonitor > {  return monitor NL }","func_name":"getMonitor","docstring":""}
{"repo":"ok-download","file":"OkDownload.cj","path":"ok-download/src/OkDownload.cj","code_tokens":"static func withs ( ) : OkDownload {  if ( let Some ( i ) = singleton ) {  } else {  synchronized ( m ) {  if ( let Some ( i ) = singleton ) {  } else {  singleton = OkDownloadBuilder ( ) . build ( ) NL } NL } NL } NL return singleton . getOrThrow ( ) NL }","func_name":"withs","docstring":""}
{"repo":"ok-download","file":"DownloadOutputStream.cj","path":"ok-download/src/DownloadOutputStream.cj","code_tokens":"func write ( b : Array < UInt8 > , off : Int64 , len : Int64 ) : Unit","func_name":"write","docstring":""}
{"repo":"ok-download","file":"DownloadOutputStream.cj","path":"ok-download/src/DownloadOutputStream.cj","code_tokens":"func close ( ) : Unit","func_name":"close","docstring":""}
{"repo":"ok-download","file":"DownloadOutputStream.cj","path":"ok-download/src/DownloadOutputStream.cj","code_tokens":"func flushAndSync ( ) : Unit","func_name":"flushAndSync","docstring":""}
{"repo":"ok-download","file":"DownloadOutputStream.cj","path":"ok-download/src/DownloadOutputStream.cj","code_tokens":"func seek ( offset : Int64 ) : Unit","func_name":"seek","docstring":""}
{"repo":"ok-download","file":"DownloadOutputStream.cj","path":"ok-download/src/DownloadOutputStream.cj","code_tokens":"func setLength ( newLength : Int64 ) : Unit","func_name":"setLength","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func taskStart ( task : DownloadTask ) : Unit {  task . getListener ( ) . taskStart ( task ) NL }","func_name":"taskStart","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func connectTrialStart ( task : DownloadTask , headerFields : HashMap < String , ArrayList < String > > ) : Unit {  task . getListener ( ) . connectTrialStart ( task , headerFields ) NL }","func_name":"connectTrialStart","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func connectTrialEnd ( task : DownloadTask , responseCode : Int64 , headerFields : HashMap < String , ArrayList < String > > ) : Unit {  task . getListener ( ) . connectTrialEnd ( task , responseCode , headerFields ) NL }","func_name":"connectTrialEnd","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func downloadFromBeginning ( task : DownloadTask ) : Unit {  task . getListener ( ) . downloadFromBeginning ( task ) NL }","func_name":"downloadFromBeginning","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func downloadFromBreakpoint ( task : DownloadTask ) : Unit {  task . getListener ( ) . downloadFromBreakpoint ( task ) NL }","func_name":"downloadFromBreakpoint","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func connectStart ( task : DownloadTask , blockIndex : Int64 , requestHeaderFields : HashMap < String , ArrayList < String > > ) : Unit {  task . getListener ( ) . connectStart ( task , blockIndex , requestHeaderFields ) NL }","func_name":"connectStart","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func connectEnd ( task : DownloadTask , blockIndex : Int64 , responseCode : Int64 , requestHeaderFields : HashMap < String , ArrayList < String > > ) : Unit {  task . getListener ( ) . connectEnd ( task , blockIndex , responseCode , requestHeaderFields ) NL }","func_name":"connectEnd","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func fetchStart ( task : DownloadTask , blockIndex : Int64 , contentLength : Int64 ) : Unit {  task . getListener ( ) . fetchStart ( task , blockIndex , contentLength ) NL }","func_name":"fetchStart","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func fetchProgress ( task : DownloadTask , blockIndex : Int64 , increaseBytes : Int64 ) : Unit {  task . getListener ( ) . fetchProgress ( task , blockIndex , increaseBytes ) NL totalSize += increaseBytes NL if ( task . getMinIntervalMillisCallbackProcess ( ) > 0 ) {  TaskHideWrapper . setLastCallbackProcessTs ( task , Time . now ( ) . unixTimeStamp ( ) . nanoseconds ( ) / 1000 ) NL } NL }","func_name":"fetchProgress","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func fetchEnd ( task : DownloadTask , blockIndex : Int64 , contentLength : Int64 ) : Unit {  task . getListener ( ) . fetchEnd ( task , blockIndex , contentLength ) NL }","func_name":"fetchEnd","docstring":""}
{"repo":"ok-download","file":"DefaultTransmitListener.cj","path":"ok-download/src/DefaultTransmitListener.cj","code_tokens":"public func taskEnd ( task : DownloadTask , realCause : Option < Exception > ) : Unit {  task . getListener ( ) . taskEnd ( task , realCause ) NL }","func_name":"taskEnd","docstring":""}
{"repo":"ok-download","file":"RetryInterceptor.cj","path":"ok-download/src/RetryInterceptor.cj","code_tokens":"public func interceptConnect ( chain : DownloadChain ) : Option < DownloadConnectionConnected > {   let cache : DownloadCache = chain . getCache ( ) NL while ( true ) {  try {  if ( cache . isInterrupt ( ) ) {  throw InterruptException . SIGNAL NL } NL return chain . processConnect ( ) NL } catch ( e : IOException ) {  throw e NL } NL } NL return Option < DownloadConnectionConnected > . None NL }","func_name":"interceptConnect","docstring":""}
{"repo":"ok-download","file":"RetryInterceptor.cj","path":"ok-download/src/RetryInterceptor.cj","code_tokens":"public func interceptFetch ( chain : DownloadChain ) : Int64 {  try {  return chain . processFetch ( ) NL } catch ( e : IOException ) {  throw e NL } NL }","func_name":"interceptFetch","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func isFilenameFromResponse ( ) : Bool {  return filenameFromResponse NL }","func_name":"isFilenameFromResponse","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getHeaderMapFields ( ) : Option < HashMap < String , ArrayList < String > > > {  return headerMapFields NL }","func_name":"getHeaderMapFields","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func getId ( ) : Int64 {  return id NL }","func_name":"getId","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func getFilename ( ) : Option < String > {  return filenameHolder . get ( ) NL }","func_name":"getFilename","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func getUri ( ) : String {  return uri NL }","func_name":"getUri","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func getUrl ( ) : String {  return url NL }","func_name":"getUrl","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func setRedirectLocation ( redirectUrl : String ) {  this . redirectLocation = redirectUrl NL }","func_name":"setRedirectLocation","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getRedirectLocation ( ) : String {  return redirectLocation NL }","func_name":"getRedirectLocation","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func getProvidedPathFile ( ) : Option < File > {  return providedPathFile NL }","func_name":"getProvidedPathFile","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getParentFile ( ) : Directory {  return directoryFile NL }","func_name":"getParentFile","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getFile ( ) : Option < File > {   let filenames : Option < String > = filenameHolder . get ( ) NL if ( let Some ( i ) = filenames ) {  } else {  return Option < File > . None NL } NL if ( let Some ( i ) = targetFile ) {  } else {  targetFile = File ( directoryFile . info . path . toString ( ) + filenames . getOrThrow ( ) , OpenOption . Open ( true , true ) ) NL } NL return targetFile NL }","func_name":"getFile","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func getReadBufferSize ( ) : Int64 {  return readBufferSize NL }","func_name":"getReadBufferSize","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func getFlushBufferSize ( ) : Int64 {  return flushBufferSize NL }","func_name":"getFlushBufferSize","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getSyncBufferSize ( ) : Int64 {  return syncBufferSize NL }","func_name":"getSyncBufferSize","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getSyncBufferIntervalMills ( ) : Int64 {  return syncBufferIntervalMills NL }","func_name":"getSyncBufferIntervalMills","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func getMinIntervalMillisCallbackProcess ( ) : Int64 {  return minIntervalMillisCallbackProcess NL }","func_name":"getMinIntervalMillisCallbackProcess","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getSetConnectionCount ( ) : Option < Int64 > {  return connectionCount NL }","func_name":"getSetConnectionCount","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getSetPreAllocateLength ( ) : Option < Bool > {  return isPreAllocateLength NL }","func_name":"getSetPreAllocateLength","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func getConnectionCount ( ) : Int64 {  if ( let Some ( i ) = info ) {  return i . getBlockCount ( ) NL } else {  return 0 NL } NL }","func_name":"getConnectionCount","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getLastCallbackProcessTs ( ) : Int64 {  return lastCallbackProcessTimestamp . load ( ) NL }","func_name":"getLastCallbackProcessTs","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func setLastCallbackProcessTs ( lastCallbackProcessTimestamp : Int64 ) : Unit {  this . lastCallbackProcessTimestamp . store ( lastCallbackProcessTimestamp ) NL }","func_name":"setLastCallbackProcessTs","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func setBreakpointInfo ( info : BreakpointInfo ) : Unit {  this . info = info NL }","func_name":"setBreakpointInfo","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"static public func enqueues ( tasks : Array < DownloadTask > , listener : DownloadListener ) : Unit {  for ( task in tasks ) {  task . listener = listener NL } NL OkDownload . withs ( ) . downloadDispatcher ( ) . enqueue ( tasks ) NL }","func_name":"enqueues","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func enqueue ( listener : DownloadListener ) : Unit {  this . listener = listener NL OkDownload . withs ( ) . downloadDispatcher ( ) . enqueue ( this ) NL }","func_name":"enqueue","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func execute ( listener : DownloadListener ) : Unit {  this . listener = listener NL OkDownload . withs ( ) . downloadDispatcher ( ) . execute ( this ) NL }","func_name":"execute","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getListener ( ) : DownloadListener {  return this . listener . getOrThrow ( ) NL }","func_name":"getListener","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"func getPriority ( ) : Int64 {  return priority NL }","func_name":"getPriority","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func toString ( ) : String {  return id . toString ( ) + @ + url + @ + directoryFile . info . path . toString ( ) + / + filenameHolder . get ( ) . getOrThrow ( ) NL }","func_name":"toString","docstring":""}
{"repo":"ok-download","file":"DownloadTask.cj","path":"ok-download/src/DownloadTask.cj","code_tokens":"public func mock ( id : Int64 ) : MockTaskForCompare {  return MockTaskForCompare ( id , this ) NL }","func_name":"mock","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func get ( id : Int64 ) : Option < BreakpointInfo > {  if ( let Some ( i ) = storedInfos . get ( id ) ) {  return i . getOrThrow ( ) NL } else {  return Option < BreakpointInfo > . None NL } NL }","func_name":"get","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func createAndInsert ( task : DownloadTask ) : BreakpointInfo {   let id : Int64 = task . getId ( ) NL  var newInfo : BreakpointInfo = BreakpointInfo ( id , task . getUrl ( ) , task . getParentFile ( ) , task . getFilename ( ) . getOrThrow ( ) ) NL synchronized ( m ) {  storedInfos . put ( id , newInfo ) NL unStoredTasks . remove ( id ) NL } NL return newInfo NL }","func_name":"createAndInsert","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func onTaskStart ( id : Int64 ) : Unit {  }","func_name":"onTaskStart","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func onSyncToFilesystemSuccess ( info : BreakpointInfo , blockIndex : Int64 , increaseLength : Int64 ) : Unit {   let onCacheOne : Option < BreakpointInfo > = this . storedInfos . get ( info . id ) . getOrThrow ( ) NL if ( refEq ( info , onCacheOne . getOrThrow ( ) ) ) {  onCacheOne . getOrThrow ( ) . getBlock ( blockIndex ) . getOrThrow ( ) . increaseCurrentOffset ( increaseLength ) NL } else {  throw ReadWriteException ( Info not on store! ) NL } NL }","func_name":"onSyncToFilesystemSuccess","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func update ( breakpointInfo : BreakpointInfo ) : Bool {   let filename : Option < String > = breakpointInfo . getFilename ( ) NL if ( let Some ( i ) = filename ) {  if ( breakpointInfo . isTaskOnlyProvidedParentPath ( ) ) {  this . responseFilenameMap . put ( breakpointInfo . getUrl ( ) , i ) NL } NL } NL  let onCacheOne : Option < BreakpointInfo > = this . storedInfos . get ( breakpointInfo . id ) . getOrThrow ( ) NL if ( let Some ( i ) = onCacheOne ) {  if ( refEq ( i , breakpointInfo ) ) {  return true NL } NL synchronized ( m ) {  this . storedInfos . put ( breakpointInfo . id , breakpointInfo ) NL } NL return true NL } else {  return false NL } NL }","func_name":"update","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func onTaskEnd ( id : Int64 , cause : EndCause , exception : Option < Exception > ) : Unit {  match ( cause ) { case EndCause . COMPLETED => remove ( id ) NL case _ => return NL } NL }","func_name":"onTaskEnd","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func getAfterCompleted ( id : Int64 ) : Option < BreakpointInfo > {  return Option < BreakpointInfo > . None NL }","func_name":"getAfterCompleted","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func markFileDirty ( id : Int64 ) : Bool {  if ( ! fileDirtyList . contains ( id ) ) {  synchronized ( m2 ) {  if ( ! fileDirtyList . contains ( id ) ) {  fileDirtyList . append ( id ) NL return true NL } NL } NL } NL return false NL }","func_name":"markFileDirty","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func markFileClear ( id : Int64 ) : Bool {  synchronized ( m2 ) {  try {  fileDirtyList . remove ( id ) NL } catch ( e : Exception ) {  return false NL } NL return true NL } NL }","func_name":"markFileClear","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func remove ( id : Int64 ) : Unit {  synchronized ( m ) {  storedInfos . remove ( id ) NL } NL }","func_name":"remove","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func findOrCreateId ( task : DownloadTask ) : Int64 {  synchronized ( m ) {   let candidate : Option < Int64 > = keyToIdMap . get ( task ) NL if ( let Some ( i ) = candidate ) {  return i NL } NL  let keyList : Keys < Int64 > = storedInfos . keys ( ) NL  let itera : Iterator < Int64 > = keyList . iterator ( ) NL while ( true ) {   var optKey : Option < Int64 > = itera . next ( ) NL match ( optKey ) { case Some ( v ) =>  let info : Option < BreakpointInfo > = storedInfos . get ( v ) . getOrThrow ( ) NL if ( let Some ( j ) = info ) {  if ( j . isSameFrom ( task ) ) {  return j . id NL } NL } NL case None => break NL } NL } NL  let keyList2 : Keys < Int64 > = unStoredTasks . keys ( ) NL  let itera2 : Iterator < Int64 > = keyList2 . iterator ( ) NL while ( true ) {   var optKey : Option < Int64 > = itera2 . next ( ) NL match ( optKey ) { case Some ( v ) =>  let another : Option < IdentifiedTask > = unStoredTasks . get ( v ) . getOrThrow ( ) NL if ( let Some ( k ) = another ) {  if ( k . compareIgnoreId ( task ) ) {  return k . getId ( ) NL } NL } else {  continue NL } NL case None => break NL } NL } NL  let id : Int64 = allocateId ( ) NL unStoredTasks . put ( id , task . mock ( id ) ) NL keyToIdMap . add ( task , id ) NL return id NL } NL }","func_name":"findOrCreateId","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func findAnotherInfoFromCompare ( task : DownloadTask , ignored : BreakpointInfo ) : Option < BreakpointInfo > {   let clonedMap : HashMap < Int64 , Option < BreakpointInfo > > NL synchronized ( m ) {  clonedMap = storedInfos . clone ( ) NL } NL  let size : Int64 = clonedMap . size NL  let keyList : Keys < Int64 > = clonedMap . keys ( ) NL  let itera : Iterator < Int64 > = keyList . iterator ( ) NL while ( true ) {   var optKey : Option < Int64 > = itera . next ( ) NL match ( optKey ) { case Some ( v ) =>  let info : Option < BreakpointInfo > = clonedMap . get ( v ) . getOrThrow ( ) NL if ( let Some ( j ) = info ) {  if ( refEq ( j , ignored ) ) {  continue NL } NL if ( j . isSameFrom ( task ) ) {  return info NL } NL } else {  continue NL } NL case None => break NL } NL } NL return Option < BreakpointInfo > . None NL }","func_name":"findAnotherInfoFromCompare","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"public func isOnlyMemoryCache ( ) : Bool {  return true NL }","func_name":"isOnlyMemoryCache","docstring":""}
{"repo":"ok-download","file":"BreakpointStoreOnCache.cj","path":"ok-download/src/BreakpointStoreOnCache.cj","code_tokens":"func allocateId ( ) : Int64 {  synchronized ( m ) {   var newId : Int64 = 0 NL  var index : Int64 = 0 NL  var preId : Int64 = 0 NL  var curId : Int64 NL for ( i in 0 .. sortedOccupiedIds . size ) {   let curIdObj : Option < Int64 > = sortedOccupiedIds . get ( i ) NL if ( let Some ( j ) = curIdObj ) {  } else {  index = i NL newId = preId + 1 NL break NL } NL curId = curIdObj . getOrThrow ( ) NL if ( preId == 0 ) {  if ( curId != FIRST_ID ) {  newId = FIRST_ID NL index = 0 NL break NL } NL preId = curId NL continue NL } NL if ( curId != preId + 1 ) {  newId = preId + 1 NL index = i NL break NL } NL preId = curId NL } NL if ( newId == 0 ) {  if ( sortedOccupiedIds . isEmpty ( ) ) {  newId = FIRST_ID NL } else {  newId = sortedOccupiedIds . get ( sortedOccupiedIds . size - 1 ) . getOrThrow ( ) + 1 NL index = sortedOccupiedIds . size NL } NL } NL sortedOccupiedIds . insert ( index , newId ) NL return newId NL } NL }","func_name":"allocateId","docstring":""}
{"repo":"ok-download","file":"DownloadUriOutputStreamFactory.cj","path":"ok-download/src/DownloadUriOutputStreamFactory.cj","code_tokens":"public func create ( file : File , flushBufferSize : Int64 ) : DownloadOutputStream {  return DownloadUriOutputStream ( file . info . path . toString ( ) , flushBufferSize ) NL }","func_name":"create","docstring":""}
{"repo":"ok-download","file":"DownloadUriOutputStreamFactory.cj","path":"ok-download/src/DownloadUriOutputStreamFactory.cj","code_tokens":"public func create ( url : String , flushBufferSize : Int64 ) : DownloadOutputStream {  return DownloadUriOutputStream ( url , flushBufferSize ) NL }","func_name":"create","docstring":""}
{"repo":"ok-download","file":"DownloadUriOutputStreamFactory.cj","path":"ok-download/src/DownloadUriOutputStreamFactory.cj","code_tokens":"public func supportSeek ( ) : Bool {  return true NL }","func_name":"supportSeek","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"func executeTrial ( ) : Unit {   var connection : DownloadConnection = OkDownload . withs ( ) . connectionFactory ( ) . create ( task . getUrl ( ) ) NL  var isNeedTrialHeadMethod : Bool = false NL try {  connection . addHeader ( Util . RANGE , bytes=0-0 ) NL  let userHeader : Option < HashMap < String , ArrayList < String > > > = task . getHeaderMapFields ( ) NL if ( let Some ( i ) = userHeader ) {  Util . addUserRequestHeaderField ( userHeader . getOrThrow ( ) , connection ) NL } NL  let listener : DownloadListener = OkDownload . withs ( ) . callbackDispatcher ( ) . dispatch ( ) NL  let requestProperties : HashMap < String , ArrayList < String > > = connection . getRequestProperties ( ) NL listener . connectTrialStart ( task , requestProperties ) NL  let connected : DownloadConnectionConnected = connection . execute ( ) NL if ( let Some ( i ) = connected . getRedirectLocation ( ) ) {  task . setRedirectLocation ( connected . getRedirectLocation ( ) . getOrThrow ( ) ) NL } NL this . responseCode = connected . getResponseCode ( ) NL this . acceptRange = isAcceptRanges ( connected ) NL this . instanceLength = findInstanceLength ( connected ) NL this . responseEtag = findEtag ( connected ) NL this . responseFilename = findFilename ( connected ) NL  var responseHeader : Option < HashMap < String , ArrayList < String > > > = connected . getResponseHeaderFields ( ) NL if ( let Some ( i ) = responseHeader ) {  } else {  responseHeader = HashMap < String , ArrayList < String > > ( ) NL } NL listener . connectTrialEnd ( task , responseCode , responseHeader . getOrThrow ( ) ) NL isNeedTrialHeadMethod = isNeedTrialHeadMethodForInstanceLength ( instanceLength ) NL } finally {  connection . release ( ) NL } NL }","func_name":"executeTrial","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"func getInstanceLength ( ) : Int64 {  return this . instanceLength NL }","func_name":"getInstanceLength","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"func isAcceptRange ( ) : Bool {  return this . acceptRange NL }","func_name":"isAcceptRange","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"func isChunked ( ) : Bool {  return this . instanceLength == Util . CHUNKED_CONTENT_LENGTH NL }","func_name":"isChunked","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"func getResponseEtag ( ) : String {  return responseEtag NL }","func_name":"getResponseEtag","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"func getResponseFilename ( ) : String {  return responseFilename NL }","func_name":"getResponseFilename","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"func getResponseCode ( ) : Int64 {  return responseCode NL }","func_name":"getResponseCode","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"static private func isAcceptRanges ( connected : DownloadConnectionConnected ) : Bool {  if ( connected . getResponseCode ( ) == Util . HTTP_PARTIAL ) {  return true NL } NL try {   let acceptRanges : String = connected . getResponseHeaderField ( Util . ACCEPT_RANGES ) . getOrThrow ( ) NL return bytes . equals ( acceptRanges ) NL } catch ( e : Exception ) {  return false NL } NL }","func_name":"isAcceptRanges","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"static private func findFilename ( connected : DownloadConnectionConnected ) : String {   let optStr : Option < String > = connected . getResponseHeaderField ( Util . CONTENT_DISPOSITION ) NL if ( let Some ( i ) = optStr ) {  return parseContentDisposition ( optStr ) . getOrThrow ( ) NL } else {  return  NL } NL }","func_name":"findFilename","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"static private func parseContentDisposition ( contentDisposition : Option < String > ) : Option < String > {  if ( let Some ( i ) = contentDisposition ) {  } else {  return Option < String > . None NL } NL try {   var fileName : Option < String > = Option < String > . None NL  var isM : Bool = false NL  var m0 = CONTENT_DISPOSITION_QUOTED_PATTERN . matcher ( contentDisposition . getOrThrow ( ) ) NL  var matchData0 = m0 . find ( ) NL match ( matchData0 ) { case Some ( s ) => if ( s . groupNumber ( ) > 0 ) {  fileName = s . matchStr ( 1 ) NL } else {  fileName = Option < String > . None NL } NL case None => isM = true NL } NL if ( let Some ( i ) = fileName ) {  if ( fileName . getOrThrow ( ) . contains ( ../ ) ) {  throw DownloadSecurityException ( The filename [ + fileName . getOrThrow ( ) + ] from the response is not allowable, because it contains '../', which can raise the directory traversal vulnerability ) NL } NL } NL return fileName NL } catch ( ex : IllegalStateException ) {  } NL return Option < String > . None NL }","func_name":"parseContentDisposition","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"static private func findEtag ( connected : DownloadConnectionConnected ) : String {  try {  return connected . getResponseHeaderField ( Util . ETAG ) . getOrThrow ( ) NL } catch ( e : Exception ) {  return  NL } NL }","func_name":"findEtag","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"static private func findInstanceLength ( connected : DownloadConnectionConnected ) : Int64 {   let instanceLength : Int64 = parseContentRangeFoInstanceLength ( connected . getResponseHeaderField ( Util . CONTENT_RANGE ) ) NL if ( instanceLength != Util . CHUNKED_CONTENT_LENGTH ) {  return instanceLength NL } NL return Util . CHUNKED_CONTENT_LENGTH NL }","func_name":"findInstanceLength","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"func isNeedTrialHeadMethodForInstanceLength ( oldInstanceLength : Int64 ) : Bool {  if ( oldInstanceLength != Util . CHUNKED_CONTENT_LENGTH ) {  return false NL } NL return true NL }","func_name":"isNeedTrialHeadMethodForInstanceLength","docstring":""}
{"repo":"ok-download","file":"ConnectTrial.cj","path":"ok-download/src/ConnectTrial.cj","code_tokens":"static private func parseContentRangeFoInstanceLength ( contentRange : Option < String > ) : Int64 {  if ( let Some ( i ) = contentRange ) {  } else {  return Util . CHUNKED_CONTENT_LENGTH NL } NL  let session : Array < String > = contentRange . getOrThrow ( ) . split ( / ) NL if ( session . size > = 2 ) {  try {  return Int64 . parse ( session [ 1 ] ) NL } catch ( e : Exception ) {  Util . d ( TAG , parse instance length failed with  + contentRange . getOrThrow ( ) . toString ( ) ) NL } NL } NL return - 1 NL }","func_name":"parseContentRangeFoInstanceLength","docstring":""}
{"repo":"ok-download","file":"TaskHideWrapper.cj","path":"ok-download/src/TaskHideWrapper.cj","code_tokens":"static func getLastCallbackProcessTs ( task : DownloadTask ) : Int64 {  return task . getLastCallbackProcessTs ( ) NL }","func_name":"getLastCallbackProcessTs","docstring":""}
{"repo":"ok-download","file":"TaskHideWrapper.cj","path":"ok-download/src/TaskHideWrapper.cj","code_tokens":"static func setLastCallbackProcessTs ( task : DownloadTask , lastCallbackProcessTimestamp : Int64 ) : Unit {  task . setLastCallbackProcessTs ( lastCallbackProcessTimestamp ) NL }","func_name":"setLastCallbackProcessTs","docstring":""}
{"repo":"ok-download","file":"TaskHideWrapper.cj","path":"ok-download/src/TaskHideWrapper.cj","code_tokens":"static func setBreakpointInfo ( task : DownloadTask , info : BreakpointInfo ) : Unit {  task . setBreakpointInfo ( info ) NL }","func_name":"setBreakpointInfo","docstring":""}
{"repo":"ok-download","file":"DownloadUriOutputStream.cj","path":"ok-download/src/DownloadUriOutputStream.cj","code_tokens":"public func write ( b : Array < UInt8 > , off : Int64 , len : Int64 ) {  out . write ( b ) NL }","func_name":"write","docstring":""}
{"repo":"ok-download","file":"DownloadUriOutputStream.cj","path":"ok-download/src/DownloadUriOutputStream.cj","code_tokens":"public func close ( ) : Unit {  fos . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"ok-download","file":"DownloadUriOutputStream.cj","path":"ok-download/src/DownloadUriOutputStream.cj","code_tokens":"public func flushAndSync ( ) : Unit {  out . flush ( ) NL fos . flush ( ) NL }","func_name":"flushAndSync","docstring":""}
{"repo":"ok-download","file":"DownloadUriOutputStream.cj","path":"ok-download/src/DownloadUriOutputStream.cj","code_tokens":"public func seek ( offset : Int64 ) : Unit {  fos . seek ( SeekPosition . Current ( offset ) ) NL }","func_name":"seek","docstring":""}
{"repo":"ok-download","file":"DownloadUriOutputStream.cj","path":"ok-download/src/DownloadUriOutputStream.cj","code_tokens":"public func setLength ( newLength : Int64 ) : Unit {  }","func_name":"setLength","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func setChunked ( chunked : Bool ) : Unit {  this . chunked = chunked NL }","func_name":"setChunked","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func addBlock ( blockInfo : BlockInfo ) : Unit {  this . blockInfoList . append ( blockInfo ) NL }","func_name":"addBlock","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func isChunked ( ) : Bool {  return this . chunked NL }","func_name":"isChunked","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func isTaskOnlyProvidedParentPath ( ) : Bool {  return taskOnlyProvidedParentPath NL }","func_name":"isTaskOnlyProvidedParentPath","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func getBlock ( blockIndex : Int64 ) : Option < BlockInfo > {  return blockInfoList . get ( blockIndex ) NL }","func_name":"getBlock","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func resetBlockInfos ( ) : Unit {  this . blockInfoList . clear ( ) NL }","func_name":"resetBlockInfos","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func getBlockCount ( ) : Int64 {  return blockInfoList . size NL }","func_name":"getBlockCount","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func setEtag ( etag : String ) : Unit {  this . etag = etag NL }","func_name":"setEtag","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func getTotalOffset ( ) : Int64 {   var offset : Int64 = 0 NL for ( block in blockInfoList ) {  offset += block . getCurrentOffset ( ) NL } NL return offset NL }","func_name":"getTotalOffset","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func getTotalLength ( ) : Int64 {  if ( isChunked ( ) ) {  return getTotalOffset ( ) NL } NL  var length : Int64 = 0 NL for ( block in blockInfoList ) {  length += block . getContentLength ( ) NL } NL return length NL }","func_name":"getTotalLength","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func getEtag ( ) : Option < String > {  return this . etag NL }","func_name":"getEtag","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func getUrl ( ) : String {  return url NL }","func_name":"getUrl","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func getFilename ( ) : Option < String > {  return filenameHolder . get ( ) NL }","func_name":"getFilename","docstring":""}
{"repo":"ok-download","file":"BreakPonitInfo.cj","path":"ok-download/src/BreakPonitInfo.cj","code_tokens":"func isSameFrom ( task : DownloadTask ) : Bool {  if ( ! parentFile . getOrThrow ( ) . info . path . toString ( ) . equals ( task . getParentFile ( ) . info . path . toString ( ) ) ) {  return false NL } NL if ( ! url . equals ( task . getUrl ( ) ) ) {  return false NL } NL  let otherFilename : Option < String > = task . getFilename ( ) NL if ( let Some ( i ) = otherFilename ) {  if ( i . equals ( filenameHolder . get ( ) . getOrThrow ( ) ) ) {  return true NL } NL } NL return false NL }","func_name":"isSameFrom","docstring":""}
{"repo":"ok-download","file":"DownloadStrategy.cj","path":"ok-download/src/DownloadStrategy.cj","code_tokens":"func resumeAvailableResponseCheck ( connected : DownloadConnectionConnected , blockIndex : Int64 , info : BreakpointInfo ) : ResumeAvailableResponseCheck {  return ResumeAvailableResponseCheck ( connected , blockIndex , info ) NL }","func_name":"resumeAvailableResponseCheck","docstring":"//100"}
{"repo":"ok-download","file":"DownloadStrategy.cj","path":"ok-download/src/DownloadStrategy.cj","code_tokens":"func determineBlockCount ( task : DownloadTask , totalLengtha : Int64 ) : Int64 {  if ( let Some ( i ) = task . getSetConnectionCount ( ) ) {  if ( i != 0 ) {  return i NL } NL } NL if ( totalLengtha < ONE_CONNECTION_UPPER_LIMITA ) {  return 1 NL } NL if ( totalLengtha < TWO_CONNECTION_UPPER_LIMITA ) {  return 2 NL } NL if ( totalLengtha < THREE_CONNECTION_UPPER_LIMITA ) {  return 3 NL } NL if ( totalLengtha < FOUR_CONNECTION_UPPER_LIMITA ) {  return 4 NL } NL return 5 NL }","func_name":"determineBlockCount","docstring":""}
{"repo":"ok-download","file":"DownloadStrategy.cj","path":"ok-download/src/DownloadStrategy.cj","code_tokens":"func inspectAnotherSameInfo ( task : DownloadTask , info : BreakpointInfo , instanceLength : Int64 ) : Bool {  if ( ! task . isFilenameFromResponse ( ) ) {  return false NL } NL  let store : BreakpointStore = OkDownload . withs ( ) . breakpointStore ( ) NL  let anotherInfo : Option < BreakpointInfo > = store . findAnotherInfoFromCompare ( task , info ) NL if ( let Some ( i ) = anotherInfo ) {  } else {  return false NL } NL if ( anotherInfo . getOrThrow ( ) . getTotalLength ( ) != instanceLength ) {  return false NL } NL return true NL }","func_name":"inspectAnotherSameInfo","docstring":""}
{"repo":"ok-download","file":"DownloadStrategy.cj","path":"ok-download/src/DownloadStrategy.cj","code_tokens":"func isUseMultiBlock ( isAcceptRange : Bool ) {  if ( ! OkDownload . withs ( ) . outputStreamFactory ( ) . supportSeek ( ) ) {  return false NL } NL return isAcceptRange NL }","func_name":"isUseMultiBlock","docstring":""}
{"repo":"ok-download","file":"DownloadStrategy.cj","path":"ok-download/src/DownloadStrategy.cj","code_tokens":"func validFilenameFromResponse ( responseFileName : String , task : DownloadTask ) : Unit {  if ( Util . isEmpty ( task . getFilename ( ) ) ) {  if ( Util . isEmpty ( responseFileName ) ) {   var filename =  NL try {   let lastIndex : Int64 = task . getUrl ( ) . lastIndexOf ( / ) . getOrThrow ( ) NL filename = task . getUrl ( ) . substring ( lastIndex + 1 ) NL } catch ( e : Exception ) {  println ( e . toString ( ) ) NL } NL if ( Util . isEmpty ( filename ) ) {  filename = Time . now ( ) . unixTimeStamp ( ) . nanoseconds ( ) . toString ( ) NL } NL task . filenameHolder = FileNameHolder ( filename ) NL task . targetFile = task . getParentFile ( ) . createFile ( filename ) NL task . providedPathFile = task . getFile ( ) . getOrThrow ( ) NL } else {  task . filenameHolder = FileNameHolder ( responseFileName ) NL task . targetFile = task . getParentFile ( ) . createFile ( responseFileName ) NL task . providedPathFile = task . getFile ( ) . getOrThrow ( ) NL } NL } NL }","func_name":"validFilenameFromResponse","docstring":""}
{"repo":"ok-download","file":"DownloadStrategy.cj","path":"ok-download/src/DownloadStrategy.cj","code_tokens":"func getPreconditionFailedCause ( responseCode : Int64 , isAlreadyProceed : Bool , info : BreakpointInfo , responseEtag : String ) : Option < ResumeFailedCause > {   let localEtag : String = info . getEtag ( ) . getOrThrow ( ) NL if ( responseCode == Util . HTTP_PRECON_FAILED ) {  return RESPONSE_PRECONDITION_FAILED NL } NL if ( ! Util . isEmpty ( localEtag ) && ! Util . isEmpty ( responseEtag ) && ! responseEtag . equals ( localEtag ) ) {  return RESPONSE_ETAG_CHANGED NL } NL if ( responseCode == Util . HTTP_CREATED && isAlreadyProceed ) {  return RESPONSE_CREATED_RANGE_NOT_FROM_0 NL } NL if ( responseCode == Util . HTTP_RESET && isAlreadyProceed ) {  return RESPONSE_RESET_RANGE_NOT_FROM_0 NL } NL return Option < ResumeFailedCause > . None NL }","func_name":"getPreconditionFailedCause","docstring":""}
{"repo":"ok-download","file":"DownloadStrategy.cj","path":"ok-download/src/DownloadStrategy.cj","code_tokens":"func isServerCanceled ( responseCode : Int64 , isAlreadyProceed : Bool ) : Bool {  if ( responseCode != Util . HTTP_PARTIAL && responseCode != Util . HTTP_OK ) {  return true NL } NL if ( responseCode == Util . HTTP_OK && isAlreadyProceed ) {  return true NL } NL return false NL }","func_name":"isServerCanceled","docstring":""}
{"repo":"ok-download","file":"BreakpointRemoteCheck.cj","path":"ok-download/src/BreakpointRemoteCheck.cj","code_tokens":"func toString ( ) : String {  return acceptRange[ + acceptRange . toString ( ) + ] resumable[ + resumable . toString ( ) + ] failedCause[failedCause.getOrThrow().toString()instanceLength[ + instanceLength . toString ( ) + ] NL }","func_name":"toString","docstring":""}
{"repo":"ok-download","file":"BreakpointRemoteCheck.cj","path":"ok-download/src/BreakpointRemoteCheck.cj","code_tokens":"func getCauseOrThrow ( ) : ResumeFailedCause {  return this . failedCause . getOrThrow ( ) NL }","func_name":"getCauseOrThrow","docstring":""}
{"repo":"ok-download","file":"BreakpointRemoteCheck.cj","path":"ok-download/src/BreakpointRemoteCheck.cj","code_tokens":"func isResumable ( ) : Bool {  return resumable NL }","func_name":"isResumable","docstring":""}
{"repo":"ok-download","file":"BreakpointRemoteCheck.cj","path":"ok-download/src/BreakpointRemoteCheck.cj","code_tokens":"func isAcceptRange ( ) : Bool {  return acceptRange NL }","func_name":"isAcceptRange","docstring":""}
{"repo":"ok-download","file":"BreakpointRemoteCheck.cj","path":"ok-download/src/BreakpointRemoteCheck.cj","code_tokens":"func getInstanceLength ( ) : Int64 {  return instanceLength NL }","func_name":"getInstanceLength","docstring":""}
{"repo":"ok-download","file":"BreakpointRemoteCheck.cj","path":"ok-download/src/BreakpointRemoteCheck.cj","code_tokens":"func check ( ) : Unit {   let downloadStrategy : DownloadStrategy = OkDownload . withs ( ) . downloadStrategy ( ) NL  var connectTrial : ConnectTrial = createConnectTrial ( ) NL connectTrial . executeTrial ( ) NL  let isAcceptRange : Bool = connectTrial . isAcceptRange ( ) NL  let isChunked : Bool = connectTrial . isChunked ( ) NL  let instanceLength : Int64 = connectTrial . getInstanceLength ( ) NL  let responseEtag : String = connectTrial . getResponseEtag ( ) NL  let responseFilename : String = connectTrial . getResponseFilename ( ) NL  let responseCode : Int64 = connectTrial . getResponseCode ( ) NL downloadStrategy . validFilenameFromResponse ( responseFilename , task ) NL info . setChunked ( isChunked ) NL info . setEtag ( responseEtag ) NL  let resumeFailedCause : Option < ResumeFailedCause > = downloadStrategy . getPreconditionFailedCause ( responseCode , info . getTotalOffset ( ) != 0 , info , responseEtag ) NL if ( let Some ( i ) = resumeFailedCause ) {  this . resumable = false NL } else {  this . resumable = true NL } NL this . failedCause = resumeFailedCause NL this . instanceLength = instanceLength NL this . acceptRange = isAcceptRange NL if ( ! isTrialSpecialPass ( responseCode , instanceLength , resumable ) && downloadStrategy . isServerCanceled ( responseCode , info . getTotalOffset ( ) != 0 ) ) {  throw ServerCanceledException ( responseCode , info . getTotalOffset ( ) ) NL } NL }","func_name":"check","docstring":""}
{"repo":"ok-download","file":"BreakpointRemoteCheck.cj","path":"ok-download/src/BreakpointRemoteCheck.cj","code_tokens":"func isTrialSpecialPass ( responseCode : Int64 , instanceLength : Int64 , isResumable : Bool ) : Bool {  if ( responseCode == Util . RANGE_NOT_SATISFIABLE && instanceLength > = 0 && isResumable ) {  return true NL } NL return false NL }","func_name":"isTrialSpecialPass","docstring":""}
{"repo":"ok-download","file":"BreakpointRemoteCheck.cj","path":"ok-download/src/BreakpointRemoteCheck.cj","code_tokens":"func createConnectTrial ( ) : ConnectTrial {  return ConnectTrial ( task , info ) NL }","func_name":"createConnectTrial","docstring":""}
{"repo":"ok-download","file":"BreakpointInterceptor.cj","path":"ok-download/src/BreakpointInterceptor.cj","code_tokens":"public func interceptConnect ( chain : DownloadChain ) : Option < DownloadConnectionConnected > {   let connected : DownloadConnectionConnected = chain . processConnect ( ) NL  let info : BreakpointInfo = chain . getInfo ( ) NL if ( chain . getCache ( ) . isInterrupt ( ) ) {  throw InterruptException . SIGNAL NL } NL if ( info . getBlockCount ( ) == 1 && ! info . isChunked ( ) ) {   let blockInstanceLength : Int64 = getExactContentLengthRangeFrom0 ( connected ) NL  let infoInstanceLength : Int64 = info . getTotalLength ( ) NL if ( blockInstanceLength > 0 && blockInstanceLength != infoInstanceLength ) {  OkDownload . withs ( ) . callbackDispatcher ( ) . dispatch ( ) . downloadFromBeginning ( chain . getTask ( ) ) NL } NL } NL  let store : DownloadStore = chain . getDownloadStore ( ) NL try {  if ( ! store . update ( info ) ) {  throw ReadWriteException ( Update store failed! ) NL } NL } catch ( e : Exception ) {  throw ReadWriteException ( Update store failed! + e . toString ( ) ) NL } NL return connected NL }","func_name":"interceptConnect","docstring":""}
{"repo":"ok-download","file":"BreakpointInterceptor.cj","path":"ok-download/src/BreakpointInterceptor.cj","code_tokens":"public func interceptFetch ( chain : DownloadChain ) : Int64 {   let contentLength : Int64 = chain . getResponseContentLength ( ) NL  let blockIndex : Int64 = chain . getBlockIndex ( ) NL  let isNotChunked : Bool = contentLength != Util . CHUNKED_CONTENT_LENGTH NL  var fetchLength : Int64 = 0 NL  var processFetchLength : Int64 = 0 NL  let outputStream : MultiPointOutputStream = chain . getOutputStream ( ) NL try {  while ( true ) {  processFetchLength = chain . loopFetch ( ) NL if ( processFetchLength <= 0 ) {  break NL } NL fetchLength += processFetchLength NL } NL } catch ( e : Exception ) {  println ( reason= + e . message . toString ( ) ) NL } finally {  chain . flushNoCallbackIncreaseBytes ( ) NL if ( ! chain . getCache ( ) . isUserCanceled ( ) ) {  outputStream . done ( blockIndex ) NL } NL } NL if ( isNotChunked ) {  if ( fetchLength != contentLength ) {  throw ReadWriteException ( Fetch-length isn't equal to the response content-length,  + fetchLength . toString ( ) + !=  + contentLength . toString ( ) ) NL } NL } NL return fetchLength NL }","func_name":"interceptFetch","docstring":""}
{"repo":"ok-download","file":"BreakpointInterceptor.cj","path":"ok-download/src/BreakpointInterceptor.cj","code_tokens":"func getExactContentLengthRangeFrom0 ( connected : DownloadConnectionConnected ) : Int64 {   let contentRangeField : Option < String > = connected . getResponseHeaderField ( Util . CONTENT_RANGE ) NL  var contentLength : Int64 = - 1 NL if ( ! Util . isEmpty ( contentRangeField ) ) {   let rightRange : Int64 = getRangeRightFromContentRange ( contentRangeField . getOrThrow ( ) ) NL if ( rightRange > 0 ) {  contentLength = rightRange + 1 NL } NL } NL return contentLength NL }","func_name":"getExactContentLengthRangeFrom0","docstring":""}
{"repo":"ok-download","file":"BreakpointInterceptor.cj","path":"ok-download/src/BreakpointInterceptor.cj","code_tokens":"static func getRangeRightFromContentRange ( contentRange : String ) : Int64 {   let r = CONTENT_RANGE_RIGHT_VALUE . matcher ( contentRange ) NL  let matchDataArray : Option < Array < MatchData > > = r . findAll ( ) NL match ( matchDataArray ) { case Some ( md ) => return Int64 . parse ( md . get ( 0 ) . getOrThrow ( ) . matchStr ( 1 ) ) NL case None => return - 1 NL } NL }","func_name":"getRangeRightFromContentRange","docstring":""}
{"repo":"ok-download","file":"KeyToIdMap.cj","path":"ok-download/src/KeyToIdMap.cj","code_tokens":"func get ( task : DownloadTask ) : Option < Int64 > {   let genKey : String = generateKey ( task ) NL if ( let Some ( i ) = keyToIdMap . get ( genKey ) ) {  return i . getOrThrow ( ) NL } else {  return Option < Int64 > . None NL } NL }","func_name":"get","docstring":""}
{"repo":"ok-download","file":"KeyToIdMap.cj","path":"ok-download/src/KeyToIdMap.cj","code_tokens":"func add ( task : DownloadTask , id : Int64 ) : Unit {   let key : String = generateKey ( task ) NL keyToIdMap . put ( key , id ) NL idToKeyMap . put ( id , key ) NL }","func_name":"add","docstring":""}
{"repo":"ok-download","file":"KeyToIdMap.cj","path":"ok-download/src/KeyToIdMap.cj","code_tokens":"func generateKey ( task : DownloadTask ) : String {  if ( Util . isEmpty ( task . getFilename ( ) ) ) {  return task . getUrl ( ) + task . getUri ( ) . toString ( ) NL } else {  return task . getUrl ( ) + task . getUri ( ) . toString ( ) + task . getFilename ( ) . getOrThrow ( ) NL } NL }","func_name":"generateKey","docstring":""}
{"repo":"ok-download","file":"HeaderInterceptor.cj","path":"ok-download/src/HeaderInterceptor.cj","code_tokens":"public func interceptConnect ( chain : DownloadChain ) : Option < DownloadConnectionConnected > {   let info : BreakpointInfo = chain . getInfo ( ) NL  let connection : DownloadConnection = chain . getConnectionOrCreate ( ) NL  let task : DownloadTask = chain . getTask ( ) NL  let userHeader : Option < HashMap < String , ArrayList < String > > > = task . getHeaderMapFields ( ) NL if ( let Some ( i ) = userHeader ) {  Util . addUserRequestHeaderField ( userHeader . getOrThrow ( ) , connection ) NL } NL if ( Option < HashMap < String , ArrayList < String > > > . None == userHeader || ! userHeader . getOrThrow ( ) . contains ( Util . USER_AGENT ) ) {  Util . addDefaultUserAgent ( connection ) NL } NL  let blockIndex : Int64 = chain . getBlockIndex ( ) NL  let blockInfo : Option < BlockInfo > = info . getBlock ( blockIndex ) NL if ( let Some ( i ) = blockInfo ) {  } else {  throw ReadWriteException ( No block-info found on  + blockIndex . toString ( ) ) NL } NL  var range : String = bytes= + blockInfo . getOrThrow ( ) . getRangeLeft ( ) . toString ( ) + - NL range = range + blockInfo . getOrThrow ( ) . getRangeRight ( ) . toString ( ) NL connection . addHeader ( Util . RANGE , range ) NL Util . d ( TAG , AssembleHeaderRange ( + task . getId ( ) . toString ( ) + ) block( + blockIndex . toString ( ) + )  + downloadFrom( + blockInfo . getOrThrow ( ) . getRangeLeft ( ) . toString ( ) + ) currentOffset( + blockInfo . getOrThrow ( ) . getCurrentOffset ( ) . toString ( ) + ) ) NL if ( chain . getCache ( ) . isInterrupt ( ) ) {  throw InterruptException . SIGNAL NL } NL OkDownload . withs ( ) . callbackDispatcher ( ) . dispatch ( ) . connectStart ( task , blockIndex , connection . getRequestProperties ( ) ) NL  var connected : DownloadConnectionConnected = chain . processConnect ( ) NL if ( chain . getCache ( ) . isInterrupt ( ) ) {  throw InterruptException . SIGNAL NL } NL  var responseHeaderFields : Option < HashMap < String , ArrayList < String > > > = connected . getResponseHeaderFields ( ) NL if ( Option < HashMap < String , ArrayList < String > > > . None == responseHeaderFields ) {  responseHeaderFields = HashMap < String , ArrayList < String > > ( ) NL } NL OkDownload . withs ( ) . callbackDispatcher ( ) . dispatch ( ) . connectEnd ( task , blockIndex , connected . getResponseCode ( ) , responseHeaderFields . getOrThrow ( ) ) NL  let strategy : DownloadStrategy = OkDownload . withs ( ) . downloadStrategy ( ) NL  let responseCheck : ResumeAvailableResponseCheck = strategy . resumeAvailableResponseCheck ( connected , blockIndex , info ) NL responseCheck . inspect ( ) NL  var contentLength : Int64 = 0 NL  let contentLengthField : Option < String > = connected . getResponseHeaderField ( Util . CONTENT_LENGTH ) NL if ( Option < String > . None != contentLengthField && contentLengthField . getOrThrow ( ) . size > 0 ) {  contentLength = Util . parseContentLength ( contentLengthField ) NL } NL chain . setResponseContentLength ( contentLength ) NL return connected NL }","func_name":"interceptConnect","docstring":""}
{"repo":"ok-download","file":"IdentifiedTask.cj","path":"ok-download/src/IdentifiedTask.cj","code_tokens":"func getId ( ) : Int64","func_name":"getId","docstring":"//文件路径为空"}
{"repo":"ok-download","file":"IdentifiedTask.cj","path":"ok-download/src/IdentifiedTask.cj","code_tokens":"func getUrl ( ) : String","func_name":"getUrl","docstring":""}
{"repo":"ok-download","file":"IdentifiedTask.cj","path":"ok-download/src/IdentifiedTask.cj","code_tokens":"protected func getProvidedPathFile ( ) : Option < File >","func_name":"getProvidedPathFile","docstring":""}
{"repo":"ok-download","file":"IdentifiedTask.cj","path":"ok-download/src/IdentifiedTask.cj","code_tokens":"func getParentFile ( ) : Directory","func_name":"getParentFile","docstring":""}
{"repo":"ok-download","file":"IdentifiedTask.cj","path":"ok-download/src/IdentifiedTask.cj","code_tokens":"func getFilename ( ) : Option < String >","func_name":"getFilename","docstring":""}
{"repo":"ok-download","file":"IdentifiedTask.cj","path":"ok-download/src/IdentifiedTask.cj","code_tokens":"func compareIgnoreId ( another : IdentifiedTask ) : Bool {  try {  if ( ! getUrl ( ) . equals ( another . getUrl ( ) ) ) {  return false NL } NL if ( getUrl ( ) . equals ( EMPTY_URL ) || getParentFile ( ) . info . path . toString ( ) . equals ( EMPTY_FILEPATH ) ) {  return false NL } NL if ( getProvidedPathFile ( ) . getOrThrow ( ) . info == another . getProvidedPathFile ( ) . getOrThrow ( ) . info ) {  return true NL } NL if ( getParentFile ( ) . info != another . getParentFile ( ) . info ) {  return false NL } NL  let fileName : String = getFilename ( ) . getOrThrow ( ) NL  let anotherFilename : String = another . getFilename ( ) . getOrThrow ( ) NL return anotherFilename . equals ( fileName ) NL } catch ( e : Exception ) {  return false NL } NL }","func_name":"compareIgnoreId","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func getOutputStream ( ) : MultiPointOutputStream {  if ( let Some ( i ) = outputStream ) {  } else {  throw IllegalArgumentException ( ) NL } NL return outputStream . getOrThrow ( ) NL }","func_name":"getOutputStream","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func setRedirectLocation ( redirectLocation : String ) : Unit {  this . redirectLocation = redirectLocation NL }","func_name":"setRedirectLocation","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func getRedirectLocation ( ) : Option < String > {  return redirectLocation NL }","func_name":"getRedirectLocation","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func isPreconditionFailed ( ) : Bool {  return preconditionFailed NL }","func_name":"isPreconditionFailed","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func isUserCanceled ( ) : Bool {  return userCanceled NL }","func_name":"isUserCanceled","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func isServerCanceled ( ) : Bool {  return serverCanceled NL }","func_name":"isServerCanceled","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func isUnknownError ( ) : Bool {  return unknownError NL }","func_name":"isUnknownError","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func isFileBusyAfterRun ( ) : Bool {  return fileBusyAfterRun NL }","func_name":"isFileBusyAfterRun","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func isPreAllocateFailed ( ) : Bool {  return preAllocateFailed NL }","func_name":"isPreAllocateFailed","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func getRealCause ( ) : IOException {  return realCause . getOrThrow ( ) NL }","func_name":"getRealCause","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func isInterrupt ( ) : Bool {  return preconditionFailed || userCanceled || serverCanceled || unknownError || fileBusyAfterRun || preAllocateFailed NL }","func_name":"isInterrupt","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func setUserCanceled ( ) : Unit {  this . userCanceled = true NL }","func_name":"setUserCanceled","docstring":""}
{"repo":"ok-download","file":"DownloadCache.cj","path":"ok-download/src/DownloadCache.cj","code_tokens":"func setUnknownError ( realCause : IOException ) : Unit {  this . unknownError = true NL this . realCause = realCause NL }","func_name":"setUnknownError","docstring":""}
{"repo":"ok-download","file":"DownloadConnection.cj","path":"ok-download/src/DownloadConnection.cj","code_tokens":"func addHeader ( name : String , value : String ) : Unit","func_name":"addHeader","docstring":""}
{"repo":"ok-download","file":"DownloadConnection.cj","path":"ok-download/src/DownloadConnection.cj","code_tokens":"func execute ( ) : DownloadConnectionConnected","func_name":"execute","docstring":""}
{"repo":"ok-download","file":"DownloadConnection.cj","path":"ok-download/src/DownloadConnection.cj","code_tokens":"func release ( ) : Unit","func_name":"release","docstring":""}
{"repo":"ok-download","file":"DownloadConnection.cj","path":"ok-download/src/DownloadConnection.cj","code_tokens":"func getRequestProperties ( ) : HashMap < String , ArrayList < String > >","func_name":"getRequestProperties","docstring":""}
{"repo":"ok-download","file":"BreakpointStore.cj","path":"ok-download/src/BreakpointStore.cj","code_tokens":"func get ( id : Int64 ) : Option < BreakpointInfo >","func_name":"get","docstring":""}
{"repo":"ok-download","file":"BreakpointStore.cj","path":"ok-download/src/BreakpointStore.cj","code_tokens":"func createAndInsert ( task : DownloadTask ) : BreakpointInfo","func_name":"createAndInsert","docstring":""}
{"repo":"ok-download","file":"BreakpointStore.cj","path":"ok-download/src/BreakpointStore.cj","code_tokens":"func findOrCreateId ( task : DownloadTask ) : Int64","func_name":"findOrCreateId","docstring":""}
{"repo":"ok-download","file":"BreakpointStore.cj","path":"ok-download/src/BreakpointStore.cj","code_tokens":"func update ( breakpointInfo : BreakpointInfo ) : Bool","func_name":"update","docstring":""}
{"repo":"ok-download","file":"BreakpointStore.cj","path":"ok-download/src/BreakpointStore.cj","code_tokens":"func remove ( id : Int64 ) : Unit","func_name":"remove","docstring":""}
{"repo":"ok-download","file":"BreakpointStore.cj","path":"ok-download/src/BreakpointStore.cj","code_tokens":"func findAnotherInfoFromCompare ( task : DownloadTask , ignored : BreakpointInfo ) : Option < BreakpointInfo >","func_name":"findAnotherInfoFromCompare","docstring":""}
{"repo":"ok-download","file":"BreakpointStore.cj","path":"ok-download/src/BreakpointStore.cj","code_tokens":"func isOnlyMemoryCache ( ) : Bool","func_name":"isOnlyMemoryCache","docstring":""}
{"repo":"ok-download","file":"CallServerInterceptor.cj","path":"ok-download/src/CallServerInterceptor.cj","code_tokens":"public func interceptConnect ( chain : DownloadChain ) : Option < DownloadConnectionConnected > {  return chain . getConnectionOrCreate ( ) . execute ( ) NL }","func_name":"interceptConnect","docstring":""}
{"repo":"ok-download","file":"FileNameHolder.cj","path":"ok-download/src/FileNameHolder.cj","code_tokens":"func get ( ) : Option < String > {  return filename NL }","func_name":"get","docstring":""}
{"repo":"ok-download","file":"ProcessFileStrategy.cj","path":"ok-download/src/ProcessFileStrategy.cj","code_tokens":"func createProcessStream ( task : DownloadTask , info : BreakpointInfo , store : DownloadStore ) : MultiPointOutputStream {  return MultiPointOutputStream ( task , info , store ) NL }","func_name":"createProcessStream","docstring":""}
{"repo":"ok-download","file":"ProcessFileStrategy.cj","path":"ok-download/src/ProcessFileStrategy.cj","code_tokens":"func discardProcess ( task : DownloadTask ) : Unit {   let file : Option < File > = task . getFile ( ) NL if ( let Some ( i ) = file ) {  } else {  return NL } NL if ( File . exists ( file . getOrThrow ( ) . info . path ) ) {  try {  if ( ! file . getOrThrow ( ) . isClosed ( ) ) {  file . getOrThrow ( ) . close ( ) NL } NL File . delete ( file . getOrThrow ( ) . info . path ) NL } catch ( e : Exception ) {  throw ReadWriteException ( Delete file failed! ) NL } NL } NL }","func_name":"discardProcess","docstring":""}
{"repo":"ok-download","file":"ProcessFileStrategy.cj","path":"ok-download/src/ProcessFileStrategy.cj","code_tokens":"func isPreAllocateLength ( task : DownloadTask ) : Bool {   var supportSeek : Bool = OkDownload . withs ( ) . outputStreamFactory ( ) . supportSeek ( ) NL if ( ! supportSeek ) {  return false NL } NL if ( let Some ( i ) = task . getSetPreAllocateLength ( ) ) {  return i NL } else {  return true NL } NL }","func_name":"isPreAllocateLength","docstring":""}
{"repo":"ok-download","file":"DownloadOutputStreamFactory.cj","path":"ok-download/src/DownloadOutputStreamFactory.cj","code_tokens":"func create ( file : File , flushBufferSize : Int64 ) : DownloadOutputStream","func_name":"create","docstring":""}
{"repo":"ok-download","file":"DownloadOutputStreamFactory.cj","path":"ok-download/src/DownloadOutputStreamFactory.cj","code_tokens":"func create ( uri : String , flushBufferSize : Int64 ) : DownloadOutputStream","func_name":"create","docstring":""}
{"repo":"ok-download","file":"DownloadOutputStreamFactory.cj","path":"ok-download/src/DownloadOutputStreamFactory.cj","code_tokens":"func supportSeek ( ) : Bool","func_name":"supportSeek","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3Connection.cj","path":"ok-download/src/DownloadOkHttp3Connection.cj","code_tokens":"public func addHeader ( name : String , value : String ) : Unit {  this . requestBuilder . header ( name , value ) NL }","func_name":"addHeader","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3Connection.cj","path":"ok-download/src/DownloadOkHttp3Connection.cj","code_tokens":"public func execute ( ) : DownloadConnectionConnected {  request = requestBuilder . build ( ) NL response = client . newCall ( request . getOrThrow ( ) ) . execute ( ) NL return this NL }","func_name":"execute","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3Connection.cj","path":"ok-download/src/DownloadOkHttp3Connection.cj","code_tokens":"public func release ( ) : Unit {  request = Option < Request > . None NL if ( let Some ( i ) = response ) {  i . close ( ) NL } NL response = Option < Response > . None NL }","func_name":"release","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3Connection.cj","path":"ok-download/src/DownloadOkHttp3Connection.cj","code_tokens":"public func getRequestProperties ( ) : HashMap < String , ArrayList < String > > {   var hashMapList : HashMap < String , ArrayList < String > > = HashMap < String , ArrayList < String > > ( ) NL  var header : Option < Header > = Option < Header > . None NL if ( let Some ( i ) = request ) {  header = i . getHeaders ( ) NL } else {  header = requestBuilder . build ( ) . getHeaders ( ) NL } NL  var itera : Iterator < ( String , ArrayList < String > ) > = header . getOrThrow ( ) . iterator ( ) NL while ( true ) {   var optKey : Option < ( String , ArrayList < String > ) > = itera . next ( ) NL match ( optKey ) { case Some ( v ) =>  var key = v [ 0 ] NL  var value = v [ 1 ] NL hashMapList . put ( key , value ) NL case None => break NL } NL } NL return hashMapList NL }","func_name":"getRequestProperties","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3Connection.cj","path":"ok-download/src/DownloadOkHttp3Connection.cj","code_tokens":"public func getResponseCode ( ) : Int64 {  if ( let Some ( i ) = response ) {  return i . getCode ( ) NL } else {  throw ReadWriteException ( Please invoke execute first! ) NL } NL }","func_name":"getResponseCode","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3Connection.cj","path":"ok-download/src/DownloadOkHttp3Connection.cj","code_tokens":"public func getInputStream ( ) : Source {  if ( let Some ( i ) = response ) {  } else {  throw ReadWriteException ( Please invoke execute first! ) NL } NL  let body : Option < ResponseBody > = response . getOrThrow ( ) . getBody ( ) NL if ( let Some ( i ) = body ) {  return i . getSource ( ) NL } else {  throw ReadWriteException ( no body found on response! ) NL } NL }","func_name":"getInputStream","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3Connection.cj","path":"ok-download/src/DownloadOkHttp3Connection.cj","code_tokens":"public func getResponseHeaderFields ( ) : Option < HashMap < String , ArrayList < String > > > {  if ( let Some ( i ) = response ) {   var header : Header = i . getHeaders ( ) NL  var hashMapList : HashMap < String , ArrayList < String > > = HashMap < String , ArrayList < String > > ( ) NL  var itera : Iterator < ( String , ArrayList < String > ) > = header . iterator ( ) NL while ( true ) {   var optKey : Option < ( String , ArrayList < String > ) > = itera . next ( ) NL match ( optKey ) { case Some ( v ) =>  var key = v [ 0 ] NL  var value = v [ 1 ] NL hashMapList . put ( key , value ) NL case None => break NL } NL } NL return hashMapList NL } else {  return Option < HashMap < String , ArrayList < String > > > . None NL } NL }","func_name":"getResponseHeaderFields","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3Connection.cj","path":"ok-download/src/DownloadOkHttp3Connection.cj","code_tokens":"public func getResponseHeaderField ( name : String ) : Option < String > {  if ( let Some ( i ) = response ) {  if ( let Some ( j ) = i . getHeader ( name ) ) {  return j NL } else {  return Option < String > . None NL } NL } else {  return Option < String > . None NL } NL }","func_name":"getResponseHeaderField","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3Connection.cj","path":"ok-download/src/DownloadOkHttp3Connection.cj","code_tokens":"public func getRedirectLocation ( ) : Option < String > {   let priorRes : Option < Response > = response . getOrThrow ( ) . getPrevResponse ( ) NL if ( let Some ( i ) = priorRes ) {  if ( response . getOrThrow ( ) . isSuccess ( ) && i . isRedirect ( ) ) {  return response . getOrThrow ( ) . getRequest ( ) . getUrl ( ) . toString ( ) NL } NL } NL return Option < String > . None NL }","func_name":"getRedirectLocation","docstring":""}
{"repo":"ok-download","file":"DownloadDispatcher.cj","path":"ok-download/src/DownloadDispatcher.cj","code_tokens":"func setDownloadStore ( store : DownloadStore ) : Unit {  this . store = store NL }","func_name":"setDownloadStore","docstring":""}
{"repo":"ok-download","file":"DownloadDispatcher.cj","path":"ok-download/src/DownloadDispatcher.cj","code_tokens":"func enqueue ( tasks : Array < DownloadTask > ) : Unit {  skipProceedCallCount . fetchAdd ( 1 ) NL enqueueLocked ( tasks ) NL skipProceedCallCount . fetchSub ( 1 ) NL }","func_name":"enqueue","docstring":""}
{"repo":"ok-download","file":"DownloadDispatcher.cj","path":"ok-download/src/DownloadDispatcher.cj","code_tokens":"func enqueue ( task : DownloadTask ) : Unit {  skipProceedCallCount . fetchAdd ( 1 ) NL enqueueLocked ( task ) NL skipProceedCallCount . fetchSub ( 1 ) NL }","func_name":"enqueue","docstring":""}
{"repo":"ok-download","file":"DownloadDispatcher.cj","path":"ok-download/src/DownloadDispatcher.cj","code_tokens":"private func enqueueLocked ( tasks : Array < DownloadTask > ) : Unit {  synchronized ( m ) {   let taskList : ArrayList < DownloadTask > = ArrayList < DownloadTask > ( ) NL taskList . appendAll ( tasks ) NL if ( taskList . size > 1 ) {  taskList . sortBy ( { rht : DownloadTask , lht : DownloadTask => if ( rht . getPriority ( ) < lht . getPriority ( ) ) {  return Ordering . GT NL } NL if ( rht . getPriority ( ) > lht . getPriority ( ) ) {  return Ordering . LT NL } NL return Ordering . EQ NL } , stable : true ) NL } NL  let originReadyAsyncCallSize : Int64 = readyAsyncCalls . size NL try {   let completedTaskList : ArrayList < DownloadTask > = ArrayList < DownloadTask > ( ) NL  let sameTaskConflictList : ArrayList < DownloadTask > = ArrayList < DownloadTask > ( ) NL  let fileBusyList : ArrayList < DownloadTask > = ArrayList < DownloadTask > ( ) NL for ( task in taskList ) {  if ( inspectCompleted ( task ) ) {  continue NL } NL enqueueIgnorePriority ( task ) NL } NL OkDownload . withs ( ) . callbackDispatcher ( ) . endTasks ( completedTaskList , sameTaskConflictList , fileBusyList ) NL } catch ( e : Exception ) {  } NL } NL }","func_name":"enqueueLocked","docstring":""}
{"repo":"ok-download","file":"DownloadDispatcher.cj","path":"ok-download/src/DownloadDispatcher.cj","code_tokens":"private func enqueueLocked ( task : DownloadTask ) : Unit {  synchronized ( m ) {  if ( inspectCompleted ( task ) ) {  return NL } NL  let originReadyAsyncCallSize : Int64 = readyAsyncCalls . size NL enqueueIgnorePriority ( task ) NL } NL }","func_name":"enqueueLocked","docstring":""}
{"repo":"ok-download","file":"DownloadDispatcher.cj","path":"ok-download/src/DownloadDispatcher.cj","code_tokens":"private func enqueueIgnorePriority ( task : DownloadTask ) : Unit {   let call : DownloadCall = DownloadCall . create ( task , true , store . getOrThrow ( ) ) NL if ( runningAsyncSize ( ) < maxParallelRunningCount ) {  runningAsyncCalls . append ( call ) NL spawn { => call . execute ( ) NL } NL } else {  readyAsyncCalls . append ( call ) NL } NL }","func_name":"enqueueIgnorePriority","docstring":""}
{"repo":"ok-download","file":"DownloadDispatcher.cj","path":"ok-download/src/DownloadDispatcher.cj","code_tokens":"func execute ( task : DownloadTask ) : Unit {   let call : DownloadCall NL synchronized ( m ) {  if ( inspectCompleted ( task ) ) {  return NL } NL call = DownloadCall . create ( task , false , store . getOrThrow ( ) ) NL runningSyncCalls . append ( call ) NL } NL call . execute ( ) NL }","func_name":"execute","docstring":""}
{"repo":"ok-download","file":"DownloadDispatcher.cj","path":"ok-download/src/DownloadDispatcher.cj","code_tokens":"func inspectCompleted ( task : DownloadTask ) : Bool {   let store : BreakpointStore = OkDownload . withs ( ) . breakpointStore ( ) NL  let isOnlyMemoryCache = store . isOnlyMemoryCache ( ) NL if ( isOnlyMemoryCache ) {  return false NL } else {  return true NL } NL }","func_name":"inspectCompleted","docstring":"//检查是否完成"}
{"repo":"ok-download","file":"DownloadDispatcher.cj","path":"ok-download/src/DownloadDispatcher.cj","code_tokens":"private func runningAsyncSize ( ) : Int64 {  return runningAsyncCalls . size - flyingCanceledAsyncCallCount . load ( ) NL }","func_name":"runningAsyncSize","docstring":""}
{"repo":"ok-download","file":"FetchDataInteceptor.cj","path":"ok-download/src/FetchDataInteceptor.cj","code_tokens":"public func interceptFetch ( chain : DownloadChain ) : Int64 {  if ( chain . getCache ( ) . isInterrupt ( ) ) {  throw InterruptException . SIGNAL NL } NL  var stream = ByteArrayStream ( ) NL  var fetchLength : Int64 = source . read ( stream , task . getReadBufferSize ( ) ) NL if ( fetchLength <= 0 ) {  return fetchLength NL } NL outputStream . write ( blockIndex , stream . readToEnd ( ) , fetchLength ) NL chain . increaseCallbackBytes ( fetchLength ) NL if ( this . dispatcher . isFetchProcessMoment ( task ) ) {  chain . flushNoCallbackIncreaseBytes ( ) NL } NL return fetchLength NL }","func_name":"interceptFetch","docstring":""}
{"repo":"ok-download","file":"StreamState.cj","path":"ok-download/src/StreamState.cj","code_tokens":"func isStreamsEndOrChanged ( ) : Bool {  return isNoMoreStream || newNoMoreStreamBlockList . size > 0 NL }","func_name":"isStreamsEndOrChanged","docstring":""}
{"repo":"ok-download","file":"MockTaskForCompare.cj","path":"ok-download/src/MockTaskForCompare.cj","code_tokens":"func getId ( ) : Int64 {  return id NL }","func_name":"getId","docstring":""}
{"repo":"ok-download","file":"MockTaskForCompare.cj","path":"ok-download/src/MockTaskForCompare.cj","code_tokens":"func getUrl ( ) : String {  return url NL }","func_name":"getUrl","docstring":""}
{"repo":"ok-download","file":"MockTaskForCompare.cj","path":"ok-download/src/MockTaskForCompare.cj","code_tokens":"func getProvidedPathFile ( ) : Option < File > {  return providedPathFile . getOrThrow ( ) NL }","func_name":"getProvidedPathFile","docstring":""}
{"repo":"ok-download","file":"MockTaskForCompare.cj","path":"ok-download/src/MockTaskForCompare.cj","code_tokens":"func getParentFile ( ) : Directory {  return parentFile . getOrThrow ( ) NL }","func_name":"getParentFile","docstring":""}
{"repo":"ok-download","file":"MockTaskForCompare.cj","path":"ok-download/src/MockTaskForCompare.cj","code_tokens":"func getFilename ( ) : Option < String > {  return filename NL }","func_name":"getFilename","docstring":""}
{"repo":"ok-download","file":"ResumeAvailableResponseCheck.cj","path":"ok-download/src/ResumeAvailableResponseCheck.cj","code_tokens":"func inspect ( ) : Unit {   let blockInfo : BlockInfo = info . getBlock ( blockIndex ) . getOrThrow ( ) NL  let code : Int64 = connected . getResponseCode ( ) NL  var newEtag : Option < String > = connected . getResponseHeaderField ( Util . ETAG ) NL if ( let Some ( i ) = newEtag ) {  } else {  newEtag =  NL } NL  let resumeFailedCause : Option < ResumeFailedCause > = OkDownload . withs ( ) . downloadStrategy ( ) . getPreconditionFailedCause ( code , blockInfo . getCurrentOffset ( ) != 0 , info , newEtag . getOrThrow ( ) ) NL  let isServerCancelled : Bool = OkDownload . withs ( ) . downloadStrategy ( ) . isServerCanceled ( code , blockInfo . getCurrentOffset ( ) != 0 ) NL if ( isServerCancelled ) {  throw ServerCanceledException ( code , blockInfo . getCurrentOffset ( ) ) NL } NL }","func_name":"inspect","docstring":""}
{"repo":"ok-download","file":"DownloadConnectionConnected.cj","path":"ok-download/src/DownloadConnectionConnected.cj","code_tokens":"func getResponseCode ( ) : Int64","func_name":"getResponseCode","docstring":""}
{"repo":"ok-download","file":"DownloadConnectionConnected.cj","path":"ok-download/src/DownloadConnectionConnected.cj","code_tokens":"func getInputStream ( ) : Source","func_name":"getInputStream","docstring":""}
{"repo":"ok-download","file":"DownloadConnectionConnected.cj","path":"ok-download/src/DownloadConnectionConnected.cj","code_tokens":"func getResponseHeaderFields ( ) : Option < HashMap < String , ArrayList < String > > >","func_name":"getResponseHeaderFields","docstring":""}
{"repo":"ok-download","file":"DownloadConnectionConnected.cj","path":"ok-download/src/DownloadConnectionConnected.cj","code_tokens":"func getResponseHeaderField ( name : String ) : Option < String >","func_name":"getResponseHeaderField","docstring":""}
{"repo":"ok-download","file":"DownloadConnectionConnected.cj","path":"ok-download/src/DownloadConnectionConnected.cj","code_tokens":"func getRedirectLocation ( ) : Option < String >","func_name":"getRedirectLocation","docstring":""}
{"repo":"ok-download","file":"DownloadStore.cj","path":"ok-download/src/DownloadStore.cj","code_tokens":"func onSyncToFilesystemSuccess ( info : BreakpointInfo , blockIndex : Int64 , increaseLength : Int64 ) : Unit","func_name":"onSyncToFilesystemSuccess","docstring":""}
{"repo":"ok-download","file":"DownloadStore.cj","path":"ok-download/src/DownloadStore.cj","code_tokens":"func onTaskStart ( id : Int64 ) : Unit","func_name":"onTaskStart","docstring":""}
{"repo":"ok-download","file":"DownloadStore.cj","path":"ok-download/src/DownloadStore.cj","code_tokens":"func onTaskEnd ( id : Int64 , cause : EndCause , exception : Option < Exception > ) : Unit","func_name":"onTaskEnd","docstring":""}
{"repo":"ok-download","file":"DownloadStore.cj","path":"ok-download/src/DownloadStore.cj","code_tokens":"func getAfterCompleted ( id : Int64 ) : Option < BreakpointInfo >","func_name":"getAfterCompleted","docstring":""}
{"repo":"ok-download","file":"DownloadStore.cj","path":"ok-download/src/DownloadStore.cj","code_tokens":"func markFileDirty ( id : Int64 ) : Bool","func_name":"markFileDirty","docstring":""}
{"repo":"ok-download","file":"DownloadStore.cj","path":"ok-download/src/DownloadStore.cj","code_tokens":"func markFileClear ( id : Int64 ) : Bool","func_name":"markFileClear","docstring":""}
{"repo":"ok-download","file":"OkDownloadBuilder.cj","path":"ok-download/src/OkDownloadBuilder.cj","code_tokens":"func build ( ) : OkDownload {  if ( let Some ( i ) = downloadDispatchers ) {  } else {  downloadDispatchers = DownloadDispatcher ( ) NL } NL if ( let Some ( i ) = callbackDispatchers ) {  } else {  callbackDispatchers = CallbackDispatcher ( ) NL } NL if ( let Some ( i ) = downloadStores ) {  } else {  downloadStores = BreakpointStoreOnCache ( ) NL } NL if ( let Some ( i ) = connectionFactorys ) {  } else {  connectionFactorys = DownloadOkHttp3ConnectionFactory ( ) NL } NL if ( let Some ( i ) = outputStreamFactorys ) {  } else {  outputStreamFactorys = DownloadUriOutputStreamFactory ( ) NL } NL if ( let Some ( i ) = processFileStrategys ) {  } else {  processFileStrategys = ProcessFileStrategy ( ) NL } NL if ( let Some ( i ) = downloadStrategys ) {  } else {  downloadStrategys = DownloadStrategy ( ) NL } NL  var okDownload : OkDownload = OkDownload ( downloadDispatchers . getOrThrow ( ) , callbackDispatchers . getOrThrow ( ) , downloadStores . getOrThrow ( ) , connectionFactorys . getOrThrow ( ) , outputStreamFactorys . getOrThrow ( ) , processFileStrategys . getOrThrow ( ) , downloadStrategys . getOrThrow ( ) ) NL okDownload . setMonitor ( monitors ) NL return okDownload NL }","func_name":"build","docstring":""}
{"repo":"ok-download","file":"DownloadTaskBuilder.cj","path":"ok-download/src/DownloadTaskBuilder.cj","code_tokens":"public func setMinIntervalMillisCallbackProcess ( minIntervalMillisCallbackProcess : Int64 ) : DownloadTaskBuilder {  if ( minIntervalMillisCallbackProcess < 0 ) {  throw IllegalArgumentException ( Value must be positive! ) NL } NL this . minIntervalMillisCallbackProcess = minIntervalMillisCallbackProcess NL return this NL }","func_name":"setMinIntervalMillisCallbackProcess","docstring":""}
{"repo":"ok-download","file":"DownloadTaskBuilder.cj","path":"ok-download/src/DownloadTaskBuilder.cj","code_tokens":"public func setReadBufferSize ( readBufferSize : Int64 ) : DownloadTaskBuilder {  if ( readBufferSize <= 0 ) {  throw IllegalArgumentException ( Value must be positive! ) NL } NL this . readBufferSize = readBufferSize NL return this NL }","func_name":"setReadBufferSize","docstring":""}
{"repo":"ok-download","file":"DownloadTaskBuilder.cj","path":"ok-download/src/DownloadTaskBuilder.cj","code_tokens":"public func setFlushBufferSize ( flushBufferSize : Int64 ) : DownloadTaskBuilder {  if ( flushBufferSize <= 0 ) {  throw IllegalArgumentException ( Value must be positive! ) NL } NL this . flushBufferSize = flushBufferSize NL return this NL }","func_name":"setFlushBufferSize","docstring":""}
{"repo":"ok-download","file":"DownloadTaskBuilder.cj","path":"ok-download/src/DownloadTaskBuilder.cj","code_tokens":"public func setFilename ( filename : String ) : DownloadTaskBuilder {  this . filename = filename NL return this NL }","func_name":"setFilename","docstring":""}
{"repo":"ok-download","file":"DownloadTaskBuilder.cj","path":"ok-download/src/DownloadTaskBuilder.cj","code_tokens":"public func build ( ) : DownloadTask {  return DownloadTask ( url , uri , priority , readBufferSize , flushBufferSize , syncBufferSize , syncBufferIntervalMillis , autoCallbackToUIThread , minIntervalMillisCallbackProcess , headerMapFields . getOrThrow ( ) , filename , passIfAlreadyCompleted , isWifiRequired , isFilenameFromResponse , connectionCount , isPreAllocateLength ) NL }","func_name":"build","docstring":""}
{"repo":"ok-download","file":"DownloadOkHttp3ConnectionFactory.cj","path":"ok-download/src/DownloadOkHttp3ConnectionFactory.cj","code_tokens":"public func create ( url : String ) : DownloadConnection {  if ( let Some ( i ) = client ) {  } else {  synchronized ( m ) {  if ( let Some ( j ) = client ) {  } else {  if ( let Some ( k ) = clientBuilder ) {  client = k . build ( ) NL } else {  client = OkHttpClient ( OkHttpClient . builder ( ) ) NL } NL clientBuilder = Option < OkHttpClientBuilder > . None NL } NL } NL } NL return DownloadOkHttp3Connection ( client . getOrThrow ( ) , url ) NL }","func_name":"create","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"static func create ( task : DownloadTask , asyncExecuted : Bool , store : DownloadStore ) {  return DownloadCall ( task , asyncExecuted , store ) NL }","func_name":"create","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"func execute ( ) : Unit {   var retry : Bool = false NL  var retryCount : Int64 = 0 NL  let okDownload : OkDownload = OkDownload . withs ( ) NL  let fileStrategy : ProcessFileStrategy = okDownload . processFileStrategy ( ) NL inspectTaskStart ( ) NL do {  if ( task . getUrl ( ) . size <= 0 ) {  this . cache = PreError ( IOException ( unexpected url:  + task . getUrl ( ) ) ) NL break NL } NL if ( canceled ) {  break NL } NL  var info : BreakpointInfo NL try {   var infoOnStore : Option < BreakpointInfo > = store . get ( task . getId ( ) ) NL if ( let Some ( i ) = infoOnStore ) {  info = i NL } else {  info = store . createAndInsert ( task ) NL } NL setInfoToTask ( info ) NL } catch ( e : IOException ) {  info = BreakpointInfo ( 0 ,  , Option < Directory > . None ,  ) NL this . cache = PreError ( e ) NL break NL } NL if ( canceled ) {  break NL } NL  let remoteCheck : BreakpointRemoteCheck = createRemoteCheck ( info ) NL try {  remoteCheck . check ( ) NL } catch ( e : ReadWriteException ) {  break NL } NL  let cachea : DownloadCache = createCache ( info ) NL this . cache = cachea NL if ( ! Util . isEmpty ( task . getRedirectLocation ( ) ) ) {  cache . getOrThrow ( ) . setRedirectLocation ( task . getRedirectLocation ( ) ) NL } NL OkDownload . withs ( ) . downloadStrategy ( ) . inspectAnotherSameInfo ( task , info , remoteCheck . getInstanceLength ( ) ) NL try {  if ( remoteCheck . isResumable ( ) ) {   let localCheck : BreakpointLocalCheck = createLocalCheck ( info , remoteCheck . getInstanceLength ( ) ) NL localCheck . check ( ) NL if ( localCheck . isDirty ( ) ) {  Util . d ( TAG , breakpoint invalid: download from beginning because of local check is dirty  + task . getId ( ) . toString ( ) +   + localCheck . toString ( ) ) NL fileStrategy . discardProcess ( task ) NL assembleBlockAndCallbackFromBeginning ( info , remoteCheck ) NL } else {  okDownload . callbackDispatcher ( ) . dispatch ( ) . downloadFromBreakpoint ( task ) NL } NL } NL } catch ( e : IOException ) {  cache . getOrThrow ( ) . setUnknownError ( e ) NL break NL } NL start ( cache . getOrThrow ( ) , info ) NL if ( canceled ) {  break NL } NL retryCount ++ NL if ( cache . getOrThrow ( ) . isPreconditionFailed ( ) && retryCount < MAX_COUNT_RETRY_FOR_PRECONDITION_FAILEDA ) {  store . remove ( task . getId ( ) ) NL retry = true NL } else {  retry = false NL } NL } while ( retry ) NL finishing = true NL blockChainList . clear ( ) NL  let cache : Option < DownloadCache > = this . cache NL if ( canceled ) {  return NL } NL if ( let Some ( i ) = cache ) {  } else {  return NL } NL  var cause : EndCause = EndCause . COMPLETED NL  var realCause : Option < Exception > = Option < Exception > . None NL if ( cache . getOrThrow ( ) . isServerCanceled ( ) || cache . getOrThrow ( ) . isUnknownError ( ) || cache . getOrThrow ( ) . isPreconditionFailed ( ) ) {  cause = EndCause . ERROR NL realCause = cache . getOrThrow ( ) . getRealCause ( ) NL } else if ( cache . getOrThrow ( ) . isFileBusyAfterRun ( ) ) {  cause = EndCause . FILE_BUSY NL } else if ( cache . getOrThrow ( ) . isPreAllocateFailed ( ) ) {  cause = EndCause . PRE_ALLOCATE_FAILED NL realCause = cache . getOrThrow ( ) . getRealCause ( ) NL } else {  cause = EndCause . COMPLETED NL } NL inspectTaskEnd ( cause , realCause ) NL }","func_name":"execute","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"private func inspectTaskStart ( ) : Unit {  store . onTaskStart ( task . getId ( ) ) NL OkDownload . withs ( ) . callbackDispatcher ( ) . dispatch ( ) . taskStart ( task ) NL }","func_name":"inspectTaskStart","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"private func inspectTaskEnd ( cause : EndCause , realCause : Option < Exception > ) {  synchronized ( m ) {  if ( canceled ) {  return NL } NL finishing = true NL } NL store . onTaskEnd ( task . getId ( ) , cause , realCause ) NL match ( cause ) { case EndCause . COMPLETED => store . markFileClear ( task . getId ( ) ) NL case _ => println ( cause not complete ) NL } NL OkDownload . withs ( ) . callbackDispatcher ( ) . dispatch ( ) . taskEnd ( task , realCause ) NL }","func_name":"inspectTaskEnd","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"func createCache ( info : BreakpointInfo ) : DownloadCache {   let outputStream : MultiPointOutputStream = OkDownload . withs ( ) . processFileStrategy ( ) . createProcessStream ( task , info , store ) NL return DownloadCache ( outputStream ) NL }","func_name":"createCache","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"func start ( cache : DownloadCache , info : BreakpointInfo ) : Unit {   let blockCount : Int64 = info . getBlockCount ( ) NL  let blockChainList : ArrayList < DownloadChain > = ArrayList < DownloadChain > ( info . getBlockCount ( ) ) NL  let blockIndexList : ArrayList < Int64 > = ArrayList < Int64 > ( ) NL for ( i in 0 .. blockCount ) {   let blockInfo : BlockInfo = info . getBlock ( i ) . getOrThrow ( ) NL if ( Util . isCorrectFull ( blockInfo . getCurrentOffset ( ) , blockInfo . getContentLength ( ) ) ) {  continue NL } NL Util . resetBlockIfDirty ( blockInfo ) NL  let chain : DownloadChain = DownloadChain . createChain ( i , task , info , cache , store ) NL blockChainList . append ( chain ) NL blockIndexList . append ( chain . getBlockIndex ( ) ) NL } NL if ( canceled ) {  return NL } NL cache . getOutputStream ( ) . setRequireStreamBlocks ( blockIndexList ) NL startBlocks ( blockChainList ) NL }","func_name":"start","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"func startBlocks ( tasks : ArrayList < DownloadChain > ) : Unit {   var futures : ArrayList < Future < Unit > > = ArrayList < Future < Unit > > ( tasks . size ) NL try {  for ( i in 0 .. tasks . size ) {   let fut : Future < Unit > = spawn { =>  let task : DownloadChain = tasks . get ( i ) . getOrThrow ( ) NL if ( task . isFinished ( ) ) {  throw IllegalAccessException ( The chain has been finished! ) NL } NL try {  task . start ( ) NL } catch ( e : Exception ) {  } finally {  task . finished . store ( true ) NL task . releaseConnectionAsync ( ) NL } NL } NL futures . append ( fut ) NL } NL blockChainList . appendAll ( tasks ) NL for ( future in futures ) {  future . getResult ( ) NL } NL } catch ( e : Exception ) {  throw e NL } finally {  doDelete ( blockChainList , tasks ) NL } NL }","func_name":"startBlocks","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"private func doDelete ( blockChainList : ArrayList < DownloadChain > , tasks : ArrayList < DownloadChain > ) {  blockChainList . removeIf ( { blockChain : DownloadChain =>  var isRight = false NL for ( task in tasks ) {  if ( task . getTask ( ) . getId ( ) == blockChain . getTask ( ) . getId ( ) ) {  isRight = true NL break NL } NL } NL return isRight NL } ) NL }","func_name":"doDelete","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"func createLocalCheck ( info : BreakpointInfo , responseInstanceLength : Int64 ) : BreakpointLocalCheck {  return BreakpointLocalCheck ( task , info , responseInstanceLength ) NL }","func_name":"createLocalCheck","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"func createRemoteCheck ( info : BreakpointInfo ) : BreakpointRemoteCheck {  return BreakpointRemoteCheck ( task , info ) NL }","func_name":"createRemoteCheck","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"func setInfoToTask ( info : BreakpointInfo ) : Unit {  TaskHideWrapper . setBreakpointInfo ( task , info ) NL }","func_name":"setInfoToTask","docstring":""}
{"repo":"ok-download","file":"DownloadCall.cj","path":"ok-download/src/DownloadCall.cj","code_tokens":"func assembleBlockAndCallbackFromBeginning ( info : BreakpointInfo , remoteCheck : BreakpointRemoteCheck ) : Unit {  Util . assembleBlock ( task , info , remoteCheck . getInstanceLength ( ) , remoteCheck . isAcceptRange ( ) ) NL OkDownload . withs ( ) . callbackDispatcher ( ) . dispatch ( ) . downloadFromBeginning ( task ) NL }","func_name":"assembleBlockAndCallbackFromBeginning","docstring":""}
{"repo":"ok-download","file":"InterceptorConnect.cj","path":"ok-download/src/InterceptorConnect.cj","code_tokens":"func interceptConnect ( chain : DownloadChain ) : Option < DownloadConnectionConnected >","func_name":"interceptConnect","docstring":""}
{"repo":"ok-download","file":"BreakPointLocalCheck.cj","path":"ok-download/src/BreakPointLocalCheck.cj","code_tokens":"func isDirty ( ) : Bool {  return dirty NL }","func_name":"isDirty","docstring":""}
{"repo":"ok-download","file":"BreakPointLocalCheck.cj","path":"ok-download/src/BreakPointLocalCheck.cj","code_tokens":"func getCauseOrThrow ( ) : ResumeFailedCause {  if ( ! infoRight ) {  return INFO_DIRTY NL } NL throw IllegalStateException ( No cause find with dirty:  + dirty . toString ( ) ) NL }","func_name":"getCauseOrThrow","docstring":""}
{"repo":"ok-download","file":"BreakPointLocalCheck.cj","path":"ok-download/src/BreakPointLocalCheck.cj","code_tokens":"func isInfoRightToResume ( ) : Bool {   let blockCount : Int64 = info . getBlockCount ( ) NL if ( blockCount <= 0 ) {  return false NL } NL return true NL }","func_name":"isInfoRightToResume","docstring":""}
{"repo":"ok-download","file":"BreakPointLocalCheck.cj","path":"ok-download/src/BreakPointLocalCheck.cj","code_tokens":"func isOutputStreamSupportResume ( ) : Bool {   let supportSeek : Bool = OkDownload . withs ( ) . outputStreamFactory ( ) . supportSeek ( ) NL if ( supportSeek ) {  return true NL } NL return true NL }","func_name":"isOutputStreamSupportResume","docstring":""}
{"repo":"ok-download","file":"BreakPointLocalCheck.cj","path":"ok-download/src/BreakPointLocalCheck.cj","code_tokens":"func isFileExistToResume ( ) : Bool {   let file : Option < File > = task . getFile ( ) NL if ( let Some ( i ) = file ) {  } else {  return false NL } NL if ( File . exists ( file . getOrThrow ( ) . info . path ) ) {  return true NL } else {  return false NL } NL }","func_name":"isFileExistToResume","docstring":""}
{"repo":"ok-download","file":"BreakPointLocalCheck.cj","path":"ok-download/src/BreakPointLocalCheck.cj","code_tokens":"func check ( ) : Unit {  fileExist = isFileExistToResume ( ) NL infoRight = isInfoRightToResume ( ) NL outputStreamSupport = isOutputStreamSupportResume ( ) NL dirty = ! infoRight || ! fileExist || ! outputStreamSupport NL }","func_name":"check","docstring":""}
{"repo":"ok-download","file":"BreakPointLocalCheck.cj","path":"ok-download/src/BreakPointLocalCheck.cj","code_tokens":"func toString ( ) : String {  return fileExist[ + fileExist . toString ( ) + ] infoRight[ + infoRight . toString ( ) + ] outputStreamSupport[ + outputStreamSupport . toString ( ) + ] NL }","func_name":"toString","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func taskStart ( task : DownloadTask ) : Unit","func_name":"taskStart","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func connectTrialStart ( task : DownloadTask , requestHeaderFields : HashMap < String , ArrayList < String > > ) : Unit","func_name":"connectTrialStart","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func connectTrialEnd ( task : DownloadTask , responseCode : Int64 , responseHeaderFields : HashMap < String , ArrayList < String > > ) : Unit","func_name":"connectTrialEnd","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func downloadFromBeginning ( task : DownloadTask ) : Unit","func_name":"downloadFromBeginning","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func downloadFromBreakpoint ( task : DownloadTask ) : Unit","func_name":"downloadFromBreakpoint","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func connectStart ( task : DownloadTask , blockIndex : Int64 , requestHeaderFields : HashMap < String , ArrayList < String > > ) : Unit","func_name":"connectStart","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func connectEnd ( task : DownloadTask , blockIndex : Int64 , responseCode : Int64 , responseHeaderFields : HashMap < String , ArrayList < String > > ) : Unit","func_name":"connectEnd","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func fetchStart ( task : DownloadTask , blockIndex : Int64 , contentLength : Int64 ) : Unit","func_name":"fetchStart","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func fetchProgress ( task : DownloadTask , blockIndex : Int64 , increaseBytes : Int64 ) : Unit","func_name":"fetchProgress","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func fetchEnd ( task : DownloadTask , blockIndex : Int64 , contentLength : Int64 ) : Unit","func_name":"fetchEnd","docstring":""}
{"repo":"ok-download","file":"DownloadListener.cj","path":"ok-download/src/DownloadListener.cj","code_tokens":"func taskEnd ( task : DownloadTask , realCause : Option < Exception > ) : Unit","func_name":"taskEnd","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"static func createChain ( blockIndex : Int64 , task : DownloadTask , info : BreakpointInfo , cache : DownloadCache , store : DownloadStore ) : DownloadChain {  return DownloadChain ( blockIndex , task , info , cache , store ) NL }","func_name":"createChain","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func getResponseContentLength ( ) : Int64 {  return responseContentLength NL }","func_name":"getResponseContentLength","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func setResponseContentLength ( responseContentLength : Int64 ) : Unit {  this . responseContentLength = responseContentLength NL }","func_name":"setResponseContentLength","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func getTask ( ) : DownloadTask {  return task NL }","func_name":"getTask","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func getInfo ( ) : BreakpointInfo {  return this . info NL }","func_name":"getInfo","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func getBlockIndex ( ) : Int64 {  return blockIndex NL }","func_name":"getBlockIndex","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func getCache ( ) : DownloadCache {  return cache NL }","func_name":"getCache","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func getOutputStream ( ) : MultiPointOutputStream {  return this . cache . getOutputStream ( ) NL }","func_name":"getOutputStream","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func getConnectionOrCreate ( ) : DownloadConnection {  synchronized ( m ) {  if ( cache . isInterrupt ( ) ) {  throw InterruptException . SIGNAL NL } NL if ( let Some ( i ) = connection ) {  } else {   var url : String =  NL  let redirectLocation : Option < String > = cache . getRedirectLocation ( ) NL if ( let Some ( j ) = redirectLocation ) {  if ( Util . isEmpty ( j ) ) {  url = info . getUrl ( ) NL } else {  url = j NL } NL } else {  url = info . getUrl ( ) NL } NL Util . d ( TAG , create connection on url:  + url ) NL connection = OkDownload . withs ( ) . connectionFactory ( ) . create ( url ) NL } NL return connection . getOrThrow ( ) NL } NL }","func_name":"getConnectionOrCreate","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func increaseCallbackBytes ( increaseBytes : Int64 ) : Unit {  this . noCallbackIncreaseBytes += increaseBytes NL }","func_name":"increaseCallbackBytes","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func flushNoCallbackIncreaseBytes ( ) : Unit {  if ( noCallbackIncreaseBytes == 0 ) {  return NL } NL callbackDispatcher . dispatch ( ) . fetchProgress ( task , blockIndex , noCallbackIncreaseBytes ) NL noCallbackIncreaseBytes = 0 NL }","func_name":"flushNoCallbackIncreaseBytes","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func start ( ) : Unit {   let dispatcher : CallbackDispatcher = OkDownload . withs ( ) . callbackDispatcher ( ) NL  let retryInterceptor : RetryInterceptor = RetryInterceptor ( ) NL  let breakpointInterceptor : BreakpointInterceptor = BreakpointInterceptor ( ) NL connectInterceptorList . append ( retryInterceptor ) NL connectInterceptorList . append ( breakpointInterceptor ) NL connectInterceptorList . append ( HeaderInterceptor ( ) ) NL connectInterceptorList . append ( CallServerInterceptor ( ) ) NL  var connectIndex : Int64 = 0 NL  let connected : DownloadConnectionConnected = processConnect ( ) NL if ( cache . isInterrupt ( ) ) {  throw InterruptException . SIGNAL NL } NL dispatcher . dispatch ( ) . fetchStart ( task , blockIndex , getResponseContentLength ( ) ) NL  let fetchDataInterceptor : FetchDataInterceptor = FetchDataInterceptor ( blockIndex , connected . getInputStream ( ) , getOutputStream ( ) , task ) NL fetchInterceptorList . append ( retryInterceptor ) NL fetchInterceptorList . append ( breakpointInterceptor ) NL fetchInterceptorList . append ( fetchDataInterceptor ) NL  var fetchIndex : Int64 = 0 NL  let totalFetchedBytes : Int64 = processFetch ( ) NL dispatcher . dispatch ( ) . fetchEnd ( task , blockIndex , totalFetchedBytes ) NL }","func_name":"start","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func resetConnectForRetry ( ) : Unit {  connectIndex = 1 NL releaseConnection ( ) NL }","func_name":"resetConnectForRetry","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func releaseConnection ( ) : Unit {  synchronized ( m ) {  if ( let Some ( i ) = connection ) {  i . release ( ) NL } NL connection = Option < DownloadConnection > . None NL } NL }","func_name":"releaseConnection","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func processConnect ( ) : DownloadConnectionConnected {  if ( cache . isInterrupt ( ) ) {  throw InterruptException . SIGNAL NL } NL  let connect : InterceptorConnect = connectInterceptorList . get ( connectIndex ) . getOrThrow ( ) NL connectIndex ++ NL return connect . interceptConnect ( this ) . getOrThrow ( ) NL }","func_name":"processConnect","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func processFetch ( ) : Int64 {  if ( cache . isInterrupt ( ) ) {  throw InterruptException . SIGNAL NL } NL  let fetch : InterceptorFetch = fetchInterceptorList . get ( fetchIndex ) . getOrThrow ( ) NL fetchIndex ++ NL return fetch . interceptFetch ( this ) NL }","func_name":"processFetch","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func loopFetch ( ) : Int64 {  if ( fetchIndex == fetchInterceptorList . size ) {  fetchIndex -- NL } NL return processFetch ( ) NL }","func_name":"loopFetch","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func isFinished ( ) : Bool {  return finished . load ( ) NL }","func_name":"isFinished","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func getDownloadStore ( ) : DownloadStore {  return store NL }","func_name":"getDownloadStore","docstring":""}
{"repo":"ok-download","file":"DownloadChain.cj","path":"ok-download/src/DownloadChain.cj","code_tokens":"func releaseConnectionAsync ( ) : Unit {  spawn { releaseConnection ( ) NL } NL }","func_name":"releaseConnectionAsync","docstring":""}
