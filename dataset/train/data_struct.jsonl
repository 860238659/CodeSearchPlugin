{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public operator func == ( that : TreeNode < T > ) : Bool {  if ( value == that . value && left == that . left && right == that . right ) {  true NL } else {  false NL } NL }","func_name":"==","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public operator func != ( that : TreeNode < T > ) : Bool {  if ( value == that . value && left == that . left && right == that . right ) {  false NL } else {  true NL } NL }","func_name":"!=","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func toString ( ) : String {  ${value} NL }","func_name":"toString","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"protected func isNone ( item : ? TreeNode < T > ) : Bool {  match ( item ) { case None => true NL case _ => false NL } NL }","func_name":"isNone","docstring":"/* public init(v:T) {\n       Root = TreeNode<T>(v)\n       } */"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"protected func getSize ( subTree : ? TreeNode < T > ) : Int64 {  match ( subTree ) { case Some ( v ) => return 1 + getSize ( v . left ) + getSize ( v . right ) NL case _ => 0 NL } NL }","func_name":"getSize","docstring":"//子树节点数"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func getHeight ( subTree : ? TreeNode < T > ) : Int64 {  match ( subTree ) { case None => 0 NL case Some ( sub ) =>  let i = getHeight ( sub . left ) NL  let j = getHeight ( sub . right ) NL if ( i < j ) {  j + 1 NL } else {  i + 1 NL } NL } NL }","func_name":"getHeight","docstring":"//树高"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func isEmpty ( ) : Bool {  if ( Size == 0 ) {  true NL } else {  false NL } NL }","func_name":"isEmpty","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func parent ( item : ? TreeNode < T > ) : ? ( TreeNode < T > , String ) {  match ( Root ) { case None => None NL case r where r == item => None NL case _ => parent ( Root , item ) NL } NL }","func_name":"parent","docstring":"//返回双亲节点"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"protected func parent ( subTree : ? TreeNode < T > , item : ? TreeNode < T > ) : ? ( TreeNode < T > , String ) {  match ( subTree ) { case None => None NL case Some ( sub ) => if ( sub . left == item ) {  ( sub , left ) NL } else if ( sub . right == item ) {  ( sub , right ) NL } else {   let p = parent ( sub . left , item ) NL match ( p ) { case Some ( v ) => p NL case _ => parent ( sub . right , item ) NL } NL } NL } NL }","func_name":"parent","docstring":"//返回双亲节点"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func getLeft ( item : ? TreeNode < T > ) : ? TreeNode < T > {  match ( item ) { case Some ( v ) => v . left NL case _ => None NL } NL }","func_name":"getLeft","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func getRight ( item : ? TreeNode < T > ) : ? TreeNode < T > {  match ( item ) { case Some ( v ) => v . right NL case _ => None NL } NL }","func_name":"getRight","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"protected func getPreOrder ( subTree : ? TreeNode < T > ) : ? TreeNode < T > {  match ( subTree ) { case Some ( sub ) => getPreOrder ( sub . left ) NL getPreOrder ( sub . right ) NL case _ => subTree NL } NL }","func_name":"getPreOrder","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public open func insert ( data : T ) : Bool {   let new = TreeNode < T > ( data ) NL if ( isNone ( Root ) ) {  Root = new NL Size = 1 NL return true NL } else {   var cur = Root NL  var parent = None < TreeNode < T > > NL while ( ! isNone ( cur ) ) {  parent = cur NL if ( cur . getOrThrow ( ) . value > data ) {  cur = cur . getOrThrow ( ) . left NL if ( isNone ( cur ) ) {  parent . getOrThrow ( ) . left = new NL Size += 1 NL return true NL } NL } else {  cur = cur . getOrThrow ( ) . right NL if ( isNone ( cur ) ) {  parent . getOrThrow ( ) . right = new NL Size += 1 NL return true NL } NL } NL } NL return false NL } NL }","func_name":"insert","docstring":"/*\n     * 二叉查找树插入节点\n     */"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func destory ( subTree : ? TreeNode < T > ) : Unit {  match ( subTree ) { case Some ( sub ) => destory ( sub . left ) NL destory ( sub . right ) NL  let p = parent ( sub ) NL match ( p ) { case Some ( v ) => if ( v [ 1 ] == left ) {  Size -= getSize ( v [ 0 ] . left ) NL v [ 0 ] . left = None NL } else {  Size -= getSize ( v [ 0 ] . right ) NL v [ 0 ] . right = None NL } NL case _ => Root = None NL Size = 0 NL } NL case _ => ( ) NL } NL }","func_name":"destory","docstring":"//所以应采用后续遍历，当访问某个结点时将该结点的存储空间释放"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func preOrder ( subTree : ? TreeNode < T > ) : Unit {  match ( subTree ) { case Some ( sub ) => println ( sub ) NL preOrder ( sub . left ) NL preOrder ( sub . right ) NL case _ => ( ) NL } NL }","func_name":"preOrder","docstring":"/*\n     * 递归实现遍历\n     */"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func midOrder ( subTree : ? TreeNode < T > ) : Unit {  match ( subTree ) { case Some ( sub ) => midOrder ( sub . left ) NL println ( sub ) NL midOrder ( sub . right ) NL case _ => ( ) NL } NL }","func_name":"midOrder","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func postOrder ( subTree : ? TreeNode < T > ) : Unit {  match ( subTree ) { case Some ( sub ) => postOrder ( sub . left ) NL postOrder ( sub . right ) NL println ( sub ) NL case _ => ( ) NL } NL }","func_name":"postOrder","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func nonRecPreOrder ( subTree : ? TreeNode < T > ) : Unit {   var stack = Stack < TreeNode < T > > ( ) NL  var node : ? TreeNode < T > = subTree NL match ( node ) { case Some ( nod ) => stack . push ( nod ) NL while ( ! stack . isEmpty ( ) ) {  node = stack . pop ( ) NL println ( node . getOrThrow ( ) ) NL match ( getRight ( node ) ) { case Some ( v ) => stack . push ( v ) NL case None => ( ) NL } NL match ( getLeft ( node ) ) { case Some ( v ) => stack . push ( v ) NL case None => ( ) NL } NL } NL case _ => ( ) NL } NL }","func_name":"nonRecPreOrder","docstring":"/*\n     * 非递归实现遍历\n     */"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func nonRecMidOrder ( subTree : ? TreeNode < T > ) : Unit {   var stack = Stack < TreeNode < T > > ( ) NL  var node : ? TreeNode < T > = subTree NL while ( ! isNone ( node ) || stack . size > 0 ) {  while ( ! isNone ( node ) ) {  stack . push ( node . getOrThrow ( ) ) NL node = node . getOrThrow ( ) . left NL } NL if ( stack . size > 0 ) {   let nod = stack . pop ( ) NL println ( nod ) NL node = nod . right NL } NL } NL }","func_name":"nonRecMidOrder","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func nonRecPostOrder ( subTree : ? TreeNode < T > ) : Unit {   let stack = Stack < TreeNode < T > > ( ) NL  var p = subTree NL  var node = subTree NL while ( ! isNone ( p ) ) {  while ( ! isNone ( p . getOrThrow ( ) . left ) ) {  stack . push ( p . getOrThrow ( ) ) NL p = p . getOrThrow ( ) . left NL } NL while ( ! isNone ( p ) && ( isNone ( p . getOrThrow ( ) . right ) || p . getOrThrow ( ) . right == node ) ) {  println ( p . getOrThrow ( ) ) NL node = p NL if ( stack . isEmpty ( ) ) {  return NL } NL p = stack . pop ( ) NL } NL stack . push ( p . getOrThrow ( ) ) NL p = p . getOrThrow ( ) . right NL } NL }","func_name":"nonRecPostOrder","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func searchNode ( data : T ) : ? TreeNode < T > {   var cur = Root NL while ( true ) {  if ( let Some ( c ) = cur ) {  if ( c . value == data ) {  break NL } else {  if ( c . value > data ) {  cur = c . left NL } else {  cur = c . right NL } NL } NL } else {  break NL } NL } NL return cur NL }","func_name":"searchNode","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func searchK ( k : Int64 ) : ? T {   var count = 0 NL  func midOrder ( subTree : ? TreeNode < T > ) : ? T {  match ( subTree ) { case Some ( sub ) => midOrder ( sub . left ) NL count += 1 NL if ( count == k ) {  return sub . value NL } NL if ( count > k ) {  return None NL } NL midOrder ( sub . right ) NL case _ => throw IndexOutOfBoundsException ( ${k} is out of tree height! ) NL } NL } NL return midOrder ( Root ) NL }","func_name":"searchK","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"func midOrder ( subTree : ? TreeNode < T > ) : ? T {  match ( subTree ) { case Some ( sub ) => midOrder ( sub . left ) NL count += 1 NL if ( count == k ) {  return sub . value NL } NL if ( count > k ) {  return None NL } NL midOrder ( sub . right ) NL case _ => throw IndexOutOfBoundsException ( ${k} is out of tree height! ) NL } NL }","func_name":"midOrder","docstring":""}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func searchMin ( node : TreeNode < T > ) : TreeNode < T > {   var cur = node NL while ( true ) {  if ( let Some ( c ) = cur . left ) {  cur = c NL } else {  break NL } NL } NL return cur NL }","func_name":"searchMin","docstring":"/*\n     * 查找node树最小节点\n     */"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func searchMax ( node : TreeNode < T > ) : TreeNode < T > {   var cur = node NL while ( true ) {  if ( let Some ( c ) = cur . right ) {  cur = c NL } else {  break NL } NL } NL return cur NL }","func_name":"searchMax","docstring":"/*\n     * 查找node树最大节点\n     */"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func insert ( data : T ) : Bool {  if ( let Some ( v ) = searchNode ( data ) ) {  return true NL } NL if ( let Some ( r ) = Root ) {   var cur : ? TreeNode < T > = r NL  var pre : ? TreeNode < T > = None NL while ( true ) {  if ( let Some ( c ) = cur ) {  pre = c NL if ( c . value < data ) {  cur = c . right NL } else {  cur = c . left NL } NL } else {  break NL } NL } NL if ( let Some ( p ) = pre ) {  if ( p . value < data ) {  p . right = TreeNode < T > ( data ) NL } else {  p . left = TreeNode < T > ( data ) NL } NL Size += 1 NL return true NL } else {  return false NL } NL } else {  Root = TreeNode < T > ( data ) NL Size = 1 NL return true NL } NL }","func_name":"insert","docstring":"/*\n     * 二叉查找树插入节点\n     */"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"private func deleteLeaf ( node : TreeNode < T > ) {   var cur_parent = parent ( node ) NL if ( let Some ( p ) = cur_parent ) {  if ( node . value < p [ 0 ] . value ) {  Size -= 1 NL p [ 0 ] . left = None NL } else {  Size -= 1 NL p [ 0 ] . right = None NL } NL } else {  Root = None NL Size = 0 NL } NL }","func_name":"deleteLeaf","docstring":"/*\n     * 删除叶子节点，修改父节点指向为空，Size-1\n     */"}
{"repo":"data_struct","file":"binarytree.cj","path":"data_struct/src/datastruct/binarytree.cj","code_tokens":"public func delete ( node : TreeNode < T > ) : Unit {  match ( ( node . left , node . right ) ) { case ( None , None ) => deleteLeaf ( node ) NL case _ =>  let replace = if ( let Some ( r ) = node . right ) {  r NL } else {  node . left . getOrThrow ( ) NL } NL  let rep_node = replace NL if ( let Some ( node_parent ) = parent ( node ) ) {  if ( node == parent ( replace ) . getOrThrow ( ) [ 0 ] ) {  if ( node_parent [ 1 ] == left ) {  node_parent [ 0 ] . left = replace NL } else {  node_parent [ 0 ] . right = replace NL } NL if ( Some ( replace ) != node . left ) {  replace . left = node . left NL } NL } else {  if ( node_parent [ 1 ] == left ) {  node_parent [ 0 ] . left = replace NL } else {  node_parent [ 0 ] . right = replace NL } NL replace . left = node . left NL replace . right = node . right NL delete ( rep_node ) NL } NL } else {  Root = replace NL } NL Size -= 1 NL } NL }","func_name":"delete","docstring":""}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func isEmpty ( ) : Bool {  if ( Size == 0 ) {  true NL } else {  false NL } NL }","func_name":"isEmpty","docstring":""}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  LinkedListIterator ( head ) NL }","func_name":"iterator","docstring":"/*\n     * LinkedList Iterator\n     * @return Iterator<T>\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func toString ( ) : String {   var s =  NL if ( ! isEmpty ( ) ) {   var i = 0 NL for ( it in this ) {  if ( i < Size - 1 ) {  s += ${it} ->  NL i ++ NL } else {  s += ${it} NL } NL } NL } NL s NL }","func_name":"toString","docstring":""}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func remove ( index : Int64 ) : ? T {  if ( index < 0 || index > = Size ) {  None < T > NL } NL match ( this [ index ] ) { case Some ( v ) => unlink ( v ) NL case _ => None < T > NL } NL }","func_name":"remove","docstring":"/**\n     * remove element at specified index for common LinkedList\n     * @param index: specified index\n     * @return T: removed value and throw exception if failed\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func insert ( index : Int64 , item : T ) : Unit {  if ( index < 0 || index > Size ) {  throw IndexOutOfBoundsException ( ) NL } NL if ( index == 0 ) {  addLast ( item ) NL } else {  addBefore ( item , this [ index ] ) NL } NL }","func_name":"insert","docstring":"/**\n     * insert element before specified index for common LinkedList\n     * @param index: specified index\n     * @param item: inserted element before index\n     * @return Unit\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func set ( index : Int64 , item : T ) : ? T {  if ( index < 0 || index > = Size ) {  None < T > NL } else {  match ( this [ index ] ) { case Some ( v ) =>  let old = v . value NL v . value = item NL old NL case None => None NL } NL } NL }","func_name":"set","docstring":"/**\n     * Replace element at specified location for common LinkedList\n     * @param index: Specified location index\n     * @param item: Specified location value\n     * @return T: Old value at specified index, whose type is T\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func get ( index : Int64 ) : ? T {  if ( index < 0 || index > = Size ) {  return None NL } NL this [ index ] ? . value NL }","func_name":"get","docstring":"/*\n     * Gets the value of the specified index\n     * for common LinkedList, different from stack based LinkedList\n     * @param index: Specified location index\n     * @return Option<T>: Return value and None if None\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func getFirst ( ) : ? T {  head ? . value NL }","func_name":"getFirst","docstring":"/*\n     * Gets the value of the first index\n     * @return Option<T>: Return value and None if None\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func getLast ( ) : ? T {  tail ? . value NL }","func_name":"getLast","docstring":"/*\n     * Gets the value of the last index\n     * @return Option<T>: Return value and None if None\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func addFirst ( item : T ) : Unit {   let first = head NL  let new = Node ( prev : None , value : item , next : first ) NL head = new NL match ( first ) { case Some ( v ) => v . prev = new NL case _ => tail = new NL } NL Size ++ NL }","func_name":"addFirst","docstring":"/**\n     * add element at first index\n     * @param item: added element at first index\n     * @return Unit\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func addLast ( item : T ) : Unit {   let last = tail NL  let new = Node ( prev : last , value : item , next : None ) NL tail = new NL match ( last ) { case Some ( v ) => v . next = new NL case _ => head = new NL } NL Size ++ NL }","func_name":"addLast","docstring":"/**\n     * add element at last index\n     * @param item: added element at last index\n     * @return Unit\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func rmFirst ( ) : ? T {  match ( head ) { case None => None < T > NL case Some ( h ) =>  let hnext = h . next NL h . next = None NL head = hnext NL match ( hnext ) { case Some ( v ) => v . prev = None NL case _ => tail = None NL } NL Size -- NL h . value NL } NL }","func_name":"rmFirst","docstring":"/**\n     * cut head for Deque based LinkedList\n     * @return T: the value of old head\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func rmLast ( ) : ? T {  match ( tail ) { case None => None < T > NL case Some ( t ) =>  let tprev = t . prev NL t . prev = None NL tail = tprev NL match ( tprev ) { case Some ( v ) => v . next = None NL case _ => head = None NL } NL Size -- NL t . value NL } NL }","func_name":"rmLast","docstring":"/**\n     * cut tail\n     * @return T: the value of old tail\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"private operator func [ ] ( index : Int64 ) : ? Node < T > {   var x = None < Node < T > > NL  var step = 0 NL  var start = - 1 NL if ( index < ( Size >> 1 ) ) {  x = head NL start = 0 NL step = 1 NL } else {  x = tail NL start = Size - 1 NL step = - 1 NL } NL for ( i in start .. index : step ) {  match ( x ) { case Some ( v ) => if ( step == 1 ) {  x = v . next NL } else {  x = v . prev NL } NL case _ => ( ) NL } NL } NL x NL }","func_name":"[]","docstring":""}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"private func unlink ( x : Node < T > ) : T {   let item = x . value NL  let xnext = x . next NL  let xprev = x . prev NL match ( xprev ) { case Some ( v ) => v . next = xnext NL x . prev = None NL case _ => head = xnext NL } NL match ( xnext ) { case Some ( v ) => v . prev = xprev NL x . next = None NL case _ => tail = xprev NL } NL Size -- NL item NL }","func_name":"unlink","docstring":"/**\n     * cut specified node\n     * @param x: cut node\n     * @return T: cut value\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"private func addBefore ( item : T , goal : ? Node < T > ) : Unit {  match ( goal ) { case Some ( v ) =>  let pred = v . prev NL  let new = Node ( prev : pred , value : item , next : goal ) NL v . prev = new NL match ( pred ) { case Some ( vpre ) => vpre . next = new NL case _ => head = new NL } NL Size ++ NL case _ => ( ) NL } NL }","func_name":"addBefore","docstring":"/**\n     * add element before specified node\n     * @param item: added element before specified node\n     * @param goal: specified node\n     * @return Unit\n     */"}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func next ( ) : ? T {  match ( cur ) { case Some ( v ) =>  let item = v . value NL cur = v . next NL item NL case _ => None NL } NL }","func_name":"next","docstring":""}
{"repo":"data_struct","file":"linkedlist.cj","path":"data_struct/src/datastruct/linkedlist.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  this NL }","func_name":"iterator","docstring":"/*\n     * LinkedList Iterator\n     * @return Iterator<T>\n     */"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func peek ( ) : ? T","func_name":"peek","docstring":"//获取队首的值，不删除，为空返回None"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func poll ( ) : ? T","func_name":"poll","docstring":"//出队，获取队首的值并删除队首，为空返回None"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func offer ( Item : T ) : Unit","func_name":"offer","docstring":"//入队，将指定的元素添加到队尾，成功返回true否则false"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func push ( item : T ) : Unit","func_name":"push","docstring":"// Stack, implement from LinkedList and Node"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func addFirst ( item : T ) : Unit","func_name":"addFirst","docstring":"//堆栈push"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func addLast ( item : T ) : Unit","func_name":"addLast","docstring":""}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func getFirst ( ) : ? T","func_name":"getFirst","docstring":"//获取值但不删除"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func get ( ) : ? T","func_name":"get","docstring":"//等效queue.peek"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func getLast ( ) : ? T","func_name":"getLast","docstring":"//堆栈get"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func rmFirst ( ) : ? T","func_name":"rmFirst","docstring":""}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func pop ( ) : ? T","func_name":"pop","docstring":""}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"func rmLast ( ) : ? T","func_name":"rmLast","docstring":"//堆栈pop"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"public func push ( item : T ) : Unit {  this . addFirst ( item ) NL }","func_name":"push","docstring":"// Stack, implement from LinkedList and Node"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"public func get ( ) : ? T {  this . getFirst ( ) NL }","func_name":"get","docstring":"//等效queue.peek"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"public func pop ( ) : ? T {  this . rmFirst ( ) NL }","func_name":"pop","docstring":""}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"public func offer ( item : T ) : Unit {  this . addLast ( item ) NL }","func_name":"offer","docstring":"//入队，将指定的元素添加到队尾，成功返回true否则false"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"public func poll ( ) : ? T {  this . rmFirst ( ) NL }","func_name":"poll","docstring":"//出队，获取队首的值并删除队首，为空返回None"}
{"repo":"data_struct","file":"queue.cj","path":"data_struct/src/datastruct/queue.cj","code_tokens":"public func peek ( ) : ? T {  this . getFirst ( ) NL }","func_name":"peek","docstring":"//获取队首的值，不删除，为空返回None"}
{"repo":"data_struct","file":"stack.cj","path":"data_struct/src/datastruct/stack.cj","code_tokens":"public func next ( ) : Option < T > {  if ( initVer != Data . version ( ) ) {  println ( The version of Data is incorrect! ) NL return None NL } NL Position ++ NL return Data . get ( Position ) NL }","func_name":"next","docstring":"/*\n     * Gets the value of the next index\n     * @return Option<T>: Return value\n     * @since 0.29.3\n     */"}
{"repo":"data_struct","file":"stack.cj","path":"data_struct/src/datastruct/stack.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  this NL }","func_name":"iterator","docstring":"/*\n     * Stack iterator\n     * @return Iterator<T>\n     * @since 0.29.3\n     */"}
{"repo":"data_struct","file":"stack.cj","path":"data_struct/src/datastruct/stack.cj","code_tokens":"public func isEmpty ( ) : Bool {  if ( Size == 0 ) {  true NL } else {  false NL } NL }","func_name":"isEmpty","docstring":""}
{"repo":"data_struct","file":"stack.cj","path":"data_struct/src/datastruct/stack.cj","code_tokens":"public func top ( ) : Option < T > {  stack . get ( Size - 1 ) NL }","func_name":"top","docstring":"/**\n     * Get the top element of stack\n     * @return Option<T>: Return value\n     * @since 0.29.3\n     */"}
{"repo":"data_struct","file":"stack.cj","path":"data_struct/src/datastruct/stack.cj","code_tokens":"public func pop ( ) : T {   let ret = stack . remove ( Size - 1 ) NL Size -- NL ret NL }","func_name":"pop","docstring":"/**\n     * Remove last element\n     * @return Option<T>: Return removed element\n     * @since 0.29.3\n     */"}
{"repo":"data_struct","file":"stack.cj","path":"data_struct/src/datastruct/stack.cj","code_tokens":"public func push ( item : T ) : Unit {  stack . insert ( Size , item ) NL Size ++ NL }","func_name":"push","docstring":"/**\n     * Add an element to the top of the stack\n     * @param item: Added element\n     * @return Unit\n     * @since 0.29.3\n     */"}
{"repo":"data_struct","file":"stack.cj","path":"data_struct/src/datastruct/stack.cj","code_tokens":"public func clone ( ) : Stack < T > {  Stack < T > ( this ) NL }","func_name":"clone","docstring":""}
{"repo":"data_struct","file":"stack.cj","path":"data_struct/src/datastruct/stack.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  StackIterator < T > ( stack ) NL }","func_name":"iterator","docstring":"/*\n     * Stack iterator\n     * @return Iterator<T>\n     * @since 0.29.3\n     */"}
{"repo":"data_struct","file":"sort.cj","path":"data_struct/src/algorithm/sort.cj","code_tokens":"operator func [ ] ( index : Int64 ) : T","func_name":"[]","docstring":""}
{"repo":"data_struct","file":"sort.cj","path":"data_struct/src/algorithm/sort.cj","code_tokens":"operator func [ ] ( range : Range < Int64 > ) : ExCollection < T >","func_name":"[]","docstring":""}
{"repo":"data_struct","file":"sort.cj","path":"data_struct/src/algorithm/sort.cj","code_tokens":"static public func bubbleSort ( arr : ArrayList < T > ) {   let length = arr . size NL for ( i in 0 .. length - 1 ) {  for ( j in 0 .. length - i - 1 ) {  if ( arr [ j ] > arr [ j + 1 ] ) {   let tmp = arr [ j ] NL arr [ j ] = arr [ j + 1 ] NL arr [ j + 1 ] = tmp NL } NL } NL } NL return arr NL }","func_name":"bubbleSort","docstring":"/*\n     * 冒泡排序，时间复杂度O(n^2)\n     */"}
{"repo":"data_struct","file":"sort.cj","path":"data_struct/src/algorithm/sort.cj","code_tokens":"static public func selectionSort ( arr : ArrayList < T > ) {   let length = arr . size NL for ( i in length - 1 .. 0 : - 1 ) {  for ( j in 0 .. i ) {  if ( arr [ j ] > arr [ i ] ) {   let tmp = arr [ j ] NL arr [ j ] = arr [ i ] NL arr [ i ] = tmp NL } NL } NL } NL return arr NL }","func_name":"selectionSort","docstring":"/*\n     * 选择排序，时间复杂度O(n^2)\n     */"}
{"repo":"data_struct","file":"sort.cj","path":"data_struct/src/algorithm/sort.cj","code_tokens":"static public func insertSort ( arr : ArrayList < T > ) {   let length = arr . size NL for ( i in 1 .. length ) {  for ( j in i .. 0 : - 1 ) {  if ( arr [ j ] < arr [ j - 1 ] ) {   let tmp = arr [ j ] NL arr [ j ] = arr [ j - 1 ] NL arr [ j - 1 ] = tmp NL } NL } NL } NL }","func_name":"insertSort","docstring":"/*\n     * 插入排序，时间复杂度O(n^2)\n     */"}
{"repo":"data_struct","file":"sort.cj","path":"data_struct/src/algorithm/sort.cj","code_tokens":"static public func quickSort ( arr : ArrayList < T > , start : Int64 , end : Int64 ) : ArrayList < T > {  if ( start > = end ) {  return arr NL } NL  var low = start NL  var high = end NL  let mid = arr [ low ] NL while ( low < high ) {  while ( low < high && mid < arr [ high ] ) {  high -= 1 NL } NL arr [ low ] = arr [ high ] NL while ( low < high && mid > arr [ low ] ) {  low += 1 NL } NL arr [ high ] = arr [ low ] NL } NL arr [ low ] = mid NL quickSort ( arr , start , low - 1 ) NL quickSort ( arr , low + 1 , end ) NL }","func_name":"quickSort","docstring":"/*\n     * 快速排序，时间复杂度O(nlog(n))\n     */"}
{"repo":"data_struct","file":"sort.cj","path":"data_struct/src/algorithm/sort.cj","code_tokens":"static public func mergeSort ( arr : ArrayList < T > ) : ArrayList < T > {   let length = arr . size NL if ( length <= 1 ) {  return arr NL } NL  let num = length / 2 NL  let left = mergeSort ( arr [ .. num ] ) NL  let right = mergeSort ( arr [ num .. ] ) NL return merge ( left , right ) NL }","func_name":"mergeSort","docstring":"/*\n     * 归并排序，时间复杂度O(nlog(n))\n     */"}
{"repo":"data_struct","file":"sort.cj","path":"data_struct/src/algorithm/sort.cj","code_tokens":"static func merge ( left : ArrayList < T > , right : ArrayList < T > ) : ArrayList < T > {   var l = 0 NL  var r = 0 NL  let result = ArrayList < T > ( ) NL while ( l < left . size && r < right . size ) {  if ( left [ l ] < right [ r ] ) {  result . append ( left [ l ] ) NL l += 1 NL } else {  result . append ( right [ r ] ) NL r += 1 NL } NL } NL result . appendAll ( left [ l .. ] ) NL result . appendAll ( right [ r .. ] ) NL return result NL }","func_name":"merge","docstring":""}
{"repo":"data_struct","file":"sort.cj","path":"data_struct/src/algorithm/sort.cj","code_tokens":"static public func shellSort ( arr : ArrayList < T > ) {   let length = arr . size NL  var gap = length / 2 NL while ( gap > 0 ) {  for ( i in gap .. length ) {   var j = i NL while ( j > = gap && arr [ j - gap ] > arr [ j ] ) {   let tmp = arr [ j ] NL arr [ j - gap ] = arr [ j ] NL arr [ j ] = tmp NL j -= gap NL } NL } NL gap /= 2 NL } NL return arr NL }","func_name":"shellSort","docstring":"/*\n     * 希尔排序，时间复杂度O(nlogn)~O(n^2)\n     */"}
