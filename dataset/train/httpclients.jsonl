{"repo":"httpclients","file":"gzip_utils.cj","path":"httpclients/src/httpclient/gzip_utils.cj","code_tokens":"public func gZipString ( strvalue : Array < UInt8 > ) : String {   let data : ArrayList < UInt8 > = Zlib . compress ( strvalue , wrap : ZLIB ) NL  let arr : Array < UInt8 > = Array < UInt8 > ( data . size , { i => data [ i ] NL } ) NL  let compressed = unsafe {  String . fromUtf8Unchecked ( arr ) NL } NL return compressed NL }","func_name":"gZipString","docstring":"/**\n     * The Function is gZipString\n     *\n     * @param strvalue of Array<UInt8>\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"gzip_utils.cj","path":"httpclients/src/httpclient/gzip_utils.cj","code_tokens":"public func ungZipString ( strvalue : Array < UInt8 > ) : String {   let data : ArrayList < UInt8 > = Zlib . uncompress ( strvalue , wrap : ZLIB ) NL  let arr : Array < UInt8 > = Array < UInt8 > ( data . size , { i => data [ i ] NL } ) NL  let compressed = unsafe {  String . fromUtf8Unchecked ( arr ) NL } NL return compressed NL }","func_name":"ungZipString","docstring":"/**\n     * The Function is ungZipString\n     *\n     * @param strvalue of Array<UInt8>\n     *\n     * @return Type of String\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"gzip_utils.cj","path":"httpclients/src/httpclient/gzip_utils.cj","code_tokens":"public func gZipFile ( srcFile : String , targetFile : String ) {   var files = FileUtils ( ) NL files . isFilePathValid ( srcFile ) NL files . isFilePathValid ( targetFile ) NL  var fs : File = File ( srcFile , Open ( true , false ) ) NL  var data : Array < UInt8 > = Array < UInt8 > ( ) NL if ( fs . canRead ( ) ) {  data = fs . readToEnd ( ) NL fs . flush ( ) NL fs . close ( ) NL } else {  throw ReadException ( Can not read source file ) NL } NL  let buf : ArrayList < UInt8 > = Zlib . compress ( data , wrap : ZLIB ) NL  let arr : Array < UInt8 > = Array < UInt8 > ( buf . size , { i => buf [ i ] NL } ) NL  let fstarget : File = File ( targetFile , Open ( false , true ) ) NL if ( fstarget . canWrite ( ) ) {   let writer = fstarget . write ( arr ) NL fstarget . flush ( ) NL fstarget . close ( ) NL } else {  throw WriteException ( Can not write gzip file ) NL } NL logger . info ( gZipFile done ) NL }","func_name":"gZipFile","docstring":"/**\n     * The Function is gZipFile\n     *\n     * @param srcFile of String\n     * @param targetFile of String\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"gzip_utils.cj","path":"httpclients/src/httpclient/gzip_utils.cj","code_tokens":"public func ungZipFile ( srcFile : String , targteFile : String ) {   var files = FileUtils ( ) NL files . isFilePathValid ( srcFile ) NL files . isFilePathValid ( targteFile ) NL  var filedata : Array < UInt8 > = Array < UInt8 > ( ) NL  let src : File = File ( srcFile , Open ( true , false ) ) NL if ( src . canRead ( ) ) {  filedata = src . readToEnd ( ) NL src . flush ( ) NL src . close ( ) NL } else {  throw ReadException ( Can not read gzip file ) NL } NL  let result : ArrayList < UInt8 > = Zlib . uncompress ( filedata , wrap : ZLIB ) NL  let buf : Array < UInt8 > = Array < UInt8 > ( result . size , { i => result [ i ] NL } ) NL  let target : File = File ( targteFile , Open ( false , true ) ) NL if ( target . canWrite ( ) ) {   let writer = target . write ( buf ) NL target . flush ( ) NL target . close ( ) NL } else {  throw WriteException ( Can not write file ) NL } NL logger . info ( ungZipFile done ) NL }","func_name":"ungZipFile","docstring":"/**\n     * The Function is ungZipFile\n     *\n     * @param srcFile of String\n     * @param targetFile of String\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"gzip_utils.cj","path":"httpclients/src/httpclient/gzip_utils.cj","code_tokens":"public func stringToUint8Array ( str : String ) : Array < UInt8 > {   var arr : StringBuilder = StringBuilder ( ) NL for ( c in str ) {  arr . append ( c . toLowerCase ( ) ) NL } NL  let tmpUint8Array = arr . toString ( ) . toUtf8Array ( ) NL return tmpUint8Array NL }","func_name":"stringToUint8Array","docstring":"/**\n     * The Function is stringToUint8Array\n     *\n     * @param str of String\n     *\n     * @return Type of Array<UInt8>\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"gzip_utils.cj","path":"httpclients/src/httpclient/gzip_utils.cj","code_tokens":"public func uint8ArrayToBuffer ( array : Array < UInt8 > ) : Utf8View {   let data = unsafe {  String . fromUtf8Unchecked ( array ) NL } NL  let buffer = String ( data . toCharArray ( ) ) . utf8View NL return buffer NL }","func_name":"uint8ArrayToBuffer","docstring":"/**\n     * The Function is uint8ArrayToBuffer\n     *\n     * @param array of Array<UInt8>\n     *\n     * @return Type of Utf8View\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"interceptor.cj","path":"httpclients/src/httpclient/interceptor.cj","code_tokens":"public func use ( str : ( ) -> Unit ) : ( ) -> Unit {  this . interceptorList . append ( str ) NL return str NL }","func_name":"use","docstring":"/**\n     * The Function is use\n     *\n     * @param str of ()->Unit\n     *\n     * @return Type of ()->Unit\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"interceptor.cj","path":"httpclients/src/httpclient/interceptor.cj","code_tokens":"public func eject ( str : ( ) -> Unit ) {  if ( interceptorList . isEmpty ( ) ) {  throw Exception ( The function object to intercept does not exist ) NL } NL this . interceptorList . clear ( ) NL }","func_name":"eject","docstring":"/**\n     * The Function is eject\n     *\n     * @param str of ()->Unit\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"interceptor.cj","path":"httpclients/src/httpclient/interceptor.cj","code_tokens":"public func getSize ( ) : Int64 {  return this . interceptorList . size NL }","func_name":"getSize","docstring":"/**\n     * The Function is getSize\n     *\n     * @return Type of Int64\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"file_download.cj","path":"httpclients/src/httpclient/file_download.cj","code_tokens":"public func builder ( pathname : String , fileData : String ) {   var filePathValid = FileUtils ( ) . isFilePathValid ( pathname ) NL  var fs : File = File ( pathname , Open ( false , true ) ) NL if ( fs . canWrite ( ) ) {   let toWrite : Array < UInt8 > = fileData . toUtf8Array ( ) NL  let writeFile = fs . write ( toWrite ) NL fs . flush ( ) NL fs . close ( ) NL } else {  throw WriteException ( Can not write file ) NL } NL }","func_name":"builder","docstring":"/**\n     * The Function is builder\n     *\n     * @param pathname of String\n     * @param fileData of String\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func setProxy ( urlPro : String ) : Unit {  this . urlPro = urlPro NL setableProxy = true NL }","func_name":"setProxy","docstring":"/**\n     * The Function is setProxy\n     *\n     * @param urlPro of String\n     *\n     * @return Type of Unit\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func send ( req : Request ) : Response {  client . send ( req ) NL }","func_name":"send","docstring":"/**\n     * The Function is send\n     *\n     * @param req of Request\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func get ( url : String ) : Response {  HttpClientConnection ( url ) NL if ( connectionExist ) {  throw Exception ( connection is already use ) NL } NL if ( setableProxy ) {  client . get ( urlPro ) NL } else {  client . get ( url ) NL } NL }","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @param url of String\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func head ( url : String ) : Response {  HttpClientConnection ( url ) NL if ( connectionExist ) {  throw Exception ( connection is already use ) NL } NL if ( setableProxy ) {  client . head ( urlPro ) NL } else {  client . head ( url ) NL } NL }","func_name":"head","docstring":"/**\n     * The Function is head\n     *\n     * @param url of String\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func post ( url : String , contentType : String , body : InputStream ) : Response {  HttpClientConnection ( url ) NL if ( connectionExist ) {  throw Exception ( connection is already use ) NL } NL if ( setableProxy ) {  client . post ( urlPro , contentType , body ) NL } else {  client . post ( url , contentType , body ) NL } NL }","func_name":"post","docstring":"/**\n     * The Function is post\n     *\n     * @param url of String\n     * @param contentType of String\n     * @param body of InputStream\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func postForm ( url : String , data : Form ) : Response {  HttpClientConnection ( url ) NL if ( connectionExist ) {  throw Exception ( connection is already use ) NL } NL if ( setableProxy ) {  client . postForm ( urlPro , data ) NL } else {  client . postForm ( url , data ) NL } NL }","func_name":"postForm","docstring":"/**\n     * The Function is postForm\n     *\n     * @param url of String\n     * @param data of Form\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func put ( url : String , contentType : String , body : InputStream ) : Response {  HttpClientConnection ( url ) NL if ( connectionExist ) {  throw Exception ( connection is already use ) NL } NL if ( setableProxy ) {  client . put ( urlPro , contentType , body ) NL } else {  client . put ( url , contentType , body ) NL } NL }","func_name":"put","docstring":"/**\n     * The Function is put\n     *\n     * @param url of String\n     * @param contentType of String\n     * @param body of InputStream\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func putForm ( url : String , data : Form ) : Response {  HttpClientConnection ( url ) NL if ( connectionExist ) {  throw Exception ( connection is already use ) NL } NL if ( setableProxy ) {  client . putForm ( urlPro , data ) NL } else {  client . putForm ( url , data ) NL } NL }","func_name":"putForm","docstring":"/**\n     * The Function is putForm\n     *\n     * @param url of String\n     * @param data of Form\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func delete ( url : String , contentType : String , body : InputStream ) : Response {  HttpClientConnection ( url ) NL if ( connectionExist ) {  throw Exception ( connection is already use ) NL } NL if ( setableProxy ) {  client . delete ( urlPro , contentType , body ) NL } else {  client . delete ( url , contentType , body ) NL } NL }","func_name":"delete","docstring":"/**\n     * The Function is delete\n     *\n     * @param url of String\n     * @param contentType of String\n     * @param body of InputStream\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func deleteForm ( url : String , data : Form ) : Response {  HttpClientConnection ( url ) NL if ( connectionExist ) {  throw Exception ( connection is already use ) NL } NL if ( setableProxy ) {  client . deleteForm ( urlPro , data ) NL } else {  client . deleteForm ( url , data ) NL } NL }","func_name":"deleteForm","docstring":"/**\n     * The Function is deleteForm\n     *\n     * @param url of String\n     * @param data of Form\n     *\n     * @return Type of Response\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"private func HttpClientConnection ( connectionUrl : String ) : Unit {  mutex . lock ( ) NL  var timer = Timer ( connectionTimeout , { => closeConnection ( connectionUrl ) NL } ) NL while ( true ) {  if ( ClientConnection . contains ( connectionUrl ) ) {   let con = ClientConnection . get ( connectionUrl ) NL  var conv : String =  NL match ( con ) { case Some ( v ) => conv = v NL case None => ( ) NL } NL if ( conv . equals ( true ) ) {  connectionExist = true NL return NL } NL } else {  if ( ClientConnection . size < connectionsMax ) {  ClientConnection . put ( connectionUrl , true ) NL return NL } NL } NL } NL mutex . unlock ( ) NL }","func_name":"HttpClientConnection","docstring":"/**\n     * The Function is HttpClientConnection\n     *\n     * @param connectionUrl of String\n     *\n     * @return Type of Unit\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"httpclient.cj","path":"httpclients/src/httpclient/httpclient.cj","code_tokens":"public func closeConnection ( connectionUrl : String ) : Unit {  if ( ClientConnection . contains ( connectionUrl ) ) {  ClientConnection . remove ( connectionUrl ) NL } else {  throw Exception ( connection not exist ) NL } NL }","func_name":"closeConnection","docstring":"/**\n     * The Function is closeConnection\n     *\n     * @param connectionUrl of String\n     *\n     * @return Type of Unit\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"file_upload.cj","path":"httpclients/src/httpclient/file_upload.cj","code_tokens":"public func getFile ( ) : ArrayList < FileObject > {  if ( ! this . files . isEmpty ( ) ) {  return this . files NL } NL return ArrayList < FileObject > ( ) NL }","func_name":"getFile","docstring":"/**\n     * The Function is getFile\n     *\n     * @return Type of ArrayList<FileObject>\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"file_upload.cj","path":"httpclients/src/httpclient/file_upload.cj","code_tokens":"public func getData ( ) : ArrayList < DataObject > {  if ( ! this . data . isEmpty ( ) ) {  return this . data NL } NL return ArrayList < DataObject > ( ) NL }","func_name":"getData","docstring":"/**\n     * The Function is getData\n     *\n     * @return Type of ArrayList<DataObject>\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"file_upload.cj","path":"httpclients/src/httpclient/file_upload.cj","code_tokens":"static public func builder ( pathname : String ) : Builder {  return Builder ( pathname ) NL }","func_name":"builder","docstring":"/**\n     * The Function is builder\n     *\n     * @param pathname of String\n     *\n     * @return Type of Builder\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"file_upload.cj","path":"httpclients/src/httpclient/file_upload.cj","code_tokens":"public func addFile ( pathname : String ) : Builder {   let con : Option < Int64 > = pathname . lastIndexOf ( / ) NL  var lastSlash : Int64 = - 1 NL match ( con ) { case Some ( v ) => lastSlash = v NL case None => ( ) NL } NL  let fileName : String = pathname . substring ( lastSlash + 1 ) NL  let conType : Option < Int64 > = fileName . lastIndexOf ( . ) NL  var indexType : Int64 = - 1 NL match ( conType ) { case Some ( v ) => indexType = v NL case None => ( ) NL } NL  let fileType = fileName . substring ( indexType + 1 ) NL  let fname = fileName . substring ( 0 , indexType ) NL  let fileObject = FileObject ( fileName , fname , pathname , fileType ) NL files . append ( fileObject ) NL return this NL }","func_name":"addFile","docstring":"/**\n     * The Function is addFile\n     *\n     * @param pathname of String\n     *\n     * @return Type of Builder\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"file_upload.cj","path":"httpclients/src/httpclient/file_upload.cj","code_tokens":"public func addData ( fname : String , fvalue : String ) : Builder {   let dataObject = DataObject ( fname , fvalue ) NL data . append ( dataObject ) NL return this NL }","func_name":"addData","docstring":"/**\n     * The Function is addData\n     *\n     * @param fname of String\n     * @param fvalue of String\n     *\n     * @return Type of Builder\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"file_upload.cj","path":"httpclients/src/httpclient/file_upload.cj","code_tokens":"public func build ( ) : FileUpload {   var filePathValid = FileUtils ( ) . isFilePathValid ( pathname ) NL  var fileUpload = FileUpload ( this ) NL  let fs : File = File ( pathname , Open ( true , false ) ) NL if ( fs . canRead ( ) ) {   let readFile = fs . readToEnd ( ) NL fileUpload . strll . append ( String . fromUtf8 ( readFile ) ) NL fs . flush ( ) NL fs . close ( ) NL } else {  throw ReadException ( Can not read file ) NL } NL return fileUpload NL }","func_name":"build","docstring":"/**\n     * The Function is build\n     *\n     * @return Type of FileUpload\n     * @since 0.29.3\n     */"}
{"repo":"httpclients","file":"file_utils.cj","path":"httpclients/src/httpclient/file_utils.cj","code_tokens":"public func isFilePathValid ( filePath : String ) : Bool {   let con : Option < Int64 > = filePath . lastIndexOf ( / ) NL  var lastSlash : Int64 = 0 NL match ( con ) { case Some ( v ) => lastSlash = v NL case None => ( ) NL } NL  let directoryName : String = filePath . substring ( 0 , lastSlash ) NL  let fileName : String = filePath . substring ( lastSlash + 1 ) NL logger . info ( isFilePathValid lastSlash INDEX :  + ${lastSlash} +  directoryName :  + ${directoryName} +  fileName :  + ${fileName} ) NL if ( ! fileName . contains ( . ) ) {  logger . info ( isFilePathValid filename does not include . ) NL throw Exception ( Invalid filepath. Need to include filename ) NL } NL  let isFile : Bool = isReg ( fileName ) NL  let isDir : Bool = isDir ( directoryName ) NL if ( ! isFile ) {  logger . info ( isFilePathValid isFile is   + ${isFile} ) NL throw Exception ( ${fileName} +  not normal file ) NL } NL if ( ! isDir ) {  logger . info ( isFilePathValid isDir is   + ${isDir} ) NL throw Exception ( isFilePathValid invalid directory ) NL } NL logger . info ( isFilePathValid filePath is valid ) NL logger . flush ( ) NL return true NL }","func_name":"isFilePathValid","docstring":"/**\n      * The Function is isFilePathValid\n      *\n      * @param filePath of String\n      *\n      * @return Type of Bool\n      * @since 0.29.3\n      */"}
