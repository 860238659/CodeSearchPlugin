{"repo":"log4cj2","file":"logger_config.cj","path":"log4cj2/src/config/logger_config.cj","code_tokens":"public func getName ( ) : String {  return this . name NL }","func_name":"getName","docstring":""}
{"repo":"log4cj2","file":"logger_config.cj","path":"log4cj2/src/config/logger_config.cj","code_tokens":"public func setName ( name : String ) : Unit {  this . name = name NL }","func_name":"setName","docstring":""}
{"repo":"log4cj2","file":"logger_config.cj","path":"log4cj2/src/config/logger_config.cj","code_tokens":"public func getLevel ( ) : String {  return this . level NL }","func_name":"getLevel","docstring":""}
{"repo":"log4cj2","file":"logger_config.cj","path":"log4cj2/src/config/logger_config.cj","code_tokens":"public func setLevel ( level : String ) : Unit {  this . level = level NL }","func_name":"setLevel","docstring":""}
{"repo":"log4cj2","file":"logger_config.cj","path":"log4cj2/src/config/logger_config.cj","code_tokens":"public func getAppenderRefList ( ) : ArrayList < AppenderRef > {  return this . appenderRefList NL }","func_name":"getAppenderRefList","docstring":""}
{"repo":"log4cj2","file":"logger_config.cj","path":"log4cj2/src/config/logger_config.cj","code_tokens":"public func setAppenderRefList ( appenderRefList : ArrayList < AppenderRef > ) : Unit {  this . appenderRefList = appenderRefList NL }","func_name":"setAppenderRefList","docstring":""}
{"repo":"log4cj2","file":"logger_configuration.cj","path":"log4cj2/src/config/logger_configuration.cj","code_tokens":"public func getAppenders ( ) : ArrayList < AppenderConfig > {  return this . appenders NL }","func_name":"getAppenders","docstring":""}
{"repo":"log4cj2","file":"logger_configuration.cj","path":"log4cj2/src/config/logger_configuration.cj","code_tokens":"public func getRoot ( ) : RootLoggerConfig {  return this . root NL }","func_name":"getRoot","docstring":""}
{"repo":"log4cj2","file":"logger_configuration.cj","path":"log4cj2/src/config/logger_configuration.cj","code_tokens":"public func getLogger ( ) : ArrayList < LoggerConfig > {  return this . logger NL }","func_name":"getLogger","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func getEnabled ( ) : String {  return this . enabled NL }","func_name":"getEnabled","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func setEnabled ( enabled : String ) : Unit {  this . enabled = enabled NL }","func_name":"setEnabled","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func getName ( ) : String {  return this . name NL }","func_name":"getName","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func setName ( name : String ) : Unit {  this . name = name NL }","func_name":"setName","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func getAppenderType ( ) : String {  return this . appenderType NL }","func_name":"getAppenderType","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func setAppenderType ( appenderType : String ) : Unit {  this . appenderType = appenderType NL }","func_name":"setAppenderType","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func getPattern ( ) : String {  return this . pattern NL }","func_name":"getPattern","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func setPattern ( pattern : String ) : Unit {  this . pattern = pattern NL }","func_name":"setPattern","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func getProperties ( ) : ArrayList < AppenderProperty > {  return this . properties NL }","func_name":"getProperties","docstring":""}
{"repo":"log4cj2","file":"appender_config.cj","path":"log4cj2/src/config/appender_config.cj","code_tokens":"public func setProperties ( properties : ArrayList < AppenderProperty > ) : Unit {  this . properties = properties NL }","func_name":"setProperties","docstring":""}
{"repo":"log4cj2","file":"appender_ref.cj","path":"log4cj2/src/config/appender_ref.cj","code_tokens":"public func getRef ( ) : String {  return this . ref NL }","func_name":"getRef","docstring":"/**\n     * No-parameter constructor.\n     */"}
{"repo":"log4cj2","file":"root_logger_config.cj","path":"log4cj2/src/config/root_logger_config.cj","code_tokens":"public func getLevel ( ) : String {  return this . level NL }","func_name":"getLevel","docstring":""}
{"repo":"log4cj2","file":"root_logger_config.cj","path":"log4cj2/src/config/root_logger_config.cj","code_tokens":"public func setLevel ( level : String ) : Unit {  this . level = level NL }","func_name":"setLevel","docstring":""}
{"repo":"log4cj2","file":"root_logger_config.cj","path":"log4cj2/src/config/root_logger_config.cj","code_tokens":"public func getAppenderRefList ( ) : ArrayList < AppenderRef > {  return this . appenderRefList NL }","func_name":"getAppenderRefList","docstring":""}
{"repo":"log4cj2","file":"root_logger_config.cj","path":"log4cj2/src/config/root_logger_config.cj","code_tokens":"public func setAppenderRefList ( appenderRefList : ArrayList < AppenderRef > ) : Unit {  this . appenderRefList = appenderRefList NL }","func_name":"setAppenderRefList","docstring":""}
{"repo":"log4cj2","file":"appender_property.cj","path":"log4cj2/src/config/appender_property.cj","code_tokens":"public func getName ( ) : String {  return this . name NL }","func_name":"getName","docstring":""}
{"repo":"log4cj2","file":"appender_property.cj","path":"log4cj2/src/config/appender_property.cj","code_tokens":"public func setName ( name : String ) : Unit {  this . name = name NL }","func_name":"setName","docstring":""}
{"repo":"log4cj2","file":"appender_property.cj","path":"log4cj2/src/config/appender_property.cj","code_tokens":"public func getValue ( ) : String {  return this . value NL }","func_name":"getValue","docstring":""}
{"repo":"log4cj2","file":"appender_property.cj","path":"log4cj2/src/config/appender_property.cj","code_tokens":"public func setValue ( value : String ) : Unit {  this . value = value NL }","func_name":"setValue","docstring":""}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"public func getName ( ) : String {  return this . name NL }","func_name":"getName","docstring":""}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"private func log ( level : LogLevel , msg : String ) : Unit {   let src =  NL  var rec = LogRecord ( this . name , level , Time . now ( ) , src , msg ) NL doLog ( level , rec ) NL }","func_name":"log","docstring":"/**\n     * Entry for writing logs.\n     *\n     * @param level log level.\n     * @param msg log information.\n     */"}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"private func doLog ( level : LogLevel , rec : LogRecord ) : Unit {  appendLog ( level , rec , Logger_Manager . getRootLogger ( ) ) NL if ( Logger_Manager . getLoggerNameArr ( ) . size > 0 && Logger_Manager . getLoggerAttrArr ( ) . size > 0 ) {   var i : Int64 = 0 NL while ( i < Logger_Manager . getLoggerNameArr ( ) . size ) {   var mapString : String = Logger_Manager . getLoggerNameArr ( ) . toArray ( ) . toString ( ) NL if ( mapString . contains ( this . name ) ) {   var j : Int64 = 0 NL  var values : Array < LoggerAppenderReference > = Logger_Manager . getLoggerAttrArr ( ) . toArray ( ) NL while ( j < values . size ) {  appendLog ( level , rec , values . get ( j ) . getOrThrow ( ) ) NL j ++ NL } NL } NL i ++ NL } NL } NL }","func_name":"doLog","docstring":"/**\n     * Writing Logs.\n     *\n     * @param level log level.\n     * @param rec log record.\n     */"}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"private func appendLog ( level : LogLevel , rec : LogRecord , appenderRef : LoggerAppenderReference ) : Unit {  if ( appenderRef . getAppenderList ( ) . size == 0 ) {  return NL } NL if ( level > = appenderRef . getLevel ( ) ) {   var i : Int64 = 0 NL while ( i < appenderRef . getAppenderList ( ) . size ) {   var appender : LoggerAppender = appenderRef . getAppenderList ( ) . get ( i ) . getOrThrow ( ) NL appender . logWrite ( rec ) NL i ++ NL } NL } NL }","func_name":"appendLog","docstring":"/**\n     * Append log.\n     *\n     * @param level log level.\n     * @param rec log record.\n     * @param appenderRef log appender-ref.\n     */"}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"public func off ( msg : String ) : Unit {  log ( OFF , msg ) NL }","func_name":"off","docstring":"/**\n     * Print critical log.\n     *\n     * @param msg log information.\n     */"}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"public func error ( msg : String ) : Unit {  log ( ERROR , msg ) NL }","func_name":"error","docstring":"/**\n     * Print error log.\n     *\n     * @param msg log information.\n     */"}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"public func warn ( msg : String ) : Unit {  log ( WARN , msg ) NL }","func_name":"warn","docstring":"/**\n     * Print warn log.\n     *\n     * @param msg log information.\n     */"}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"public func info ( msg : String ) : Unit {  log ( INFO , msg ) NL }","func_name":"info","docstring":"/**\n     * Print info log.\n     *\n     * @param msg log inoformation.\n     */"}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"public func debug ( msg : String ) : Unit {  log ( DEBUG , msg ) NL }","func_name":"debug","docstring":"/**\n     * Print debug log.\n     *\n     * @param msg log inoformation.\n     */"}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"public func trace ( msg : String ) : Unit {  log ( TRACE , msg ) NL }","func_name":"trace","docstring":"/**\n     * Print trace log.\n     *\n     * @param msg log information.\n     */"}
{"repo":"log4cj2","file":"logger.cj","path":"log4cj2/src/logger/logger.cj","code_tokens":"public func all ( msg : String ) : Unit {  log ( ALL , msg ) NL }","func_name":"all","docstring":"/**\n     * Print fine log.\n     *\n     * @param msg log information.\n     */"}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"public func getLoggerAppenderFactory ( ) : LoggerAppenderFactory {  return this . loggerAppenderFactory NL }","func_name":"getLoggerAppenderFactory","docstring":""}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"public func getRootLogger ( ) : LoggerAppenderReference {  return this . rootLogger NL }","func_name":"getRootLogger","docstring":""}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"public func getLoggerNameArr ( ) : ArrayList < String > {  return this . loggerNameArr NL }","func_name":"getLoggerNameArr","docstring":""}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"public func getLoggerAttrArr ( ) : ArrayList < LoggerAppenderReference > {  return this . loggerAttrArr NL }","func_name":"getLoggerAttrArr","docstring":""}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"public func getLogger ( name : String ) : Logger {   var logger = Logger ( name ) NL return logger NL }","func_name":"getLogger","docstring":"/**\n     * Get the specific logger based on the logger name.\n     *\n     * @param name logger name.\n     * @return logger object.\n     */"}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"private func initWithDefaultConfig ( xmlPath : String ) : Unit {   var loggerConfiguration : LoggerConfiguration = loadXML ( xmlPath ) NL if ( loggerConfiguration . getAppenders ( ) . size == 0 ) {  println ( can not find any appender! ) NL return NL } NL initWithConfig ( loggerConfiguration ) NL }","func_name":"initWithDefaultConfig","docstring":"/**\n     * Initialize default configurations of log file.\n     *\n     * @param xmlPath log file path.\n     */"}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"private func initWithConfig ( configuration : LoggerConfiguration ) : Unit {  this . loggerAppenderFactory = Logger_Appender_Factory . new ( ) NL this . loggerNameArr = ArrayList < String > ( ) NL this . loggerAttrArr = ArrayList < LoggerAppenderReference > ( ) NL this . rootLogger = LoggerAppenderReference ( DEFAULT_LOG_LEVEL , ArrayList < LoggerAppender > ( ) ) NL  var nameArr : ArrayList < String > = ArrayList < String > ( ) NL  var enabledArr : ArrayList < String > = ArrayList < String > ( ) NL if ( configuration . getAppenders ( ) . size > 0 ) {   var i : Int64 = 0 NL  var appenders : ArrayList < AppenderConfig > = configuration . getAppenders ( ) NL while ( i < appenders . size ) {  nameArr . append ( appenders . get ( i ) . getOrThrow ( ) . getName ( ) . toAsciiLower ( ) ) NL enabledArr . append ( appenders . get ( i ) . getOrThrow ( ) . getEnabled ( ) . toAsciiLower ( ) . trimAscii ( ) ) NL if ( ! nameArr . get ( i ) . getOrThrow ( ) . isEmpty ( ) && enabledArr . get ( i ) . getOrThrow ( ) . equals ( true ) ) {  this . loggerAppenderFactory . registerLoggerAppender ( appenders . get ( i ) . getOrThrow ( ) . getName ( ) , appenders . get ( i ) . getOrThrow ( ) . getAppenderType ( ) , appenders . get ( i ) . getOrThrow ( ) . getPattern ( ) , appenders . get ( i ) . getOrThrow ( ) . getProperties ( ) ) NL } NL i ++ NL } NL } NL  let rootConfig = configuration . getRoot ( ) NL this . rootLogger . setLevel ( LogLevel . getLevelByString ( rootConfig . getLevel ( ) ) ) NL if ( rootConfig . getAppenderRefList ( ) . size > 0 ) {   var j : Int64 = 0 NL  var appenderRefList : ArrayList < AppenderRef > = rootConfig . getAppenderRefList ( ) NL while ( j < appenderRefList . size ) {   var appenderRef = appenderRefList . get ( j ) . getOrThrow ( ) NL  var index : Int64 = 0 NL while ( index < nameArr . size ) {  if ( nameArr . get ( index ) . getOrThrow ( ) . equals ( appenderRef . getRef ( ) . toAsciiLower ( ) ) && enabledArr . get ( index ) . getOrThrow ( ) . equals ( true ) ) {   let ap = this . loggerAppenderFactory . getAppenderByName ( appenderRef . getRef ( ) . toAsciiLower ( ) ) NL this . rootLogger . getAppenderList ( ) . append ( ap ) NL } NL index ++ NL } NL j ++ NL } NL } NL if ( configuration . getLogger ( ) . size > 0 ) {   var k : Int64 = 0 NL  var loggers : ArrayList < LoggerConfig > = configuration . getLogger ( ) NL while ( k < loggers . size ) {   var logger : LoggerConfig = loggers . get ( k ) . getOrThrow ( ) NL  let oneLogger = LoggerAppenderReference ( LogLevel . getLevelByString ( logger . getLevel ( ) ) , ArrayList < LoggerAppender > ( ) ) NL  var m : Int64 = 0 NL while ( m < logger . getAppenderRefList ( ) . size ) {   var appenderRef : AppenderRef = logger . getAppenderRefList ( ) . get ( m ) . getOrThrow ( ) NL  var index : Int64 = 0 NL while ( index < nameArr . size ) {  if ( nameArr . get ( index ) . getOrThrow ( ) . equals ( appenderRef . getRef ( ) . toAsciiLower ( ) ) && enabledArr . get ( index ) . getOrThrow ( ) . equals ( true ) ) {   let oneAppender = this . loggerAppenderFactory . getAppenderByName ( appenderRef . getRef ( ) . toAsciiLower ( ) ) NL oneLogger . getAppenderList ( ) . append ( oneAppender ) NL } NL index ++ NL } NL m ++ NL } NL if ( oneLogger . getAppenderList ( ) . size > 0 ) {  this . loggerNameArr . append ( logger . getName ( ) ) NL this . loggerAttrArr . append ( oneLogger ) NL } NL k ++ NL } NL } NL }","func_name":"initWithConfig","docstring":"/**\n     * Initialize the log configurtion obtained by loading the xml file.\n     *\n     * @param configuration log configuration obtained by loading the xml file.\n     */"}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"private func initLoggerManager ( xmlPath : String ) : Unit {  Logger_Appender_Factory . registryType ( file , FileLoggerAppender ( ) ) NL initWithDefaultConfig ( xmlPath ) NL }","func_name":"initLoggerManager","docstring":""}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"private func loadXML ( xmlPath : String ) : LoggerConfiguration {   var filePath : Path = Path ( xmlPath ) NL  var isFileExist : Bool = File . exists ( filePath ) NL if ( xmlPath . size == 0 || ! isFileExist ) {  return loadDefaultConfiguration ( ) NL } NL  var allElements : ArrayList < XmlElement > = getXmlBasicProperties ( xmlPath ) NL if ( allElements . size == 0 ) {  println ( can not find any element in xml file! ) NL return LoggerConfiguration ( ) NL } NL  var appenderList : ArrayList < AppenderConfig > = getAppenderConfiguration ( allElements ) NL if ( appenderList . size == 0 ) {  println ( can not find any appender in xml file! ) NL return LoggerConfiguration ( ) NL } NL  var loggerList : ArrayList < LoggerConfig > = getLoggerConfiguration ( allElements ) NL if ( loggerList . size == 0 ) {  println ( can not find any logger in xml file! ) NL } NL  var root : RootLoggerConfig = getRootConfiguration ( allElements ) NL if ( root . getLevel ( ) . size == 0 || root . getAppenderRefList ( ) . size == 0 ) {  println ( root configuration has mistakes! ) NL return LoggerConfiguration ( ) NL } NL return LoggerConfiguration ( appenderList , root , loggerList ) NL }","func_name":"loadXML","docstring":"/**\n     * This function is used to parse the XML file into the LoggerConfiguration object.\n     *\n     * @param xmlPath log file path.\n     * @return logger configuration object.\n     */"}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"public func loadDefaultConfiguration ( ) : LoggerConfiguration {   let content = \"\"\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<configuration>\\n  <appender enabled=\\\"true\\\" name=\\\"console\\\">\\n    <type>console</type>\\n    <pattern>[%D %T %m] [%L] [%l] (%S) %M</pattern>\\n  </appender>\\n  <appender enabled=\\\"true\\\" name=\\\"file\\\">\\n    <type>file</type>\\n    <pattern>[%D %T %m] [%L] [%l] (%S) %M</pattern>\\n    <property name=\\\"filename\\\">root.log</property>\\n    <property name=\\\"rotate\\\">true</property>\\n    <property name=\\\"maxsize\\\">20M</property>\\n    <property name=\\\"daily\\\">false</property>\\n  </appender>\\n  <root>\\n    <level>info</level>\\n    <appender-ref ref=\\\"console\\\"/>\\n    <appender-ref ref=\\\"file\\\"/>\\n  </root>\\n</configuration>\\n        \"\"\" NL  var x : XmlParser = XmlParser ( ) NL  var elements : Option < XmlElement > = x . parse ( content ) NL  var xmlElements : XmlElement = elements . getOrThrow ( ) NL  var appenderList : ArrayList < AppenderConfig > = getAppenderConfiguration ( xmlElements . childrenElements ) NL  var loggerList : ArrayList < LoggerConfig > = getLoggerConfiguration ( xmlElements . childrenElements ) NL  var root : RootLoggerConfig = getRootConfiguration ( xmlElements . childrenElements ) NL return LoggerConfiguration ( appenderList , root , loggerList ) NL }","func_name":"loadDefaultConfiguration","docstring":"/**\n     * Parse the built-in log configuration.\n     *\n     * @return logger configuration object.\n     */"}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"private func getXmlBasicProperties ( xmlPath : String ) : ArrayList < XmlElement > {   var filePath : Path = Path ( xmlPath ) NL  var allBytes : Array < Byte > = File . readFrom ( filePath ) NL if ( allBytes . size == 0 ) {  println ( xml file is empty! ) NL return ArrayList < XmlElement > ( ) NL } NL  var content : String = String . fromUtf8 ( allBytes ) NL  var x : XmlParser = XmlParser ( ) NL  var elements : Option < XmlElement > = Option < XmlElement > . None NL try {  elements = x . parse ( content ) NL } catch ( e : XmlException ) {  println ( parse xml occur exception ${e.message}! ) NL return ArrayList < XmlElement > ( ) NL } NL try {  elements . getOrThrow ( ) NL } catch ( e : NoneValueException ) {  println ( get xml element occur exception ${e.message}! ) NL return ArrayList < XmlElement > ( ) NL } NL  var xmlElements : XmlElement = elements . getOrThrow ( ) NL  var childrenElements : ArrayList < XmlElement > = xmlElements . childrenElements NL if ( childrenElements . size == 0 ) {  println ( xml children element is empty! ) NL return ArrayList < XmlElement > ( ) NL } NL return childrenElements NL }","func_name":"getXmlBasicProperties","docstring":"/**\n     * Get configuration items by parsing xml file.\n     *\n     * @param xmlPath log file path.\n     * @return configuration element list.\n     */"}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"private func getAppenderConfiguration ( allElements : ArrayList < XmlElement > ) : ArrayList < AppenderConfig > {   var configList : ArrayList < AppenderConfig > = ArrayList < AppenderConfig > ( ) NL  var i : Int64 = 0 NL while ( i < allElements . size ) {   var element : XmlElement = allElements . get ( i ) . getOrThrow ( ) NL if ( element . name . toAsciiLower ( ) . equals ( appender ) ) {   let allChildrenElements : ArrayList < XmlElement > = element . childrenElements NL  let allAttrs : ArrayList < XmlAttr > = element . attributes NL  var appender : AppenderConfig = AppenderConfig ( ) NL  var propertyList : ArrayList < AppenderProperty > = ArrayList < AppenderProperty > ( ) NL  var j : Int64 = 0 NL while ( j < allAttrs . size ) {   var attr : XmlAttr = allAttrs . get ( j ) . getOrThrow ( ) NL if ( attr . name . toAsciiLower ( ) . equals ( enabled ) ) {  appender . setEnabled ( attr . content ) NL } NL if ( attr . name . toAsciiLower ( ) . equals ( name ) ) {  appender . setName ( attr . content ) NL } NL j ++ NL } NL  var k : Int64 = 0 NL while ( k < allChildrenElements . size ) {   var childrenElement : XmlElement = allChildrenElements . get ( k ) . getOrThrow ( ) NL if ( childrenElement . name . toAsciiLower ( ) . equals ( type ) ) {  appender . setAppenderType ( childrenElement . content ) NL } NL if ( childrenElement . name . toAsciiLower ( ) . equals ( pattern ) ) {  appender . setPattern ( childrenElement . content ) NL } else {   let allChildrenAttrs : ArrayList < XmlAttr > = childrenElement . attributes NL  var m : Int64 = 0 NL while ( allChildrenAttrs . size != 0 && m < allChildrenAttrs . size ) {   var childrenAttr : XmlAttr = allChildrenAttrs . get ( m ) . getOrThrow ( ) NL  var property : AppenderProperty = AppenderProperty ( childrenAttr . content , childrenElement . content ) NL propertyList . append ( property ) NL m ++ NL } NL appender . setProperties ( propertyList ) NL } NL k ++ NL } NL configList . append ( appender ) NL } NL i ++ NL } NL return configList NL }","func_name":"getAppenderConfiguration","docstring":"/**\n     * Get appender configuarations.\n     *\n     * @param allElements basic configuration elements by parsing xml file.\n     * @return appender configuration list.\n     */"}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"private func getLoggerConfiguration ( allElements : ArrayList < XmlElement > ) : ArrayList < LoggerConfig > {   var loggerList : ArrayList < LoggerConfig > = ArrayList < LoggerConfig > ( ) NL  var i : Int64 = 0 NL while ( i < allElements . size ) {   var element : XmlElement = allElements . get ( i ) . getOrThrow ( ) NL if ( element . name . toAsciiLower ( ) . equals ( logger ) ) {   let allChildrenElements : ArrayList < XmlElement > = element . childrenElements NL  let allAttrs : ArrayList < XmlAttr > = element . attributes NL  var logger : LoggerConfig = LoggerConfig ( ) NL  var refList : ArrayList < AppenderRef > = ArrayList < AppenderRef > ( ) NL  var j : Int64 = 0 NL while ( j < allAttrs . size ) {   var attr : XmlAttr = allAttrs . get ( j ) . getOrThrow ( ) NL if ( attr . name . toAsciiLower ( ) . equals ( name ) ) {  logger . setName ( attr . content ) NL } NL j ++ NL } NL  var k : Int64 = 0 NL while ( k < allChildrenElements . size ) {   var childrenElement : XmlElement = allChildrenElements . get ( k ) . getOrThrow ( ) NL if ( childrenElement . name . toAsciiLower ( ) . equals ( level ) ) {  logger . setLevel ( childrenElement . content ) NL } else {   let allChildrenAttrs : ArrayList < XmlAttr > = childrenElement . attributes NL  var m : Int64 = 0 NL while ( allChildrenAttrs . size != 0 && m < allChildrenAttrs . size ) {   var childrenAttr : XmlAttr = allChildrenAttrs . get ( m ) . getOrThrow ( ) NL if ( childrenAttr . name . toAsciiLower ( ) . equals ( ref ) ) {  refList . append ( AppenderRef ( childrenAttr . content ) ) NL } NL m ++ NL } NL logger . setAppenderRefList ( refList ) NL } NL k ++ NL } NL loggerList . append ( logger ) NL } NL i ++ NL } NL return loggerList NL }","func_name":"getLoggerConfiguration","docstring":"/**\n     * Get logger configuarations.\n     *\n     * @param allElements basic configuration elements by parsing xml file.\n     * @return logger configuration list.\n     */"}
{"repo":"log4cj2","file":"logger_manager.cj","path":"log4cj2/src/logger/logger_manager.cj","code_tokens":"private func getRootConfiguration ( allElements : ArrayList < XmlElement > ) : RootLoggerConfig {   var root : RootLoggerConfig = RootLoggerConfig ( ) NL  var refList : ArrayList < AppenderRef > = ArrayList < AppenderRef > ( ) NL  var i : Int64 = 0 NL while ( i < allElements . size ) {   var element : XmlElement = allElements . get ( i ) . getOrThrow ( ) NL if ( element . name . toAsciiLower ( ) . equals ( root ) ) {   let allChildrenElements : ArrayList < XmlElement > = element . childrenElements NL  var j : Int64 = 0 NL while ( j < allChildrenElements . size ) {   var childrenElement : XmlElement = allChildrenElements . get ( j ) . getOrThrow ( ) NL if ( childrenElement . name . toAsciiLower ( ) . equals ( level ) ) {  root . setLevel ( childrenElement . content ) NL } else {   let allChildrenAttrs : ArrayList < XmlAttr > = childrenElement . attributes NL  var k : Int64 = 0 NL while ( allChildrenAttrs . size != 0 && k < allChildrenAttrs . size ) {   var childrenAttr : XmlAttr = allChildrenAttrs . get ( k ) . getOrThrow ( ) NL  var appenderRef : AppenderRef = AppenderRef ( ) NL if ( childrenAttr . name . equals ( ref ) ) {  refList . append ( AppenderRef ( childrenAttr . content ) ) NL } NL k ++ NL } NL root . setAppenderRefList ( refList ) NL } NL j ++ NL } NL } NL i ++ NL } NL return root NL }","func_name":"getRootConfiguration","docstring":"/**\n     * Get root configuarations.\n     *\n     * @param allElements basic configuration elements by parsing xml file.\n     * @return root configuration list.\n     */"}
{"repo":"log4cj2","file":"util.cj","path":"log4cj2/src/utils/util.cj","code_tokens":"public func flushLeft ( str : String , limit : Int64 , placeholder : String ) : String {   var len = limit - str . size NL if ( len == limit ) {  return str NL } NL  var result : StringBuilder = StringBuilder ( ) NL for ( i in 0 .. len ) {  result . append ( placeholder ) NL } NL result . append ( str ) NL return result . toString ( ) NL }","func_name":"flushLeft","docstring":"/**\n * Align the character string to the right and supplement the specified character in the remaining bits.\n *\n * @param str character string to be converted.\n * @param limit limit num.\n * @param placeholder placeholder.\n * @return return the processed result.\n */"}
{"repo":"log4cj2","file":"util.cj","path":"log4cj2/src/utils/util.cj","code_tokens":"public func strToNumBySuffix ( str : String , mult : Int64 , defaultValue : Int64 ) : Int64 {   var num = 1 NL  let len = str . size NL  var numStr = str NL if ( str . endsWith ( g ) || str . endsWith ( G ) ) {  num = num * mult * mult * mult NL numStr = str [ 0 .. len - 1 ] NL } else if ( str . endsWith ( m ) || str . endsWith ( M ) ) {  num = num * mult * mult NL numStr = str [ 0 .. len - 1 ] NL } else if ( str . endsWith ( k ) || str . endsWith ( K ) ) {  num = num * mult NL numStr = str [ 0 .. len - 1 ] NL } NL try {   let parsed = Int64 . parse ( numStr ) NL return parsed * num NL } catch ( e : ConvertException ) {  return defaultValue NL } NL }","func_name":"strToNumBySuffix","docstring":"/**\n * Parse a number with K/M/G suffixes based on thousands (1000) or 2^10 (1024) Algorithm to be improved.\n *\n * @param str character string to be converted.\n * @param mult mult.\n * @param defaultValue default value.\n * @return Data after the algorithm improved.\n */"}
{"repo":"log4cj2","file":"util.cj","path":"log4cj2/src/utils/util.cj","code_tokens":"public func getNumByString ( str : String , defaultValue : Int64 ) : Int64 {  try {  return Int64 . parse ( str ) NL } catch ( e : ConvertException ) {  return defaultValue NL } NL }","func_name":"getNumByString","docstring":"/**\n * Converting numeric strings to int64.\n *\n * @param str character string to be converted.\n * @param defaultValue the default value is returned when the conversion is abnormal.\n * @return deta of the Int64 type is returned.\n */"}
{"repo":"log4cj2","file":"log_record.cj","path":"log4cj2/src/utils/log_record.cj","code_tokens":"public func getTagName ( ) : String {  return this . tagName NL }","func_name":"getTagName","docstring":""}
{"repo":"log4cj2","file":"log_record.cj","path":"log4cj2/src/utils/log_record.cj","code_tokens":"public func getLevel ( ) : LogLevel {  return this . level NL }","func_name":"getLevel","docstring":""}
{"repo":"log4cj2","file":"log_record.cj","path":"log4cj2/src/utils/log_record.cj","code_tokens":"public func getSource ( ) : String {  return this . source NL }","func_name":"getSource","docstring":""}
{"repo":"log4cj2","file":"log_record.cj","path":"log4cj2/src/utils/log_record.cj","code_tokens":"public func getMessage ( ) : String {  return this . message NL }","func_name":"getMessage","docstring":""}
{"repo":"log4cj2","file":"log_record.cj","path":"log4cj2/src/utils/log_record.cj","code_tokens":"public func getCreatedTime ( ) : Time {  return this . createdTime NL }","func_name":"getCreatedTime","docstring":""}
{"repo":"log4cj2","file":"time_slice.cj","path":"log4cj2/src/utils/time_slice.cj","code_tokens":"public func setCachedTimeSlice ( timeSlice : TimeSlice ) : Unit {  timeSliceCache . lock . lock ( ) NL timeSliceCache . lastUpdateSeconds = timeSlice . lastUpdateSeconds NL timeSliceCache . shortTime = timeSlice . shortTime NL timeSliceCache . shortDate = timeSlice . shortDate NL timeSliceCache . longTime = timeSlice . longTime NL timeSliceCache . longDate = timeSlice . longDate NL timeSliceCache . lock . unlock ( ) NL }","func_name":"setCachedTimeSlice","docstring":"/**\n * Sets the value of timeSliceCache.\n *\n * @param timeSlice time slice.\n */"}
{"repo":"log4cj2","file":"time_slice.cj","path":"log4cj2/src/utils/time_slice.cj","code_tokens":"public func getTimeSlice ( time : Time ) : Unit {   var secs = time . unixTimeStamp ( ) . nanoseconds ( ) / Int64 ( 1e9 ) NL  var cached = timeSliceCache NL if ( cached . lastUpdateSeconds != secs ) {   let year = time . year ( ) NL  let month = time . month ( ) . value ( ) NL  let day = time . day ( ) NL  let hour = time . hour ( ) NL  let minute = time . minute ( ) NL  let second = time . second ( ) NL  let zone = time . zone ( ) [ 0 ] NL this . lastUpdateSeconds = secs NL this . shortTime = hour . format ( 02 ) + : + minute . format ( 02 ) NL this . shortDate = day . format ( 02 ) + / + month . format ( 02 ) + / + ( year % 100 ) . format ( 02 ) NL this . longTime = hour . format ( 02 ) + : + minute . format ( 02 ) + : + second . format ( 02 ) +   + zone NL this . longDate = year . format ( 04 ) + / + month . format ( 02 ) + / + day . format ( 02 ) NL setCachedTimeSlice ( this ) NL } else {  this . lastUpdateSeconds = cached . lastUpdateSeconds NL this . shortTime = cached . shortTime NL this . shortDate = cached . shortDate NL this . longTime = cached . longTime NL this . longDate = cached . longDate NL } NL }","func_name":"getTimeSlice","docstring":"/**\n     * Get time slice.\n     *\n     * @param time time.\n     */"}
{"repo":"log4cj2","file":"time_slice.cj","path":"log4cj2/src/utils/time_slice.cj","code_tokens":"public func getShortTime ( ) : String {  return this . shortTime NL }","func_name":"getShortTime","docstring":""}
{"repo":"log4cj2","file":"time_slice.cj","path":"log4cj2/src/utils/time_slice.cj","code_tokens":"public func getLongTime ( ) : String {  return this . longTime NL }","func_name":"getLongTime","docstring":""}
{"repo":"log4cj2","file":"time_slice.cj","path":"log4cj2/src/utils/time_slice.cj","code_tokens":"public func getShortDate ( ) : String {  return this . shortDate NL }","func_name":"getShortDate","docstring":""}
{"repo":"log4cj2","file":"time_slice.cj","path":"log4cj2/src/utils/time_slice.cj","code_tokens":"public func getLongDate ( ) : String {  return this . longDate NL }","func_name":"getLongDate","docstring":""}
{"repo":"log4cj2","file":"pattern_converter.cj","path":"log4cj2/src/utils/pattern_converter.cj","code_tokens":"func formatLogRecord ( pattern : String , logRecord : LogRecord ) : String","func_name":"formatLogRecord","docstring":"/**\n     * Formatting log recording.\n     *\n     * @param pattern output pattern.\n     * @param logRecord log record.\n     * @return format result.\n     */"}
{"repo":"log4cj2","file":"pattern_converter.cj","path":"log4cj2/src/utils/pattern_converter.cj","code_tokens":"public func getDefaultPatternConvert ( ) : PatternConverter {  return defaultPatternConverter NL }","func_name":"getDefaultPatternConvert","docstring":""}
{"repo":"log4cj2","file":"pattern_converter.cj","path":"log4cj2/src/utils/pattern_converter.cj","code_tokens":"public func formatLogRecord ( pattern : String , logRecord : LogRecord ) : String {   var result = StringBuilder ( ) NL if ( pattern . size == 0 ) {  return String . empty NL } NL  let timeSlice = TimeSlice ( ) NL timeSlice . getTimeSlice ( logRecord . getCreatedTime ( ) ) NL  let pieces = pattern . split ( % ) NL  var i : Int64 = 0 NL while ( pieces . size != 0 && i < pieces . size ) {   var piece : String = pieces . get ( i ) . getOrThrow ( ) NL if ( piece != pieces [ 0 ] && piece . size > 0 ) {  match ( piece [ 0 ] ) { case T => result . append ( timeSlice . getLongTime ( ) ) NL case o => result . append ( ( logRecord . getCreatedTime ( ) . unixTimeStamp ( ) . nanoseconds ( ) / Int64 ( 1e6 ) ) . toString ( ) ) NL case n => result . append ( flushLeft ( logRecord . getCreatedTime ( ) . nanosecond ( ) . toString ( ) , 9 , 0 ) ) NL case m => result . append ( flushLeft ( ( logRecord . getCreatedTime ( ) . nanosecond ( ) / Int64 ( 1e6 ) ) . toString ( ) , 3 , 0 ) ) NL case t => result . append ( timeSlice . getShortTime ( ) ) NL case D => result . append ( timeSlice . getLongDate ( ) ) NL case d => result . append ( timeSlice . getShortDate ( ) ) NL case l => result . append ( logRecord . getTagName ( ) ) NL case L => result . append ( logRecord . getLevel ( ) . levelName ( ) ) NL case S => result . append ( logRecord . getSource ( ) ) NL case s =>  var slice : Array < String > = logRecord . getSource ( ) . split ( / ) NL if ( slice . size == 0 ) {  result . append ( String . empty ) NL } else {  result . append ( slice [ slice . size - 1 ] ) NL } NL case M => result . append ( logRecord . getMessage ( ) ) NL case _ => result . append ( String . empty ) NL } NL if ( piece . size > 1 ) {  result . append ( piece [ 1 .. ] ) NL } NL } else if ( piece . size > 0 ) {  result . append ( piece ) NL } NL i ++ NL } NL result . append ( \\n ) NL return result . toString ( ) NL }","func_name":"formatLogRecord","docstring":"/**\n     * Formatting log recording.\n     *\n     * @param pattern output pattern.\n     * @param logRecord log record.\n     * @return format result.\n     */"}
{"repo":"log4cj2","file":"log_level.cj","path":"log4cj2/src/utils/log_level.cj","code_tokens":"public func level ( ) : Int64 {   let num = match ( this ) { case ALL => 1 NL case TRACE => 2 NL case DEBUG => 3 NL case INFO => 4 NL case WARN => 5 NL case ERROR => 6 NL case OFF => 7 NL } NL return num NL }","func_name":"level","docstring":"/**\n     * Get the log level.\n     *\n     * @return number corresponding to the log level.\n     */"}
{"repo":"log4cj2","file":"log_level.cj","path":"log4cj2/src/utils/log_level.cj","code_tokens":"public func levelName ( ) : String {   let name = match ( this ) { case ALL => ALL NL case TRACE => TRACE NL case DEBUG => DEBUG NL case INFO => INFO NL case WARN => WARN NL case ERROR => ERROR NL case OFF => OFF NL } NL return name NL }","func_name":"levelName","docstring":"/**\n     * Get the log level name.\n     *\n     * @return character string corresponding to the log level.\n     */"}
{"repo":"log4cj2","file":"log_level.cj","path":"log4cj2/src/utils/log_level.cj","code_tokens":"public operator func > = ( target : LogLevel ) : Bool {  return this . level ( ) > = target . level ( ) NL }","func_name":">=","docstring":""}
{"repo":"log4cj2","file":"log_level.cj","path":"log4cj2/src/utils/log_level.cj","code_tokens":"static public func getLevelByString ( lable : String ) : LogLevel {   let level = match ( lable . toAsciiUpper ( ) ) { case ALL => ALL NL case TRACE => TRACE NL case DEBUG => DEBUG NL case INFO => INFO NL case WARN => WARN NL case ERROR => ERROR NL case OFF => OFF NL case _ => DEFAULT_LOG_LEVEL NL } NL return level NL }","func_name":"getLevelByString","docstring":"/**\n     * Get the log level string based on the input parameters.\n     *\n     * @param lable log level name\n     * @return character string corresponding to the log level.\n     */"}
{"repo":"log4cj2","file":"file_logger_appender.cj","path":"log4cj2/src/appender/file_logger_appender.cj","code_tokens":"func ~init ( ) {  if ( ! file . isClosed ( ) ) {  file . flush ( ) NL file . close ( ) NL } NL }","func_name":"~init","docstring":""}
{"repo":"log4cj2","file":"file_logger_appender.cj","path":"log4cj2/src/appender/file_logger_appender.cj","code_tokens":"public func initAppender ( pattern : String , properties : ArrayList < AppenderProperty > ) : Unit {   var file =  NL  let dFormat = [%T %D %m] [%L][%l] (%S) %M NL  var maxSize = 0 NL  var daily = false NL  var rotate = false NL  var retentionDays = 7 NL if ( pattern . size == 0 ) {  this . pattern = dFormat NL } else {  this . pattern = pattern NL } NL  var i : Int64 = 0 NL while ( i < properties . size ) {   var value = properties . get ( i ) . getOrThrow ( ) . getValue ( ) . trimLeft (  \\r\\n ) . trimRight (  \\r\\n ) NL match ( properties . get ( i ) . getOrThrow ( ) . getName ( ) . toAsciiLower ( ) ) { case filename => file = value NL case maxsize => maxSize = strToNumBySuffix ( value , 1024 , 20 * 1024 * 1024 ) NL case daily => daily = value . toAsciiLower ( ) != false NL case rotate => rotate = value . toAsciiLower ( ) != false NL case retentiondays => retentionDays = getNumByString ( value , 7 ) NL case _ => print ( LoadConfiguration: Warning: Unknown property ${properties.get(i).getOrThrow().getName()} ) NL } NL i ++ NL } NL if ( file . size == 0 ) {  file = root.log NL } NL this . fileName = file NL this . rotate = rotate NL this . maxSize = maxSize NL this . daily = daily NL this . retentionDays = retentionDays NL }","func_name":"initAppender","docstring":"/**\n     * Initialize file logger appender.\n     *\n     * @param pattern log format.\n     * @param property file appender properties.\n     */"}
{"repo":"log4cj2","file":"file_logger_appender.cj","path":"log4cj2/src/appender/file_logger_appender.cj","code_tokens":"public func start ( ) : Unit {  this . file = File ( this . fileName , OpenOption . CreateOrAppend ) NL this . curSize = this . file . info . length NL this . opendate = this . file . info . creationTime . day ( ) NL  let fut = spawn { while ( true ) {  if ( contentList . isEmpty ( ) ) {  continue NL } NL lock . lock ( ) NL  var rec : LogRecord = contentList . get ( 0 ) . getOrThrow ( ) NL if ( this . file . isClosed ( ) ) {  this . file = File ( this . fileName , OpenOption . CreateOrAppend ) NL this . curSize = this . file . info . length NL this . opendate = this . file . info . creationTime . day ( ) NL } NL  let now = Time . now ( ) NL if ( ( this . maxSize > 0 && this . curSize > = this . maxSize ) || ( this . daily && now . day ( ) != this . opendate ) ) {  rollingFile ( ) NL } NL  var mess = getDefaultPatternConvert ( ) . formatLogRecord ( this . pattern , rec ) . toUtf8Array ( ) NL try {  this . file . write ( mess ) NL } catch ( e : FSException ) {  println ( write file occur exception: ${e.message} ) NL return NL } NL  let n = mess . size NL this . curSize += n NL contentList . remove ( 0 ) NL lock . unlock ( ) NL } NL } NL }","func_name":"start","docstring":"/**\n     * Process default file, and assigns values to file-related variables.\n     */"}
{"repo":"log4cj2","file":"file_logger_appender.cj","path":"log4cj2/src/appender/file_logger_appender.cj","code_tokens":"public func logWrite ( rec : LogRecord ) : Unit {  lock . lock ( ) NL contentList . append ( rec ) NL lock . unlock ( ) NL }","func_name":"logWrite","docstring":"/**\n     * Write log to file.\n     *\n     * @param rec log recording.\n     */"}
{"repo":"log4cj2","file":"file_logger_appender.cj","path":"log4cj2/src/appender/file_logger_appender.cj","code_tokens":"public func close ( ) : Unit {  if ( ! this . file . isClosed ( ) ) {  this . file . flush ( ) NL this . file . close ( ) NL } NL }","func_name":"close","docstring":"/**\n     * Close file.\n     */"}
{"repo":"log4cj2","file":"file_logger_appender.cj","path":"log4cj2/src/appender/file_logger_appender.cj","code_tokens":"private func rollingFile ( ) : Unit {  if ( ! this . rotate ) {  return NL } NL lock . lock ( ) NL if ( ! this . file . isClosed ( ) ) {  this . file . flush ( ) NL this . file . close ( ) NL } NL  var fname =  NL if ( this . daily && Time . now ( ) . day ( ) != this . opendate ) {   let yesterday = Time . now ( ) . addDays ( 0 , 0 , - 1 ) . toString ( YYYYMMddhhmmss-SS ) NL fname = this . fileName + _ + yesterday + .log NL } else {  fname = this . fileName + _ + Time . now ( ) . toString ( YYYYMMddhhmmss-SS ) + .log NL } NL try {  File . move ( this . fileName , fname , true ) NL this . file = File ( this . fileName , OpenOption . CreateOrAppend ) NL } catch ( e : IllegalArgumentException | FSException ) {  lock . unlock ( ) NL println ( rolling file occur exception: ${e.message} ) NL return NL } NL this . opendate = Time . now ( ) . day ( ) NL this . curSize = 0 NL deleterollingFile ( ) NL lock . unlock ( ) NL }","func_name":"rollingFile","docstring":"// If this is called in a threaded context, it must be synchronized."}
{"repo":"log4cj2","file":"file_logger_appender.cj","path":"log4cj2/src/appender/file_logger_appender.cj","code_tokens":"private func deleterollingFile ( ) : Unit {  try {   let fileDir = this . file . info . parentDirectory . getOrThrow ( ) NL for ( file in Directory ( fileDir . path ) . fileList ( ) ) {  if ( file . path . toString ( ) . contains ( .log ) && file . lastModificationTime . addDays ( 0 , 0 , this . retentionDays ) < Time . now ( ) ) {  File . delete ( file . path ) NL } NL } NL } catch ( e : NoneValueException ) {  println ( logfile Directory is none ) NL return NL } catch ( e : FSException ) {  println ( delete log file has occur an exception ) NL } NL }","func_name":"deleterollingFile","docstring":"/**\n     * Delete log files whose storage duration exceeds the retention period.\n     */"}
{"repo":"log4cj2","file":"console_logger_appender.cj","path":"log4cj2/src/appender/console_logger_appender.cj","code_tokens":"public func initAppender ( pattern : String , property : ArrayList < AppenderProperty > ) : Unit {  if ( pattern . size == 0 ) {  this . pattern = [%T %D %m] [%L][%l] (%S) %M NL } else {  this . pattern = pattern NL } NL }","func_name":"initAppender","docstring":"/**\n     * Initialize console logger appender.\n     *\n     * @param pattern log format.\n     * @param property console appender properties.\n     */"}
{"repo":"log4cj2","file":"console_logger_appender.cj","path":"log4cj2/src/appender/console_logger_appender.cj","code_tokens":"public func start ( ) : Unit {  }","func_name":"start","docstring":"/**\n     * Start print.\n     */"}
{"repo":"log4cj2","file":"console_logger_appender.cj","path":"log4cj2/src/appender/console_logger_appender.cj","code_tokens":"public func logWrite ( rec : LogRecord ) : Unit {  print ( getDefaultPatternConvert ( ) . formatLogRecord ( pattern , rec ) ) NL }","func_name":"logWrite","docstring":"/**\n     * Formatting and printting logs.\n     *\n     * @param rec log recording.\n     */"}
{"repo":"log4cj2","file":"console_logger_appender.cj","path":"log4cj2/src/appender/console_logger_appender.cj","code_tokens":"public func close ( ) : Unit {  }","func_name":"close","docstring":"/**\n     * End print.\n     */"}
{"repo":"log4cj2","file":"logger_appender_factory.cj","path":"log4cj2/src/appender/logger_appender_factory.cj","code_tokens":"public func new ( ) : LoggerAppenderFactory {  this . typeLock . lock ( ) NL if ( this . appenderValues . size > 0 && this . appenderNames . size > 0 ) {   var index : Int64 = 0 NL while ( index < appenderValues . size ) {  appenderValues . get ( index ) . getOrThrow ( ) . close ( ) NL index ++ NL } NL } NL this . appenderNames = ArrayList < String > ( ) NL this . appenderValues = ArrayList < LoggerAppender > ( ) NL this . typeLock . unlock ( ) NL return this NL }","func_name":"new","docstring":"/**\n     * Clear logger appender.\n     *\n     * @return new object of this class.\n     */"}
{"repo":"log4cj2","file":"logger_appender_factory.cj","path":"log4cj2/src/appender/logger_appender_factory.cj","code_tokens":"public func registryType ( typeName : String , typeClz : LoggerAppender ) : LoggerAppenderFactory {  this . typeLock . lock ( ) NL if ( typeClz is LoggerAppender ) {  typeNames . append ( typeName . toAsciiLower ( ) ) NL typeValues . append ( typeClz ) NL } NL this . typeLock . unlock ( ) NL return this NL }","func_name":"registryType","docstring":"/**\n     * Register logger appender.\n     *\n     * @param typeName logger appender type name.\n     * @param typeClz logger appender type class.\n     * @return new object of this class.\n     */"}
{"repo":"log4cj2","file":"logger_appender_factory.cj","path":"log4cj2/src/appender/logger_appender_factory.cj","code_tokens":"public func getAppenderByType ( typeName : String ) : LoggerAppender {  if ( this . typeNames . contains ( typeName . toAsciiLower ( ) ) ) {   var index : Int64 = 0 NL while ( index < typeNames . size ) {  if ( typeNames . get ( index ) . getOrThrow ( ) . equals ( typeName . toAsciiLower ( ) ) ) {  return typeValues . get ( index ) . getOrThrow ( ) NL } NL index ++ NL } NL } NL return FileLoggerAppender ( ) NL }","func_name":"getAppenderByType","docstring":"/**\n     * Get logger appender by type name.\n     *\n     * @param typeName appender logger type name.\n     * @return implementation class of LoggerAppender. if typeName doesn't meet the condtion, return console appender logger.\n     */"}
{"repo":"log4cj2","file":"logger_appender_factory.cj","path":"log4cj2/src/appender/logger_appender_factory.cj","code_tokens":"public func getAppenderByName ( name : String ) : LoggerAppender {  if ( this . appenderNames . contains ( name . toAsciiLower ( ) ) ) {   var index : Int64 = 0 NL while ( index < appenderNames . size ) {  if ( appenderNames . get ( index ) . getOrThrow ( ) . equals ( name . toAsciiLower ( ) ) ) {  return appenderValues . get ( index ) . getOrThrow ( ) NL } NL index ++ NL } NL } NL return FileLoggerAppender ( ) NL }","func_name":"getAppenderByName","docstring":"/**\n     * Get logger appender by name.\n     *\n     * @param name  appender name.\n     * @return implementation class of LoggerAppender. if typeName doesn't meet the condtion, return console appender logger.\n     */"}
{"repo":"log4cj2","file":"logger_appender_factory.cj","path":"log4cj2/src/appender/logger_appender_factory.cj","code_tokens":"public func registerLoggerAppender ( name : String , typename : String , pattern : String , properties : ArrayList < AppenderProperty > ) : LoggerAppenderFactory {  this . typeLock . lock ( ) NL  var appenderName = name . toAsciiLower ( ) NL if ( this . typeNames . size == 0 || this . typeValues . size == 0 ) {  println ( AppenderType is empty, please RegistryType at first ) NL this . typeLock . unlock ( ) NL return LoggerAppenderFactory ( ) NL } NL  var newObj = getAppenderByType ( typename ) NL newObj . initAppender ( pattern , properties ) NL newObj . start ( ) NL this . appenderNames . append ( appenderName ) NL this . appenderValues . append ( newObj ) NL this . typeLock . unlock ( ) NL return this NL }","func_name":"registerLoggerAppender","docstring":"/**\n     * Register logger appender.\n     *\n     * @param name  appender name.\n     * @param typename  appender type name\n     * @param pattern  log pattern.\n     * @param properties appender preperties.\n     * @return new object of this class.\n     */"}
{"repo":"log4cj2","file":"logger_appender.cj","path":"log4cj2/src/appender/logger_appender.cj","code_tokens":"func initAppender ( pattern : String , property : ArrayList < AppenderProperty > ) : Unit","func_name":"initAppender","docstring":"/**\n     * Initialize logger appender.\n     *\n     * @param pattern log format.\n     * @param property appender properties.\n     */"}
{"repo":"log4cj2","file":"logger_appender.cj","path":"log4cj2/src/appender/logger_appender.cj","code_tokens":"func start ( ) : Unit","func_name":"start","docstring":"/**\n     * Start print.\n     */"}
{"repo":"log4cj2","file":"logger_appender.cj","path":"log4cj2/src/appender/logger_appender.cj","code_tokens":"func logWrite ( rec : LogRecord ) : Unit","func_name":"logWrite","docstring":"/**\n     * Writing logs.\n     *\n     * @param rec log recording.\n     */"}
{"repo":"log4cj2","file":"logger_appender.cj","path":"log4cj2/src/appender/logger_appender.cj","code_tokens":"func close ( ) : Unit","func_name":"close","docstring":"/**\n     * End print.\n     */"}
{"repo":"log4cj2","file":"logger_appender_reference.cj","path":"log4cj2/src/appender/logger_appender_reference.cj","code_tokens":"public func getAppenderList ( ) : ArrayList < LoggerAppender > {  return this . appenderList NL }","func_name":"getAppenderList","docstring":""}
{"repo":"log4cj2","file":"logger_appender_reference.cj","path":"log4cj2/src/appender/logger_appender_reference.cj","code_tokens":"public func setAppenderList ( appenderList : ArrayList < LoggerAppender > ) : Unit {  this . appenderList = appenderList NL }","func_name":"setAppenderList","docstring":""}
{"repo":"log4cj2","file":"logger_appender_reference.cj","path":"log4cj2/src/appender/logger_appender_reference.cj","code_tokens":"public func getLevel ( ) : LogLevel {  return this . level NL }","func_name":"getLevel","docstring":""}
{"repo":"log4cj2","file":"logger_appender_reference.cj","path":"log4cj2/src/appender/logger_appender_reference.cj","code_tokens":"public func setLevel ( level : LogLevel ) : Unit {  this . level = level NL }","func_name":"setLevel","docstring":""}
