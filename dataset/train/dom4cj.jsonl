{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"func head ( ) : ? T","func_name":"head","docstring":"/*\n     * Get linked list header element\n     *\n     * @return header element\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"func tail ( ) : ? T","func_name":"tail","docstring":"/**\n     * The Function is tail\n     *\n     * @return Type of ?T\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"func putHead ( ele : T ) : Unit","func_name":"putHead","docstring":"/**\n     * Add element in head\n     *\n     * @param ele Add element\n     *\n     * @return Type of Unit\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"func putTail ( ele : T ) : Unit","func_name":"putTail","docstring":"/**\n     * Add element in tail\n     *\n     * @param ele Add element\n     *\n     * @return Type of Unit\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"func remove ( index : Int64 ) : Bool","func_name":"remove","docstring":"/**\n     * Deletes the node under the specified index\n     *\n     * @param index of Int64\n     *\n     * @return Type of Bool\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"func size ( ) : Int64","func_name":"size","docstring":"/**\n     * The List length\n     *\n     * @return Int64 Return size\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"func isEmpty ( ) : Bool","func_name":"isEmpty","docstring":"/**\n     * Judge whether list is empty\n     *\n     * @return Bool Return bool\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"operator func [ ] ( index : Int64 ) : T","func_name":"[]","docstring":""}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"operator func [ ] ( index : Int64 , value ! : T ) : Unit","func_name":"[]","docstring":""}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"public func head ( ) : ? T {  match ( Frist . Next ) { case Some ( x ) => x . Ele NL case None => None NL } NL }","func_name":"head","docstring":"/*\n     * Get linked list header element\n     *\n     * @return header element\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"public func tail ( ) : ? T {  match ( End . Last ) { case Some ( x ) => x . Ele NL case None => None NL } NL }","func_name":"tail","docstring":"/**\n     * The Function is tail\n     *\n     * @return Type of ?T\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"private func insert ( v1 : LinkedNode < T > , v2 : LinkedNode < T > , mid : LinkedNode < T > ) : Unit {  v1 . Next = mid NL v2 . Last = mid NL mid . Last = v1 NL mid . Next = v2 NL }","func_name":"insert","docstring":"/*\n     * Insert a mid between V1 and V2\n     *\n     * @param v1 Type of LinkedNode<T>\n     * @param v2 Type of LinkedNode<T>\n     * @param mid Type of LinkedNode<T>\n     *\n     * @return Type of ?T\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"private func findX ( index : Int64 ) : LinkedNode < T > {   var i = 0 NL  var h = Frist NL while ( i <= index ) {  match ( h . Next ) { case Some ( x ) => h = x NL case None => ( ) NL } NL i ++ NL } NL return h NL }","func_name":"findX","docstring":"/*\n     * Find the element with index below. Not including head and tail.\n     *\n     * @param index LinkedNode index\n     *\n     * @return LinkedNode<T> Return LinkedNode\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"public func putHead ( ele : T ) : Unit {   var n = LinkedNode < T > ( ) NL n . Ele = ele NL match ( Frist . Next ) { case Some ( x ) => insert ( Frist , x , n ) NL Cont ++ NL case None => ( ) NL } NL }","func_name":"putHead","docstring":"/**\n     * Add element in head\n     *\n     * @param ele Add element\n     *\n     * @return Type of Unit\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"public func putTail ( ele : T ) : Unit {   var n = LinkedNode < T > ( ) NL n . Ele = ele NL match ( End . Last ) { case Some ( x ) => insert ( x , End , n ) NL Cont ++ NL case None => ( ) NL } NL }","func_name":"putTail","docstring":"/**\n     * Add element in tail\n     *\n     * @param ele Add element\n     *\n     * @return Type of Unit\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"public func size ( ) : Int64 {  Cont NL }","func_name":"size","docstring":"/**\n     * The List length\n     *\n     * @return Int64 Return size\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"public func isEmpty ( ) : Bool {  match ( ( Frist . Next , End . Last ) ) { case ( Some ( x ) , Some ( y ) ) => refEq ( x , y ) NL case _ => false NL } NL }","func_name":"isEmpty","docstring":"/**\n     * Judge whether list is empty\n     *\n     * @return Bool Return bool\n     */"}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"public operator func [ ] ( index : Int64 ) : T {  if ( index > = Cont || index < 0 ) {  throw IndexOutOfBoundsException ( Index ${index} is out of bound. ) NL } NL  var v = findX ( index ) NL match ( v . Ele ) { case Some ( x ) => return x NL case None => throw IndexOutOfBoundsException ( Index ${index} is out of bound. ) NL } NL }","func_name":"[]","docstring":""}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"public operator func [ ] ( index : Int64 , value ! : T ) : Unit {  if ( index > Cont || index < 0 ) {  throw IndexOutOfBoundsException ( Index ${index} is out of bound. ) NL } NL if ( index == Cont ) {  putTail ( value ) NL } else {   var n = LinkedNode < T > ( ) NL n . Ele = value NL  var v = findX ( index ) NL v . Ele = value NL } NL }","func_name":"[]","docstring":""}
{"repo":"dom4cj","file":"linkedlist.cj","path":"dom4cj/src/collection/linkedlist.cj","code_tokens":"public func remove ( index : Int64 ) : Bool {  if ( index < 0 || index > = Cont ) {  return false NL } else {   var v = findX ( index ) NL match ( ( v . Last , v . Next ) ) { case ( Some ( x ) , Some ( y ) ) => x . Next = y NL y . Last = x NL Cont -- NL return true NL case _ => return false NL } NL } NL }","func_name":"remove","docstring":"/**\n     * Deletes the node under the specified index\n     *\n     * @param index of Int64\n     *\n     * @return Type of Bool\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"func pop ( ) : Unit","func_name":"pop","docstring":"/**\n     * Pop up function of stack\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"func top ( ) : ? T","func_name":"top","docstring":"/**\n     * Stack top\n     *\n     * @return Type of ?T\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"func isEmpty ( ) : Bool","func_name":"isEmpty","docstring":"/**\n     * Judge whether the stack is empty\n     *\n     * @return Type of Bool\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"func size ( ) : Int64","func_name":"size","docstring":"/**\n     * Stack size\n     *\n     * @return Type of Int64\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"func push ( ele : T ) : Unit","func_name":"push","docstring":"/**\n     * Stack push element\n     *\n     * @param ele element\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"public func pop ( ) {  match ( head . getNext ( ) ) { case Some ( rt ) => head . setNext ( rt . getNext ( ) ) NL cont -- NL case None => ( ) NL } NL }","func_name":"pop","docstring":"/**\n     * Pop up function of stack\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"public func top ( ) : ? T {  match ( head . getNext ( ) ) { case Some ( rtt ) => rtt . getElement ( ) NL case None => None NL } NL }","func_name":"top","docstring":"/**\n     * Stack top\n     *\n     * @return Type of ?T\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"public func isEmpty ( ) : Bool {  match ( head . getNext ( ) ) { case Some ( rtt ) => false NL case None => true NL } NL }","func_name":"isEmpty","docstring":"/**\n     * Judge whether the stack is empty\n     *\n     * @return Type of Bool\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"public func size ( ) : Int64 {  cont NL }","func_name":"size","docstring":"/**\n     * Stack size\n     *\n     * @return Type of Int64\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"public func push ( ele : T ) {   var n = Node ( ele ) NL n . setNext ( head . getNext ( ) ) NL head . setNext ( n ) NL cont ++ NL }","func_name":"push","docstring":"/**\n     * Stack push element\n     *\n     * @param ele element\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"public func setElement ( e : T ) : Unit {  this . ele = e NL ( ) NL }","func_name":"setElement","docstring":"/**\n     * Set the element of this node\n     *\n     * @param e Element\n     *\n     * @return Type of Unit\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"public func setNext ( nex : ? Node < T > ) : Unit {  this . next = nex NL ( ) NL }","func_name":"setNext","docstring":"/**\n     * Sets the pointer to the next node\n     *\n     * @param nex Pointer to the next element\n     *\n     * @return Type of Unit\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"public func getElement ( ) {  return this . ele NL }","func_name":"getElement","docstring":"/**\n     * Get element\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"stack.cj","path":"dom4cj/src/collection/stack.cj","code_tokens":"public func getNext ( ) {  return this . next NL }","func_name":"getNext","docstring":"/**\n     * Get next element\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"error.cj","path":"dom4cj/src/core/error.cj","code_tokens":"public override func toString ( ) : String {   let mess = super . toString ( ) NL return ${mess} the index of the error which was happen is in ${Index}. NL }","func_name":"toString","docstring":"/**\n     * Get exception information.\n     *\n     * @return String Error message\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"parse.cj","path":"dom4cj/src/core/parse.cj","code_tokens":"private func flushBuild ( ) {  if ( ! Build . isEmpty ( ) ) {  DomStack . push ( ( Txt ( Build . toString ( ) ) , None ) ) NL Build . clear ( ) NL } NL }","func_name":"flushBuild","docstring":""}
{"repo":"dom4cj","file":"parse.cj","path":"dom4cj/src/core/parse.cj","code_tokens":"private func processTop ( name : String ) {  DomStack . pop ( ) NL  var son : LinkedList < DomType > = MList < DomType > ( ) NL while ( ! DomStack . isEmpty ( ) ) {   var now = DomStack . top ( ) NL DomStack . pop ( ) NL match ( now ) { case Some ( ele ) => match ( ele ) { case ( LeftTag ( info ) , None ) => if ( info . Name == name ) {   var data : DomTagNode = MDom ( info . Name , info . Attributes , son ) NL DomStack . push ( ( LeftTag ( info ) , MTag ( data ) ) ) NL return NL } else {   var data : SingleTagNode = MSDom ( info . Name , info . Attributes ) NL son . putHead ( STag ( data ) ) NL } NL case ( LeftTag ( info ) , Some ( x ) ) => son . putHead ( x ) NL case ( Error ( thr ) , None ) => ( ) NL case ( Error ( thr ) , Some ( x ) ) => son . putHead ( x ) NL case ( RightTag ( str ) , _ ) =>  var data : SingleTagNode = MSDom ( str , HashMap < String , ? String > ( ) ) NL son . putHead ( STag ( data ) ) NL case ( Comment ( str ) , _ ) => son . putHead ( Comment ( str ) ) NL case ( Txt ( str ) , _ ) => son . putHead ( Txt ( str ) ) NL case ( SingleTag ( info ) , _ ) =>  var data : SingleTagNode = MSDom ( info . Name , info . Attributes ) NL son . putHead ( STag ( data ) ) NL } NL case None => ( ) NL } NL } NL  var ee = ParseError ( there are right tag which is not closed. , Index ) NL while ( ! son . isEmpty ( ) ) {   var v = son . head ( ) NL DomStack . push ( ( Error ( ee ) , v ) ) NL son . remove ( 0 ) NL } NL  var st : SingleTagNode = MSDom ( name , HashMap < String , ? String > ( ) ) NL DomStack . push ( ( Error ( ee ) , STag ( st ) ) ) NL }","func_name":"processTop","docstring":"/*\n     * You must have a right tag at the top of the stack to call this method. Or it must be called through the checktop method.\n     *\n     * @param name Tag name\n     */"}
{"repo":"dom4cj","file":"parse.cj","path":"dom4cj/src/core/parse.cj","code_tokens":"private func checkTop ( ) {  if ( ! DomStack . isEmpty ( ) ) {   var top = DomStack . top ( ) NL match ( top ) { case Some ( now_tag ) => match ( now_tag [ 0 ] ) { case RightTag ( str ) => processTop ( str ) NL case _ => ( ) NL } NL ( ) NL case None => ( ) NL } NL } NL }","func_name":"checkTop","docstring":""}
{"repo":"dom4cj","file":"parse.cj","path":"dom4cj/src/core/parse.cj","code_tokens":"public func parse ( ) : LinkedList < DomType > {  while ( Index < Html . size ) {  if ( Html [ Index ] . isAsciiWhiteSpace ( ) ) {  Index ++ NL } else {  if ( Html [ Index ] == < ) {   var v = parseTag ( Html , Index ) NL match ( v [ 0 ] ) { case Error ( thr ) => Build . append ( Html [ Index ] ) NL Index ++ NL case Txt ( str ) => Build . append ( str ) NL Index = v [ 1 ] NL case _ => flushBuild ( ) NL DomStack . push ( ( v [ 0 ] , None ) ) NL Index = v [ 1 ] NL checkTop ( ) NL } NL } else {  Build . append ( Html [ Index ] ) NL Index ++ NL } NL } NL } NL flushBuild ( ) NL checkTop ( ) NL  var ans : LinkedList < DomType > = MList < DomType > ( ) NL while ( ! DomStack . isEmpty ( ) ) {   var top = DomStack . top ( ) NL DomStack . pop ( ) NL match ( top ) { case Some ( x ) => match ( x ) { case ( _ , Some ( ws ) ) => ans . putHead ( ws ) NL case ( LeftTag ( info ) , None ) => ans . putHead ( MTag ( MDom ( info . Name , info . Attributes , MList < DomType > ( ) ) ) ) NL case ( RightTag ( str ) , None ) => ans . putHead ( STag ( MSDom ( str , HashMap < String , ? String > ( ) ) ) ) NL case ( SingleTag ( info ) , None ) => ans . putHead ( STag ( MSDom ( info . Name , info . Attributes ) ) ) NL case ( Comment ( str ) , None ) => ans . putHead ( Comment ( str ) ) NL case ( Txt ( str ) , None ) => ans . putHead ( Txt ( str ) ) NL case ( Error ( thr ) , None ) => ( ) NL } NL case None => ( ) NL } NL } NL return ans NL }","func_name":"parse","docstring":"/**\n     * Dom parse\n     *\n     * @return Type of LinkedList<DomType>\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"parse.cj","path":"dom4cj/src/core/parse.cj","code_tokens":"public func parseHtml ( html : String ) : LinkedList < DomType > {   var work = ParseHtml ( html . toCharArray ( ) ) NL return work . parse ( ) NL }","func_name":"parseHtml","docstring":"/**\n * Parse html\n *\n * @param html of String\n *\n * @return Type of LinkedList<DomType>\n * @since 0.28.4\n */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"static public func contains ( name : String ) : Bool {  set . contains ( name ) NL }","func_name":"contains","docstring":"/**\n     * Is it a single line label\n     *\n     * @param name Tag name\n     * @return Bool \n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"public func parseTag ( doc : Array < Char > , begin : Int64 ) : ( TagType , Int64 ) {  if ( begin > = doc . size || doc [ begin ] != < ) {  return ( TagType . Error ( ParseError ( There is not a tag , begin ) ) , - 1 ) NL } NL match ( parseHtmlComment ( doc , begin ) ) { case Ok ( x ) => return ( TagType . Comment ( x [ 1 ] ) , x [ 0 ] ) NL case Err ( thr ) => ( ) NL } NL try {   var pro : ParseTag = TagProcessor ( doc , begin ) NL  var ret = pro . parse ( ) NL match ( ret ) { case Error ( thr ) => return ( ret , - 1 ) NL case _ => return ( ret , pro . getEnd ( ) ) NL } NL } catch ( e : ParseError ) {  return ( TagType . Error ( e ) , - 1 ) NL } NL }","func_name":"parseTag","docstring":"/**\n * Handling tags or comments\n *\n * @param doc HTML character array\n * @param begin Starting position\n *\n * @return TagType Type and data of tag\n * @return Int64 End position, left closed right open\n */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"func parseHtmlComment ( str : Array < Char > , index : Int64 ) : Result < ( Int64 , String ) > {   let left = <!-- NL  var check = true NL for ( i in 0 .. left . size ) {  if ( index + i > = str . size || left [ i ] != str [ index + i ] ) {  check = false NL break NL } NL } NL if ( check ) {   let right = --> NL  var end = index + left . size NL while ( end < str . size ) {   var isOk = true NL for ( i in 0 .. right . size ) {  if ( end + i > = str . size || str [ end + i ] != right [ i ] ) {  isOk = false NL break NL } NL } NL if ( isOk ) {  end += right . size NL break NL } NL end ++ NL } NL  var comment = String ( str , start : index , length : end - index ) NL return Result . Ok ( ( end , comment ) ) NL } else {  return Result . Err ( ParseError ( There is no a tag comment. , index ) ) NL } NL }","func_name":"parseHtmlComment","docstring":"/*\n * Handle tag comments in HTML.\n * \n * @param str Character array\n * @param index Start position\n *\n * @return Result<Int64*String>\n *  Ok\n *    Int64 End position, left closed and right open, including left and right symbols\n *    String Notes, including left and right<!-- -->\n *  Err\n *    thr Data error\n */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"func parse ( ) : TagType","func_name":"parse","docstring":"/**\n     * Processing tag\n     *\n     * @return Different types of tags\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"func getEnd ( ) : Int64","func_name":"getEnd","docstring":"/**\n     * End position\n     *\n     * @return Int64 At the end of the tag, close left and open right\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"public func parse ( ) : TagType {  processNormalTag ( ) NL }","func_name":"parse","docstring":"/**\n     * Processing tag\n     *\n     * @return Different types of tags\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"private func processNormalTag ( ) : TagType {  if ( Slash [ 0 ] != - 1 && Slash [ 1 ] != - 1 ) {   var now = Slash [ 0 ] + 1 NL now = readName ( now , Slash [ 1 ] ) NL if ( now != - 1 ) {  if ( SingleTagNames . contains ( Name ) ) {   var att = readAttr ( now , Slash [ 1 ] ) NL return TagType . SingleTag ( TagInfo ( Name , att ) ) NL } else {  return TagType . RightTag ( Name ) NL } NL } else {  return TagType . Error ( ParseError ( The tag does not have name. , Begin ) ) NL } NL } else if ( Slash [ 0 ] == - 1 && Slash [ 1 ] != - 1 ) {   var now = Begin + 1 NL now = readName ( now , Slash [ 1 ] ) NL  var att = readAttr ( now , Slash [ 1 ] ) NL return TagType . SingleTag ( TagInfo ( Name , att ) ) NL } else if ( Slash [ 0 ] != - 1 && Slash [ 1 ] == - 1 ) {  readName ( Slash [ 0 ] + 1 , End - 1 ) NL return TagType . RightTag ( Name ) NL } else {   var now = Begin + 1 NL now = readName ( now , End - 1 ) NL  var attr = readAttr ( now , End - 1 ) NL return TagType . LeftTag ( TagInfo ( Name , attr ) ) NL } NL }","func_name":"processNormalTag","docstring":"/*\n     * Dealing with other situations\n     *\n     * @return Type of TagType\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"private func readAttr ( head : Int64 , tail : Int64 ) {   var head = head NL  var tail = tail NL  var attrs = HashMap < String , ? String > ( ) NL while ( head < tail ) {   var attr =  NL  var value =  NL while ( head < tail && Str [ head ] . isAsciiWhiteSpace ( ) ) {  head ++ NL } NL if ( head > = tail ) {  break NL } NL  var check = processDomString ( head ) NL match ( check ) { case Some ( rt ) => head += rt . size NL attr = rt NL case None =>  var sb = StringBuilder ( ) NL while ( head < tail && ! Str [ head ] . isAsciiWhiteSpace ( ) && Str [ head ] != = ) {  sb . append ( Str [ head ] ) NL head ++ NL } NL attr = sb . toString ( ) NL } NL if ( ! attr . isEmpty ( ) && head < tail ) {  while ( head < tail && Str [ head ] . isAsciiWhiteSpace ( ) ) {  head ++ NL } NL if ( head > = tail ) {  attrs . put ( attr , None ) NL break NL } NL if ( Str [ head ] == = && head + 1 < tail ) {  head ++ NL while ( head < tail && Str [ head ] . isAsciiWhiteSpace ( ) ) {  head ++ NL } NL if ( head > = tail ) {  attrs . put ( attr , None ) NL break NL } NL  var check = processDomString ( head ) NL match ( check ) { case Some ( rt ) => head += rt . size NL value = rt NL case None =>  var sb = StringBuilder ( ) NL while ( head < tail && ! Str [ head ] . isAsciiWhiteSpace ( ) && Str [ head ] != = ) {  sb . append ( Str [ head ] ) NL head ++ NL } NL value = sb . toString ( ) NL } NL attrs . put ( attr , value ) NL } NL } else {  attrs . put ( attr , None ) NL ( ) NL } NL } NL return attrs NL }","func_name":"readAttr","docstring":"/*\n     * Read attribute name\n     *\n     * @param head Tag head\n     * @param tail Tag tail\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"public func processDomString ( now : Int64 ) : ? String {   let opt = Str [ now ] NL if ( opt == \\\" || opt == ' ) {   var end : Int64 = - 1 NL for ( i in now + 1 .. Len ) {  if ( Str [ i ] == opt ) {  end = i NL break NL } NL } NL if ( end == - 1 ) {  return None NL } else {   var ans = String ( Str , start : now , length : end + 1 - now ) NL return Some ( ans ) NL } NL } else {  return None NL } NL }","func_name":"processDomString","docstring":"/**\n     * Processing string\n     *\n     * @param now of Int64\n     *\n     * @return Type of ?String\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"private func readName ( begin : Int64 , end : Int64 ) {   var now = skipBlank ( begin , end ) NL  var name = StringBuilder ( ) NL while ( now < Len && ! isStringEnd ( now ) ) {  name . append ( Str [ now ] ) NL now ++ NL } NL Name = name . toString ( ) NL return now NL }","func_name":"readName","docstring":"/*\n     * Read tag name\n     *\n     * @param begin of Int64\n     * @param end of Int64\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"private func isStringEnd ( now : Int64 ) : Bool {   var ans = true NL  var n = Str [ now ] NL if ( n . isAsciiWhiteSpace ( ) || n == / || n == > ) {  ans = false NL } NL return ! ans NL }","func_name":"isStringEnd","docstring":"/*\n     * Determine whether the end of a complete word block is reached\n     *\n     * @param now String index\n     *\n     * @return Bool\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"private func skipBlank ( begin : Int64 , end : Int64 ) {   var begin = begin NL  var end = end NL while ( begin < end && Str [ begin ] . isAsciiWhiteSpace ( ) ) {  begin ++ NL } NL return match { case begin < end => begin NL case _ => - 1 NL } NL }","func_name":"skipBlank","docstring":"/*\n     * skip blanks\n     *\n     * @param begin String begin index\n     * @param end String end index\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"private func findTagRange ( ) : Int64 {  if ( Begin < Len && Str [ Begin ] == < ) {   var index = - 1 NL  var cont = [ 0 , 0 ] NL for ( x in Begin + 1 .. Len ) {  if ( Str [ x ] == ' && cont [ 1 ] == 0 ) {  cont [ 0 ] ^= 1 NL } else if ( Str [ x ] == \\\" && cont [ 0 ] == 0 ) {  cont [ 1 ] ^= 1 NL } else {  if ( cont [ 0 ] == 0 && cont [ 1 ] == 0 ) {  if ( Str [ x ] == > ) {  index = x NL break NL } NL } NL } NL } NL if ( index == - 1 ) {  return - 1 NL } else {  return index + 1 NL } NL } else {  return - 1 NL } NL }","func_name":"findTagRange","docstring":"/*\n     * Find a tag full range\n     *\n     * @return Type of Int64\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"private func findFristSlash ( ) {   var backward : Int64 = - 1 NL for ( i in Begin + 1 ..= End - 2 : 1 ) {  if ( Str [ i ] == / ) {  backward = i NL break NL } else if ( ! Str [ i ] . isAsciiWhiteSpace ( ) ) {  break NL } NL } NL  var forward : Int64 = - 1 NL for ( i in End - 2 ..= Begin + 1 : - 1 ) {  if ( Str [ i ] == / ) {  forward = i NL break NL } else if ( ! Str [ i ] . isAsciiWhiteSpace ( ) ) {  break NL } NL } NL return ( backward , forward ) NL }","func_name":"findFristSlash","docstring":"/*\n     * Look from front to back / and from back to front /. Note that there must be no characters until / is found\n     *\n     * @since 0.28.4\n     */"}
{"repo":"dom4cj","file":"tag.cj","path":"dom4cj/src/core/tag.cj","code_tokens":"public func getEnd ( ) {  this . End NL }","func_name":"getEnd","docstring":"/**\n     * End position\n     *\n     * @return Int64 At the end of the tag, close left and open right\n     */"}
{"repo":"dom4cj","file":"until.cj","path":"dom4cj/src/core/until.cj","code_tokens":"public func parseSingleLineComment ( str : Array < Char > , index : Int64 ) : Result < ( Int64 , Int64 , String ) > {  if ( index + 1 < str . size && str [ index ] == / && str [ index + 1 ] == / ) {   var end : Int64 = - 1 NL for ( ind in index + 2 .. str . size ) {  if ( str [ ind ] == \\r ) {  if ( ind + 1 < str . size && str [ ind + 1 ] == \\n ) {  end = ind + 2 NL } else {  end = ind + 1 NL } NL break NL } else if ( str [ ind ] == \\n ) {  end = ind + 1 NL break NL } NL } NL if ( end == - 1 ) {  return Result . Ok ( ( index , str . size , String ( str , start : index ) ) ) NL } else {  return Result . Ok ( ( index , end , String ( str , start : index , length : end - index ) ) ) NL } NL } else {  return Result . Err ( ParseError ( There is no comments. , index ) ) NL } NL }","func_name":"parseSingleLineComment","docstring":"/*\n * Single line comment processing in JavaScript.\n * \n * @param str Array of characters\n * @param index Start position\n *\n * @return Result<Int64*Int64*String>\n *  Result.Ok Correct handling\n *      Int64 Start position\n *      Int64 End position, left closed and right open, including line feed at the end\n *      String Note that the previous comments are saved here/\n *  Result.Err Cannot handle correctly\n *      ParseError Abnormal information\n */"}
{"repo":"dom4cj","file":"until.cj","path":"dom4cj/src/core/until.cj","code_tokens":"public func parseMultilineComment ( str : Array < Char > , index : Int64 ) : Result < ( Int64 , Int64 , String ) > {  if ( index + 1 < str . size && str [ index ] == / && str [ index + 1 ] == * ) {   var end : Int64 = - 1 NL for ( i in index + 2 .. str . size ) {  if ( str [ i ] == * && i + 1 < str . size && str [ i + 1 ] == / ) {  end = i + 2 NL break NL } NL } NL if ( end == - 1 ) {  return Result . Err ( ParseError ( Lost the end of comment. , index ) ) NL } else {  return Result . Ok ( ( index , end , String ( str , start : index , length : end - index ) ) ) NL } NL } else {  return Result . Err ( ParseError ( There must be a multiline comment.  , index ) ) NL } NL }","func_name":"parseMultilineComment","docstring":"/*\n * Handle multiline comments. Note that HTML's multiline annotations are handled differently than most languages.\n *\n * @param str Character array\n * @param index Start position\n *\n * @return Result<Int64*Int64*String>\n *  Ok Normal results\n *      Int64 Start position\n *      Int64 End position, left closed and right open, including \\/ * and * on the left and right sides *\\/\n *      String Contents of notes\n *  Err error\n *      thr Abnormal content\n */"}
