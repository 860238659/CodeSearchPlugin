{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func isNull ( ) : Bool {  return this . code == 0 && msg . isEmpty ( ) NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func message ( ) : String {  return this . msg NL }","func_name":"message","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public open func getError ( ) : String {  return err code is [${this.code}],  + this . msg NL }","func_name":"getError","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func getCode ( ) : UInt32 {  return this . code NL }","func_name":"getCode","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public override func getError ( ) : String {  if ( ! this . cause . isNull ( ) ) {  return stream error: stream ID = ${this.streamID}; error code = ${this.code}; err = ${this.cause.getError()} NL } NL return stream error: stream ID = ${this.streamID}; errcode = ${this.code} NL }","func_name":"getError","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func error ( ) : String {  return connection error: desc =  + this . desc NL }","func_name":"error","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func temporary ( ) : Bool {  return this . temp NL }","func_name":"temporary","docstring":"//Indicates whether this connection error is temporary or fatal."}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func origin ( ) : GrpcError {  if ( this . err . isNull ( ) ) {  return GrpcError ( GrpcUnknown , desc ) NL } NL return this . err NL }","func_name":"origin","docstring":"//Returns the original error for this connection error."}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func unwrap ( ) : GrpcError {  return this . err NL }","func_name":"unwrap","docstring":"//Returns the original error of this connection error. If the origin is zero, it returns zero."}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"protected func m_size ( ) : Int64 {   var i_tmp = 0 NL if ( p_code != 0 ) {  i_tmp += 1 + varintSize ( p_code ) NL } NL if ( ! p_msg . isEmpty ( ) ) {  i_tmp += 1 + binSize ( p_msg . data ) NL } NL return i_tmp NL }","func_name":"m_size","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"protected func m_isEmpty ( ) : Bool {  p_code == 0 && p_msg . isEmpty ( ) NL }","func_name":"m_isEmpty","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"protected func m_clear ( ) : Unit {  p_code = 0 NL p_msg . clear ( ) NL }","func_name":"m_clear","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func unpack < T > ( src : T ) : Unit where T <: BytesReader {  while ( ! src . isEmpty ( ) ) {   let i_tmp = src . parseTag ( ) NL match ( i_tmp [ 0 ] ) { case 1 => p_code = src . parseUInt32 ( ) NL case 2 => p_msg . unpack ( src ) NL case _ => m_unknown ( src , i_tmp ) NL } NL } NL markDirty ( ) NL }","func_name":"unpack","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func pack < T > ( out : T ) : Unit where T <: BytesWriter {  if ( p_code != 0 ) {  out . append ( 8 ) NL out . packVarint ( p_code ) NL } NL if ( ! p_msg . isEmpty ( ) ) {  out . append ( 18 ) NL out . packBin ( p_msg . data ) NL } NL m_unknown ( out ) NL }","func_name":"pack","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func toString ( ) : String {   var i_tmp = StructPrinter ( ) NL if ( p_code != 0 ) {  i_tmp . append ( code , p_code ) NL } NL if ( ! p_msg . isEmpty ( ) ) {  i_tmp . append ( msg , p_msg . get ( ) ) NL } NL return i_tmp . done ( ) . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func packi ( out : BytesWriter ) {  match ( out ) { case i_tmp : SimpleWriter => pack ( i_tmp ) NL case _ => pack ( out ) NL } NL }","func_name":"packi","docstring":""}
{"repo":"grpc","file":"grpc_error.cj","path":"grpc/src/exceptions/grpc_error.cj","code_tokens":"public func unpacki ( src : BytesReader ) {  match ( src ) { case i_stmp : SimpleReader => unpack ( i_stmp ) NL case _ => unpack ( src ) NL } NL }","func_name":"unpacki","docstring":""}
{"repo":"grpc","file":"socket_ffi.cj","path":"grpc/src/internal/resolver/dns/socket_ffi.cj","code_tokens":"foreign func okhttp_SOCKET_GetAddrInfo ( net : UInt8 , damin : CString ) : CPointer < UInt8 >","func_name":"okhttp_SOCKET_GetAddrInfo","docstring":""}
{"repo":"grpc","file":"socket_ffi.cj","path":"grpc/src/internal/resolver/dns/socket_ffi.cj","code_tokens":"@ fastNative   foreign func free ( ptr : CPointer < Unit > ) : Unit","func_name":"free","docstring":""}
{"repo":"grpc","file":"socket_ffi.cj","path":"grpc/src/internal/resolver/dns/socket_ffi.cj","code_tokens":"func resolveDomain ( net : SocketNet , domain : String ) : ArrayList < ( SocketAddressKind , Array < UInt8 > ) > {   var protocol = match ( net ) { case TCP => AI_IPPROTO_TCP NL case UDP => AI_IPPROTO_UDP NL } NL  var domainName = CString ( domain ) NL  var ip = unsafe {  okhttp_SOCKET_GetAddrInfo ( protocol , domainName ) NL } NL unsafe {  domainName . free ( ) NL } NL if ( ip . isNull ( ) ) {  throw Exception ( parse domain = ${domain} fail  ) NL } NL  let size = Int64 ( unsafe {  ip . read ( ) NL } ) NL  let arr = ArrayList < ( SocketAddressKind , Array < UInt8 > ) > ( ) NL  var index = 1 NL for ( i in 0 .. size ) {   let sz = Int64 ( unsafe {  ip . read ( index ) NL } ) NL index ++ NL if ( sz != SOCK_ADDR_IPV4_LEN && sz != SOCK_ADDR_IPV6_LEN ) {  unsafe {  free ( CPointer < Unit > ( ip ) ) NL } NL throw Exception ( parse domain = ${domain} fail  ) NL } NL  var ips = Array < UInt8 > ( sz , item : 0 ) NL for ( i in 0 .. sz ) {  ips [ i ] = unsafe {  ip . read ( i + index ) NL } NL } NL index += sz NL match { case sz == SOCK_ADDR_IPV4_LEN => arr . append ( ( IPv4 , ips ) ) NL case _ => arr . append ( ( IPv6 , ips ) ) NL } NL } NL unsafe {  free ( CPointer < Unit > ( ip ) ) NL } NL return arr NL }","func_name":"resolveDomain","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/internal/resolver/dns/resolver.cj","code_tokens":"func parseTarget ( target : String , defaultPort ! : String = DEFAULT_PORT ) : ( String , UInt16 ) {   var ( host , port ) = splitHostPort ( target ) NL if ( host ==  ) {  host = localhost NL } NL if ( port ==  ) {  port = defaultPort NL } NL  var ( ipv4 , ipv4false ) = parseIPv4 ( host ) NL if ( ! ipv4false ) {  return ( host , UInt16 . parse ( port ) ) NL } NL  var ipArr = resolveDomain ( TCP , host ) NL  var ( kind , arr ) = ipArr [ 0 ] NL  var ip = arr [ 0 ] . toString ( ) + . + arr [ 1 ] . toString ( ) + . + arr [ 2 ] . toString ( ) + . + arr [ 3 ] . toString ( ) NL return ( ip , UInt16 . parse ( port ) ) NL }","func_name":"parseTarget","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/internal/resolver/dns/resolver.cj","code_tokens":"func splitHostPort ( target : String ) : ( String , String ) {  if ( target ==  ) {  return (  ,  ) NL } NL  var address = target . split ( : ) NL if ( address . size > 2 ) {  throw Exception ( illegal address ) NL } NL if ( address . size == 1 ) {  return ( address [ 0 ] . toString ( ) ,  ) NL } NL return ( address [ 0 ] . toString ( ) , address [ 1 ] ) NL }","func_name":"splitHostPort","docstring":""}
{"repo":"grpc","file":"socket_util.cj","path":"grpc/src/internal/resolver/dns/socket_util.cj","code_tokens":"func parseIPv4 ( address : String ) : ( Array < UInt8 > , Bool ) {   var it = address . lazySplit ( . ) NL  var ip = Array < UInt8 > ( SOCK_ADDR_IPV4_LEN , item : 0 ) NL for ( i in 0 .. SOCK_ADDR_IPV4_LEN ) {  match ( it . next ( ) ) { case Some ( v ) => if ( v . size == 0 ) {  return ( DEFAULT_ARRAY_UINT8 , true ) NL } NL  var n = stoi ( v ) NL if ( n < 0 || n > 255 ) {  return ( DEFAULT_ARRAY_UINT8 , true ) NL } NL ip [ i ] = UInt8 ( n ) NL case None => return ( DEFAULT_ARRAY_UINT8 , true ) NL } NL } NL match ( it . next ( ) ) { case None => return ( ip , false ) NL case _ => return ( DEFAULT_ARRAY_UINT8 , true ) NL } NL }","func_name":"parseIPv4","docstring":""}
{"repo":"grpc","file":"socket_util.cj","path":"grpc/src/internal/resolver/dns/socket_util.cj","code_tokens":"func stoi ( s : String ) : Int64 {   var num : Int64 = 0 NL for ( u in s . utf8View ) {  if ( u < b'0' || u > b'9' ) {  return - 1 NL } NL  var n = u - b'0' NL num = num * 10 + Int64 ( n ) NL } NL return num NL }","func_name":"stoi","docstring":""}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/internal/resolver/dns/dns_resolver.cj","code_tokens":"public func NewBuilder ( ) : resolver . Builder {  return dnsBuilder ( { target : resolver . Target => } , { rn : resolver . ResolveNowOptions => } , { => } , dns ) NL }","func_name":"NewBuilder","docstring":""}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/internal/resolver/dns/dns_resolver.cj","code_tokens":"public func InitialState ( s : resolver . State ) {  this . bootstrapState = s NL }","func_name":"InitialState","docstring":""}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/internal/resolver/dns/dns_resolver.cj","code_tokens":"public func build ( target : resolver . Target ) : ( resolver . Resolver , GrpcError ) {  this . buildCallback ( target ) NL this . target = target NL return ( this , NULL_ERR ) NL }","func_name":"build","docstring":""}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/internal/resolver/dns/dns_resolver.cj","code_tokens":"public func scheme ( ) : String {  return this . builderScheme NL }","func_name":"scheme","docstring":""}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/internal/resolver/dns/dns_resolver.cj","code_tokens":"public func resolveNow ( o : resolver . ResolveNowOptions ) : Unit {  this . resolveNowCallback ( o ) NL  var ( address , port ) = parseTarget ( this . target . endpoint ) NL this . target . url . Host = address + :${port} NL }","func_name":"resolveNow","docstring":""}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/internal/resolver/dns/dns_resolver.cj","code_tokens":"public func close ( ) : Unit {  this . closeCallback ( ) NL }","func_name":"close","docstring":"// Close is a noop for Resolver."}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/internal/resolver/dns/dns_resolver.cj","code_tokens":"public func updateState ( s : resolver . State ) : GrpcError {  this . cc . getOrThrow ( ) . updateState ( s ) NL }","func_name":"updateState","docstring":"// UpdateState calls cc.UpdateState."}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/internal/resolver/dns/dns_resolver.cj","code_tokens":"public func reportError ( err : GrpcError ) : Unit {  this . cc . getOrThrow ( ) . reportError ( err ) NL }","func_name":"reportError","docstring":"// ReportError calls cc.ReportError."}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/internal/resolver/dns/dns_resolver.cj","code_tokens":"public func getTarget ( ) : String {  return this . target . url . Host NL }","func_name":"getTarget","docstring":""}
{"repo":"grpc","file":"grpcrand.cj","path":"grpc/src/grpc/grpcrand.cj","code_tokens":"func randInt64 ( ) : Int64 {  randMu . lock ( ) NL  let r : Random = Random ( ) NL  var time = UInt64 ( Time . now ( ) . nanosecond ( ) ) NL r . setSeed ( time ) NL try {  return r . nextInt64 ( ) NL } finally {  randMu . unlock ( ) NL } NL }","func_name":"randInt64","docstring":"/*\n * The Function is randInt64\n *\n * @return Type of Int64\n */"}
{"repo":"grpc","file":"grpcrand.cj","path":"grpc/src/grpc/grpcrand.cj","code_tokens":"func randInt32 ( ) : Int32 {  randMu . lock ( ) NL  let r : Random = Random ( ) NL  let time = UInt64 ( Time . now ( ) . nanosecond ( ) ) NL r . setSeed ( time ) NL try {  return r . nextInt32 ( ) NL } finally {  randMu . unlock ( ) NL } NL }","func_name":"randInt32","docstring":"/*\n * The Function is randInt32\n *\n * @return Type of Int32\n */"}
{"repo":"grpc","file":"grpcrand.cj","path":"grpc/src/grpc/grpcrand.cj","code_tokens":"func randInt16 ( ) : Int16 {  randMu . lock ( ) NL  let r : Random = Random ( ) NL  let time = UInt64 ( Time . now ( ) . nanosecond ( ) ) NL r . setSeed ( time ) NL try {  return r . nextInt16 ( ) NL } finally {  randMu . unlock ( ) NL } NL }","func_name":"randInt16","docstring":"/*\n * The Function is randInt16\n *\n * @return Type of Int16\n */"}
{"repo":"grpc","file":"grpcrand.cj","path":"grpc/src/grpc/grpcrand.cj","code_tokens":"func randFloat64 ( ) : Float64 {  randMu . lock ( ) NL  let r : Random = Random ( ) NL  let time = UInt64 ( Time . now ( ) . nanosecond ( ) ) NL r . setSeed ( time ) NL try {  return r . nextFloat64 ( ) NL } finally {  randMu . unlock ( ) NL } NL }","func_name":"randFloat64","docstring":"/*\n * The Function is randFloat64\n *\n * @return Type of Float64\n */"}
{"repo":"grpc","file":"grpcrand.cj","path":"grpc/src/grpc/grpcrand.cj","code_tokens":"func randUInt64 ( ) : UInt64 {  randMu . lock ( ) NL  let r : Random = Random ( ) NL  let time = UInt64 ( Time . now ( ) . nanosecond ( ) ) NL r . setSeed ( time ) NL try {  return r . nextUInt64 ( ) NL } finally {  randMu . unlock ( ) NL } NL }","func_name":"randUInt64","docstring":"/*\n * The Function is randUInt64\n *\n * @return Type of UInt64\n */"}
{"repo":"grpc","file":"server_stream.cj","path":"grpc/src/grpc/server_stream.cj","code_tokens":"public override func setHeader ( md : HashMap < String , Array < String > > ) : GrpcError {  if ( md . size == 0 ) {  return NULL_ERR NL } NL  let err : String = validate ( md ) NL if ( ! err . isEmpty ( ) ) {  return GrpcError ( insideInternal , err ) NL } NL return this . stream . setHeader ( md ) NL }","func_name":"setHeader","docstring":"/**\n     * Set header metadata. It can be called multiple times.\n     * When called multiple times, all provided metadata will be merged.\n     *\n     *  All the metadata will be sent out when one of the following happens:\n     *   - ServerStream.SendHeader() is called;\n     *   - The first response is sent out;\n     *   - An RPC status is sent out (error or success).\n     *\n     * @param md of HashMap<String,Array<String>>\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server_stream.cj","path":"grpc/src/grpc/server_stream.cj","code_tokens":"public override func sendHeader ( md : HashMap < String , Array < String > > ) : GrpcError {   var str : String = validate ( md ) NL if ( ! str . isEmpty ( ) ) {  return GrpcError ( insideInternal , str ) NL } NL return this . stss . writeHeader ( this . stream , md ) NL }","func_name":"sendHeader","docstring":"/**\n     * Send header metadata.\n     * The supplied md and headers set by SetHeader() will be sent.\n     * If called multiple times, it will fail.\n     *\n     * @param md of HashMap<String,Array<String>>\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server_stream.cj","path":"grpc/src/grpc/server_stream.cj","code_tokens":"public override func setTrailer ( md : HashMap < String , Array < String > > ) : GrpcError {  if ( md . size == 0 ) {  return NULL_ERR NL } NL this . stream . setTrailer ( md ) NL return NULL_ERR NL }","func_name":"setTrailer","docstring":"/**\n     * Sets the tail metadata that will be sent with RPC status.\n     * When called multiple times, all provided metadata will be merged.\n     *\n     * @param md of HashMap<String,Array<String>>\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server_stream.cj","path":"grpc/src/grpc/server_stream.cj","code_tokens":"public func sendMsg ( m : Message ) : GrpcError {   var err : GrpcError = NULL_ERR NL  func sendMsgInside ( ) {  if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  this . stss . writeStatus ( this . stream , err ) NL } NL if ( isOn ( ) && err . isNull ( ) ) {  this . stss . incrMsgSent ( ) NL } NL } NL  let compress : String = stream . getRecvCompress ( ) NL  var flagCompress : Bool = false NL if ( compress == gzip ) {  flagCompress = true NL } NL  let ( hdr , payload , data , errPM ) : ( Array < Byte > , Array < Byte > , Array < Byte > , GrpcError ) = prepareMsg ( m , this . codec , flagCompress ) NL if ( ! errPM . isNull ( ) ) {  sendMsgInside ( ) NL return errPM NL } NL if ( payload . size > this . maxSendMessageSize ) {  sendMsgInside ( ) NL return GrpcError ( ResourceExhausted , trying to send message larger than max (${payload.size} vs. ${this.maxSendMessageSize}) ) NL } NL err = this . stss . write ( this . stream , hdr , payload ) NL if ( ! err . isNull ( ) ) {  sendMsgInside ( ) NL return toRPCErr ( err ) NL } NL if ( this . statsHandler . size != 0 ) {   let nowTime : Time = Time . now ( ) NL  let num : Int64 = this . statsHandler . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = this . statsHandler [ i ] NL sh . handleRPC ( OutPayload . getOutPayload ( false , m , data , payload , nowTime ) ) NL } NL } NL sendMsgInside ( ) NL return NULL_ERR NL }","func_name":"sendMsg","docstring":"/**\n     * Send a message. When an error occurs, SendMsg aborts the flow and returns an error directly.\n     *  SendMsg blocks until:\n     *    - There is sufficient flow control to schedule m with the transport, or\n     *    - The stream is done, or\n     *    - The stream breaks.\n     * SendMsg will not wait until the client receives the message.\n     * Closing the flow prematurely can result in message loss.\n     *\n     * It is safe for a goroutine to call SendMsg and another goroutine to call RecVMS on the same stream at the same time,\n     * However, it is not safe to call SendMsg on the same class in different goroutines.\n     *\n     * @param m of Any\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server_stream.cj","path":"grpc/src/grpc/server_stream.cj","code_tokens":"func sendMsgInside ( ) {  if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  this . stss . writeStatus ( this . stream , err ) NL } NL if ( isOn ( ) && err . isNull ( ) ) {  this . stss . incrMsgSent ( ) NL } NL }","func_name":"sendMsgInside","docstring":""}
{"repo":"grpc","file":"server_stream.cj","path":"grpc/src/grpc/server_stream.cj","code_tokens":"public func recvMsg ( m : Message ) : GrpcError {   var err : GrpcError = NULL_ERR NL  func recvMsgInside ( ) {  if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  this . stss . writeStatus ( this . stream , err ) NL } NL if ( isOn ( ) && err . isNull ( ) ) {  this . stss . incrMsgSent ( ) NL } NL } NL  var payInfo : PayloadInfo = PayloadInfo ( ) NL if ( this . statsHandler . size != 0 ) {  payInfo = PayloadInfo ( 0 ) NL } NL err = recv ( this . parser , this . codec , this . stream , m , this . maxReceiveMessageSize , payInfo ) NL if ( ! err . isNull ( ) ) {  if ( err is EOFError ) {  recvMsgInside ( ) NL return err NL } NL if ( err is ErrUnexpectedEOF ) {  err = GrpcError ( insideInternal , err . msg ) NL } NL recvMsgInside ( ) NL return toRPCErr ( err ) NL } NL if ( this . statsHandler . size != 0 ) {   let num : Int64 = this . statsHandler . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = this . statsHandler [ i ] NL sh . handleRPC ( InPayload ( payload : m , data : payInfo . uncompressedBytes , length : payInfo . uncompressedBytes . size , wireLength : payInfo . wireLength + headerLen , recvTime : Time . now ( ) ) ) NL } NL } NL recvMsgInside ( ) NL return NULL_ERR NL }","func_name":"recvMsg","docstring":"/**\n     * Block until it receives the message in m or the flow is completed.\n     * When the client executes CloseSend, it returns io EOF.\n     * For any non EOF error, the stream will be aborted and the error contains RPC state.\n     * It is safe for one goroutine to call SendMsg and another goroutine to call RecVMs on the same stream at the same time,\n     * but it is not safe for different goroutines to call RECVMs on the same stream.\n     *\n     * @param m of Any\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server_stream.cj","path":"grpc/src/grpc/server_stream.cj","code_tokens":"func recvMsgInside ( ) {  if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  this . stss . writeStatus ( this . stream , err ) NL } NL if ( isOn ( ) && err . isNull ( ) ) {  this . stss . incrMsgSent ( ) NL } NL }","func_name":"recvMsgInside","docstring":""}
{"repo":"grpc","file":"backoff.cj","path":"grpc/src/grpc/backoff.cj","code_tokens":"func Backoff ( retries : Int64 ) : Duration","func_name":"Backoff","docstring":"/*\n     * The Function is Backoff\n     *\n     * @param retries of Int64\n     *\n     * @return Type of Duration\n     */"}
{"repo":"grpc","file":"backoff.cj","path":"grpc/src/grpc/backoff.cj","code_tokens":"public func Backoff ( retries : Int64 ) : Duration {  if ( retries == 0 ) {  return config . baseDelay NL } NL  var parservalue = Float64 ( config . baseDelay . seconds ( ) ) NL  var backoff : Float64 = parservalue NL parservalue = Float64 ( config . maxDelay . seconds ( ) ) NL  var max : Float64 = parservalue NL  var val = retries NL while ( backoff < max && val > 0 ) {  backoff *= config . multiplier NL val -- NL } NL if ( backoff > max ) {  backoff = max NL } NL  var ramnum = Float64 ( randInt64 ( ) ) + Float64 ( randInt32 ( ) ) + Float64 ( randInt16 ( ) ) + Float64 ( randUInt64 ( ) ) NL backoff *= 1.0 + config . jitter * ( ramnum + randFloat64 ( ) * 2.0 - 1.0 ) NL if ( backoff < 0.0 ) {  return Duration . nanosecond ( 0 ) NL } NL return Duration . second ( retries ) NL }","func_name":"Backoff","docstring":"/*\n     * The Function is Backoff\n     *\n     * @param retries of Int64\n     *\n     * @return Type of Duration\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/grpc/transport.cj","code_tokens":"func write ( target : String , h2conn : H2ClientConn , hdr : Array < Byte > , data : Array < Byte > ) : Array < UInt8 > {  return Http2Client ( ) . write ( target , h2conn , hdr , data ) NL }","func_name":"write","docstring":"/*\n     * The Function is Write\n     *\n     * @param target of String\n     * @param hdr of Array<Byte>\n     * @param data of Array<Byte>\n     *\n     * @return Type of Array<UInt8>\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"func before ( c : CallInfo ) : Unit","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"func after ( attempt : ClientStream ) : Unit","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"func encode ( bc : BaseCodec , msg : Any ) : Array < Byte > {   var data = bc . marshal ( ( msg as Message ) . getOrThrow ( ) ) NL if ( data . size > Int64 ( UInt32 . Max ) ) {  throw Exception ( message too large ) NL } NL return data NL }","func_name":"encode","docstring":"/*\n * The Function is encode\n *\n * @param bc of BaseCodec\n * @param msg of Any\n *\n * @return Type of ArrayList<Byte>\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"func msgHeader ( data : Array < Byte > ) : ( Array < Byte > , Array < Byte > ) {   let hdr : Array < Byte > = Array < Byte > ( Int64 ( HEADER_LEN ) , item : 0 ) NL hdr [ 0 ] = COMPRESSION_NONE NL  let s : Int64 = data . size NL hdr [ 1 ] = UInt8 ( ( s >> 24 ) & 0xff ) NL hdr [ 2 ] = UInt8 ( ( s >> 16 ) & 0xff ) NL hdr [ 3 ] = UInt8 ( ( s >> 8 ) & 0xff ) NL hdr [ 4 ] = UInt8 ( s & 0xff ) NL return ( hdr , data ) NL }","func_name":"msgHeader","docstring":"/*\n * The Function is msgHeader\n *\n * @param data of Array<Byte>\n *\n * @return Type of (Array<Byte>, Array<Byte>)\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func maxCallRecvMsgSize ( bytes : Int64 ) : CallOption {  return MaxRecvMsgSizeCallOption ( bytes ) NL }","func_name":"maxCallRecvMsgSize","docstring":"/*\n * The Function is maxCallRecvMsgSize\n *\n * @param bytes of Int64\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func before ( c : CallInfo ) : Unit {  c . maxReceiveMessageSize = maxRecvMsgSize NL }","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func after ( attempt : ClientStream ) : Unit {  }","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func callCustomCodec ( codec : BaseCodec ) : CallOption {  return CustomCodecCallOption ( codec ) NL }","func_name":"callCustomCodec","docstring":"/*\n * The Function is callCustomCodec\n *\n * @param codec of BaseCodec\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func before ( c : CallInfo ) : Unit {  c . codec = this . codec NL }","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func after ( attempt : ClientStream ) : Unit {  }","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func CallContentSubtype ( contentSubtype : String ) : CallOption {  return ContentSubtypeCallOption ( contentSubtype . toAsciiLower ( ) ) NL }","func_name":"CallContentSubtype","docstring":"/**\n * The Function is CallContentSubtype\n *\n * @param contentSubtype of String\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func before ( c : CallInfo ) : Unit {  c . contentSubtype = this . contentSubtype NL }","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func after ( attempt : ClientStream ) : Unit {  }","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func failFast ( failFast : Bool ) : CallOption {  return FailFastCallOption ( failFast ) NL }","func_name":"failFast","docstring":"/**\n * The Function is failFast\n *\n * @param failFast of Bool\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func before ( c : CallInfo ) : Unit {  c . failFast = this . failFast NL }","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func after ( attempt : ClientStream ) : Unit {  }","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func forceCodec ( codec : BaseCodec ) : CallOption {  return ForceCodecCallOption ( codec ) NL }","func_name":"forceCodec","docstring":"/**\n * The Function is forceCodec\n *\n * @param codec of BaseCodec\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func before ( c : CallInfo ) : Unit {  c . codec = this . codec NL }","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func after ( attempt : ClientStream ) : Unit {  }","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func maxCallSendMsgSize ( bytes : Int64 ) : CallOption {  return MaxSendMsgSizeCallOption ( bytes ) NL }","func_name":"maxCallSendMsgSize","docstring":"/**\n * The Function is maxCallSendMsgSize\n *\n * @param bytes of Int64\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func before ( c : CallInfo ) : Unit {  c . maxSendMessageSize = this . maxSendMessageSize NL }","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func after ( attempt : ClientStream ) : Unit {  }","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func maxRetryRPCBufferSize ( bytes : Int64 ) : CallOption {  return MaxRetryRPCBufferSizeCallOption ( bytes ) NL }","func_name":"maxRetryRPCBufferSize","docstring":"/**\n * The Function is maxRetryRPCBufferSize\n *\n * @param bytes of Int64\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func before ( c : CallInfo ) : Unit {  c . maxRetryRPCBufferSize = this . maxRetryRPCBufferSize NL }","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func after ( attempt : ClientStream ) : Unit {  }","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func useCompressor ( name : String ) : CallOption {  return CompressorCallOption ( name ) NL }","func_name":"useCompressor","docstring":"/**\n * The Function is useCompressor\n *\n * @param name of String\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func before ( c : CallInfo ) : Unit {  c . compressorType = this . compressorType NL }","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func after ( attempt : ClientStream ) : Unit {  }","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func waitForReady ( waitForReady : Bool ) : CallOption {  return FailFastCallOption ( waitForReady ) NL }","func_name":"waitForReady","docstring":"/**\n * The Function is waitForReady\n *\n * @param waitForReady of Bool\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func perRPCCredentials ( creds : PerRPCCredentials ) : CallOption {  return PerRPCCredsCallOption ( creds ) NL }","func_name":"perRPCCredentials","docstring":"/**\n * The Function is perRPCCredentials\n *\n * @param creds of PerRPCCredentials\n *\n * @return Type of CallOption\n */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func before ( c : CallInfo ) : Unit {  c . creds = this . creds NL }","func_name":"before","docstring":"/*\n     * The Function is before\n     *\n     * @param c of CallInfo\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"util.cj","path":"grpc/src/grpc/util.cj","code_tokens":"public func after ( attempt : ClientStream ) : Unit {  }","func_name":"after","docstring":"/**\n     * The Function is after\n     *\n     * @param c of CallInfo\n     * @param attempt of ClientStreamAttempt\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"func apply ( da : DialOptions ) : Unit","func_name":"apply","docstring":"/*\n     * The Function is apply\n     *\n     * @param da of DialOptions\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"func defaultDialOptions ( ) : DialOptions {   var opts = DialOptions ( ) NL  var copts = ConnectOptions ( ) NL opts . healthCheckFunc = HealthChecker NL copts . writeBufferSize = DEFAULT_WRITE_BUF_SIZE NL copts . readBufferSize = DEFAULT_READ_BUF_SIZE NL copts . useProxy = true NL opts . copts = copts NL return opts NL }","func_name":"defaultDialOptions","docstring":""}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func newFuncDialOption ( f : ( DialOptions ) -> Unit ) : FuncDialOption {  return FuncDialOption ( f ) NL }","func_name":"newFuncDialOption","docstring":"/**\n * The Function is newFuncDialOption\n *\n * @param f of (DialOptions)->Unit\n *\n * @return Type of FuncDialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func failOnNonTempDialError ( bol : Bool ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . copts . failOnNonTempDialError = bol NL } ) NL }","func_name":"failOnNonTempDialError","docstring":"/**\n * The Function is failOnNonTempDialError\n *\n * @param bol of Bool\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withAuthority ( str : String ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . authority = str NL } ) NL }","func_name":"withAuthority","docstring":"/**\n * The Function is withAuthority\n *\n * @param str of String\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withBackoffConfig ( b : BackoffConfig ) : DialOption {   var bc = DEFAULT_CONFIG NL bc . maxDelay = b . maxDelay NL return withBackoff ( Exponential ( DEFAULT_CONFIG ) ) NL }","func_name":"withBackoffConfig","docstring":"/**\n * The Function is withBackoffConfig\n *\n * @param b of BackoffConfig\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withBackoff ( bs : Strategy ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . bs = bs NL } ) NL }","func_name":"withBackoff","docstring":"/**\n * The Function is withBackoff\n *\n * @param bs of Strategy\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withReadBufferSize ( s : Int64 ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . copts . readBufferSize = s NL } ) NL }","func_name":"withReadBufferSize","docstring":"/**\n * The Function is withReadBufferSize\n *\n * @param s of Int64\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withInitialWindowSize ( s : Int32 ) : DialOption {  if ( s < 0 ) {  throw Exception ( WindowSize Illegal Value ) NL } NL return newFuncDialOption ( { dos : DialOptions => dos . copts . initialWindowSize = s NL } ) NL }","func_name":"withInitialWindowSize","docstring":"/**\n * The Function is withInitialWindowSize\n *\n * @param s of Int32\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withInitialConnWindowSize ( s : Int32 ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . copts . initialConnWindowSize = s NL } ) NL }","func_name":"withInitialConnWindowSize","docstring":"/**\n * The Function is withInitialConnWindowSize\n *\n * @param s of Int32\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withMaxMsgSize ( s : Int64 ) : DialOption {   var arr = ArrayList < CallOption > ( ) NL arr . append ( maxCallRecvMsgSize ( s ) ) NL return withDefaultCallOptions ( arr ) NL }","func_name":"withMaxMsgSize","docstring":"/**\n * The Function is withMaxMsgSize\n *\n * @param s of Int64\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"func withDefaultCallOptions ( cos : ArrayList < CallOption > ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . callOptions . appendAll ( cos ) NL } ) NL }","func_name":"withDefaultCallOptions","docstring":"/*\n * The Function is withDefaultCallOptions\n *\n * @param cos of ArrayList<CallOption>\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withCodec ( c : BaseCodec ) : DialOption {   var arr = ArrayList < CallOption > ( ) NL arr . append ( callCustomCodec ( c ) ) NL return withDefaultCallOptions ( arr ) NL }","func_name":"withCodec","docstring":"/**\n * The Function is withCodec\n *\n * @param c of BaseCodec\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withBlock ( ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . block = true NL } ) NL }","func_name":"withBlock","docstring":"/**\n * The Function is withBlock\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withWriteBufferSize ( s : Int64 ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . copts . writeBufferSize = s NL } ) NL }","func_name":"withWriteBufferSize","docstring":"/**\n * The Function is withWriteBufferSize\n *\n * @param s of Int64\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withUserAgent ( s : String ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . copts . userAgent = s NL } ) NL }","func_name":"withUserAgent","docstring":"/**\n * The Function is withUserAgent\n *\n * @param s of String\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withTimeout ( d : Duration ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . timeout = d NL } ) NL }","func_name":"withTimeout","docstring":"/**\n * The Function is withTimeout\n *\n * @param d of Duration\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withReturnConnectionError ( ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . block = true NL dos . returnLastError = true NL } ) NL }","func_name":"withReturnConnectionError","docstring":"/**\n * The Function is withReturnConnectionError\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withNoProxy ( ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . copts . useProxy = false NL } ) NL }","func_name":"withNoProxy","docstring":"/**\n * The Function is withNoProxy\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withMaxHeaderListSize ( s : UInt32 ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . copts . maxHeaderListSize = s NL } ) NL }","func_name":"withMaxHeaderListSize","docstring":"/**\n * The Function is withMaxHeaderListSize\n *\n * @param s of UInt32\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withInsecure ( ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . copts . transportCredentials = InsecureTC ( ) NL } ) NL }","func_name":"withInsecure","docstring":"/**\n * The Function is withInsecure\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withDisableServiceConfig ( ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . disableServiceConfig = true NL } ) NL }","func_name":"withDisableServiceConfig","docstring":"/**\n * The Function is withDisableServiceConfig\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withDisableRetry ( ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . disableRetry = true NL } ) NL }","func_name":"withDisableRetry","docstring":"/**\n * The Function is withDisableRetry\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withDisableHealthCheck ( ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . disableHealthCheck = true NL } ) NL }","func_name":"withDisableHealthCheck","docstring":"/**\n * The Function is withDisableHealthCheck\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withDefaultServiceConfig ( s : String ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . defaultServiceConfigRawJSON = s NL } ) NL }","func_name":"withDefaultServiceConfig","docstring":"/**\n * The Function is withDefaultServiceConfig\n *\n * @param s of String\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withResolvers ( rs : resolver . Builder ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . resolvers . append ( rs ) NL } ) NL }","func_name":"withResolvers","docstring":"/**\n * The Function is withResolvers\n *\n * @param rs of Builder\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func WithUnaryInterceptor ( unary : UnaryInvoker ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . unaryInt = unary NL } ) NL }","func_name":"WithUnaryInterceptor","docstring":"/**\n * The Function is withResolvers\n *\n * @param rs of Builder\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func withStreamInterceptor ( unary : StreamClientInterceptor ) : DialOption {  return newFuncDialOption ( { dos : DialOptions => dos . streamInt = unary NL } ) NL }","func_name":"withStreamInterceptor","docstring":"/**\n * The Function is withResolvers\n *\n * @param rs of Builder\n *\n * @return Type of DialOption\n */"}
{"repo":"grpc","file":"dialoptions.cj","path":"grpc/src/grpc/dialoptions.cj","code_tokens":"public func apply ( dos : DialOptions ) {  f ( dos ) NL }","func_name":"apply","docstring":"/*\n     * The Function is apply\n     *\n     * @param da of DialOptions\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"public func pairs ( kv : ArrayList < String > ) : MetaData {  if ( ( kv . size ) % 2 == 1 ) {  throw Exception ( metadata: Pairs got the odd number of input pairs for metadata: ${kv.size} ) NL } NL  var i : Int64 = 0 NL while ( i < kv . size ) {   var key = kv [ i ] . toAsciiLower ( ) NL  var val = ArrayList < String > ( ) NL val . append ( kv [ i + 1 ] ) NL md . put ( key , val ) NL i += 2 NL } NL return this NL }","func_name":"pairs","docstring":"/**\n     * The Function is pairs\n     *\n     * @param kv of ArrayList<String>\n     *\n     * @return Type of MetaData\n     */"}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"public func len ( ) : Int64 {  return md . size NL }","func_name":"len","docstring":"/**\n     * The Function is len\n     *\n     * @return Type of Int64\n     */"}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"public func copy ( ) : MetaData {   var arr = Array < MetaData > ( [ this ] ) NL return join ( arr ) NL }","func_name":"copy","docstring":"/**\n     * The Function is copy\n     *\n     * @return Type of MetaData\n     */"}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"public func get ( k : String ) : ArrayList < String > {   var key = k . toAsciiLower ( ) NL return md [ key ] NL }","func_name":"get","docstring":"/**\n     * The Function is get\n     *\n     * @param k of String\n     *\n     * @return Type of ArrayList<String>\n     */"}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"public func set ( k : String , v : ArrayList < String > ) : Unit {  if ( v . isEmpty ( ) ) {  return NL } NL  var key = k . toAsciiLower ( ) NL md . put ( key , v ) NL }","func_name":"set","docstring":"/**\n     * The Function is set\n     *\n     * @param k of String\n     * @param v of ArrayList<String>\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"public func append ( k : String , v : ArrayList < String > ) : Unit {  if ( v . isEmpty ( ) ) {  return NL } NL  var key = k . toAsciiLower ( ) NL if ( md . contains ( key ) ) {   var newval = get ( key ) NL newval . appendAll ( v ) NL md [ key ] = newval NL return NL } NL md . put ( key , v ) NL }","func_name":"append","docstring":"/*\n * The Function is append\n *\n * @param k of String\n * @param v of ArrayList<String>\n *\n * @return Type of Unit\n */"}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"public func delete ( k : String ) {   var key = k . toAsciiLower ( ) NL match ( md . remove ( key ) ) { case Some ( V ) => ( ) NL case None => throw Exception ( ${key} not exist in the metadata ) NL } NL }","func_name":"delete","docstring":"/*\n * The Function is delete\n *\n * @param k of String\n */"}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"@ fastCall   public operator func [ ] ( key : String ) : ArrayList < String > {  return this . get ( key ) NL }","func_name":"[]","docstring":""}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"@ fastCall   public operator func [ ] ( key : String , value ! : ArrayList < String > ) : Unit {  return this . set ( key , value ) NL }","func_name":"[]","docstring":""}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"public func DecodeKeyValue ( k : String , v : String ) : ( String , String ) {  return ( k , v ) NL }","func_name":"DecodeKeyValue","docstring":"/**\n * The Function is DecodeKeyValue\n *\n * @param k of String\n * @param v of String\n *\n * @return Type of (String, String)\n */"}
{"repo":"grpc","file":"metadata.cj","path":"grpc/src/grpc/metadata.cj","code_tokens":"public func join ( mds : Array < MetaData > ) : MetaData {   var out : MetaData = MetaData ( ) NL for ( i in 0 .. mds . size ) {   let data = mds [ i ] NL for ( ( k , v ) in data . md ) {  out . append ( k , v ) NL } NL } NL return out NL }","func_name":"join","docstring":"/**\n * The Function is join\n *\n * @param mds of Array<MetaData>\n *\n * @return Type of MetaData\n */"}
{"repo":"grpc","file":"stream_util.cj","path":"grpc/src/grpc/stream_util.cj","code_tokens":"public func validate ( md : HashMap < String , Array < String > > ) : String {  for ( ( k , vals ) in md ) {  if ( k [ 0 ] == : ) {  continue NL } NL for ( c in k ) {  if ( ! ( c > = a && c <= z ) && ! ( c > = 0 && c <= 9 ) && c != . && c != - && c != _ ) {  return header key ${k} contains illegal characters not in [0-9a-z-_.] NL } NL } NL if ( k . endsWith ( -bin ) ) {  continue NL } NL  let len : Int64 = vals . size NL for ( i in 0 .. len ) {   let str : String = vals [ i ] NL if ( hasNotPrintable ( str ) ) {  return header key ${k} contains value with non-printable ASCII characters NL } NL } NL } NL return  NL }","func_name":"validate","docstring":"/*\n * If the input md contains invalid keys or values, Validate returns an error.\n * If the title is not a pseudo title, check the following:\n *  - The title name must contain one or more characters [0-9 a-z_ -.] in this set.\n *  - If the title name ends with the suffix \"- bin\", the title value will not be validated.\n *  - Otherwise, the header value must contain one or more characters in the set [% x20 -% x7E].\n */"}
{"repo":"grpc","file":"stream_util.cj","path":"grpc/src/grpc/stream_util.cj","code_tokens":"func chainUnaryServerInterceptors ( s : Server ) : Unit {   var interceptors : ArrayList < UnaryServerInterceptor > = s . opts . chainUnaryInts NL match ( s . opts . unaryInt ) { case Some ( v ) => interceptors . append ( v ) NL case None => ( ) NL } NL  var chainedInt : Option < UnaryServerInterceptor > = None NL if ( interceptors . size == 0 ) {  chainedInt = None NL } else if ( interceptors . size == 1 ) {  chainedInt = Some ( interceptors [ 0 ] ) NL } else {  chainedInt = Some ( chainUnaryInterceptors ( Array < UnaryServerInterceptor > ( interceptors ) ) ) NL } NL s . opts . unaryInt = chainedInt NL }","func_name":"chainUnaryServerInterceptors","docstring":"//Link all the unary server interceptors into one."}
{"repo":"grpc","file":"stream_util.cj","path":"grpc/src/grpc/stream_util.cj","code_tokens":"func chainUnaryInterceptors ( interceptors : Array < UnaryServerInterceptor > ) : UnaryServerInterceptor {   func usi ( req : Any , info : UnaryServerInfo , handler : UnaryHandler ) : ( Message , GrpcError ) {   let state : State = State ( ) NL  func stateNext ( req : Any ) : ( Message , GrpcError ) {  if ( state . index == interceptors . size - 1 ) {  return interceptors [ state . index ] . f ( req , info , handler ) NL } NL state . index ++ NL return interceptors [ state . index - 1 ] . f ( req , info , UnaryHandler ( state . nextUnary ) ) NL } NL state . nextUnary = stateNext NL return state . nextUnary ( req ) NL } NL return UnaryServerInterceptor ( usi ) NL }","func_name":"chainUnaryInterceptors","docstring":""}
{"repo":"grpc","file":"stream_util.cj","path":"grpc/src/grpc/stream_util.cj","code_tokens":"func usi ( req : Any , info : UnaryServerInfo , handler : UnaryHandler ) : ( Message , GrpcError ) {   let state : State = State ( ) NL  func stateNext ( req : Any ) : ( Message , GrpcError ) {  if ( state . index == interceptors . size - 1 ) {  return interceptors [ state . index ] . f ( req , info , handler ) NL } NL state . index ++ NL return interceptors [ state . index - 1 ] . f ( req , info , UnaryHandler ( state . nextUnary ) ) NL } NL state . nextUnary = stateNext NL return state . nextUnary ( req ) NL }","func_name":"usi","docstring":""}
{"repo":"grpc","file":"stream_util.cj","path":"grpc/src/grpc/stream_util.cj","code_tokens":"func stateNext ( req : Any ) : ( Message , GrpcError ) {  if ( state . index == interceptors . size - 1 ) {  return interceptors [ state . index ] . f ( req , info , handler ) NL } NL state . index ++ NL return interceptors [ state . index - 1 ] . f ( req , info , UnaryHandler ( state . nextUnary ) ) NL }","func_name":"stateNext","docstring":""}
{"repo":"grpc","file":"stream_util.cj","path":"grpc/src/grpc/stream_util.cj","code_tokens":"func chainStreamServerInterceptors ( s : Server ) : Unit {   var interceptors : ArrayList < StreamServerInterceptor > = s . opts . chainStreamInts NL match ( s . opts . streamInt ) { case Some ( v ) => interceptors . append ( v ) NL case None => ( ) NL } NL  var chainedInt : Option < StreamServerInterceptor > = None NL if ( interceptors . size == 0 ) {  chainedInt = None NL } else if ( interceptors . size == 1 ) {  chainedInt = Some ( interceptors [ 0 ] ) NL } else {  chainedInt = Some ( chainStreamInterceptors ( Array < StreamServerInterceptor > ( interceptors ) ) ) NL } NL s . opts . streamInt = chainedInt NL }","func_name":"chainStreamServerInterceptors","docstring":"//Link all stream server interceptors into one."}
{"repo":"grpc","file":"stream_util.cj","path":"grpc/src/grpc/stream_util.cj","code_tokens":"func chainStreamInterceptors ( interceptors : Array < StreamServerInterceptor > ) : StreamServerInterceptor {   func usi ( srv : Any , ss : ServerStream , info : StreamServerInfo , handler : StreamHandler ) : GrpcError {   let state : State = State ( ) NL  func stateNext ( srv : Any , ss : ServerStream ) : GrpcError {  if ( state . index == interceptors . size - 1 ) {  return interceptors [ state . index ] . f ( srv , ss , info , handler ) NL } NL state . index ++ NL return interceptors [ state . index - 1 ] . f ( srv , ss , info , StreamHandler ( state . nextStream ) ) NL } NL state . nextStream = stateNext NL return state . nextStream ( srv , ss ) NL } NL return StreamServerInterceptor ( usi ) NL }","func_name":"chainStreamInterceptors","docstring":""}
{"repo":"grpc","file":"stream_util.cj","path":"grpc/src/grpc/stream_util.cj","code_tokens":"func usi ( srv : Any , ss : ServerStream , info : StreamServerInfo , handler : StreamHandler ) : GrpcError {   let state : State = State ( ) NL  func stateNext ( srv : Any , ss : ServerStream ) : GrpcError {  if ( state . index == interceptors . size - 1 ) {  return interceptors [ state . index ] . f ( srv , ss , info , handler ) NL } NL state . index ++ NL return interceptors [ state . index - 1 ] . f ( srv , ss , info , StreamHandler ( state . nextStream ) ) NL } NL state . nextStream = stateNext NL return state . nextStream ( srv , ss ) NL }","func_name":"usi","docstring":""}
{"repo":"grpc","file":"stream_util.cj","path":"grpc/src/grpc/stream_util.cj","code_tokens":"func stateNext ( srv : Any , ss : ServerStream ) : GrpcError {  if ( state . index == interceptors . size - 1 ) {  return interceptors [ state . index ] . f ( srv , ss , info , handler ) NL } NL state . index ++ NL return interceptors [ state . index - 1 ] . f ( srv , ss , info , StreamHandler ( state . nextStream ) ) NL }","func_name":"stateNext","docstring":""}
{"repo":"grpc","file":"clientInterceptor.cj","path":"grpc/src/grpc/clientInterceptor.cj","code_tokens":"func orderUnaryClientInterceptor ( method : String , req : Message , resp : Message ) : Unit","func_name":"orderUnaryClientInterceptor","docstring":""}
{"repo":"grpc","file":"clientInterceptor.cj","path":"grpc/src/grpc/clientInterceptor.cj","code_tokens":"func orderStreamClientInterceptor ( method : String ) : Unit","func_name":"orderStreamClientInterceptor","docstring":""}
{"repo":"grpc","file":"clientInterceptor.cj","path":"grpc/src/grpc/clientInterceptor.cj","code_tokens":"func orderStreamClientInterceptorReq ( req : Message ) : Unit","func_name":"orderStreamClientInterceptorReq","docstring":""}
{"repo":"grpc","file":"clientInterceptor.cj","path":"grpc/src/grpc/clientInterceptor.cj","code_tokens":"func orderStreamClientInterceptorResp ( resp : Message ) : Unit","func_name":"orderStreamClientInterceptorResp","docstring":""}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"public func sendMsg ( m : Message ) : Array < UInt8 > {   let ( hdr , payload , data ) : ( Array < Byte > , Array < Byte > , Array < Byte > ) = prepareMsg ( m , codec ) NL  var csAttemp = ClientStreamAttempt ( this ) NL return csAttemp . sendMsg ( cc . getTarget ( ) , cc . h2conn . getOrThrow ( ) , method , hdr , data ) NL }","func_name":"sendMsg","docstring":"/**\n     * The Function is sendMsg\n     *\n     * @param m of Any\n     *\n     * @return Type of Array<UInt8>\n     */"}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"func prepareMsg ( m : Message , codec : BaseCodec ) : ( Array < Byte > , Array < Byte > , Array < Byte > ) {   let data : Array < Byte > = encode ( codec , m ) NL  let ( hdr , payload ) : ( Array < Byte > , Array < Byte > ) = msgHeader ( data ) NL if ( ! this . cc . compressor . isEmpty ( ) ) {  hdr [ 0 ] = COMPRESSION_MADE NL } NL return ( hdr , payload , Array < Byte > ( data ) ) NL }","func_name":"prepareMsg","docstring":"/*\n     * The Function is prepareMsg\n     *\n     * @param m of Any\n     * @param codec of BaseCodec\n     *\n     * @return Type of (ArrayList<Byte>, ArrayList<Byte>, ArrayList<Byte>)\n     */"}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"public func recvMsg ( output : Message , data : Array < UInt8 > ) : Unit {  BaseCodec ( ) . unmarshal ( ArrayList < UInt8 > ( data ) , output ) NL }","func_name":"recvMsg","docstring":"/**\n     * The Function is recvMsg\n     *\n     * @param output of Any\n     * @param data of Array<UInt8>\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"public func doStreamRequest ( method : String ) : Unit {  if ( method . isEmpty ( ) ) {  throw Exception ( call method is empty ) NL } NL match ( cc . dopts . streamInt ) { case Some ( v ) => v . orderStreamClientInterceptor ( method ) NL case None => ( ) NL } NL  var target = this . cc . getTarget ( ) + method NL  let req : H2Request = H2Request ( RequestMethod . POST , http://${target} ) NL req . header . set ( content-type , application/grpc ) NL req . header . set ( te , trailers ) NL  var data = Array < UInt8 > ( [ 0 ] ) NL  var body = ByteArrayStream ( ) NL body . write ( data ) NL req . body = body NL this . cc . h2conn . getOrThrow ( ) . doStreamRequest ( req ) NL }","func_name":"doStreamRequest","docstring":"/**\n     * The Function is doStreamRequest,do stream request\n     *\n     * @param method of String\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"public func sendStreamMsg ( message : Message ) : Unit {  match ( cc . dopts . streamInt ) { case Some ( v ) => v . orderStreamClientInterceptorReq ( message ) NL case None => ( ) NL } NL  let ( hdr , payload , body ) : ( Array < Byte > , Array < Byte > , Array < Byte > ) = prepareMsg ( message , codec ) NL  let data : ByteArrayStream = handleStreamData ( hdr , body ) NL try {  this . cc . h2conn . getOrThrow ( ) . sendStreamMsg ( data . readToEnd ( ) ) NL } catch ( e : Exception ) {  throw Exception ( data send failed ) NL } NL }","func_name":"sendStreamMsg","docstring":"/**\n     * The Function is doStreamRequest,do stream request\n     *\n     * @param method of String\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"func handleStreamData ( hdr : Array < Byte > , data : Array < Byte > ) : ByteArrayStream {   var ss : ByteArrayStream = ByteArrayStream ( ) NL ss . write ( hdr ) NL ss . write ( data ) NL return ss NL }","func_name":"handleStreamData","docstring":"/*\n     * The Function is handleStreamData,do stream request\n     *\n     * @param hdr of ArrayList<Byte>\n     * @param data of ArrayList<Byte>\n     *\n     * @return Type of ByteArrayStream\n     */"}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"public func closeAndRecv ( ) : ReadStream {  try {   let res = this . cc . h2conn . getOrThrow ( ) . closeAndRecv ( ) NL return ReadStream ( Http2Client ( ) . handleStreamResponse ( res ) , this . cc . dopts . streamInt ) NL } catch ( e : Exception ) {  throw Exception ( stream close failed ) NL } NL }","func_name":"closeAndRecv","docstring":"/**\n     * The Function is closeAndRecv,do stream request\n     *\n     * @param method of String\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"public func recv ( output : Message ) : Bool {  if ( index + 1 > size ) {  return false NL } NL recvStreamMsg ( output , ArrayList ( bytebuffer [ index ] ) ) NL match ( this . streamInt ) { case Some ( v ) => v . orderStreamClientInterceptorResp ( output ) NL case None => ( ) NL } NL index ++ NL return true NL }","func_name":"recv","docstring":""}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"private func recvStreamMsg ( output : Message , data : ArrayList < UInt8 > ) : Unit {  BaseCodec ( ) . unmarshal ( data , output ) NL }","func_name":"recvStreamMsg","docstring":""}
{"repo":"grpc","file":"clientstream.cj","path":"grpc/src/grpc/clientstream.cj","code_tokens":"func sendMsg ( target : String , h2conn : H2ClientConn , method : String , hdr : Array < Byte > , data : Array < Byte > ) : Array < UInt8 > {  return t . write ( target + method , h2conn , hdr , data ) NL }","func_name":"sendMsg","docstring":"/**\n     * The Function is sendMsg\n     *\n     * @param m of Any\n     *\n     * @return Type of Array<UInt8>\n     */"}
{"repo":"grpc","file":"server_stream_util.cj","path":"grpc/src/grpc/server_stream_util.cj","code_tokens":"public func defaultAnyAndServerStreamToGrpcError ( any : Any , ss : ServerStream ) : GrpcError {  return NULL_ERR NL }","func_name":"defaultAnyAndServerStreamToGrpcError","docstring":""}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func invoke ( method : String , input : Message , output : Message ) : Any {  if ( this . csMgr . getState ( ) == ConState . SHUTDOWN ) {  throw Exception ( connect is isClosed ) NL } NL if ( method . isEmpty ( ) ) {  throw Exception ( call method is method ) NL } NL  var cs = ClientStream ( this , method ) NL  let result : Array < UInt8 > = cs . sendMsg ( input ) NL cs . recvMsg ( output , result ) NL match ( dopts . unaryInt ) { case Some ( v ) => v . orderUnaryClientInterceptor ( method , input , output ) NL case None => ( ) NL } NL return output NL }","func_name":"invoke","docstring":"/**\n     * The Function is invoke\n     *\n     * @param method of String\n     * @param input of Any\n     * @param output of Any\n     *\n     * @return Type of Any\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func getTarget ( ) : String {  return this . target NL }","func_name":"getTarget","docstring":"/**\n     * The Function is getTarget\n     *\n     * @return Type of String\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func close ( ) {  if ( ! this . socket . getOrThrow ( ) . isClosed ( ) ) {  this . socket . getOrThrow ( ) . close ( ) NL this . csMgr . updateState ( ConState . SHUTDOWN ) NL } NL }","func_name":"close","docstring":"/**\n     * The Function is close\n     *\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func getState ( ) : ConState {  return this . csMgr . getState ( ) NL }","func_name":"getState","docstring":"/**\n     * The Function is getState\n     *\n     * @return Type of ConState\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func newAddrConn ( addr : String ) : Unit {   let ( ip , port ) = handleTarget ( addr ) NL  let socket : Socket = Socket ( TCP , ip , port ) NL socket . connect ( ) NL  var newaddr = AddrConn ( ClientConn ( addr , socket ) ) NL newaddr . updateConnectivityState ( ConState . CONNECTING ) NL this . conns . append ( newaddr ) NL }","func_name":"newAddrConn","docstring":"/**\n     * The Function is newAddrConn\n     *\n     * @param addr of String\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func WaitForStateChange ( sourceState : ConState ) : Bool {  while ( true ) {  if ( this . csMgr . getState ( ) == sourceState ) {  return true NL } NL if ( this . csMgr . getState ( ) == INVALID_STATE ) {  break NL } NL return false NL } NL return false NL }","func_name":"WaitForStateChange","docstring":"/**\n     * The Function is WaitForStateChange\n     *\n     * @param sourceState of ConState\n     *\n     * @return Type of Bool\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"private func GetServiceConfig ( ) : ServiceConfig {  return this . sc NL }","func_name":"GetServiceConfig","docstring":"/*\n     * The Function is GetServiceConfig\n     *\n     * @return Type of ServiceConfig\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func GetMethodConfig ( method : String ) : MethodConfig {   var sc = GetServiceConfig ( ) NL if ( getTarget ( ) . isEmpty ( ) ) {  return MethodConfig ( ) NL } NL if ( sc . Methods . contains ( method ) ) {  return sc . Methods . get ( method ) . getOrThrow ( ) NL } NL throw Exception ( method: ${method} not found ) NL }","func_name":"GetMethodConfig","docstring":"/**\n     * The Function is GetMethodConfig\n     *\n     * @param method of String\n     *\n     * @return Type of MethodConfig\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func parseTargetAndFindResolver ( ) : ( resolver . Builder ) {   var rb : resolver . Builder NL if ( ! this . target . contains ( / ) ) {  this . parsedTarget . endpoint = this . target NL return get ( getDefaultScheme ( ) ) NL } NL  var ( parsedTarget , err ) = parseTarget ( this . target ) NL if ( ! err . isNull ( ) ) {  throw Exception ( dial target ${this.target} parse failed: %v ) NL } else {  rb = this . getResolver ( parsedTarget . scheme ) NL this . parsedTarget = parsedTarget NL return rb NL } NL }","func_name":"parseTargetAndFindResolver","docstring":""}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func getResolver ( scheme : String ) : resolver . Builder {  for ( rb in this . dopts . resolvers ) {  if ( scheme == rb . scheme ( ) ) {  return rb NL } NL } NL return resolver . get ( scheme ) NL }","func_name":"getResolver","docstring":""}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func newStreamClient ( ) : ClientStream {  match ( this . socket ) { case None => throw Exception ( socket is not connected ) NL case Some ( v ) => ( ) NL } NL if ( this . csMgr . getState ( ) == ConState . SHUTDOWN ) {  throw Exception ( connect is isClosed ) NL } NL return ClientStream ( this ,  ) NL }","func_name":"newStreamClient","docstring":"/**\n     * The Function is newStreamClient\n     *\n     * @return Type of ClientStream\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func useCompressor ( ) : Unit {  this . compressor = zlib NL }","func_name":"useCompressor","docstring":"/**\n     * The Function is useCompressor\n     * enable gzip Compressor\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func dial ( target : String , cfg ! : TlsClientConfig = TlsClientConfig (  ) ) : ClientConn {  if ( target . isEmpty ( ) ) {  throw Exception ( empty address ) NL } NL return dialContext ( target , ArrayList < DialOption > ( ) , cfg ) NL }","func_name":"dial","docstring":"/**\n * The Function is dial\n *\n * @param target of String\n *\n * @return Type of ClientConn\n */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"public func dial ( target : String , opts : ArrayList < DialOption > , cfg ! : TlsClientConfig = TlsClientConfig (  ) ) : ClientConn {  if ( target . isEmpty ( ) ) {  throw Exception ( empty address ) NL } NL return dialContext ( target , opts , cfg ) NL }","func_name":"dial","docstring":"/**\n * The Function is dial\n *\n * @param target of String\n *\n * @return Type of ClientConn\n */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func dialContext ( target : String , opts : ArrayList < DialOption > , cfg : TlsClientConfig ) : ClientConn {  initPassThrough ( ) NL  var con = ClientConn ( ) NL con . target = target NL for ( opt in opts ) {  opt . apply ( con . dopts ) NL } NL  var resolverBuilder = con . parseTargetAndFindResolver ( ) NL  var ( res , err ) = resolverBuilder . build ( con . parsedTarget ) NL res . resolveNow ( resolver . ResolveNowOptions ( ) ) NL  var resolved = res . getTarget ( ) NL res . close ( ) NL  let ( ip , port ) = handleTarget ( resolved ) NL  let noneTls : Bool = cfg . caFile . isEmpty ( ) NL  let socket : Socket = Socket ( TCP , ip , port ) NL  let tlsSocket : TlsSocket = TlsSocket ( TCP , ip , port , cfg ) NL try {  if ( noneTls ) {  socket . connect ( ) NL socket . noDelay = true NL socket . quickAck = true NL } else {  tlsSocket . connect ( ) NL } NL } catch ( e : Exception ) {  throw Exception ( connect failed ) NL } NL con . target = resolved NL if ( noneTls ) {  con . socket = socket NL con . h2conn = H2ClientConn . createClientConn ( H2Transport ( ) , SyncSockClient . build ( socket ) ) NL } else {  con . h2conn = H2ClientConn . createClientConn ( H2Transport ( ) , SyncSockClient . build ( tlsSocket ) ) NL } NL for ( opt in opts ) {  opt . apply ( con . dopts ) NL } NL return con NL }","func_name":"dialContext","docstring":"/*\n * The Function is dialContext\n *\n * @param target of String\n *\n * @return Type of ClientConn\n */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func updateState ( state : ConState ) {  lock . lock ( ) NL if ( this . state == ConState . SHUTDOWN ) {  lock . unlock ( ) NL return NL } NL if ( this . state == state ) {  lock . unlock ( ) NL return NL } NL this . state = state NL lock . unlock ( ) NL }","func_name":"updateState","docstring":"/*\n     * The Function is updateState\n     *\n     * @param state of ConState\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func getState ( ) : ConState {  lock . lock ( ) NL  var state = this . state NL lock . unlock ( ) NL return state NL }","func_name":"getState","docstring":"/**\n     * The Function is getState\n     *\n     * @return Type of ConState\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func updateConnectivityState ( s : ConState ) {  if ( this . state == s ) {  return NL } NL this . state = s NL }","func_name":"updateConnectivityState","docstring":"/*\n     * The Function is updateConnectivityState\n     *\n     * @param s of ConState\n     */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func parseTarget ( target : String ) : ( resolver . Target , GrpcError ) {   var u = Parse ( target ) NL  var endpoint = u . Path NL if ( endpoint ==  ) {  endpoint = u . Opaque NL } NL endpoint = trimPrefix ( endpoint , / ) NL  var newtarget = resolver . Target ( ) NL newtarget . scheme = u . Scheme NL newtarget . authority = u . Host NL newtarget . endpoint = endpoint NL newtarget . url = u NL return ( newtarget , NULL_ERR ) NL }","func_name":"parseTarget","docstring":""}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func trimPrefix ( s : String , prefix : String ) : String {  if ( hasPrefix ( s , prefix ) ) {  return s [ prefix . size .. ] NL } NL return s NL }","func_name":"trimPrefix","docstring":"/**\n * TrimPrefix returns s without the provided leading prefix string.\n * If s doesn't start with prefix, s is returned unchanged.\n */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func hasPrefix ( s : String , prefix : String ) : Bool {  return s . size > = prefix . size && s [ 0 .. prefix . size ] == prefix NL }","func_name":"hasPrefix","docstring":"/**\n * HasPrefix tests whether the string s begins with prefix.\n */"}
{"repo":"grpc","file":"clientconn.cj","path":"grpc/src/grpc/clientconn.cj","code_tokens":"func handleTarget ( target : String ) : ( String , UInt16 ) {   var ipaddress = target . split ( / ) [ 0 ] NL  var address = ipaddress . split ( : ) NL return ( address [ 0 ] . toString ( ) , UInt16 . parse ( address [ 1 ] . toString ( ) ) ) NL }","func_name":"handleTarget","docstring":"/*\n * The Function is handleTarget\n *\n * @param target of String\n *\n * @return Type of (String, UInt16)\n */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"func clientHandshake ( s : String , socket : Socket ) : ( Socket , AuthInfo )","func_name":"clientHandshake","docstring":"/*\n     * The Function is clientHandshake\n     *\n     * @param s of String\n     * @param socket of Socket\n     *\n     * @return Type of (Socket, AuthInfo)\n     */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"func serverHandshake ( socket : Socket ) : ( Socket , AuthInfo )","func_name":"serverHandshake","docstring":"/*\n     * The Function is serverHandshake\n     *\n     * @param socket of Socket\n     *\n     * @return Type of (Socket, AuthInfo)\n     */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"func info ( ) : ProtocolInfo","func_name":"info","docstring":"/*\n     * The Function is info\n     *\n     * @return Type of ProtocolInfo\n     */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"func clone ( ) : TransportCredentials","func_name":"clone","docstring":"/*\n     * The Function is clone\n     *\n     * @return Type of TransportCredentials\n     */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"func overrideServerName ( s : String ) : Unit","func_name":"overrideServerName","docstring":"/*\n     * The Function is overrideServerName\n     *\n     * @param s of String\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"func getRequestMetadata ( uri : ArrayList < String > ) : ( HashMap < String , String > )","func_name":"getRequestMetadata","docstring":""}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"func requireTransportSecurity ( ) : Bool","func_name":"requireTransportSecurity","docstring":""}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"public func clientHandshake ( s : String , socket : Socket ) : ( Socket , AuthInfo ) {   var commonAuthInfo = CommonAuthInfo ( ) NL commonAuthInfo . securityLevel = SecurityLevel . NoSecurity NL return ( socket , Info ( commonAuthInfo ) ) NL }","func_name":"clientHandshake","docstring":"/*\n     * The Function is clientHandshake\n     *\n     * @param s of String\n     * @param socket of Socket\n     *\n     * @return Type of (Socket, AuthInfo)\n     */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"public func serverHandshake ( socket : Socket ) : ( Socket , AuthInfo ) {   var commonAuthInfo = CommonAuthInfo ( ) NL commonAuthInfo . securityLevel = SecurityLevel . NoSecurity NL return ( socket , Info ( commonAuthInfo ) ) NL }","func_name":"serverHandshake","docstring":"/*\n     * The Function is serverHandshake\n     *\n     * @param socket of Socket\n     *\n     * @return Type of (Socket, AuthInfo)\n     */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"public func info ( ) : ProtocolInfo {   var protoinfo = ProtocolInfo ( ) NL protoinfo . securityProtocol = insecure NL return protoinfo NL }","func_name":"info","docstring":"/*\n     * The Function is info\n     *\n     * @return Type of ProtocolInfo\n     */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"public func clone ( ) : TransportCredentials {  return this NL }","func_name":"clone","docstring":"/*\n     * The Function is clone\n     *\n     * @return Type of TransportCredentials\n     */"}
{"repo":"grpc","file":"credentials.cj","path":"grpc/src/grpc/credentials.cj","code_tokens":"public func overrideServerName ( s : String ) : Unit {  }","func_name":"overrideServerName","docstring":"/*\n     * The Function is overrideServerName\n     *\n     * @param s of String\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"url.cj","path":"grpc/src/grpc/url.cj","code_tokens":"func Parse ( rawURL : String ) : URL {   var ( u , frag , _ ) = cut ( rawURL , # ) NL  var url = parse ( u , false ) NL if ( frag . isEmpty ( ) ) {  return url NL } NL url . Fragment = frag NL return url NL }","func_name":"Parse","docstring":"/**\n * Parse parses a raw url into a URL structure.\n * The url may be relative (a path, without a host) or absolute\n * (starting with a scheme). Trying to parse a hostname and path\n * without a scheme is invalid but may not necessarily return an\n * error, due to parsing ambiguities.\n */"}
{"repo":"grpc","file":"url.cj","path":"grpc/src/grpc/url.cj","code_tokens":"func cut ( s : String , sep : String ) : ( String , String , Bool ) {   var i = s . indexOf ( sep ) NL match ( i ) { case Some ( v ) => return ( s [ .. v ] , s [ v + sep . size .. ] , true ) NL case None => return ( s ,  , false ) NL } NL }","func_name":"cut","docstring":"/*\n * The Function is cut url\n * Cut slices s around the first instance of sep,\n * returning the text before and after sep.\n * The found result reports whether sep appears in s.\n * If sep does not appear in s, cut returns s, \"\", false.\n */"}
{"repo":"grpc","file":"url.cj","path":"grpc/src/grpc/url.cj","code_tokens":"func parse ( rawURL : String , viaRequest : Bool ) : URL {   var err : GrpcError NL if ( stringContainsCTLByte ( rawURL ) ) {  throw Exception ( net/url: invalid control character in URL ) NL } NL if ( rawURL ==  && viaRequest ) {  throw Exception ( empty url ) NL } NL  var url = URL ( ) NL if ( rawURL == * ) {  url . Path = * NL return url NL } NL  var ( scheme , rest ) = getScheme ( rawURL ) NL url . Scheme = scheme . toAsciiLower ( ) NL if ( ! ( rest [ 0 ] == / ) ) {  throw Exception ( first path segment in URL is not '/' ) NL } NL if ( url . Scheme !=  || ! viaRequest && ! ( rest [ .. 3 ] == /// ) && ! ( rest [ .. 2 ] == // ) ) {   var authority : String NL authority = rest [ 2 .. ] NL  var i = authority . indexOf ( / ) . getOrThrow ( ) NL if ( i > = 0 ) {  rest = authority [ i .. ] NL authority = authority [ .. i ] NL } NL } NL url . Path = rest NL url . RawPath = rawURL NL return url NL }","func_name":"parse","docstring":"/**\n * parse parses a URL from a string in one of two contexts. If\n * viaRequest is true, the URL is assumed to have arrived via an HTTP request,\n * in which case only absolute URLs or path-absolute relative URLs are allowed.\n * If viaRequest is falsetring, all forms of relative URLs are allowed.\n */"}
{"repo":"grpc","file":"url.cj","path":"grpc/src/grpc/url.cj","code_tokens":"func stringContainsCTLByte ( s : String ) : Bool {   var i = 0 NL while ( i < s . size ) {   var b = s [ i ] NL if ( b <   || b ==  ) {  return true NL } NL i ++ NL } NL return false NL }","func_name":"stringContainsCTLByte","docstring":"/*\n * stringContainsCTLByte reports whether s contains any ASCII control character.\n */"}
{"repo":"grpc","file":"url.cj","path":"grpc/src/grpc/url.cj","code_tokens":"func getScheme ( rawURL : String ) : ( String , String ) {   var i = 0 NL while ( i < rawURL . size ) {   var c = rawURL [ i ] NL if ( a <= c && c <= z || A <= c && c <= Z ) {  i ++ NL continue NL } else if ( 0 <= c && c <= 9 || c == + || c == - || c == . ) {  if ( i == 0 ) {  throw Exception ( scheme firest character cannot be ${c} ) NL } NL i ++ NL continue NL } else if ( c == : ) {  if ( i == 0 ) {  throw Exception ( missing protocol scheme ) NL } NL return ( rawURL [ .. i ] , rawURL [ i + 1 .. ] ) NL } else {  throw Exception ( scheme encountered an invalid character ${c} ) NL } NL } NL throw Exception ( scheme encountered an invalid character 2 ) NL }","func_name":"getScheme","docstring":"/**\n * Maybe rawURL is of the form scheme:path.\n * (Scheme must be [a-zA-Z][a-zA-Z0-9+-.]*)\n * If so, return scheme, path; else return \"\", rawURL.\n */"}
{"repo":"grpc","file":"stream.cj","path":"grpc/src/grpc/stream.cj","code_tokens":"func sendMsg ( m : Message ) : Array < UInt8 >","func_name":"sendMsg","docstring":"/*\n     * The Function is sendMsg\n     *\n     * @param m of Any\n     *\n     * @return Type of ArrayList<UInt8>\n     */"}
{"repo":"grpc","file":"stream.cj","path":"grpc/src/grpc/stream.cj","code_tokens":"func recvMsg ( output : Message , data : Array < UInt8 > ) : Unit","func_name":"recvMsg","docstring":"/*\n     * The Function is recvMsg\n     *\n     * @param output of Any\n     * @param data of ArrayList<UInt8>\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"stream.cj","path":"grpc/src/grpc/stream.cj","code_tokens":"public func isNull ( ) : Bool {  return this . isNone NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"connectivity.cj","path":"grpc/src/grpc/connectivity.cj","code_tokens":"public func toString ( ) : String {  return match ( this ) { case IDLE => IDLE NL case CONNECTING => CONNECTING NL case READY => READY NL case TRANSIENT_FAILURE => TRANSIENT_FAILURE NL case SHUTDOWN => SHUTDOWN NL case INVALID_STATE => INVALID_STATE NL } NL }","func_name":"toString","docstring":"/**\n     * The Function is toString\n     *\n     * @return Type of String\n     */"}
{"repo":"grpc","file":"connectivity.cj","path":"grpc/src/grpc/connectivity.cj","code_tokens":"public operator func == ( that : ConState ) : Bool {  match ( ( this , that ) ) { case ( IDLE , IDLE ) => true NL case ( CONNECTING , CONNECTING ) => true NL case ( READY , READY ) => true NL case ( TRANSIENT_FAILURE , TRANSIENT_FAILURE ) => true NL case ( SHUTDOWN , SHUTDOWN ) => true NL case ( INVALID_STATE , INVALID_STATE ) => true NL case _ => false NL } NL }","func_name":"==","docstring":"/**\n     * The Function is ==\n     *\n     * @param that of ConState\n     *\n     * @return Type of Bool\n     */"}
{"repo":"grpc","file":"connectivity.cj","path":"grpc/src/grpc/connectivity.cj","code_tokens":"public operator func != ( that : ConState ) : Bool {  return ! ( this == that ) NL }","func_name":"!=","docstring":"/**\n     * The Function is !=\n     *\n     * @param that of ConState\n     *\n     * @return Type of Bool\n     */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"func apply ( so : ServerOptions ) : Unit","func_name":"apply","docstring":"/*\n     * The Function is apply\n     *\n     * @param so of ServerOptions\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func apply ( sOptions : ServerOptions ) : Unit {  f ( sOptions ) NL }","func_name":"apply","docstring":"/*\n     * The Function is apply\n     *\n     * @param so of ServerOptions\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"func newFuncServerOption ( soFunc : ( ServerOptions ) -> Unit ) : FuncServerOption {  return FuncServerOption ( soFunc ) NL }","func_name":"newFuncServerOption","docstring":""}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func chainStreamInterceptor ( interceptors : Array < StreamServerInterceptor > ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . chainStreamInts . appendAll ( interceptors ) NL } ) NL }","func_name":"chainStreamInterceptor","docstring":"/**\n * Returns a ServerOption, which specifies the link interceptor of streaming RPC.\n * The first interceptor will be the outermost,\n * and the last interceptor will be the innermost wrapper that is actually called.\n * All flow interceptors added by this method will be linked.\n *\n * @param interceptors of Array<StreamServerInterceptor>\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func chainUnaryInterceptor ( interceptors : Array < UnaryServerInterceptor > ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . chainUnaryInts . appendAll ( interceptors ) NL } ) NL }","func_name":"chainUnaryInterceptor","docstring":"/**\n * Returns a ServerOption, which specifies the link interceptor of a unary RPC.\n * The first interceptor will be the outermost,\n * and the last interceptor will be the innermost wrapper that is actually called.\n * All unary interceptors added by this method will be linked.\n *\n * @param interceptors of Array<UnaryServerInterceptor>\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func connectionTimeout ( d : Duration ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . connectionTimeout = d NL } ) NL }","func_name":"connectionTimeout","docstring":"/**\n * A ServerOption is returned,\n * which sets the connection establishment timeout (including HTTP/2 handshake) for all new connections.\n * If not set, the default value is 120 seconds.\n * A zero or negative value causes an immediate timeout.\n * Experimental. Note: This API is experimental and may be changed or deleted in future versions.\n *\n * @param d of Duration\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func customCodec ( codec : BaseCodec ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . codec = codec NL } ) NL }","func_name":"customCodec","docstring":"/**\n * Returns a ServerOption that sets the codec used for message marshaling and unmarshalling.\n * This overrides any content subtype lookups for codecs registered through RegisterCodec.\n *\n * @param codec of BaseCodec\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func headerTableSize ( num : UInt32 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . headerTableSize = num NL } ) NL }","func_name":"headerTableSize","docstring":"/**\n * Returns a ServerOption used to set the size of the dynamic header table of the stream.\n * Experimental. Note: This API is experimental and may be changed or deleted in future versions.\n *\n * @param num of UInt32\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func inTapHandle ( handle : ServerInHandle ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . inTapHandle = handle NL } ) NL }","func_name":"inTapHandle","docstring":"/**\n * Returns a ServerOption, which sets the click handles of all server transfers to be created.\n * Only one can be installed.\n * Experimental. Note: This API is experimental and may be changed or deleted in future versions.\n *\n * @param handle of ServerInHandle\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func initialConnWindowSize ( s : Int32 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . initialConnWindowSize = s NL } ) NL }","func_name":"initialConnWindowSize","docstring":"/**\n * Returns the server option to set the size of the connection window.\n * The minimum window size is 64K. Any value smaller than this value will be ignored.\n *\n * @param s of Int32\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func setInitialWindowSize ( num : Int32 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . initialWindowSize = num NL } ) NL }","func_name":"setInitialWindowSize","docstring":"/**\n * Returns a ServerOption used to set the window size of the stream.\n * The minimum window size is 64K. Any value smaller than this value will be ignored.\n *\n * @param num of Int32\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func keepaliveEnforcementPolicy ( ep : EnforcementPolicy ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . keepalivePolicy = ep NL } ) NL }","func_name":"keepaliveEnforcementPolicy","docstring":"/**\n * Returns the ServerOption that sets the keepalive enforcement policy for the server.\n *\n * @param ep of EnforcementPolicy\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func keepaliveParams ( kp : ServerParameters ) : ServerOption {  if ( kp . time > EMPTY_TIME && kp . time < Duration . second ( 1 ) ) {  kp . time = Duration . second ( 1 ) NL } NL return newFuncServerOption ( { so : ServerOptions => so . keepaliveParams = kp NL } ) NL }","func_name":"keepaliveParams","docstring":"/**\n * Returns a ServerOption, which is used to set the keepalive and max age parameters of the server.\n *\n * @param kp of ServerParameters\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func maxConcurrentStreams ( mc : UInt32 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . maxConcurrentStreams = mc NL } ) NL }","func_name":"maxConcurrentStreams","docstring":"/**\n * Returns a ServerOption that limits the number of concurrent streams per ServerTransport.\n *\n * @param mc of UInt32\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func maxHeaderListSize ( num : UInt32 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . maxHeaderListSize = num NL } ) NL }","func_name":"maxHeaderListSize","docstring":"/**\n * Returns a ServerOption that sets the maximum (uncompressed) size of the header list that the server is prepared to accept.\n *\n * @param num of UInt32\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func maxMsgSize ( m : Int64 ) : ServerOption {  return maxRecvMsgSize ( m ) NL }","func_name":"maxMsgSize","docstring":"/**\n * Returns a ServerOption to set the maximum message size (in bytes) that the server can receive.\n * If not set, gRPC uses the default limit.\n *\n * @param m of Int64\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func maxRecvMsgSize ( mr : Int64 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . maxReceiveMessageSize = mr NL } ) NL }","func_name":"maxRecvMsgSize","docstring":"/**\n * Returns the server option to set the maximum message size (in bytes) that the server can receive.\n * If not set, gRPC uses the default 4MB.\n *\n * @param mr of Int64\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func maxSendMsgSize ( num : Int64 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . maxSendMessageSize = num NL } ) NL }","func_name":"maxSendMsgSize","docstring":"/**\n * Returns the server option to set the maximum message size (in bytes) that the server can send.\n * If not set, gRPC will use the default \"math. MaxInt32\".\n *\n * @param num of Int64\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func numStreamWorkers ( num : UInt32 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . numServerWorkers = num NL } ) NL }","func_name":"numStreamWorkers","docstring":"/**\n * Returns a ServerOption, which sets the number of goroutines applied to the worker process processing incoming streams.\n * Setting it to zero (the default) disables the worker and generates a new goroutine for each flow.\n * Experimental. Note: This API is experimental and may be changed or deleted in future versions.\n *\n * @param num of UInt32\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func readBufferSize ( s : Int64 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . readBufferSize = s NL } ) NL }","func_name":"readBufferSize","docstring":"/**\n * Allows you to set the size of the read buffer, which determines how much data can be read at most in a read system call.\n * The default value for this buffer is 32KB.\n * Zero disables the connected read buffer so that the data framer can directly access the underlying conn.\n *\n * @param s of Int64\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func statsHandler ( h : GrpcHandler ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . statsHandlers . append ( h ) NL } ) NL }","func_name":"statsHandler","docstring":"/**\n * Returns a ServerOption, which is used to set the statistics handler of the server.\n *\n * @param h of GrpcHandler\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func streamInterceptor ( si : StreamServerInterceptor ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => match ( so . streamInt ) { case Some ( v ) => throw Exception ( The stream server interceptor was already set and may not be reset. ) NL case None => so . streamInt = si NL } NL } ) NL }","func_name":"streamInterceptor","docstring":"/**\n * Returns a ServerOption, which sets the StreamServerInterceptor of the server.\n * Only one stream interceptor can be installed.\n *\n * @param si of StreamServerInterceptor\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func unaryInterceptor ( usi : UnaryServerInterceptor ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => match ( so . unaryInt ) { case Some ( v ) => throw Exception ( The unary server interceptor was already set and may not be reset. ) NL case None => so . unaryInt = usi NL } NL } ) NL }","func_name":"unaryInterceptor","docstring":"/**\n * Returns the ServerOption of the UnaryServerInterceptor of the setting server.\n * Only one unary interceptor can be installed.\n * The construction of multiple interceptors (such as links) can be implemented in the caller.\n *\n * @param usi of UnaryServerInterceptor\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func unknownServiceHandler ( streamHandler : StreamHandler ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . unknownStreamDesc = StreamDesc ( streamName : unknown_service_handler , clientStreams : true , serverStreams : true , handler : streamHandler ) NL } ) NL }","func_name":"unknownServiceHandler","docstring":"/**\n * Returns the ServerOption that allows adding custom unknown service handlers.\n * The provided method is a bidi streaming RPC service handler.\n * Whenever a request for an unregistered service or method is received,\n * this handler will be called instead of returning an \"unimplemented\" gRPC error.\n * Processing functions and stream interceptors (if set) can fully access ServerStream, including its context.\n *\n * @param streamHandler of StreamHandler\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_option.cj","path":"grpc/src/grpc/server_option.cj","code_tokens":"public func writeBufferSize ( s : Int64 ) : ServerOption {  return newFuncServerOption ( { so : ServerOptions => so . writeBufferSize = s NL } ) NL }","func_name":"writeBufferSize","docstring":"/**\n * Determines how much data can be batched before writing lines.\n * The corresponding memory allocation of this buffer will be twice the size of keeping system calls low.\n * The default value for this buffer is 32KB.\n * Zero disables the write buffer so that each write is on the underlying connection.\n * Note: Sending calls may not be directly converted to writing.\n *\n * @param s of Int64\n *\n * @return Type of ServerOption\n * @since 0.32.5\n */"}
{"repo":"grpc","file":"server_util.cj","path":"grpc/src/grpc/server_util.cj","code_tokens":"public func isNull ( ) : Bool {  return this . isNone NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"server_util.cj","path":"grpc/src/grpc/server_util.cj","code_tokens":"public func close ( ) : Unit {  this . st . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"static public func newServer ( opt : Array < ServerOption > ) : Server {   let opts : ServerOptions = defaultServerOptions NL  let num : Int64 = opt . size NL for ( i in 0 .. num ) {   let so : ServerOption = opt [ i ] NL so . apply ( opts ) NL } NL  let s : Server = Server ( opts : opts ) NL chainUnaryServerInterceptors ( s ) NL chainStreamServerInterceptors ( s ) NL return s NL }","func_name":"newServer","docstring":"/**\n     * A gRPC server will be created.\n     * The server did not register services and did not start accepting requests.\n     *\n     * @param opt of Array<ServerOption>\n     *\n     * @return Type of Server\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"public func registerService ( desc : ServiceDesc , ss : Message ) : Unit {  this . register ( desc , ss ) NL }","func_name":"registerService","docstring":"/**\n     * Service Registration\n     * Call register () to bind the server with the method ss to be called.\n     * You need to check that ss corresponds to desc.HandlerThantype.\n     * Register the service and its implementation with the gRPC server.\n     * It is called from the code generated by IDL.\n     * This must be called before invoking the service.\n     * If ss is non nil (for legacy code), check its type to ensure that it implements sd.HandlerType.\n     *\n     * @param desc of ServiceDesc\n     * @param ss of Any\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"protected func register ( sd : ServiceDesc , ss : Message ) : Unit {  synchronized ( this . mu ) {   let info : ServiceInfoInside = ServiceInfoInside ( serviceImpl : ss , mdata : sd . metadata ) NL  let numm : Int64 = sd . methods . size NL for ( i in 0 .. numm ) {   let md : MethodDesc = sd . methods [ i ] NL info . methods . put ( md . methodName , md ) NL } NL  let nums : Int64 = sd . streams . size NL for ( i in 0 .. nums ) {   let sDesc : StreamDesc = sd . streams [ i ] NL info . streams . put ( sDesc . streamName , sDesc ) NL } NL this . services . put ( sd . serviceName , info ) NL } NL }","func_name":"register","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"public func getServiceInfo ( ) : HashMap < String , ServiceInfo > {   var ret : HashMap < String , ServiceInfo > = HashMap < String , ServiceInfo > ( ) NL  let mif : MethodInfo = MethodInfo ( ) NL for ( ( n , srv ) in this . services ) {   let capacity : Int64 = srv . methods . size + srv . streams . size NL  let methods : Array < MethodInfo > = Array < MethodInfo > ( capacity , item : mif ) NL  var index : Int64 = 0 NL for ( ( m , v ) in srv . methods ) {  methods [ index ] = MethodInfo ( name : m , isClientStream : false , isServerStream : false ) NL index ++ NL } NL for ( ( m , d ) in srv . streams ) {  methods [ index ] = MethodInfo ( name : m , isClientStream : d . clientStreams , isServerStream : d . serverStreams ) NL index ++ NL } NL ret . put ( n , ServiceInfo ( methods : methods , metadata : srv . mdata ) ) NL } NL return ret NL }","func_name":"getServiceInfo","docstring":"/**\n     * Returns the mapping from service name to service information.\n     * The service name includes the package name in the form of<package>and<Service>.\n     *\n     * @return Type of HashMap<String, ServiceInfo>\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"public func serve ( ss : GRPCServerSocket ) : GrpcError {  synchronized ( this . mu ) {  this . server = true NL this . lis . put ( ss , true ) NL } NL  func lastStep ( ) {  synchronized ( this . mu ) {  if ( this . lis . size != 0 && this . lis . contains ( ss ) ) {  ss . close ( ) NL this . lis . remove ( ss ) NL } NL } NL } NL  var err : GrpcError = NULL_ERR NL  let tempDelay : Duration = EMPTY_TIME NL while ( true ) {  try {   let rawConn : GRPCConnSocket = GRPCConnSocket ( ss . accept ( ) ) NL spawn { => this . handleRawConn ( ss . getAddr ( ) . toString ( ) , rawConn ) NL } NL } catch ( e : Exception ) {  err = GrpcError ( GrpcUnknown , e . message ) NL } NL } NL lastStep ( ) NL return err NL }","func_name":"serve","docstring":"/**\n     * Service call\n     * Start the service to accept requests from the listener.\n     * Serve accepts incoming connections on the listener lis and creates a new ServerTransport and service goroutine for each connection.\n     * The service goroutine reads grpc requests and then calls the registered handler to reply to them.\n     * When LIS fails to accept and a fatal error occurs, Serve returns. When this method returns, lis will be closed.\n     * Unless Stop or GracefulStop is called, Serve will return a non-zero error.\n     *\n     * @param ss of GRPCServerSocket\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func lastStep ( ) {  synchronized ( this . mu ) {  if ( this . lis . size != 0 && this . lis . contains ( ss ) ) {  ss . close ( ) NL this . lis . remove ( ss ) NL } NL } NL }","func_name":"lastStep","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"protected func handleRawConn ( lisAddr : String , rawConn : GRPCConnSocket ) : Unit {  rawConn . setDeadline ( this . opts . connectionTimeout ) NL  let st : Option < ServerTransport > = this . newHTTP2Transport ( rawConn ) NL rawConn . setDeadline ( EMPTY_TIME ) NL match ( st ) { case Some ( v ) =>  let st : ServerTransport = v NL if ( ! this . addConn ( lisAddr , v ) ) {  return NL } NL spawn { => this . serveStreams ( v ) NL this . removeConn ( lisAddr , v ) NL } NL case None => return NL } NL }","func_name":"handleRawConn","docstring":"//A goroutine is forked to handle a connection that has just been accepted and has not performed any I/O."}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func addConn ( addr : String , st : ServerTransport ) : Bool {  synchronized ( this . mu ) {  if ( this . drain ) {  st . drain ( ) NL } NL  var stb : HashMap < ServerTransport , Bool > = HashMap < ServerTransport , Bool > ( ) NL if ( this . conns . contains ( addr ) ) {  stb = this . conns [ addr ] NL } NL stb . put ( st , true ) NL this . conns . put ( addr , stb ) NL return true NL } NL }","func_name":"addConn","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func removeConn ( addr : String , st : ServerTransport ) {  synchronized ( this . mu ) {  if ( this . conns . contains ( addr ) ) {   var stHashMap : HashMap < ServerTransport , Bool > = this . conns [ addr ] NL stHashMap . remove ( st ) NL if ( stHashMap . size == 0 ) {  this . conns . remove ( addr ) NL } NL } NL } NL }","func_name":"removeConn","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func serveStreams ( st : ServerTransport ) : Unit {   func insideHS1 ( stream : Stream ) : Unit {  if ( this . opts . numServerWorkers > 0 ) {   let data : ServerWorkerData = ServerWorkerData ( st , stream ) NL spawn { => this . handleStream ( st , stream ) NL } NL } else {  spawn { => this . handleStream ( st , stream ) NL } NL } NL } NL  func insideHS2 ( method : String ) : Unit {  } NL st . handleStreams ( insideHS1 , insideHS2 ) NL st . close ( ) NL }","func_name":"serveStreams","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func insideHS1 ( stream : Stream ) : Unit {  if ( this . opts . numServerWorkers > 0 ) {   let data : ServerWorkerData = ServerWorkerData ( st , stream ) NL spawn { => this . handleStream ( st , stream ) NL } NL } else {  spawn { => this . handleStream ( st , stream ) NL } NL } NL }","func_name":"insideHS1","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func insideHS2 ( method : String ) : Unit {  }","func_name":"insideHS2","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"public func serveHTTP ( w : ResponseWriteStream , r : Request ) : Unit {   let ( st , err ) : ( ServerTransport , GrpcError ) = ServerHandlerTransport . newServerHandlerTransport ( w , r , Array < GrpcHandler > ( this . opts . statsHandlers ) ) NL if ( ! err . isNull ( ) ) {  return NL } NL if ( ! this . addConn ( listenerAddressForServeHTTP , st ) ) {  return NL } NL this . serveStreams ( st ) NL this . removeConn ( listenerAddressForServeHTTP , st ) NL }","func_name":"serveHTTP","docstring":"/**\n     * By responding to the gRPC request r and finding the requested gRPC method in the gRPC server s,\n     * the http handler interface of the Go standard library is implemented.\n     * The provided HTTP request must arrive through an HTTP/2 connection.\n     * When using the server of the Go standard library, this actually means that the request must also arrive through TLS.\n     *\n     * @param w of ResponseWriteStream\n     * @param r of Request\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func handleStream ( t : ServerTransport , stream : Stream ) : Unit {   var sm : String = stream . getMethod ( ) NL sm = clearHeadAndTailControlCharacters ( sm ) NL if ( ! sm . isEmpty ( ) && sm [ 0 ] == / ) {  sm = sm . substring ( 1 ) NL } NL  let pos : Int64 = sm . lastIndexOf ( / ) ?? - 1 NL  var err : GrpcError = NULL_ERR NL if ( pos == - 1 ) {  err = t . writeStatus ( stream , GrpcError ( Unimplemented , malformed method name: ${sm} ) ) NL return NL } NL  let service : String = sm [ 0 .. pos ] NL  let method : String = sm [ ( pos + 1 ) .. sm . size ] NL  let knownService : Bool = this . services . contains ( service ) NL if ( knownService ) {   let srv : ServiceInfoInside = this . services [ service ] NL if ( srv . methods . contains ( method ) ) {   let md : MethodDesc = srv . methods [ method ] NL this . processUnaryRPC ( t , stream , srv , md ) NL return NL } NL if ( srv . streams . contains ( method ) ) {   let sd : StreamDesc = srv . streams [ method ] NL this . processStreamingRPC ( t , stream , srv , sd ) NL return NL } NL } NL  let unknownDesc : StreamDesc = this . opts . unknownStreamDesc NL if ( ! unknownDesc . isNull ( ) ) {  this . processStreamingRPC ( t , stream , ServiceInfoInside ( isNone : true ) , unknownDesc ) NL return NL } NL  var errDesc : String =  NL if ( ! knownService ) {  errDesc = unknown service  + service NL } else {  errDesc = unknown method ${method} for service ${service} NL } NL err = t . writeStatus ( stream , GrpcError ( Unimplemented , errDesc ) ) NL }","func_name":"handleStream","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func processUnaryRPC ( t : ServerTransport , stream : Stream , info : ServiceInfoInside , md : MethodDesc ) : GrpcError {   let shs : Array < GrpcHandler > = Array < GrpcHandler > ( this . opts . statsHandlers ) NL  var err : GrpcError = GrpcError ( ) NL  let ( hasLastStep , statsBegin ) : ( Bool , Begin ) = this . processUnaryRPCStart ( shs ) NL  func lastStep ( ) {   let num : Int64 = shs . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = shs [ i ] NL  let end : End = End ( beginTime : statsBegin . beginTime , endTime : Time . now ( ) ) NL if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  end . error = toRPCErr ( err ) NL } NL sh . handleRPC ( end ) NL } NL if ( isOn ( ) ) {  if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  this . incrCallsFailed ( ) NL } else {  this . incrCallsSucceeded ( ) NL } NL } NL } NL  let payInfo : PayloadInfo = PayloadInfo ( ) NL  var ( d , errd ) : ( Array < UInt8 > , GrpcError ) = recvAndDecompress ( Parser ( r : stream ) , stream , this . opts . maxReceiveMessageSize , payInfo ) NL if ( ! errd . isNull ( ) ) {  err = t . writeStatus ( stream , errd ) NL if ( hasLastStep ) {  lastStep ( ) NL } NL return errd NL } NL if ( isOn ( ) ) {  t . incrMsgRecv ( ) NL } NL  let ddf : Array < UInt8 > = d NL  let errdf : GrpcError = err NL  let payInfodf : PayloadInfo = payInfo NL  let hasLastStepdf : Bool = hasLastStep NL  let getCodecStr : String = stream . getContentSubtype ( ) NL  func df ( v : Message ) : GrpcError {  getCodec ( ) . unmarshal ( ArrayList < UInt8 > ( ddf ) , v ) NL if ( ! errdf . isNull ( ) ) {  return GrpcError ( insideInternal , grpc: error unmarshalling request: ${errdf.msg} ) NL } NL  let num : Int64 = shs . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = shs [ i ] NL sh . handleRPC ( InPayload ( recvTime : Time . now ( ) , payload : v , wireLength : payInfodf . wireLength + headerLen , data : ddf , length : ddf . size ) ) NL } NL return NULL_ERR NL } NL  let ( reply , appErr ) : ( Message , GrpcError ) = md . handler ( info . serviceImpl , df , this . opts . unaryInt ) NL err = this . processUnaryRPCEnd ( reply , appErr , t , stream ) NL if ( hasLastStep ) {  lastStep ( ) NL } NL return err NL }","func_name":"processUnaryRPC","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func lastStep ( ) {   let num : Int64 = shs . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = shs [ i ] NL  let end : End = End ( beginTime : statsBegin . beginTime , endTime : Time . now ( ) ) NL if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  end . error = toRPCErr ( err ) NL } NL sh . handleRPC ( end ) NL } NL if ( isOn ( ) ) {  if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  this . incrCallsFailed ( ) NL } else {  this . incrCallsSucceeded ( ) NL } NL } NL }","func_name":"lastStep","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func df ( v : Message ) : GrpcError {  getCodec ( ) . unmarshal ( ArrayList < UInt8 > ( ddf ) , v ) NL if ( ! errdf . isNull ( ) ) {  return GrpcError ( insideInternal , grpc: error unmarshalling request: ${errdf.msg} ) NL } NL  let num : Int64 = shs . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = shs [ i ] NL sh . handleRPC ( InPayload ( recvTime : Time . now ( ) , payload : v , wireLength : payInfodf . wireLength + headerLen , data : ddf , length : ddf . size ) ) NL } NL return NULL_ERR NL }","func_name":"df","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"private func processUnaryRPCStart ( shs : Array < GrpcHandler > ) : ( Bool , Begin ) {   var hasLastStep : Bool = false NL  var statsBegin : Begin = Begin ( ) NL  let flagIsOn : Bool = isOn ( ) NL if ( shs . size != 0 || flagIsOn ) {  if ( flagIsOn ) {  this . incrCallsStarted ( ) NL } NL  let num : Int64 = shs . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = shs [ i ] NL  let beginTime : Time = Time . now ( ) NL statsBegin = Begin ( beginTime : beginTime , isClientStream : false , isServerStream : false ) NL sh . handleRPC ( statsBegin ) NL } NL hasLastStep = true NL } NL return ( hasLastStep , statsBegin ) NL }","func_name":"processUnaryRPCStart","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func processUnaryRPCEnd ( reply : Message , appErr : GrpcError , t : ServerTransport , stream : Stream ) : GrpcError {   var err : GrpcError = GrpcError ( ) NL if ( ! appErr . isNull ( ) ) {  return t . writeStatus ( stream , appErr ) NL } NL err = this . sendResponse ( t , stream , reply ) NL if ( ! err . isNull ( ) ) {  if ( err is EOFError ) {  return err NL } NL return t . writeStatus ( stream , err ) NL } NL if ( isOn ( ) ) {  t . incrMsgSent ( ) NL } NL err = t . writeStatus ( stream , statusOK ) NL return err NL }","func_name":"processUnaryRPCEnd","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func processStreamingRPC ( t : ServerTransport , stream : Stream , info : ServiceInfoInside , sd : StreamDesc ) : GrpcError {   let shs : Array < GrpcHandler > = Array < GrpcHandler > ( this . opts . statsHandlers ) NL  let ( statsBegin , ss ) : ( Begin , ServerStream ) = this . processStreamingRPCStart ( shs , t , stream , sd ) NL  var err : GrpcError = NULL_ERR NL  var hasLastStep : Bool = false NL if ( shs . size != 0 ) {  hasLastStep = true NL } else if ( isOn ( ) ) {  hasLastStep = true NL } NL  func lastStep ( ) {  if ( shs . size != 0 ) {   let end : End = End ( beginTime : statsBegin . beginTime , endTime : Time . now ( ) ) NL if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  end . error = toRPCErr ( err ) NL } NL  let num : Int64 = shs . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = shs [ i ] NL sh . handleRPC ( end ) NL } NL } NL if ( isOn ( ) ) {  if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  this . incrCallsFailed ( ) NL } else {  this . incrCallsSucceeded ( ) NL } NL } NL } NL  var appErr : GrpcError = NULL_ERR NL  let server : Any = 0 NL match ( this . opts . streamInt ) { case Some ( v ) =>  let info : StreamServerInfo = StreamServerInfo ( fullMethod : stream . getMethod ( ) , isClientStream : sd . clientStreams , isServerStream : sd . serverStreams ) NL appErr = this . opts . streamInt . getOrThrow ( ) . f ( server , ss , info , sd . handler ) NL case None => err = sd . handler . f ( server , ss ) NL } NL if ( ! appErr . isNull ( ) ) {  t . writeStatus ( ss . stream , appErr ) NL if ( hasLastStep ) {  lastStep ( ) NL } NL return appErr NL } NL err = t . writeStatus ( ss . stream , statusOK ) NL if ( hasLastStep ) {  lastStep ( ) NL } NL return err NL }","func_name":"processStreamingRPC","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func lastStep ( ) {  if ( shs . size != 0 ) {   let end : End = End ( beginTime : statsBegin . beginTime , endTime : Time . now ( ) ) NL if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  end . error = toRPCErr ( err ) NL } NL  let num : Int64 = shs . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = shs [ i ] NL sh . handleRPC ( end ) NL } NL } NL if ( isOn ( ) ) {  if ( ! err . isNull ( ) && ! ( err is EOFError ) ) {  this . incrCallsFailed ( ) NL } else {  this . incrCallsSucceeded ( ) NL } NL } NL }","func_name":"lastStep","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"private func processStreamingRPCStart ( shs : Array < GrpcHandler > , t : ServerTransport , stream : Stream , sd : StreamDesc ) : ( Begin , ServerStream ) {  if ( isOn ( ) ) {  this . incrCallsStarted ( ) NL } NL  var statsBegin : Begin = Begin ( ) NL if ( shs . size != 0 ) {   let beginTime : Time = Time . now ( ) NL statsBegin = Begin ( beginTime : beginTime , isClientStream : sd . clientStreams , isServerStream : sd . serverStreams ) NL  let num : Int64 = shs . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = shs [ i ] NL sh . handleRPC ( statsBegin ) NL } NL } NL  let ss : ServerStream = ServerStream ( stss : t , stream : stream , parser : Parser ( r : stream ) , codec : this . getCodec ( ) , maxReceiveMessageSize : this . opts . maxReceiveMessageSize , maxSendMessageSize : this . opts . maxSendMessageSize , statsHandler : shs ) NL return ( statsBegin , ss ) NL }","func_name":"processStreamingRPCStart","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func sendResponse ( t : ServerTransport , stream : Stream , msg : Message ) : GrpcError {   var ( data , err ) : ( Array < Byte > , GrpcError ) = encodeGrpc ( this . getCodec ( ) , msg ) NL if ( ! err . isNull ( ) ) {  return err NL } NL  let compress : String = stream . getRecvCompress ( ) NL  var compData : Array < Byte > = EMPTY_ARRAY NL if ( compress == gzip ) {   let ( dataCompress , errCom ) : ( Array < Byte > , GrpcError ) = compressGRPC ( data ) NL if ( ! errCom . isNull ( ) ) {   let strError : String = grpc: server failed to compress response:  + errCom . msg NL errCom . msg = strError NL return errCom NL } NL compData = dataCompress NL } NL  let ( hdr , payload ) : ( Array < Byte > , Array < Byte > ) = msgHeader ( data , compData ) NL if ( payload . size > this . opts . maxSendMessageSize ) {  return GrpcError ( ResourceExhausted , grpc: trying to send message larger than max (${payload.size} vs. ${this.opts.maxSendMessageSize}) ) NL } NL err = t . write ( stream , hdr , payload ) NL if ( ! err . isNull ( ) ) {  for ( sh in this . opts . statsHandlers ) {  sh . handleRPC ( OutPayload . getOutPayload ( false , msg , data , payload , Time . now ( ) ) ) NL } NL } NL return err NL }","func_name":"sendResponse","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func getCodec ( ) : BaseCodec {  return this . opts . codec NL }","func_name":"getCodec","docstring":"//ContentSubtype must be lowercase and cannot return nil"}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func incrCallsStarted ( ) : Unit {  this . czData . callsStarted += 1 NL this . czData . lastCallStartedTime = unixNano ( ) NL }","func_name":"incrCallsStarted","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func incrCallsSucceeded ( ) : Unit {  this . czData . callsSucceeded += 1 NL }","func_name":"incrCallsSucceeded","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"func incrCallsFailed ( ) : Unit {  this . czData . callsFailed += 1 NL }","func_name":"incrCallsFailed","docstring":""}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"protected func newHTTP2Transport ( c : GRPCConnSocket ) : Option < ServerTransport > {   let config : ServerConfig = ServerConfig ( maxStreams : this . opts . maxConcurrentStreams , connectionTimeout : this . opts . connectionTimeout , inTapHandle : this . opts . inTapHandle , statsHandlers : this . opts . statsHandlers , keepaliveParams : this . opts . keepaliveParams , keepalivePolicy : this . opts . keepalivePolicy , initialWindowSize : this . opts . initialWindowSize , initialConnWindowSize : this . opts . initialConnWindowSize , writeBufferSize : this . opts . writeBufferSize , readBufferSize : this . opts . readBufferSize , maxHeaderListSize : this . opts . maxHeaderListSize , headerTableSize : this . opts . headerTableSize ) NL  let ( st , err ) : ( Option < ServerTransport > , GrpcError ) = Http2Server . newServerTransport ( c , config ) NL if ( ! err . isNull ( ) ) {  if ( ! err . msg . equals ( credentials: rawConn is dispatched out of gRPC ) ) {  c . close ( ) NL } NL return None NL } NL return st NL }","func_name":"newHTTP2Transport","docstring":"//Set the http/2 transport (use the gRPC http2 server transport in transport/http2_server.go)."}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"public func stop ( ) : Unit {  synchronized ( this . mu ) {   let listeners : HashMap < GRPCServerSocket , Bool > = this . lis NL this . lis = HashMap < GRPCServerSocket , Bool > ( ) NL  let conns : HashMap < String , HashMap < ServerTransport , Bool > > = this . conns NL this . conns = HashMap < String , HashMap < ServerTransport , Bool > > ( ) NL for ( ( listener , v ) in listeners ) {  listener . close ( ) NL } NL for ( ( k , cs ) in conns ) {  for ( ( st , v ) in cs ) {  st . close ( ) NL } NL } NL } NL }","func_name":"stop","docstring":"/**\n     * Stop Stops the gRPC server.\n     * It immediately closes all open connections and listeners.\n     * It will cancel all active RPCs on the server side,\n     * and the corresponding suspended RPCs on the client will receive connection error notifications.\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"server.cj","path":"grpc/src/grpc/server.cj","code_tokens":"public func gracefulStop ( ) : Unit {  synchronized ( this . mu ) {  if ( this . conns . isEmpty ( ) ) {  return NL } NL for ( ( k , v ) in this . lis ) {  k . close ( ) NL } NL this . lis . clear ( ) NL if ( ! this . drain ) {  for ( ( k , cs ) in conns ) {  for ( ( st , v ) in cs ) {  st . drain ( ) NL } NL } NL this . drain = true NL } NL } NL }","func_name":"gracefulStop","docstring":"/**\n     * Stop the gRPC server gracefully.\n     * It stops the server from accepting new connections, RPCs, and blocks until all pending RPCs are complete.\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"func recvMsg ( maxReceiveMessageSize : Int64 ) : ( UInt8 , Array < UInt8 > , GrpcError ) {   var pf : UInt8 = 0 NL  var err : GrpcError = NULL_ERR NL  var num : Int64 = 0 NL try {  if ( this . header . size != 5 ) {  throw Exception ( this.header.size != 5, is wrong! ) NL } NL num = this . r . read ( this . header ) NL } catch ( e : Exception ) {  err = GrpcError ( GrpcUnknown , e . message ) NL } NL if ( ! err . isNull ( ) || num == 0 ) {  return ( 0 , EMPTY_ARRAY_UINT8 , err ) NL } NL pf = this . header [ 0 ] NL  let length : UInt32 = getUInt32 ( this . header [ 1 .. header . size ] ) NL if ( length == 0 ) {  return ( pf , EMPTY_ARRAY_UINT8 , NULL_ERR ) NL } NL if ( Int64 ( length ) > maxReceiveMessageSize ) {  return ( 0 , EMPTY_ARRAY_UINT8 , GrpcError ( ResourceExhausted , grpc: received message larger than max (${length} vs. ${maxReceiveMessageSize}) ) ) NL } NL  var msg : Array < UInt8 > = Array < UInt8 > ( Int64 ( length ) , item : 0 ) NL try {  num = this . r . read ( msg ) NL } catch ( e : Exception ) {  err = GrpcError ( GrpcUnknown , e . message ) NL } NL if ( num != Int64 ( length ) ) {  err = GrpcError ( GrpcUnknown , The information read is error, length = ${length}, num = ${num}. ) NL } NL if ( ! err . isNull ( ) ) {  if ( err is EOFError ) {  err = ErrUnexpectedEOF ( ) NL } NL return ( 0 , EMPTY_ARRAY_UINT8 , err ) NL } NL return ( pf , msg , NULL_ERR ) NL }","func_name":"recvMsg","docstring":""}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"public func prepareMsg ( m : Message , codec : BaseCodec , flagCompress : Bool ) : ( Array < Byte > , Array < Byte > , Array < Byte > , GrpcError ) {   let ( data , err ) : ( Array < Byte > , GrpcError ) = encodeGrpc ( codec , m ) NL if ( ! err . isNull ( ) ) {  return ( EMPTY_ARRAY , EMPTY_ARRAY , EMPTY_ARRAY , err ) NL } NL  var compData : Array < Byte > = EMPTY_ARRAY NL if ( flagCompress ) {   let ( dataCompress , errCom ) : ( Array < Byte > , GrpcError ) = compressGRPC ( data ) NL if ( ! errCom . isNull ( ) ) {  return ( EMPTY_ARRAY , EMPTY_ARRAY , EMPTY_ARRAY , errCom ) NL } NL compData = dataCompress NL } NL  let ( hdr , payload ) : ( Array < Byte > , Array < Byte > ) = msgHeader ( data , compData ) NL return ( hdr , payload , data , NULL_ERR ) NL }","func_name":"prepareMsg","docstring":"//Use the passed compressor or use the passed prepareMsg to return the hdr, payload, and data"}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"public func encodeGrpc ( c : BaseCodec , msg : Message ) : ( Array < Byte > , GrpcError ) {   var data : Array < Byte > = EMPTY_ARRAY NL  var err : GrpcError = NULL_ERR NL try {  data = c . marshal ( ( msg as Message ) . getOrThrow ( ) ) NL } catch ( e : Exception ) {  err = GrpcError ( GrpcUnknown , e . message ) NL } NL if ( ! err . isNull ( ) ) {  return ( EMPTY_ARRAY , GrpcError ( insideInternal , grpc: error while marshaling: ${err.msg} ) ) NL } NL if ( UInt64 ( data . size ) > UInt64 ( UInt32 . Max ) ) {  return ( EMPTY_ARRAY , GrpcError ( ResourceExhausted , grpc: message too large (${data.size} bytes) ) ) NL } NL return ( data , NULL_ERR ) NL }","func_name":"encodeGrpc","docstring":"/*\n * Serialize the message and return the buffer containing the message.\n * If the message is too large to be transmitted by grpc, an error is returned.\n * If msg is nil, an empty message is generated.\n */"}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"public func compressGRPC ( inbuf : Array < Byte > ) : ( Array < Byte > , GrpcError ) {  if ( inbuf . size < 2 ) {  return ( inbuf , NULL_ERR ) NL } NL  var dest : Array < Byte > = EMPTY_ARRAY NL  var err : GrpcError = NULL_ERR NL try {   var buf : ByteArrayStream = ByteArrayStream ( 1024 ) NL  var comp : CompressOutputStream = CompressOutputStream ( buf , wrap : GzipFormat , bufLen : 1024 ) NL comp . write ( inbuf ) NL comp . flush ( ) NL comp . close ( ) NL dest = buf . readToEnd ( ) NL buf . clear ( ) NL } catch ( e : Exception ) {  err = GrpcError ( GrpcUnknown , e . message ) NL } NL return ( dest , err ) NL }","func_name":"compressGRPC","docstring":"/*\n * Returns compressed input bytes.\n * Compress with CompressOutputStream of zlib library.\n * Unlike go, go uses a compressor that specifies the incoming.\n */"}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"public func msgHeader ( buf : Array < Byte > , compData : Array < Byte > ) : ( Array < Byte > , Array < Byte > ) {   var data : Array < Byte > = buf NL  let hdr : Array < Byte > = Array < Byte > ( Int64 ( HEADER_LEN ) , item : 0 ) NL if ( compData . size != 0 ) {  hdr [ 0 ] = COMPRESSION_MADE NL data = compData NL } else {  hdr [ 0 ] = COMPRESSION_NONE NL } NL putUInt32 ( hdr , UInt32 ( data . size ) , 1 ) NL return ( hdr , data ) NL }","func_name":"msgHeader","docstring":"/*\n * A 5-byte header is returned for the message and payload being transmitted.\n * If it is not nil, it is compData; otherwise, it is data.\n * 5 bytes of the header. The first byte indicates whether to compress, 0-uncompressed, 1-compressed.\n * 2-5 bytes represent the length of transmitted data.\n */"}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"func checkRecvPayload ( pf : UInt8 , recvCompress : String ) : GrpcError {  match { case pf == COMPRESSION_NONE => ( ) NL case pf == COMPRESSION_MADE => if ( recvCompress . isEmpty ( ) || recvCompress . equals ( Identity ) ) {  return GrpcError ( insideInternal , grpc: compressed flag set with identity or empty encoding ) NL } NL case _ => return GrpcError ( insideInternal , grpc: received unexpected payload format ${pf} ) NL } NL return NULL_ERR NL }","func_name":"checkRecvPayload","docstring":""}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"public func isNull ( ) : Bool {  return this . isNone NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"public func recvAndDecompress ( p : Parser , s : Stream , maxReceiveMessageSize : Int64 , payInfo : PayloadInfo ) : ( Array < UInt8 > , GrpcError ) {   var buf : Array < Byte > = EMPTY_ARRAY NL  let ( pf , dbuf , err ) : ( UInt8 , Array < UInt8 > , GrpcError ) = p . recvMsg ( maxReceiveMessageSize ) NL if ( ! err . isNull ( ) ) {  return ( EMPTY_ARRAY_UINT8 , err ) NL } NL if ( ! payInfo . isNull ( ) ) {  payInfo . wireLength = dbuf . size NL } NL buf = dbuf NL  let st : GrpcError = checkRecvPayload ( pf , s . getRecvCompress ( ) ) NL if ( ! st . isNull ( ) ) {  return ( EMPTY_ARRAY_UINT8 , st ) NL } NL if ( pf == COMPRESSION_MADE ) {   let ( dbuf2 , size , errDC ) : ( Array < Byte > , Int64 , GrpcError ) = decompress ( dbuf , maxReceiveMessageSize ) NL buf = dbuf2 NL if ( ! errDC . isNull ( ) ) {  return ( EMPTY_ARRAY_UINT8 , GrpcError ( insideInternal , grpc: failed to decompress the received message ${errDC.msg} ) ) NL } NL if ( size > maxReceiveMessageSize ) {  return ( EMPTY_ARRAY_UINT8 , GrpcError ( ResourceExhausted , grpc: received message after decompression larger than max (${size} vs. ${maxReceiveMessageSize}) ) ) NL } NL } NL return ( buf , NULL_ERR ) NL }","func_name":"recvAndDecompress","docstring":"//Use the standard library zlib library compression and decompression tool."}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"public func decompress ( dcbuf : Array < UInt8 > , maxReceiveMessageSize : Int64 ) : ( Array < Byte > , Int64 , GrpcError ) {   var data : Array < Byte > = EMPTY_ARRAY NL  var err : GrpcError = NULL_ERR NL  var sum : Int64 = 0 NL try {   var buf : ByteArrayStream = ByteArrayStream ( 1024 ) NL  var dc : DecompressOutputStream = DecompressOutputStream ( buf , wrap : GzipFormat , bufLen : 1024 ) NL dc . write ( dcbuf ) NL dc . flush ( ) NL dc . close ( ) NL data = buf . readToEnd ( ) NL sum = data . size NL buf . clear ( ) NL } catch ( e : Exception ) {  err = GrpcError ( GrpcUnknown , e . message ) NL } NL if ( ! err . isNull ( ) ) {  return ( EMPTY_ARRAY_UINT8 , 0 , err ) NL } NL if ( sum > maxReceiveMessageSize ) {  return ( EMPTY_ARRAY_UINT8 , sum , NULL_ERR ) NL } NL return ( data , sum , err ) NL }","func_name":"decompress","docstring":"/*\n * Use the compressor to decompress d and return data and size.\n * Or, if the data will exceed maxReceiveMessageSize, only the size will be returned.\n */"}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"public func recv ( p : Parser , c : BaseCodec , s : Stream , m : Message , maxReceiveMessageSize : Int64 , payInfo : PayloadInfo ) : GrpcError {   let ( dbuf , err ) : ( Array < UInt8 > , GrpcError ) = recvAndDecompress ( p , s , maxReceiveMessageSize , payInfo ) NL if ( ! err . isNull ( ) ) {  return err NL } NL  var errum : GrpcError = NULL_ERR NL try {  c . unmarshal ( ArrayList < UInt8 > ( dbuf ) , m ) NL } catch ( e : Exception ) {  errum = GrpcError ( GrpcUnknown , e . message ) NL } NL if ( ! errum . isNull ( ) ) {  return GrpcError ( insideInternal , grpc: failed to unmarshal the received message ${errum.msg} ) NL } NL if ( ! payInfo . isNull ( ) ) {  payInfo . uncompressedBytes = dbuf NL } NL return NULL_ERR NL }","func_name":"recv","docstring":"//Use the standard library zlib library compression and decompression tool."}
{"repo":"grpc","file":"rpc_util.cj","path":"grpc/src/grpc/rpc_util.cj","code_tokens":"public func toRPCErr ( err : GrpcError ) : GrpcError {  if ( err . isNull ( ) || err is EOFError ) {  return err NL } else if ( err is ErrUnexpectedEOF ) {  return GrpcError ( insideInternal , err . msg ) NL } NL if ( err is ConnectionError ) {  return GrpcError ( DeadlineExceeded , err . msg ) NL } else if ( err is NewStreamError ) {   let nerr : NewStreamError = ( err as NewStreamError ) . getOrThrow ( ) NL toRPCErr ( nerr . err ) NL } NL return GrpcError ( GrpcUnknown , err . msg ) NL }","func_name":"toRPCErr","docstring":"//Convert errors to errors in the status package."}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"public func hasPadded ( flags : UInt8 ) : Bool {  return ( flags & FLAG_PADDED ) != 0 NL }","func_name":"hasPadded","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"public func hasPriority ( flags : UInt8 ) : Bool {  return ( flags & FLAG_PRIORITY ) != 0 NL }","func_name":"hasPriority","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"public func isAck ( flags : UInt8 ) : Bool {  return ( flags & FLAG_ACK ) != 0 NL }","func_name":"isAck","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"public func headersEnded ( flags : UInt8 ) : Bool {  return ( flags & FLAG_END_HEADERS ) != 0 NL }","func_name":"headersEnded","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"public func streamEnded ( flags : UInt8 ) : Bool {  return ( flags & FLAG_END_STREAM ) != 0 NL }","func_name":"streamEnded","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"public func isPseudo ( hf : HeaderField ) : Bool {  return hf . name . size != 0 && hf . name [ 0 ] == : NL }","func_name":"isPseudo","docstring":"/*\n * Reports whether the header field is an http2 pseudo header. That is, it reports whether it starts with a colon.\n * However, there is no guarantee that it is a valid pseudo header field.\n */"}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func readFrameHeader ( buf : Array < UInt8 > ) : FrameHeader {  return FrameHeader ( length : ( UInt32 ( buf [ 0 ] ) << 16 | UInt32 ( buf [ 1 ] ) << 8 | UInt32 ( buf [ 2 ] ) ) , types : buf [ 3 ] , flags : buf [ 4 ] , streamID : ( UInt32 ( buf [ 5 ] ) << 24 | UInt32 ( buf [ 6 ] ) << 16 | UInt32 ( buf [ 7 ] ) << 8 | UInt32 ( buf [ 8 ] ) ) ) NL }","func_name":"readFrameHeader","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func typeFrameParser ( t : UInt8 ) : FrameParser {  if ( t > = 0 && t < 10 ) {  return frameParsers [ Int64 ( t ) ] NL } NL return parseUnknownFrame NL }","func_name":"typeFrameParser","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parseUnknownFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {   let frame : Frame = UnknownFrame ( fh . length , fh . flags , fh . streamID , payload ) NL if ( hasCountError ) {  countError ( countError ) NL } NL return ( frame , NULL_ERR ) NL }","func_name":"parseUnknownFrame","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parseDataFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( fh . streamID == 0 ) {  if ( hasCountError ) {  countError ( frame_data_stream_0 ) NL } NL return ( ERROR_FRAME , GrpcError ( ErrCodeProtocol , DATA frame with stream ID 0 ) ) NL } NL  var padLength : Int64 = 0 NL  var buf : Array < UInt8 > = payload NL if ( hasPadded ( fh . flags ) ) {  padLength = Int64 ( buf [ 0 ] ) NL  let endIndex : Int64 = buf . size - padLength NL buf = buf [ 1 .. endIndex ] NL } NL  let frame : Frame = GrpcDataFrame ( fh . length , fh . flags , fh . streamID , buf , padLength ) NL return ( frame , NULL_ERR ) NL }","func_name":"parseDataFrame","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parseHeadersFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( fh . streamID == 0 ) {  if ( hasCountError ) {  countError ( frame_headers_zero_stream ) NL } NL return ( ERROR_FRAME , GrpcError ( ErrCodeProtocol , HEADERS frame with stream ID 0 ) ) NL } NL  var padLength : Int64 = 0 NL  var buf : Array < UInt8 > = payload NL if ( hasPadded ( fh . flags ) ) {  padLength = Int64 ( buf [ 0 ] ) NL  let endIndex : Int64 = buf . size - padLength NL buf = buf [ 1 .. endIndex ] NL } NL  var myStreamDependency : Int64 = 0 NL  var myWeight : Int64 = 0 NL  var myExclusive : Bool = false NL  let isPriority : Bool = hasPriority ( fh . flags ) NL if ( isPriority ) {   let num : UInt32 = UInt32 ( buf [ 3 ] ) | UInt32 ( buf [ 2 ] ) << 8 | UInt32 ( buf [ 1 ] ) << 16 | UInt32 ( buf [ 0 ] ) << 24 NL myStreamDependency = Int64 ( num & 0x7fffffff ) NL myExclusive = ( Int64 ( num ) != myStreamDependency ) NL myWeight = Int64 ( buf [ 4 ] ) NL buf = buf [ 5 .. buf . size ] NL } NL  let frame : GrpcHeadersFrame = GrpcHeadersFrame ( fh . length , fh . flags , fh . streamID , buf ) NL if ( isPriority ) {  frame . setPriority ( myStreamDependency , myExclusive , myWeight ) NL } NL return ( frame , NULL_ERR ) NL }","func_name":"parseHeadersFrame","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parsePriorityFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( fh . streamID == 0 ) {  if ( hasCountError ) {  countError ( frame_priority_zero_stream ) NL } NL return ( ERROR_FRAME , GrpcError ( ErrCodeProtocol , PRIORITY frame with stream ID 0 ) ) NL } NL if ( payload . size != 5 ) {  if ( hasCountError ) {  countError ( frame_priority_bad_length ) NL } NL return ( ERROR_FRAME , GrpcError ( ErrCodeFrameSize , PRIORITY frame payload size was ${payload.size}; want 5 ) ) NL } NL  let num : UInt32 = UInt32 ( payload [ 3 ] ) | UInt32 ( payload [ 2 ] ) << 8 | UInt32 ( payload [ 1 ] ) << 16 | UInt32 ( payload [ 0 ] ) << 24 NL  let myStreamDependency : Int64 = Int64 ( num & 0x7fffffff ) NL  let myWeight : Int64 = Int64 ( payload [ 4 ] ) NL  let myExclusive : Bool = ( Int64 ( num ) != myStreamDependency ) NL  let hf : Frame = GrpcPriorityFrame ( fh . length , fh . streamID , myStreamDependency , myExclusive , myWeight ) NL return ( hf , NULL_ERR ) NL }","func_name":"parsePriorityFrame","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parseRSTStreamFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( payload . size != 4 ) {  if ( hasCountError ) {  countError ( frame_rststream_bad_len ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeFrameSize ) ) NL } NL if ( fh . streamID == 0 ) {  if ( hasCountError ) {  countError ( frame_rststream_zero_stream ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeProtocol ) ) NL } NL  let errCode : UInt32 = UInt32 ( payload [ 3 ] ) | UInt32 ( payload [ 2 ] ) << 8 | UInt32 ( payload [ 1 ] ) << 16 | UInt32 ( payload [ 0 ] ) << 24 NL  let frame : Frame = GrpcRSTStreamFrame ( fh . length , fh . streamID , errCode ) NL return ( frame , NULL_ERR ) NL }","func_name":"parseRSTStreamFrame","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parseSettingsFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( isAck ( fh . flags ) && fh . length > 0 ) {  if ( hasCountError ) {  countError ( frame_settings_ack_with_length ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeFrameSize ) ) NL } NL if ( fh . streamID != 0 ) {  if ( hasCountError ) {  countError ( frame_settings_has_stream ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeProtocol ) ) NL } NL if ( ( payload . size % 6 ) != 0 ) {  if ( hasCountError ) {  countError ( frame_settings_mod_6 ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeFrameSize ) ) NL } NL  let frame : GrpcSettingsFrame = GrpcSettingsFrame ( fh . length , fh . flags , payload ) NL  let val : UInt32 = frame . getParameter ( SettingInitialWindowSize - 1 ) NL if ( val > ( 1 << 31 ) - 1 ) {  if ( hasCountError ) {  countError ( frame_settings_window_size_too_big ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeFlowControl ) ) NL } NL return ( frame , NULL_ERR ) NL }","func_name":"parseSettingsFrame","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parsePushPromise ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( fh . streamID == 0 ) {  if ( hasCountError ) {  countError ( frame_pushpromise_zero_stream ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeProtocol ) ) NL } NL  var padLength : Int64 = 0 NL  var myPromiseID : Int64 = 0 NL  var buf : Array < UInt8 > = payload NL if ( hasPadded ( fh . flags ) ) {  padLength = Int64 ( buf [ 0 ] ) NL  let num : UInt32 = UInt32 ( buf [ 4 ] ) | UInt32 ( buf [ 3 ] ) << 8 | UInt32 ( buf [ 2 ] ) << 16 | UInt32 ( buf [ 1 ] ) << 24 NL myPromiseID = Int64 ( num ) NL  let endIndex : Int64 = buf . size - padLength NL buf = buf [ 5 .. endIndex ] NL } else {   let num : UInt32 = UInt32 ( buf [ 3 ] ) | UInt32 ( buf [ 2 ] ) << 8 | UInt32 ( buf [ 1 ] ) << 16 | UInt32 ( buf [ 0 ] ) << 24 NL myPromiseID = Int64 ( num & ( 1 << 31 - 1 ) ) NL buf = buf [ 4 .. buf . size ] NL } NL  let frame : Frame = GrpcPushPromiseFrame ( fh . length , fh . flags , fh . streamID , buf , padLength , myPromiseID ) NL return ( frame , NULL_ERR ) NL }","func_name":"parsePushPromise","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parsePingFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( payload . size != 8 ) {  if ( hasCountError ) {  countError ( frame_ping_length ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeFrameSize ) ) NL } NL if ( fh . streamID != 0 ) {  if ( hasCountError ) {  countError ( frame_ping_has_stream ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeProtocol ) ) NL } NL  let frame : Frame = GrpcPingFrame ( fh . length , fh . flags , payload . clone ( ) ) NL return ( frame , NULL_ERR ) NL }","func_name":"parsePingFrame","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parseGoAwayFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( fh . streamID != 0 ) {  if ( hasCountError ) {  countError ( frame_goaway_has_stream ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeProtocol ) ) NL } NL if ( payload . size < 8 ) {  if ( hasCountError ) {  countError ( frame_goaway_short ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeFrameSize ) ) NL } NL  let lastStreamID : UInt32 = UInt32 ( payload [ 3 ] ) | UInt32 ( payload [ 2 ] ) << 8 | UInt32 ( payload [ 1 ] ) << 16 | UInt32 ( payload [ 0 ] ) << 24 NL  let errCode : UInt32 = UInt32 ( payload [ 7 ] ) | UInt32 ( payload [ 6 ] ) << 8 | UInt32 ( payload [ 5 ] ) << 16 | UInt32 ( payload [ 4 ] ) << 24 NL  let data : Array < UInt8 > = if ( payload . size == 8 ) {  EMPTY_ARRAY_UINT8 NL } else {  payload [ 8 .. payload . size ] NL } NL  let frame : Frame = GrpcGoAwayFrame ( fh . length , lastStreamID & ( 1 << 31 - 1 ) , errCode , data ) NL return ( frame , NULL_ERR ) NL }","func_name":"parseGoAwayFrame","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parseWindowUpdateFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( payload . size != 4 ) {  if ( hasCountError ) {  countError ( frame_windowupdate_bad_len ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeFrameSize ) ) NL } NL  let num : UInt32 = UInt32 ( payload [ 3 ] ) | UInt32 ( payload [ 2 ] ) << 8 | UInt32 ( payload [ 1 ] ) << 16 | UInt32 ( payload [ 0 ] ) << 24 NL  let increment : UInt32 = num & 0x7fffffff NL if ( increment == 0 ) {  if ( fh . streamID == 0 ) {  if ( hasCountError ) {  countError ( frame_windowupdate_zero_inc_conn ) NL } NL return ( ERROR_FRAME , ConnectionError ( ErrCodeProtocol ) ) NL } NL if ( hasCountError ) {  countError ( frame_windowupdate_zero_inc_stream ) NL } NL return ( ERROR_FRAME , StreamError ( streamID : fh . streamID , code : ErrCodeProtocol ) ) NL } NL  let frame : Frame = GrpcWindowUpdateFrame ( fh . streamID , increment ) NL return ( frame , NULL_ERR ) NL }","func_name":"parseWindowUpdateFrame","docstring":""}
{"repo":"grpc","file":"frame_util.cj","path":"grpc/src/transport/frame_util.cj","code_tokens":"func parseContinuationFrame ( fh : FrameHeader , countError : ( String ) -> Unit , payload : Array < UInt8 > , hasCountError : Bool ) : ( Frame , GrpcError ) {  if ( fh . streamID == 0 ) {  if ( hasCountError ) {  countError ( frame_continuation_zero_stream ) NL } NL return ( ERROR_FRAME , GrpcError ( ErrCodeProtocol , CONTINUATION frame with stream ID 0 ) ) NL } NL  let frame : Frame = GrpcContinuationFrame ( fh . length , fh . flags , fh . streamID , payload ) NL return ( frame , NULL_ERR ) NL }","func_name":"parseContinuationFrame","docstring":""}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func handleStreams ( handle : ( Stream ) -> Unit , traceCtx : ( String ) -> Unit ) : Unit","func_name":"handleStreams","docstring":"/**\n     * Receives the incoming stream using the given handler.\n     *\n     * @param handle of (Stream)->Unit\n     * @param traceCtx of (String)->Unit\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func writeHeader ( s : Stream , md : HashMap < String , Array < String > > ) : GrpcError","func_name":"writeHeader","docstring":"/**\n     * Sends the header metadata of the given stream. WriteHeader cannot be called on all streams.\n     *\n     * @param s of Stream\n     * @param md of HashMap<String,Array<String>>\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func write ( s : Stream , hdr : Array < UInt8 > , data : Array < UInt8 > ) : GrpcError","func_name":"write","docstring":"/**\n     * Sends data for a given stream. Write cannot be called on all streams.\n     *\n     * @param s of Stream\n     * @param hdr of Array<UInt8>\n     * @param data of Array<UInt8>\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func writeStatus ( s : Stream , st : GrpcError ) : GrpcError","func_name":"writeStatus","docstring":"/**\n     * Send the status of the stream to the client.\n     * WriteStatus is the last call to the stream and always occurs.\n     *\n     * @param s of Stream\n     * @param st of GrpcError\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func close ( ) : Unit","func_name":"close","docstring":"/**\n     * The Function is close\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func getRemoteAddr ( ) : SocketAddress","func_name":"getRemoteAddr","docstring":"/**\n     * The Function is getRemoteAddr\n     *\n     * @return Type of SocketAddress\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func drain ( ) : Unit","func_name":"drain","docstring":"/**\n     * Notify the client that this ServerTransport stops accepting new RPCs.\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func incrMsgSent ( ) : Unit","func_name":"incrMsgSent","docstring":"/**\n     * Increase the number of messages sent through this transport.\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func incrMsgRecv ( ) : Unit","func_name":"incrMsgRecv","docstring":"/**\n     * Increase the number of messages received through this transport.\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public func hashCode ( ) : Int64 {  return hashNum NL }","func_name":"hashCode","docstring":""}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public operator func == ( that : ServerTransport ) : Bool {  return refEq ( this , that ) NL }","func_name":"==","docstring":""}
{"repo":"grpc","file":"transport.cj","path":"grpc/src/transport/transport.cj","code_tokens":"public operator func != ( that : ServerTransport ) : Bool {  return ! refEq ( this , that ) NL }","func_name":"!=","docstring":""}
{"repo":"grpc","file":"handle_server_util.cj","path":"grpc/src/transport/handle_server_util.cj","code_tokens":"public func mapRecvMsgError ( err : GrpcError ) : GrpcError {   let flagEOF : Bool = err is EOFError NL  let flagUEOF : Bool = err is ErrUnexpectedEOF NL if ( flagEOF || flagUEOF ) {  return err NL } NL  let flagSError : Bool = err is StreamError NL if ( flagSError ) {  if ( err . code > = ErrCodeNo && err . code <= ErrCodeHTTP11Required ) {   let code : UInt32 = http2ErrConvTab [ Int64 ( err . code ) ] NL return GrpcError ( code , err . msg ) NL } NL } NL if ( err . msg . contains ( body closed by handler ) ) {  return GrpcError ( Canceled , err . getError ( ) ) NL } NL return ConnectionError ( err . msg , true , err ) NL }","func_name":"mapRecvMsgError","docstring":"/*\n * The non-zero error is returned to the corresponding error value, which is expected by the caller of grpc.parser.recvMsg.\n *  In particular, in can only be:\n *    - io.EOF\n *    - io.ErrUnexpectedEOF\n *    - of type transport.ConnectionError\n *    - an error from the status package\n */"}
{"repo":"grpc","file":"handle_server_util.cj","path":"grpc/src/transport/handle_server_util.cj","code_tokens":"public func splitHostPort ( strHostPort : String ) : ( String , String , String ) {   var j : Int64 = 0 NL  var k : Int64 = 0 NL  var host : String =  NL  var port : String =  NL  let lastColonIndex : Int64 = strHostPort . lastIndexOf ( : ) ?? - 1 NL if ( lastColonIndex < 0 ) {  return ( strHostPort ,  , grpcMissingPort ) NL } NL if ( strHostPort [ 0 ] == [ ) {   let end : Int64 = strHostPort . indexOf ( ] ) ?? - 1 NL if ( end < 0 ) {  return ( strHostPort ,  , missing ']' in address ) NL } NL  let colonNum : Int64 = end + 1 NL if ( colonNum != lastColonIndex && colonNum == strHostPort . size ) {  return ( strHostPort ,  , grpcMissingPort ) NL } else if ( colonNum != lastColonIndex && strHostPort [ end + 1 ] == : ) {  return ( strHostPort ,  , grpcTooManyColons ) NL } else if ( colonNum != lastColonIndex ) {  return ( strHostPort ,  , grpcMissingPort ) NL } NL host = strHostPort [ 1 .. end ] NL j = 1 NL k = end + 1 NL } else {  host = strHostPort [ 0 .. lastColonIndex ] NL if ( ( host . indexOf ( : ) ?? - 1 ) > = 0 ) {  return ( strHostPort ,  , grpcTooManyColons ) NL } NL } NL  let num : Int64 = strHostPort . size NL if ( ( strHostPort [ j .. num ] . indexOf ( [ ) ?? - 1 ) > = 0 ) {  return ( strHostPort ,  , unexpected '[' in address ) NL } NL if ( ( strHostPort [ k .. num ] . indexOf ( ] ) ?? - 1 ) > = 0 ) {  return ( strHostPort ,  , unexpected ']' in address ) NL } NL return ( host , strHostPort [ lastColonIndex + 1 .. num ] ,  ) NL }","func_name":"splitHostPort","docstring":""}
{"repo":"grpc","file":"util.cj","path":"grpc/src/transport/util.cj","code_tokens":"func compress ( inbuf : Array < Byte > ) : Array < Byte > {  if ( inbuf . size < 2 ) {  return inbuf NL } NL  var dest : Array < Byte > = EMPTY_ARRAY NL try {   var buf : ByteArrayStream = ByteArrayStream ( 1024 ) NL  var com : CompressOutputStream = CompressOutputStream ( buf , wrap : GzipFormat , bufLen : 1024 ) NL com . write ( Array < Byte > ( inbuf ) ) NL com . flush ( ) NL com . close ( ) NL dest = buf . readToEnd ( ) NL buf . clear ( ) NL } catch ( e : Exception ) {  throw Exception ( compress failed ) NL } NL return dest NL }","func_name":"compress","docstring":""}
{"repo":"grpc","file":"util.cj","path":"grpc/src/transport/util.cj","code_tokens":"func newmsgHeader ( data : Array < Byte > ) : Array < Byte > {   let hdr : Array < Byte > = Array < Byte > ( Int64 ( HEADER_LEN ) , item : 0 ) NL hdr [ 0 ] = COMPRESSION_MADE NL  let s : Int64 = data . size NL hdr [ 1 ] = UInt8 ( ( s >> 24 ) & 0xff ) NL hdr [ 2 ] = UInt8 ( ( s >> 16 ) & 0xff ) NL hdr [ 3 ] = UInt8 ( ( s >> 8 ) & 0xff ) NL hdr [ 4 ] = UInt8 ( s & 0xff ) NL return hdr NL }","func_name":"newmsgHeader","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func read ( buf : Array < Byte > ) : Int64 {  return match ( this ) { case SocketConn ( conn ) => conn . read ( buf ) NL case TlsConn ( conn ) => conn . read ( buf ) NL case InputStreamConn ( conn ) => conn . read ( buf ) NL case _ => throw Exception ( There is no matching Conn value type that can call the read function. ) NL } NL }","func_name":"read","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func read ( buf : Array < Byte > , timeout : Duration ) : Int64 {  return match ( this ) { case SocketConn ( conn ) => conn . read ( buf , timeout ) NL case TlsConn ( conn ) => conn . read ( buf ) NL case _ => throw Exception ( There is no matching Conn value type that can call the read function with a timeout limit. ) NL } NL }","func_name":"read","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func write ( buf : Array < Byte > ) : Unit {  return match ( this ) { case SocketConn ( conn ) => conn . write ( buf ) NL case TlsConn ( conn ) => conn . write ( buf ) NL case OutputStreamConn ( conn ) => conn . write ( buf ) NL case _ => throw Exception ( There is no matching Conn value type that can call the write function. ) NL } NL }","func_name":"write","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func write ( buf : Array < Byte > , timeout : Duration ) : Unit {  return match ( this ) { case SocketConn ( conn ) => conn . write ( buf , timeout ) NL case TlsConn ( conn ) => conn . write ( buf ) NL case _ => throw Exception ( There is no matching Conn value type that can call the write function with a timeout limit. ) NL } NL }","func_name":"write","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func close ( ) : Unit {  return match ( this ) { case SocketConn ( conn ) => conn . close ( ) NL case TlsConn ( conn ) => conn . close ( ) NL case _ => throw Exception ( There is no matching Conn value type that can call the close function. ) NL } NL }","func_name":"close","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func getLocalAddr ( ) : SocketAddress {  return match ( this ) { case SocketConn ( conn ) => conn . localAddress . getOrThrow ( ) NL case TlsConn ( conn ) => conn . socket . localAddress . getOrThrow ( ) NL case _ => throw Exception ( There is no matching Conn value type that can get localAddress. ) NL } NL }","func_name":"getLocalAddr","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func getRemoteAddr ( ) : SocketAddress {  return match ( this ) { case SocketConn ( conn ) => conn . remoteAddress NL case TlsConn ( conn ) => conn . socket . remoteAddress NL case _ => throw Exception ( There is no matching Conn value type that can get remoteAddress. ) NL } NL }","func_name":"getRemoteAddr","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func accept ( ) : GRPCConn {  return match ( this ) { case GrpcSocketS ( server ) => SocketConn ( server . accept ( ) ) NL case GrpcTlsS ( server ) => TlsConn ( server . accept ( ) ) NL } NL }","func_name":"accept","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func accept ( timeout : Duration ) : GRPCConn {  return match ( this ) { case GrpcSocketS ( server ) => SocketConn ( server . accept ( timeout ) ) NL case GrpcTlsS ( server ) => TlsConn ( server . accept ( ) ) NL } NL }","func_name":"accept","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func toString ( ) : String {  return match ( this ) { case GrpcSocketS ( server ) => server . toString ( ) NL case GrpcTlsS ( server ) => server . toString ( ) NL } NL }","func_name":"toString","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func getAddr ( ) : SocketAddress {  return match ( this ) { case GrpcSocketS ( server ) => server . address NL case GrpcTlsS ( server ) => server . address NL } NL }","func_name":"getAddr","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func close ( ) : Unit {  return match ( this ) { case GrpcSocketS ( server ) => server . close ( ) NL case GrpcTlsS ( server ) => server . close ( ) NL } NL }","func_name":"close","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func isClosed ( ) : Bool {  return match ( this ) { case GrpcSocketS ( server ) => server . isClosed ( ) NL case GrpcTlsS ( server ) => server . isClosed ( ) NL } NL }","func_name":"isClosed","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func write ( src : Array < UInt8 > ) : ( Int64 , GrpcError ) {  if ( ! this . err . isNull ( ) ) {  return ( 0 , this . err ) NL } NL if ( this . batchSize == 0 ) {  try {  this . conn . write ( src ) NL } catch ( e : SocketException ) {  this . err = GrpcError ( GrpcUnknown , e . toString ( ) ) NL } NL return ( src . size , this . err ) NL } NL  var num : Int64 = 0 NL  var err : GrpcError = NULL_ERR NL  var bufferNum : Int64 = src . size NL while ( bufferNum > 0 ) {   var nn : Int64 = this . buf . size - this . offset NL if ( nn > bufferNum ) {  nn = bufferNum NL } NL src . copyTo ( this . buf , num , this . offset , nn ) NL bufferNum -= nn NL this . offset += nn NL num += nn NL if ( this . offset > = this . batchSize ) {  err = this . flush ( ) NL } NL } NL return ( num , err ) NL }","func_name":"write","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func flush ( ) : GrpcError {  if ( ! this . err . isNull ( ) ) {  return this . err NL } NL if ( this . offset == 0 ) {  return NULL_ERR NL } NL try {  this . conn . write ( this . buf [ 0 .. this . offset ] ) NL this . offset = 0 NL } catch ( e : Exception ) {  this . err = GrpcError ( GrpcUnknown , e . toString ( ) ) NL } NL return this . err NL }","func_name":"flush","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func read ( srcRead : Array < UInt8 > ) : ( Int64 , GrpcError ) {  try {   let num : Int64 = this . conn . read ( srcRead ) NL return ( num , NULL_ERR ) NL } catch ( e : SocketException ) {  this . err = GrpcError ( GrpcUnknown , e . toString ( ) ) NL } NL return ( - 1 , this . err ) NL }","func_name":"read","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func timeoutUnitToDuration ( char : Char ) : ( Duration , Bool ) {  if ( char == H ) {  return ( Duration . hour ( ) , true ) NL } else if ( char == M ) {  return ( Duration . minute ( ) , true ) NL } else if ( char == S ) {  return ( Duration . second ( ) , true ) NL } else if ( char == m ) {  return ( Duration . millisecond ( ) , true ) NL } else if ( char == u ) {  return ( Duration . microsecond ( ) , true ) NL } else if ( char == n ) {  return ( Duration . nanosecond ( ) , true ) NL } NL return ( EMPTY_TIME , false ) NL }","func_name":"timeoutUnitToDuration","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func decodeTimeout ( s : String ) : ( Duration , GrpcError ) {   let size : Int64 = s . size NL if ( size < 2 ) {  return ( EMPTY_TIME , GrpcError ( GrpcUnknown , transport: timeout string is too short: ${s}. ) ) NL } NL if ( size > 9 ) {  return ( EMPTY_TIME , GrpcError ( GrpcUnknown , transport: timeout string is too long: ${s}. ) ) NL } NL  let char : Char = s [ size - 1 ] NL  let ( d , ok ) : ( Duration , Bool ) = timeoutUnitToDuration ( char ) NL if ( ! ok ) {  return ( EMPTY_TIME , GrpcError ( GrpcUnknown , transport: timeout unit is not recognized: ${s}. ) ) NL } NL  let t : Int64 = Int64 . parse ( s [ 0 .. ( size - 1 ) ] ) NL  let maxHours : Int64 = Int64 . Max / Int64 ( 60 * 60 * 1000 * 1000 * 1000 ) NL if ( d == Duration . hour ( ) && t > maxHours ) {  return ( Duration . nanosecond ( Int64 . Max ) , NULL_ERR ) NL } NL return ( d * t , NULL_ERR ) NL }","func_name":"decodeTimeout","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func isWhitelistedHeader ( hdr : String ) : Bool {  return hdr . equals ( :authority ) || hdr . equals ( user-agent ) NL }","func_name":"isWhitelistedHeader","docstring":"//Check whether the hdr should be propagated to the user visible metadata, even if it is classified as \"reserved\", as described above."}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func decodeMetadataHeader ( k : String , v : String ) : ( String , GrpcError ) {  if ( k . endsWith ( binHdrSuffix ) ) {   let ( buf , err ) : ( Array < UInt8 > , GrpcError ) = decodeBinHeader ( v ) NL return ( String . fromUtf8 ( buf ) , err ) NL } NL return ( v , NULL_ERR ) NL }","func_name":"decodeMetadataHeader","docstring":""}
{"repo":"grpc","file":"http_util.cj","path":"grpc/src/transport/http_util.cj","code_tokens":"public func decodeBinHeader ( str : String ) : ( Array < UInt8 > , GrpcError ) {   let res : Option < Array < UInt8 > > = fromBase64String ( str ) NL match ( res ) { case Some ( buf ) => return ( buf , NULL_ERR ) NL case None => return ( EMPTY_ARRAY_UINT8 , GrpcError ( GrpcUnknown , decoding of Base64 encoded string failed. ) ) NL } NL }","func_name":"decodeBinHeader","docstring":"//Returns the bytes represented by the base64 string s."}
{"repo":"grpc","file":"bdp_estimator.cj","path":"grpc/src/transport/bdp_estimator.cj","code_tokens":"public func isNull ( ) : Bool {  return this . isNone NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"bdp_estimator.cj","path":"grpc/src/transport/bdp_estimator.cj","code_tokens":"public func timesnap ( d : Array < UInt8 > ) : Unit {  if ( bdpPing . data != d ) {  return NL } NL this . sentAt = Time . now ( ) NL }","func_name":"timesnap","docstring":"/*\n     * Register the time of sending the bdp ping, so as to calculate the network rtt when receiving its ack.\n     * When BDP is written on the line, it is called (by the controller).\n     */"}
{"repo":"grpc","file":"bdp_estimator.cj","path":"grpc/src/transport/bdp_estimator.cj","code_tokens":"public func add ( n : UInt32 ) : Bool {  if ( this . bdp == bdpLimit ) {  return false NL } NL if ( ! this . isSent ) {  this . isSent = true NL this . sample = n NL this . sentAt = Time . now ( ) NL this . sampleCount ++ NL return true NL } NL this . sample += n NL return false NL }","func_name":"add","docstring":""}
{"repo":"grpc","file":"bdp_estimator.cj","path":"grpc/src/transport/bdp_estimator.cj","code_tokens":"func calculate ( buf : Array < UInt8 > ) : Unit {  if ( bdpPing . data != buf ) {  return NL } NL synchronized ( this . mu ) {   let rttSample : Float64 = Float64 ( Time . since ( this . sentAt ) . seconds ( ) ) NL if ( this . sampleCount < 10 ) {  this . rtt += ( rttSample - this . rtt ) / Float64 ( this . sampleCount ) NL } else {  this . rtt += ( rttSample - this . rtt ) * alpha NL } NL this . isSent = false NL  let bwCurrent : Float64 = Float64 ( this . sample ) / ( this . rtt * Float64 ( 1.5 ) ) NL if ( bwCurrent > this . bwMax ) {  this . bwMax = bwCurrent NL } NL if ( Float64 ( this . sample ) > = beta * Float64 ( this . bdp ) && bwCurrent == this . bwMax && this . bdp != bdpLimit ) {   let sampleFloat : UInt32 = this . sample NL this . bdp = gamma * sampleFloat NL if ( this . bdp > bdpLimit ) {  this . bdp = bdpLimit NL } NL this . updateFlowControl ( this . bdp ) NL return NL } NL } NL }","func_name":"calculate","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return false NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"func isTransportResponseFrame ( ) : Bool","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return false NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return ! this . cleanup . isNull ( ) && this . cleanup . rst NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return false NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return false NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return false NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return true NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return false NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return false NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return false NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return true NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return this . rst NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isNull ( ) : Bool {  return this . streamID == 0 && this . rst == false && this . rstCode == 0 NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func isTransportResponseFrame ( ) : Bool {  return false NL }","func_name":"isTransportResponseFrame","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"protected func put ( it : CbItem ) : GrpcError {   let ( flag , errCB ) : ( Bool , GrpcError ) = this . executeAndPut ( defaultAnyToBool , it , fIsNull : true ) NL return errCB NL }","func_name":"put","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"protected func executeAndPut ( f : ( Any ) -> Bool , it : CbItem , fIsNull ! : Bool = false ) : ( Bool , GrpcError ) {   var wakeUp : Bool = false NL synchronized ( this . mu ) {  if ( ! this . err . isNull ( ) ) {  return ( false , this . err ) NL } NL if ( ! fIsNull ) {  if ( ! f ( it ) ) {  return ( false , NULL_ERR ) NL } NL } NL if ( this . consumerWaiting ) {  wakeUp = true NL this . consumerWaiting = false NL } NL synchronized ( m ) {  this . list . enqueue ( it ) NL m . notify ( notEmpty ) NL } NL if ( it . isTransportResponseFrame ( ) ) {  this . transportResponseFrames ++ NL } NL } NL return ( true , NULL_ERR ) NL }","func_name":"executeAndPut","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"protected func execute ( f : ( Any ) -> Bool , it : Any ) : ( Bool , GrpcError ) {  synchronized ( this . mu ) {  if ( ! this . err . isNull ( ) ) {  return ( false , this . err ) NL } NL if ( ! f ( it ) ) {  return ( false , NULL_ERR ) NL } NL } NL return ( true , NULL_ERR ) NL }","func_name":"execute","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"protected func get ( block : Bool ) : ( CbItem , GrpcError ) {  while ( true ) {  synchronized ( this . mu ) {  if ( ! this . err . isNull ( ) ) {  return ( default_CbItem , this . err ) NL } NL if ( ! this . list . isEmpty ( ) ) {   let h : CbItem = this . list . dequeue ( ) NL if ( h . isTransportResponseFrame ( ) ) {  this . transportResponseFrames -- NL } NL return ( h , NULL_ERR ) NL } NL if ( ! block ) {  return ( default_CbItem , NULL_ERR ) NL } NL this . consumerWaiting = true NL } NL if ( block ) {  synchronized ( m ) {  while ( this . list . isEmpty ( ) ) {  m . wait ( notEmpty ) NL } NL } NL } NL } NL return ( default_CbItem , ErrConnClosing ) NL }","func_name":"get","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"public func finish ( ) : Unit {  synchronized ( this . mu ) {  if ( ! this . err . isNull ( ) ) {  return NL } NL this . err = ErrConnClosing NL  var head : Option < ItemNode < CbItem > > = this . list . dequeueAll ( ) NL while ( ! isNullOptionIN ( head ) ) {   let headParam : ItemNode < CbItem > = head . getOrThrow ( ) NL head = head . getOrThrow ( ) . next NL  let isHeaderFrame : Bool = headParam . value is HeaderFrame NL if ( ! isHeaderFrame ) {  continue NL } NL  let hdr : HeaderFrame = ( headParam . value as HeaderFrame ) . getOrThrow ( ) NL if ( ! hdr . isServer && hdr . isClient ) {  hdr . onOrphaned ( ErrConnClosing ) NL } NL } NL } NL }","func_name":"finish","docstring":""}
{"repo":"grpc","file":"controlhuf.cj","path":"grpc/src/transport/controlhuf.cj","code_tokens":"private func isNullOptionIN ( head : Option < ItemNode < CbItem > > ) : Bool {  match ( head ) { case Some ( v ) => return false NL case _ => return true NL } NL }","func_name":"isNullOptionIN","docstring":""}
{"repo":"grpc","file":"out_stream.cj","path":"grpc/src/transport/out_stream.cj","code_tokens":"public func isNull ( ) : Bool {  return this . isNone NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"out_stream.cj","path":"grpc/src/transport/out_stream.cj","code_tokens":"public func deleteSelf ( ) : Unit {  match ( this . prev ) { case Some ( v ) => this . prev . getOrThrow ( ) . next = this . next NL case None => ( ) NL } NL match ( this . next ) { case Some ( v ) => this . next . getOrThrow ( ) . prev = this . prev NL case None => ( ) NL } NL this . next = OUTSTREAM_EMPTY NL this . prev = OUTSTREAM_EMPTY NL }","func_name":"deleteSelf","docstring":""}
{"repo":"grpc","file":"out_stream.cj","path":"grpc/src/transport/out_stream.cj","code_tokens":"static public func newOutStreamList ( ) : OutStreamList {   var head : OutStream = EMPTY_OUTSTREAM NL  var tail : OutStream = EMPTY_OUTSTREAM NL head . next = tail NL tail . prev = head NL return OutStreamList ( head : head , tail : tail ) NL }","func_name":"newOutStreamList","docstring":""}
{"repo":"grpc","file":"out_stream.cj","path":"grpc/src/transport/out_stream.cj","code_tokens":"public func enqueue ( s : OutStream ) : Unit {   var e : ? OutStream = this . tail . prev NL match ( e ) { case Some ( e2 ) => e2 . next = s NL case None => ( ) NL } NL s . prev = e NL s . next = this . tail NL this . tail . prev = s NL }","func_name":"enqueue","docstring":""}
{"repo":"grpc","file":"out_stream.cj","path":"grpc/src/transport/out_stream.cj","code_tokens":"public func dequeue ( ) : OutStream {   let os : ? OutStream = this . head . next NL match ( os ) { case Some ( os2 ) => if ( refEq ( os2 , this . tail ) ) {  return EMPTY_OUTSTREAM NL } NL os2 . deleteSelf ( ) NL return os2 NL case None => return EMPTY_OUTSTREAM NL } NL }","func_name":"dequeue","docstring":"//Remove from the beginning of the list."}
{"repo":"grpc","file":"handles.cj","path":"grpc/src/transport/handles.cj","code_tokens":"func tagRPC ( info : RPCTagInfo ) : Unit","func_name":"tagRPC","docstring":"/*\n     * Some information can be attached to a given context.\n     * The context used for the remaining lifetime of the RPC will be derived from the returned context.\n     */"}
{"repo":"grpc","file":"handles.cj","path":"grpc/src/transport/handles.cj","code_tokens":"func handleRPC ( stats : RPCStats ) : Unit","func_name":"handleRPC","docstring":"/*\n     * Process RPC statistics.\n     *\n     * @param stats of RPCStats\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"handles.cj","path":"grpc/src/transport/handles.cj","code_tokens":"func tagConn ( ctInfo : ConnTagInfo ) : Unit","func_name":"tagConn","docstring":"/*\n     * You can attach some information to a given context.\n     * The returned context will be used for statistical processing.\n     * For conn stats processing, the context used for this connection in HandleConn will be derived from the returned context.\n     * For RPC state processing,\n     * -On the server side, the context used for all RPCs on this connection in HandleRPC will be derived from the returned context.\n     * -On the client side, the context is not derived from the returned context.\n     *\n     * @param ctInfo of ConnTagInfo\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"handles.cj","path":"grpc/src/transport/handles.cj","code_tokens":"func handleConn ( cs : ConnStats ) : Unit","func_name":"handleConn","docstring":"/*\n     * Process Conn statistics.\n     *\n     * @param cs of ConnStats\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"ssutils.cj","path":"grpc/src/transport/ssutils.cj","code_tokens":"public func isNull ( ) : Bool {  return this . isNone NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"static public func newLoopyWriter ( side : Int64 , fr : Framer , cbuf : ControlBuffer , bdpEst : BdpEstimator ) : LoopyWriter {  return LoopyWriter ( side : side , cbuf : cbuf , sendQuota : UInt32 ( defaultWindowSize ) , oiws : UInt32 ( defaultWindowSize ) , framer : fr , bdpEst : bdpEst ) NL }","func_name":"newLoopyWriter","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"public func run ( ) : GrpcError {   var err : GrpcError = NULL_ERR NL while ( true ) {   let ( it , errGet ) : ( CbItem , GrpcError ) = this . cbuf . get ( true ) NL err = this . runFirst ( it , errGet ) NL if ( ! err . isNull ( ) ) {  return err NL } NL  var gosched : Bool = true NL while ( true ) {   let ( itGet , errGetFalse ) : ( CbItem , GrpcError ) = this . cbuf . get ( false ) NL if ( ! errGetFalse . isNull ( ) ) {  this . cbuf . isClosed = true NL return errGetFalse NL } NL  var flagItNone : Bool = this . runItGet ( itGet ) NL if ( ! flagItNone ) {  err = this . runFlagItNone ( itGet ) NL if ( ! err . isNull ( ) ) {  return err NL } NL continue NL } NL  let ( isEmptyFlag , errd ) : ( Bool , GrpcError ) = this . processData ( ) NL if ( ! errd . isNull ( ) ) {  this . cbuf . isClosed = true NL return errd NL } NL if ( ! isEmptyFlag ) {  continue NL } NL if ( gosched ) {  gosched = false NL if ( this . framer . writer . offset < minBatchSize ) {  continue NL } NL } NL this . framer . writer . flush ( ) NL break NL } NL } NL return NULL_ERR NL }","func_name":"run","docstring":"/*\n     * The operation should be run in a separate goroutine.\n     * It reads control frames from controlBuf and processes them in the following ways:\n     * 1. Update the internal status of the loop, or/and\n     * 2. Write HTTP2 frame on the wire.\n     *\n     * Loop saves all the activity flows containing the data to be sent in the link list.\n     * All streams in the activeStreams link list must have:\n     * 1. Data to be sent, and\n     * 2. Flow level flow control quota is available.\n     *\n     * In each iteration of the running loop, in addition to processing the incoming control frame,\n     * loop calls processData, which processes a node in the activeStreams link list.\n     * This causes HTTP2 frames to be written to the underlying write buffer.\n     * When no more control frames can be read from controlBuf, loop will flush the write buffer.\n     * As an optimization, to increase the batch size of each refresh,\n     * if the batch size is too low and the stream goroutine has a chance to fill, the loop will generate a processor.\n     */"}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"private func runFirst ( it : CbItem , errGet : GrpcError ) : GrpcError {  if ( ! errGet . isNull ( ) ) {  this . cbuf . isClosed = true NL return errGet NL } NL  let err : GrpcError = this . handle ( it ) NL if ( ! err . isNull ( ) ) {  this . cbuf . isClosed = true NL return err NL } NL  let ( flag , errPD ) : ( Bool , GrpcError ) = this . processData ( ) NL if ( ! errPD . isNull ( ) ) {  this . cbuf . isClosed = true NL return errPD NL } NL return NULL_ERR NL }","func_name":"runFirst","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"private func runItGet ( itGet : CbItem ) : Bool {   var flagItNone : Bool = false NL if ( itGet is DefaultCbItem ) {  flagItNone = true NL } NL return flagItNone NL }","func_name":"runItGet","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"private func runFlagItNone ( itGet : CbItem ) : GrpcError {   let err : GrpcError = this . handle ( itGet ) NL if ( ! err . isNull ( ) ) {  this . cbuf . isClosed = true NL return err NL } NL  let ( flagPD , errp ) : ( Bool , GrpcError ) = this . processData ( ) NL if ( ! errp . isNull ( ) ) {  this . cbuf . isClosed = true NL return errp NL } NL return NULL_ERR NL }","func_name":"runFlagItNone","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"public func handle ( any : CbItem ) : GrpcError {  if ( any is IncomingWindowUpdate ) {  return this . incomingWindowUpdateHandler ( ( any as IncomingWindowUpdate ) . getOrThrow ( ) ) NL } else if ( any is OutgoingWindowUpdate ) {  return this . outgoingWindowUpdateHandler ( ( any as OutgoingWindowUpdate ) . getOrThrow ( ) ) NL } else if ( any is IncomingSettings ) {  return this . incomingSettingsHandler ( ( any as IncomingSettings ) . getOrThrow ( ) ) NL } else if ( any is OutgoingSettings ) {  return this . outgoingSettingsHandler ( ( any as OutgoingSettings ) . getOrThrow ( ) ) NL } else if ( any is HeaderFrame ) {  return this . headerHandler ( ( any as HeaderFrame ) . getOrThrow ( ) ) NL } else if ( any is RegisterStream ) {  return this . registerStreamHandler ( ( any as RegisterStream ) . getOrThrow ( ) ) NL } else if ( any is CleanupStream ) {  return this . cleanupStreamHandler ( ( any as CleanupStream ) . getOrThrow ( ) ) NL } else if ( any is EarlyAbortStream ) {  return this . earlyAbortStreamHandler ( ( any as EarlyAbortStream ) . getOrThrow ( ) ) NL } else if ( any is IncomingGoAway ) {  return this . incomingGoAwayHandler ( ) NL } else if ( any is DataFrameCbItem ) {  return this . preprocessData ( ( any as DataFrameCbItem ) . getOrThrow ( ) ) NL } else if ( any is Ping ) {  return this . pingHandler ( ( any as Ping ) . getOrThrow ( ) ) NL } else if ( any is GoAway ) {  return this . goAwayHandler ( ( any as GoAway ) . getOrThrow ( ) ) NL } else {  return GrpcError ( GrpcUnknown , transport: unknown control message type  ) NL } NL }","func_name":"handle","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func incomingWindowUpdateHandler ( w : IncomingWindowUpdate ) : GrpcError {  if ( w . streamID == 0 ) {  this . sendQuota += w . increment NL return NULL_ERR NL } NL if ( this . estdStreams . contains ( w . streamID ) ) {   var str : OutStream = this . estdStreams [ w . streamID ] NL str . bytesOutStanding -= Int64 ( w . increment ) NL  let strQuota : Int64 = Int64 ( this . oiws ) - str . bytesOutStanding NL if ( strQuota > 0 && str . state == waitingOnStreamQuota ) {  str . state = active NL this . activeStreams . enqueue ( str ) NL return NULL_ERR NL } NL } NL return NULL_ERR NL }","func_name":"incomingWindowUpdateHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func outgoingWindowUpdateHandler ( w : OutgoingWindowUpdate ) : GrpcError {   let ( arr , err ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeWindowUpdate ( w . streamID , w . increment ) NL return err NL }","func_name":"outgoingWindowUpdateHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func incomingSettingsHandler ( s : IncomingSettings ) : GrpcError {  this . applySettings ( s . ss ) NL  let ( arr , errWsa ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeSettingsAck ( ) NL return errWsa NL }","func_name":"incomingSettingsHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func registerStreamHandler ( h : RegisterStream ) : GrpcError {   let str : OutStream = OutStream ( id : h . streamID , state : empty , wq : h . wq ) NL this . estdStreams . put ( h . streamID , str ) NL return NULL_ERR NL }","func_name":"registerStreamHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func outgoingSettingsHandler ( s : OutgoingSettings ) : GrpcError {   let ( arr , err ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeSettings ( s . ss ) NL return err NL }","func_name":"outgoingSettingsHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func headerHandler ( h : HeaderFrame ) : GrpcError {  if ( this . side == serverSide ) {  if ( ! this . estdStreams . contains ( h . streamID ) ) {  return NULL_ERR NL } NL  let str : OutStream = this . estdStreams [ h . streamID ] NL if ( ! h . endStream ) {  return this . writeHeader ( h . streamID , h . endStream , h . hf , h . onWrite ) NL } NL if ( str . state != empty ) {  str . itl . enqueue ( h ) NL return NULL_ERR NL } NL  let err : GrpcError = this . writeHeader ( h . streamID , h . endStream , h . hf , h . onWrite ) NL if ( ! err . isNull ( ) ) {  return err NL } NL return this . cleanupStreamHandler ( h . cleanup ) NL } NL  let str : OutStream = OutStream ( id : h . streamID , state : empty , wq : h . wq ) NL str . itl . enqueue ( h ) NL return this . originateStream ( str ) NL }","func_name":"headerHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func originateStream ( str : OutStream ) : GrpcError {   var hdr : HeaderFrame = ( str . itl . dequeue ( ) as HeaderFrame ) . getOrThrow ( ) NL  var err : GrpcError = hdr . initStream ( str . id ) NL if ( ! err . isNull ( ) ) {  match ( err as ConnectionError ) { case Some ( v ) => if ( v . desc . contains ( ConnectionError ) && v . temp ) {  return err NL } NL return NULL_ERR NL case None => return NULL_ERR NL } NL } NL err = this . writeHeader ( str . id , hdr . endStream , hdr . hf , hdr . onWrite ) NL if ( ! err . isNull ( ) ) {  return err NL } NL this . estdStreams . put ( str . id , str ) NL return NULL_ERR NL }","func_name":"originateStream","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func cleanupStreamHandler ( c : CleanupStream ) : GrpcError {  c . onWrite ( ) NL  var str : OutStream = EMPTY_OUTSTREAM NL if ( this . estdStreams . contains ( c . streamID ) ) {  str = this . estdStreams [ c . streamID ] NL this . estdStreams . remove ( c . streamID ) NL str . deleteSelf ( ) NL } NL if ( c . rst ) {   let ( arr , err ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeRSTStream ( c . streamID , c . rstCode ) NL if ( ! err . isNull ( ) ) {  return err NL } NL } NL if ( this . side == clientSide && this . draining && this . estdStreams . size == 0 ) {  return ErrConnClosing NL } NL return NULL_ERR NL }","func_name":"cleanupStreamHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func earlyAbortStreamHandler ( eas : EarlyAbortStream ) : GrpcError {  if ( this . side == clientSide ) {  return GrpcError ( GrpcUnknown , earlyAbortStream not handled on client ) NL } NL if ( eas . httpStatus == 0 ) {  eas . httpStatus = 200 NL } NL  let headerFields : Array < HeaderField > = [ HeaderField ( :status , itoa ( Int64 ( eas . httpStatus ) ) ) , HeaderField ( content-type , contentType ( eas . contentSubtype ) ) , HeaderField ( grpc-status , itoa ( Int64 ( eas . status . code ) ) ) , HeaderField ( grpc-message , encodeGrpcMessage ( eas . status . msg ) ) ] NL  var err : GrpcError = this . writeHeader ( eas . streamID , true , headerFields , defaultUnitToUnit , hasOnWrite : false ) NL if ( ! err . isNull ( ) ) {  return err NL } NL if ( eas . rst ) {   let ( arr , errRST ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeRSTStream ( eas . streamID , ErrCodeNo ) NL if ( ! errRST . isNull ( ) ) {  return errRST NL } NL } NL return NULL_ERR NL }","func_name":"earlyAbortStreamHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func incomingGoAwayHandler ( ) : GrpcError {  if ( this . side == clientSide ) {  this . draining = true NL if ( this . estdStreams . size == 0 ) {  return ErrConnClosing NL } NL } NL return NULL_ERR NL }","func_name":"incomingGoAwayHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func goAwayHandler ( g : GoAway ) : GrpcError {  match ( this . ssGoAwayHandler ) { case Some ( f ) =>  let ( drainingGah , err ) : ( Bool , GrpcError ) = f ( g ) NL if ( ! err . isNull ( ) ) {  return err NL } NL this . draining = drainingGah NL case None => ( ) NL } NL return NULL_ERR NL }","func_name":"goAwayHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func preprocessData ( df : DataFrameCbItem ) : GrpcError {  if ( ! this . estdStreams . contains ( df . streamID ) ) {  return NULL_ERR NL } NL  let str : OutStream = this . estdStreams [ df . streamID ] NL str . itl . enqueue ( df ) NL if ( str . state == empty ) {  str . state = active NL this . activeStreams . enqueue ( str ) NL } NL return NULL_ERR NL }","func_name":"preprocessData","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func pingHandler ( p : Ping ) : GrpcError {  if ( ! p . ack ) {  this . bdpEst . timesnap ( p . data ) NL } NL  let ( arr , err ) : ( Array < UInt8 > , GrpcError ) = this . framer . writePing ( p . ack , p . data ) NL return err NL }","func_name":"pingHandler","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func writeHeader ( streamID : UInt32 , endStream : Bool , hf : Array < HeaderField > , onWrite : ( ) -> Unit , hasOnWrite ! : Bool = true ) : GrpcError {  if ( hasOnWrite ) {  onWrite ( ) NL } NL this . hBuf . clear ( ) NL  var err : GrpcError = NULL_ERR NL try {   let arrEncode : Array < UInt8 > = this . hEnc . encode ( ArrayList < HeaderField > ( hf ) ) NL this . hBuf . write ( arrEncode ) NL } catch ( e : Exception ) {  err = GrpcError ( GrpcUnknown , e . toString ( ) ) NL } NL  var endHeaders : Bool = false NL  var first : Bool = true NL while ( ! endHeaders ) {   var size : Int64 = this . hBuf . length NL if ( size > http2MaxFrameLen ) {  size = http2MaxFrameLen NL } else {  endHeaders = true NL } NL  let buf : Array < Byte > = Array < Byte > ( size , item : 0 ) NL  let num : Int64 = this . hBuf . read ( buf ) NL if ( num != size ) {  return GrpcError ( GrpcUnknown , read from this.hBuf fail! ) NL } NL if ( first ) {  first = false NL  let ( buffer , errWH ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeHeaders ( streamID , buf , endStream , endHeaders , 0 ) NL err = errWH NL } else {   let ( buffer , errWH ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeContinuation ( streamID , endHeaders , buf ) NL err = errWH NL } NL if ( ! err . isNull ( ) ) {  return err NL } NL } NL return NULL_ERR NL }","func_name":"writeHeader","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func applySettings ( ss : HashMap < Int64 , UInt32 > ) : GrpcError {  for ( ( k , v ) in ss ) {  if ( k == SettingInitialWindowSize ) {   let num : UInt32 = this . oiws NL this . oiws = v NL if ( num < this . oiws ) {  for ( ( kk , os ) in this . estdStreams ) {  if ( os . state == waitingOnStreamQuota ) {  os . state = active NL this . activeStreams . enqueue ( os ) NL } NL } NL } NL } NL } NL return NULL_ERR NL }","func_name":"applySettings","docstring":""}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func processData ( ) : ( Bool , GrpcError ) {  if ( this . sendQuota == 0 ) {  return ( true , NULL_ERR ) NL } NL  let str : OutStream = this . activeStreams . dequeue ( ) NL if ( str . isNull ( ) || str . itl . isEmpty ( ) ) {  return ( true , NULL_ERR ) NL } NL  let dataItemOption : Option < DataFrameCbItem > = str . itl . peek ( ) as DataFrameCbItem NL  var dataItem : DataFrameCbItem = DataFrameCbItem ( ) NL match ( dataItemOption ) { case Some ( v ) => dataItem = v NL case None => return ( true , GrpcError ( GrpcUnknown , str.itl.peek() type is not GrpcDataFrame. ) ) NL } NL if ( dataItem . h . size == 0 && dataItem . d . size == 0 ) {   let ( notReturn , errEnd ) : ( Bool , GrpcError ) = this . processDataIf ( str , dataItem ) NL if ( ! notReturn ) {  return ( notReturn , errEnd ) NL } NL return ( false , NULL_ERR ) NL } NL  var maxSize : Int64 = http2MaxFrameLen NL  let strQuota : Int64 = Int64 ( this . oiws ) - str . bytesOutStanding NL if ( strQuota <= 0 ) {  str . state = waitingOnStreamQuota NL return ( false , NULL_ERR ) NL } else if ( maxSize > strQuota ) {  maxSize = strQuota NL } NL if ( maxSize > Int64 ( this . sendQuota ) ) {  maxSize = Int64 ( this . sendQuota ) NL } NL  let ( notReturn , errEnd ) : ( Bool , GrpcError ) = this . processDataCentre ( maxSize , str , dataItem ) NL if ( ! notReturn ) {  return ( notReturn , errEnd ) NL } NL return ( false , NULL_ERR ) NL }","func_name":"processData","docstring":"/*\n     * Delete the first flow from the activity flow, write out up to 16KB of data,\n     * and then put it at the end of the activity flow if there is more data to send and the flow has some flow level flow control.\n     */"}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func processDataIf ( str : OutStream , dataItem : DataFrameCbItem ) : ( Bool , GrpcError ) {   var ( arr , err ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeData ( dataItem . streamID , dataItem . endStream , EMPTY_ARRAY_UINT8 ) NL if ( ! err . isNull ( ) ) {  return ( false , err ) NL } NL str . itl . dequeue ( ) NL  var trailer : Any = 0 NL if ( ! str . itl . isEmpty ( ) ) {  trailer = str . itl . peek ( ) NL } NL if ( str . itl . isEmpty ( ) ) {  str . state = empty NL } else if ( trailer is HeaderFrame ) {   let headerFrame : HeaderFrame = ( trailer as HeaderFrame ) . getOrThrow ( ) NL err = this . writeHeader ( headerFrame . streamID , headerFrame . endStream , headerFrame . hf , headerFrame . onWrite ) NL if ( ! err . isNull ( ) ) {  return ( false , err ) NL } NL err = this . cleanupStreamHandler ( headerFrame . cleanup ) NL if ( ! err . isNull ( ) ) {  return ( false , NULL_ERR ) NL } NL } else {  this . activeStreams . enqueue ( str ) NL } NL return ( true , NULL_ERR ) NL }","func_name":"processDataIf","docstring":"//the result is not return--notReturn."}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func processDataCentre ( maxSize : Int64 , str : OutStream , dataItem : DataFrameCbItem ) : ( Bool , GrpcError ) {   var buf : Array < UInt8 > = EMPTY_ARRAY_UINT8 NL  let hSize : Int64 = min ( maxSize , dataItem . h . size ) NL  let dSize : Int64 = min ( maxSize - hSize , dataItem . d . size ) NL  let size : Int64 = hSize + dSize NL if ( hSize != 0 ) {  if ( dSize == 0 ) {  buf = dataItem . h NL } else {   var localBuf : Array < UInt8 > = Array < UInt8 > ( size , item : 0 ) NL dataItem . h . copyTo ( localBuf , 0 , 0 , hSize ) NL dataItem . d . copyTo ( localBuf , 0 , hSize , dSize ) NL buf = localBuf [ 0 .. size ] NL } NL } else {  buf = dataItem . d NL } NL str . wq . replenish ( size ) NL  var endStream : Bool = false NL if ( dataItem . endStream && dataItem . h . size + dataItem . d . size <= size ) {  endStream = true NL } NL dataItem . onEachWrite ( ) NL  let ( arr , errWD ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeData ( dataItem . streamID , endStream , buf [ 0 .. size ] ) NL if ( ! errWD . isNull ( ) ) {  return ( false , errWD ) NL } NL str . bytesOutStanding += size NL this . sendQuota -= UInt32 ( size ) NL if ( hSize > = dataItem . h . size ) {  dataItem . h = EMPTY_ARRAY_UINT8 NL } else {  dataItem . h = dataItem . h [ hSize .. dataItem . h . size ] NL } NL if ( dSize > = dataItem . d . size ) {  dataItem . d = EMPTY_ARRAY_UINT8 NL } else {  dataItem . d = dataItem . d [ dSize .. dataItem . d . size ] NL } NL if ( dataItem . h . size == 0 && dataItem . d . size == 0 && ! str . itl . isEmpty ( ) ) {  str . itl . dequeue ( ) NL } NL return this . processDataEnd ( str ) NL }","func_name":"processDataCentre","docstring":"//the result is not return--notReturn."}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func processDataEnd ( str : OutStream ) : ( Bool , GrpcError ) {   let flagStrItlIsEmpty : Bool = str . itl . isEmpty ( ) NL  var trailer : Any = 0 NL if ( ! flagStrItlIsEmpty ) {  trailer = str . itl . peek ( ) NL } NL if ( str . itl . isEmpty ( ) ) {  str . state = empty NL } else if ( trailer is HeaderFrame ) {  match ( trailer as HeaderFrame ) { case Some ( v ) =>  var err : GrpcError = this . writeHeader ( v . streamID , v . endStream , v . hf , v . onWrite ) NL if ( ! err . isNull ( ) ) {  return ( false , err ) NL } NL err = this . cleanupStreamHandler ( v . cleanup ) NL if ( ! err . isNull ( ) ) {  return ( false , NULL_ERR ) NL } NL case None => ( ) NL } NL } else if ( Int64 ( this . oiws ) - str . bytesOutStanding <= 0 ) {  str . state = waitingOnStreamQuota NL } else {  this . activeStreams . enqueue ( str ) NL } NL return ( true , NULL_ERR ) NL }","func_name":"processDataEnd","docstring":"//the result is not return--notReturn."}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func itoa ( nums : Int64 ) : String {  return formatInt ( nums , 10 ) NL }","func_name":"itoa","docstring":"// +1 for sign of 64bit value in base 2"}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func formatInt ( nums : Int64 , base : Int64 ) : String {  if ( 0 <= nums && nums < NSMALLS && base == 10 ) {  return small ( nums ) NL } NL return formatBits ( UInt64 ( nums ) , base , nums < 0 , false ) NL }","func_name":"formatInt","docstring":"// for digit values >= 10."}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func small ( nums : Int64 ) : String {  if ( nums < 10 ) {  return digits . substring ( nums , 1 ) NL } NL return SMALLS_STR . substring ( nums * 2 , 2 ) NL }","func_name":"small","docstring":"// small returns the string for an i with 0 <= i < nSmalls."}
{"repo":"grpc","file":"loopy_writer.cj","path":"grpc/src/transport/loopy_writer.cj","code_tokens":"func formatBits ( nums : UInt64 , base : Int64 , neg : Bool , append_ : Bool ) : String {  if ( base < 2 || base > digits . size ) {  throw Exception ( strconv: illegal AppendInt/FormatInt base ) NL } NL  var index : Int64 = a . size NL  var num : UInt64 = nums NL if ( neg ) {  num = - num NL } NL if ( base == 10 ) {   var us : UInt64 = num NL while ( us > = 100 ) {   let isu : Int64 = Int64 ( us % 100 * 2 ) NL us /= 100 NL index -= 2 NL a [ index + 1 ] = UInt8 ( UInt32 ( SMALLS_STRING [ isu + 1 ] ) ) NL a [ index ] = UInt8 ( UInt32 ( SMALLS_STRING [ isu ] ) ) NL } NL  let ius : Int64 = Int64 ( us * 2 ) NL index -- NL a [ index ] = UInt8 ( UInt32 ( SMALLS_STRING [ ius + 1 ] ) ) NL if ( us > = 10 ) {  index -- NL a [ index ] = UInt8 ( UInt32 ( SMALLS_STRING [ ius ] ) ) NL } NL } NL if ( neg ) {  index -- NL a [ index ] = UInt8 ( UInt32 ( - ) ) NL } NL if ( append_ ) {  return  NL } NL return String . fromUtf8 ( a [ index .. a . size ] ) NL }","func_name":"formatBits","docstring":""}
{"repo":"grpc","file":"http2client.cj","path":"grpc/src/transport/http2client.cj","code_tokens":"public func write ( target : String , h2conn : H2ClientConn , hdr : Array < Byte > , data : Array < Byte > ) : Array < UInt8 > {   var ss : ByteArrayStream = handleData ( hdr , data ) NL  let req : H2Request = H2Request ( RequestMethod . POST , http://${target} ) NL if ( hdr [ 0 ] == 1 ) {  req . header . set ( grpc-encoding , gzip ) NL } NL req . header . set ( content-type , application/grpc ) NL req . header . set ( te , trailers ) NL req . body = ss NL  let fut : Future < H2Response > = spawn { => return h2conn . doRequest ( req ) NL } NL  let res : Option < H2Response > = fut . getResult ( DEFAULT_TIME_OUT ) NL match ( res ) { case Some ( v ) => return handleResponse ( v ) NL case None => throw Exception ( gprc request timeout ) NL } NL }","func_name":"write","docstring":"/*\n     * The Function is Write\n     *\n     * @param target of String\n     * @param hdr of Array<Byte>\n     * @param data of Array<Byte>\n     *\n     * @return Type of Array<UInt8>\n     */"}
{"repo":"grpc","file":"http2client.cj","path":"grpc/src/transport/http2client.cj","code_tokens":"public func handleResponse ( resp : H2Response ) : Array < UInt8 > {   var compress : String =  NL if ( resp . resp . status != 200 Ok ) {  throw Exception ( receive errer ) NL } NL for ( ( k , v ) in resp . resp . header ) {   let strKey : String = k . trim ( ) NL if ( strKey == grpc-status || strKey == Grpc-Status ) {  handleError ( v [ 0 ] . trim ( ) ) NL } else if ( strKey == grpc-encoding || strKey == Grpc-Encoding ) {  compress = v [ 0 ] . trim ( ) NL } NL } NL if ( ! resp . data . isEmpty ( ) ) {   var ss = resp . resp . body as ByteArrayStream NL  var data : Array < UInt8 > = ss . getOrThrow ( ) . readToEnd ( ) NL  var dataSize : Int64 = Int64 ( data [ 1 ] ) << 24 NL dataSize += Int64 ( data [ 2 ] ) << 16 NL dataSize += Int64 ( data [ 3 ] ) << 8 NL dataSize += Int64 ( data [ 4 ] ) NL if ( dataSize + 5 > data . size ) {  throw Exception ( data size error, data size should be ${dataSize} but receive ${data.size} ) NL } NL if ( dataSize == 0 ) {  return EMPTY_ARRAY_UINT8 NL } NL if ( data [ 0 ] == 1 ) {  if ( compress . isEmpty ( ) || compress != gzip ) {  throw Exception ( unknow compress method ) NL } NL  var buf : ByteArrayStream = ByteArrayStream ( 1024 ) NL  var dc : DecompressOutputStream = DecompressOutputStream ( buf , wrap : GzipFormat , bufLen : 1024 ) NL  let temp : Array < Byte > = data [ 5 .. 5 + dataSize ] NL dc . write ( temp ) NL dc . flush ( ) NL dc . close ( ) NL  let uncompressdata : Array < Byte > = buf . readToEnd ( ) NL return uncompressdata NL } NL return data [ 5 .. 5 + dataSize ] NL } NL return EMPTY_ARRAY_UINT8 NL }","func_name":"handleResponse","docstring":"/*\n     * The Function is handleResponse\n     *\n     * @param resp of H2Response\n     *\n     * @return Type of Array<UInt8>\n     */"}
{"repo":"grpc","file":"http2client.cj","path":"grpc/src/transport/http2client.cj","code_tokens":"public func handleStreamResponse ( resp : H2Response ) : ArrayList < Array < UInt8 > > {   var compress : String =  NL if ( resp . resp . status != 200 Ok ) {  throw Exception ( receive errer ) NL } NL for ( ( k , v ) in resp . resp . header ) {   let strKey : String = k . trim ( ) NL if ( strKey == grpc-status || strKey == Grpc-Status ) {  handleError ( v [ 0 ] . trim ( ) ) NL } else if ( strKey == grpc-encoding || strKey == Grpc-Encoding ) {  compress = v [ 0 ] . trim ( ) NL } NL } NL  var res : ArrayList < Array < UInt8 > > = ArrayList < Array < UInt8 > > ( ) NL  let dataframes : Array < DataFrame > = resp . data NL  let len : Int64 = dataframes . size NL  let byteArray : ByteArrayStream = ByteArrayStream ( ) NL for ( i in 0 .. len ) {   let dataframe : DataFrame = dataframes [ i ] NL for ( v in dataframe . data ) {  byteArray . write ( ByteBufferToArray ( v ) ) NL } NL  let data : Array < Byte > = byteArray . readToEnd ( ) NL if ( data . size < 5 ) {  continue NL } NL  let size : Int64 = getSize ( data ) NL if ( size == 0 ) {  continue NL } NL if ( data [ 0 ] == 1 ) {  if ( compress . isEmpty ( ) || compress != gzip ) {  throw Exception ( unknow compress method ) NL } NL  var buf : ByteArrayStream = ByteArrayStream ( 1024 ) NL  var dc : DecompressOutputStream = DecompressOutputStream ( buf , wrap : GzipFormat , bufLen : 1024 ) NL  var temp : Array < Byte > = data [ 5 .. 5 + size ] NL dc . write ( temp ) NL dc . flush ( ) NL dc . close ( ) NL  var uncompressdata = buf . readToEnd ( ) NL res . append ( uncompressdata ) NL continue NL } NL res . append ( data [ 5 .. 5 + size ] ) NL } NL return res NL }","func_name":"handleStreamResponse","docstring":"/*\n     * The Function is handleResponse\n     *\n     * @param resp of H2Response\n     *\n     * @return Type of ArrayList<UInt8>\n     */"}
{"repo":"grpc","file":"http2client.cj","path":"grpc/src/transport/http2client.cj","code_tokens":"func getSize ( data : Array < Byte > ) : Int64 {   var size : Int64 = Int64 ( data [ 1 ] ) << 24 NL size += Int64 ( data [ 2 ] ) << 16 NL size += Int64 ( data [ 3 ] ) << 8 NL size += Int64 ( data [ 4 ] ) NL if ( size + 5 > data . size ) {  throw Exception ( data size error, data size should be ${size} but receive ${data.size} ) NL } NL return size NL }","func_name":"getSize","docstring":""}
{"repo":"grpc","file":"http2client.cj","path":"grpc/src/transport/http2client.cj","code_tokens":"public func handleError ( errCode : String ) : Unit {   var num : Int64 = 0 NL for ( u in errCode . utf8View ) {  if ( u < b'0' || u > b'9' ) {  continue NL } NL  var n = u - b'0' NL num = num * 10 + Int64 ( n ) NL } NL match ( num ) { case 0 => ( ) NL case 1 => throw Exception ( CANCELLED ERROR  ) NL case 2 => throw Exception ( UNKNOWN ERROR ) NL case 3 => throw Exception ( INVALID_ARGUMENT ERROR ) NL case 4 => throw Exception ( DEADLINE_EXCEEDED ERROR ) NL case 5 => throw Exception ( NOT_FOUND ERROR ) NL case 6 => throw Exception ( ALREADY_EXISTS ERROR ) NL case 7 => throw Exception ( PERMISSION_DENIED ERROR ) NL case 8 => throw Exception ( RESOURCE_EXHAUSTED ERROR ) NL case 9 => throw Exception ( FAILED_PRECONDITION ERROR ) NL case 10 => throw Exception ( ABORTED ERROR ) NL case 11 => throw Exception ( OUT_OF_RANGE ERROR ) NL case 12 => throw Exception ( UNIMPLEMENTED ERROR ) NL case 13 => throw Exception ( INTERNAL ERROR ) NL case 14 => throw Exception ( UNAVAILABLE ERROR ) NL case 15 => throw Exception ( DATA_LOSS ERROR ) NL case 16 => throw Exception ( UNAUTHENTICATED ERROR ) NL case _ => throw Exception ( ILLEGAL VALUE ) NL } NL }","func_name":"handleError","docstring":"/*\n     * The function is handle received error\n     *\n     * @param errCode of String\n     *\n     */"}
{"repo":"grpc","file":"http2client.cj","path":"grpc/src/transport/http2client.cj","code_tokens":"public func setGrpcTimeout ( ns : Int64 ) : Unit {  if ( ns < 0 ) {  throw Exception ( Illegal Value  ) NL } NL DEFAULT_TIME_OUT = ns NL }","func_name":"setGrpcTimeout","docstring":"/*\n * The function is set timeout value\n *\n * @param ns of Int64\n *\n */"}
{"repo":"grpc","file":"http2client.cj","path":"grpc/src/transport/http2client.cj","code_tokens":"public func setRefreshTime ( ns : Int64 ) : Unit {  if ( ns < 0 ) {  throw Exception ( Illegal Value  ) NL } NL REFRESH_TIME = ns NL }","func_name":"setRefreshTime","docstring":"/*\n * The function is set request cache refresh time\n *\n * @param ns of Int64\n *\n */"}
{"repo":"grpc","file":"http2client.cj","path":"grpc/src/transport/http2client.cj","code_tokens":"public func getRefreshTime ( ) : Int64 {  return REFRESH_TIME NL }","func_name":"getRefreshTime","docstring":"/*\n * The function is get current request cache refresh time\n *\n * @return ns of Int64\n *\n */"}
{"repo":"grpc","file":"http2client.cj","path":"grpc/src/transport/http2client.cj","code_tokens":"func handleData ( hdr : Array < Byte > , data : Array < Byte > ) : ByteArrayStream {  if ( hdr [ 0 ] == 1 ) {   let compdata : Array < Byte > = compress ( data ) NL  let header : Array < Byte > = newmsgHeader ( compdata ) NL  var ss : ByteArrayStream = ByteArrayStream ( ) NL ss . write ( header ) NL ss . write ( compdata ) NL return ss NL } NL  var ss : ByteArrayStream = ByteArrayStream ( ) NL ss . write ( hdr ) NL ss . write ( data ) NL return ss NL }","func_name":"handleData","docstring":"/*\n * The Function is handleData\n *\n * @param hdr of Array<Byte>\n * @param data of Array<Byte>\n *\n * @return Type of StringStream\n */"}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func isNull ( ) : Bool {  return this . isNone NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"static public func newServerHandlerTransport ( w : ResponseWriteStream , r : Request , stats : Array < GrpcHandler > ) : ( ServerTransport , GrpcError ) {  if ( r . protoMajor != 2 ) {  return ( ServerHandlerTransport ( isNone : true ) , GrpcError ( GrpcUnknown , gRPC requires HTTP/2 ) ) NL } NL if ( r . method != RequestMethod . POST ) {  return ( ServerHandlerTransport ( isNone : true ) , GrpcError ( GrpcUnknown , invalid gRPC request method ) ) NL } NL  let cType : String = r . header . get ( Content-Type ) ??  NL  let ( cstype , validContentType ) : ( String , Bool ) = handleContentSubtype ( cType ) NL if ( ! validContentType ) {  return ( ServerHandlerTransport ( isNone : true ) , GrpcError ( GrpcUnknown , invalid gRPC request content-type ) ) NL } NL  let st : ServerHandlerTransport = ServerHandlerTransport ( rw : w , req : r , contentType : cType , contentSubtype : cstype , stats : stats ) NL  let v : String = r . header . get ( grpc-timeout ) ??  NL if ( ! v . isEmpty ( ) ) {   let ( to , err ) : ( Duration , GrpcError ) = decodeTimeout ( v ) NL if ( ! err . isNull ( ) ) {   let msg : String = malformed time-out:  + err . msg NL return ( ServerHandlerTransport ( isNone : true ) , GrpcError ( insideInternal , msg ) ) NL } NL st . timeoutSet = true NL st . timeout = to NL } NL  var metakv : HashMap < String , Array < String > > = HashMap < String , Array < String > > ( ) NL metakv . put ( content-type , [ cType ] ) NL if ( ! r . host . isEmpty ( ) ) {  appendHashMapValue ( metakv , :authority , r . host ) NL } NL for ( ( kk , vv ) in r . header ) {   let k : String = kk . toAsciiLower ( ) NL if ( isReservedHeader ( k ) && ! isWhitelistedHeader ( k ) ) {  continue NL } NL for ( vin in vv ) {   let ( val , err ) : ( String , GrpcError ) = decodeMetadataHeader ( k , vin ) NL if ( ! err . isNull ( ) ) {  return ( ServerHandlerTransport ( isNone : true ) , GrpcError ( insideInternal , malformed binary metadata: ${err.msg} ) ) NL } NL appendHashMapValue ( metakv , k , val ) NL } NL } NL st . headerMD = metakv NL return ( st , NULL_ERR ) NL }","func_name":"newServerHandlerTransport","docstring":"/*\n     * Returns the ServerTransport that handles gRPC from within the http handler.\n     * It requires the http server to support http/2.\n     */"}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func handleStreams ( startStream : ( Stream ) -> Unit , traceCtx : ( String ) -> Unit ) : Unit {   let req : Request = this . req NL  var strEncoding : String = req . header . get ( grpc-encoding ) ??  NL if ( strEncoding . isEmpty ( ) ) {  strEncoding = req . header . get ( Grpc-Encoding ) ??  NL } NL  let s : Stream = Stream ( id : 0 , method : req . url . path , st : this , recvCompress : strEncoding , contentSubtype : this . contentSubtype ) NL  let num : Int64 = this . stats . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = this . stats [ i ] NL sh . tagRPC ( RPCTagInfo ( fullMethodName : s . method ) ) NL  let inHeader : InHeader = InHeader ( fullMethod : s . method , remoteAddr : this . getRemoteAddr ( ) , compression : s . recvCompress ) NL sh . handleRPC ( inHeader ) NL } NL  let reader : InputStream = RecvBufferReader ( recv : s . buf ) NL s . trReader = TransportReader ( reader : reader ) NL spawn { =>  let readSize : Int64 = 8196 NL  var buf : Array < UInt8 > = Array < UInt8 > ( readSize , item : 0 ) NL while ( true ) {   var err : GrpcError = NULL_ERR NL  var n : Int64 = 0 NL try {  n = req . body . read ( buf ) NL } catch ( e : Exception ) {  err = GrpcError ( GrpcUnknown , e . message ) NL } NL if ( n > 0 ) {  s . write ( buf [ 0 .. n ] ) NL buf = buf [ n .. buf . size ] NL } else if ( n == 0 ) {  s . buf . put ( RecvMsg ( err : EOF_ERR ) ) NL return NL } NL if ( ! err . isNull ( ) ) {  s . buf . put ( RecvMsg ( err : mapRecvMsgError ( err ) ) ) NL return NL } NL if ( buf . size == 0 ) {  buf = Array < UInt8 > ( readSize , item : 0 ) NL } NL } NL } NL startStream ( s ) NL }","func_name":"handleStreams","docstring":""}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func writeHeader ( s : Stream , md : HashMap < String , Array < String > > ) : GrpcError {   let err : GrpcError = s . setHeader ( md ) NL if ( ! err . isNull ( ) ) {  return err NL } NL  let headersWritten : Bool = s . updateHeaderSent ( ) NL if ( ! headersWritten ) {  this . writePendingHeaders ( s ) NL } NL this . rw . writeStatusCode ( 200 ) NL this . rw . flush ( ) NL if ( err . isNull ( ) ) {   let num : Int64 = this . stats . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = this . stats [ i ] NL sh . handleRPC ( OutHeader ( header : md . clone ( ) , compression : s . sendCompress ) ) NL } NL } NL return err NL }","func_name":"writeHeader","docstring":""}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func write ( s : Stream , hdr : Array < UInt8 > , data : Array < UInt8 > ) : GrpcError {   let headersWritten : Bool = s . updateHeaderSent ( ) NL if ( ! headersWritten ) {  this . writePendingHeaders ( s ) NL } NL this . rw . write ( hdr ) NL this . rw . write ( data ) NL this . rw . flush ( ) NL return NULL_ERR NL }","func_name":"write","docstring":""}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func writeStatus ( s : Stream , st : GrpcError ) : GrpcError {  synchronized ( this . writeStatusMu ) {   let headersWritten : Bool = s . updateHeaderSent ( ) NL  var err : GrpcError = NULL_ERR NL if ( ! headersWritten ) {  this . writePendingHeaders ( s ) NL } NL this . rw . flush ( ) NL  let header : Header = this . rw . header ( ) NL header . set ( Grpc-Status , st . code . toString ( ) ) NL  let msg : String = st . msg NL if ( ! msg . isEmpty ( ) ) {  header . set ( Grpc-Message , encodeGrpcMessage ( msg ) ) NL } NL if ( ! st . isNull ( ) ) {   let ( stBytes , errh ) : ( Array < UInt8 > , GrpcError ) = handleMarshal ( st ) NL if ( ! errh . isNull ( ) ) {  throw Exception ( errh . msg ) NL } NL header . set ( Grpc-Status-Details-Bin , encodeBinHeader ( stBytes ) ) NL } NL  let md : HashMap < String , Array < String > > = s . getTrailer ( ) NL if ( md . size > 0 ) {  for ( ( k , vv ) in md ) {  if ( isReservedHeader ( k ) ) {  continue NL } NL  let num : Int64 = vv . size NL for ( i in 0 .. num ) {  header . add ( trailerPrefix + k , encodeMetadataHeader ( k , vv [ i ] ) ) NL } NL } NL } NL if ( err . isNull ( ) ) {   let num : Int64 = this . stats . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = this . stats [ i ] NL sh . handleRPC ( OutTrailer ( trailer : s . trailer . clone ( ) ) ) NL } NL } NL this . close ( ) NL return err NL } NL }","func_name":"writeStatus","docstring":""}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func handleMarshal ( err : GrpcError ) : ( Array < UInt8 > , GrpcError ) {   var data : Array < Byte > = Array < Byte > ( ) NL  var error : GrpcError = NULL_ERR NL try {   let errMessage : GrpcErrorMessage = GrpcErrorMessage ( err . code , err . msg ) NL data = BaseCodec ( ) . marshal ( ( errMessage as Message ) . getOrThrow ( ) ) NL } catch ( e : Exception ) {  error = GrpcError ( GrpcUnknown , e . message ) NL } NL return ( data , error ) NL }","func_name":"handleMarshal","docstring":""}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func writePendingHeaders ( stream : Stream ) : Unit {  this . writeCommonHeaders ( stream ) NL this . writeCustomHeaders ( stream ) NL }","func_name":"writePendingHeaders","docstring":"//Set public and custom headers on the first write call (write, WriteHeader, or WriteStatus)"}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func writeCommonHeaders ( stream : Stream ) : Unit {   let header : Header = this . rw . header ( ) NL header . set ( Date ,  ) NL header . set ( Content-Type , this . contentType ) NL header . add ( Trailer , Grpc-Status ) NL header . add ( Trailer , Grpc-Message ) NL header . add ( Trailer , Grpc-Status-Details-Bin ) NL if ( ! stream . sendCompress . isEmpty ( ) ) {  header . set ( Grpc-Encoding , stream . sendCompress ) NL } NL }","func_name":"writeCommonHeaders","docstring":"//Set the public header on the first write call (write, WriteHeader, or WriteStatus)."}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func writeCustomHeaders ( stream : Stream ) : Unit {   let header : Header = this . rw . header ( ) NL  let streamHeader : HashMap < String , Array < String > > = stream . header . clone ( ) NL for ( ( k , vv ) in streamHeader ) {  if ( isReservedHeader ( k ) ) {  continue NL } NL  let num : Int64 = vv . size NL for ( i in 0 .. num ) {  header . add ( k , encodeMetadataHeader ( k , vv [ i ] ) ) NL } NL } NL streamHeader . clear ( ) NL }","func_name":"writeCustomHeaders","docstring":"//Set the public header on the first write call (write, WriteHeader, or WriteStatus)."}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func close ( ) : Unit {  }","func_name":"close","docstring":""}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func getRemoteAddr ( ) : SocketAddress {   let remoteAddr : String = this . req . url . host NL if ( remoteAddr . isEmpty ( ) ) {  return SocketAddress ( 0.0.0.0 , 0 ) NL } NL  let ( host , port , err ) : ( String , String , String ) = splitHostPort ( remoteAddr ) NL if ( ! err . isEmpty ( ) ) {  return SocketAddress ( 0.0.0.0 , 0 ) NL } NL return SocketAddress ( host , UInt16 . parse ( port ) ) NL }","func_name":"getRemoteAddr","docstring":"//like: IP:port"}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func incrMsgSent ( ) : Unit {  }","func_name":"incrMsgSent","docstring":""}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func incrMsgRecv ( ) : Unit {  }","func_name":"incrMsgRecv","docstring":""}
{"repo":"grpc","file":"handle_server.cj","path":"grpc/src/transport/handle_server.cj","code_tokens":"public func drain ( ) : Unit {  throw Exception ( drain() is not implemented ) NL }","func_name":"drain","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"static public func newServerTransport ( conn : GRPCConnSocket , config : ServerConfig ) : ( Option < ServerTransport > , GrpcError ) {   let ( framer , loopy , t , errS ) : ( Framer , LoopyWriter , Http2Server , GrpcError ) = newServerTransportStart ( conn , config ) NL if ( ! errS . isNull ( ) ) {  return ( None , errS ) NL } NL  var err : GrpcError = NULL_ERR NL  func errClose ( ) {  if ( ! err . isNull ( ) ) {  t . close ( ) NL } NL } NL  var preface : Array < UInt8 > = Array < UInt8 > ( clientPreface . size , item : 0 ) NL  var num : Int64 = 0 NL try {  num = t . conn . read ( preface ) NL } catch ( e : Exception ) {  err = GrpcError ( GrpcUnknown , e . message ) NL } NL if ( ! err . isNull ( ) ) {  errClose ( ) NL if ( err is EOFError ) {  return ( None , EOF_ERR ) NL } NL return ( None , ConnectionError ( transport: http2Server.HandleStreams failed to receive the preface from client: ${err.msg} , false , err ) ) NL } NL if ( preface != clientPreface ) {  errClose ( ) NL return ( None , ConnectionError ( transport: http2Server.HandleStreams received bogus greeting from client: ${preface} , false , NULL_ERR ) ) NL } NL  let ( frame , isMHFrame , errRF ) : ( Frame , Bool , GrpcError ) = t . framer . readFrame ( ) NL if ( errRF is EOFError || errRF is ErrUnexpectedEOF ) {  errClose ( ) NL return ( None , err ) NL } NL err = errRF NL if ( ! err . isNull ( ) ) {  errClose ( ) NL return ( None , ConnectionError ( transport: http2Server.HandleStreams failed to read initial settings frame: ${err.msg} , false , err ) ) NL } NL t . lastRead = unixNano ( ) NL if ( frame . types != FREAM_SETTINGS ) {  errClose ( ) NL return ( None , ConnectionError ( transport: http2Server.HandleStreams saw invalid preface type ${frame.types} from client , false , NULL_ERR ) ) NL } NL newServerTransportEnd ( t , ( frame as GrpcSettingsFrame ) . getOrThrow ( ) ) NL errClose ( ) NL return ( Option < ServerTransport > . Some ( t ) , NULL_ERR ) NL }","func_name":"newServerTransport","docstring":"/*\n     * Create an http2 transport using the conn and configuration options in the configuration.\n     * If successful, non-zero transmission and zero error are returned. \n     * On failure, it returns a nil transfer and a non nil error.\n     * For a special case, the underlying conn is closed before reading the client foreword, and it returns a nil transfer and a NIR error.\n     */"}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"func errClose ( ) {  if ( ! err . isNull ( ) ) {  t . close ( ) NL } NL }","func_name":"errClose","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"static private func newServerTransportEnd ( h2Server : Http2Server , frame : GrpcSettingsFrame ) : Unit {  h2Server . handleSettings ( frame ) NL spawn { => h2Server . loopy = LoopyWriter . newLoopyWriter ( serverSide , h2Server . framer , h2Server . controlBuf , h2Server . bdpEst ) NL h2Server . loopy . ssGoAwayHandler = h2Server . outgoingGoAwayHandler NL h2Server . loopy . run ( ) NL h2Server . conn . close ( ) NL h2Server . controlBuf . finish ( ) NL } NL }","func_name":"newServerTransportEnd","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"static private func newServerTransportStart ( conn : GRPCConnSocket , config : ServerConfig ) : ( Framer , LoopyWriter , Http2Server , GrpcError ) {   var authInfo : AuthInfo = Info ( CommonAuthInfo ( ) ) NL  let writeBufSize : Int64 = config . writeBufferSize NL  var maxHeaderListSize : Int64 = defaultServerMaxHeaderListSize NL if ( config . maxHeaderListSize > 0 ) {  maxHeaderListSize = Int64 ( config . maxHeaderListSize ) NL } NL  var framer : Framer = Framer ( conn , writeBufSize ) NL  let loopy : LoopyWriter = LoopyWriter ( framer : framer ) NL  var settings : HashMap < UInt16 , UInt32 > = HashMap < UInt16 , UInt32 > ( ) NL settings . put ( UInt16 ( SettingMaxFrameSize ) , UInt32 ( http2MaxFrameLen ) ) NL  var maxStreams : UInt32 = config . maxStreams NL if ( maxStreams == 0 ) {  maxStreams = UInt32 . Max NL } else {  settings . put ( UInt16 ( SettingMaxConcurrentStreams ) , UInt32 ( maxStreams ) ) NL } NL  let ( dynamicWindow , iwz , icwz ) : ( Bool , Int32 , Int32 ) = newServerTransportSettings ( settings , config ) NL  let ( arr , errWS ) : ( Array < UInt8 > , GrpcError ) = framer . writeSettings ( settings ) NL if ( ! errWS . isNull ( ) ) {  return ( framer , loopy , Http2Server ( conn : conn , framer : framer , loopy : loopy ) , ConnectionError ( transport: ${errWS.msg} , false , errWS ) ) NL } NL  let delta : UInt32 = UInt32 ( icwz - defaultWindowSize ) NL if ( delta > 0 ) {   let ( arrwu , errwu ) : ( Array < UInt8 > , GrpcError ) = framer . writeWindowUpdate ( 0 , delta ) NL if ( ! errwu . isNull ( ) ) {  return ( framer , loopy , Http2Server ( conn : conn , framer : framer , loopy : loopy ) , ConnectionError ( transport: ${errwu.msg} , false , errwu ) ) NL } NL } NL  let kp : ServerParameters = config . keepaliveParams NL newServerTransportHandleKp ( kp ) NL  let kep : EnforcementPolicy = config . keepalivePolicy NL if ( kep . minTime == EMPTY_TIME ) {  kep . minTime = defaultKeepalivePolicyMinTime NL } NL  let h2Server : Http2Server = Http2Server ( conn : conn , remoteAddr : conn . getRemoteAddr ( ) , localAddr : conn . getLocalAddr ( ) , authInfo : authInfo , framer : framer , loopy : loopy , maxStreams : maxStreams , inTapHandle : config . inTapHandle , fc : TrInFlow ( UInt32 ( icwz ) ) , state : reachable , stats : Array < GrpcHandler > ( config . statsHandlers ) , kp : kp , idle : Time . now ( ) , kep : kep , initialWindowSize : iwz ) NL newServerTransportH2Server ( h2Server , dynamicWindow ) NL return ( framer , loopy , h2Server , NULL_ERR ) NL }","func_name":"newServerTransportStart","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"static private func newServerTransportSettings ( settings : HashMap < UInt16 , UInt32 > , config : ServerConfig ) : ( Bool , Int32 , Int32 ) {   var iwz : Int32 = initialWindowSizeLen NL  var dynamicWindow : Bool = true NL if ( config . initialWindowSize > = defaultWindowSize ) {  iwz = config . initialWindowSize NL dynamicWindow = false NL } NL  var icwz : Int32 = initialWindowSizeLen NL if ( config . initialConnWindowSize > = defaultWindowSize ) {  icwz = config . initialConnWindowSize NL dynamicWindow = false NL } NL if ( iwz != defaultWindowSize ) {  settings . put ( UInt16 ( SettingInitialWindowSize ) , UInt32 ( iwz ) ) NL } NL if ( config . maxHeaderListSize != 0 ) {  settings . put ( UInt16 ( SettingInitialWindowSize ) , UInt32 ( config . maxHeaderListSize ) ) NL } NL if ( config . headerTableSize != 0 ) {  settings . put ( UInt16 ( SettingHeaderTableSize ) , UInt32 ( config . headerTableSize ) ) NL } NL return ( dynamicWindow , iwz , icwz ) NL }","func_name":"newServerTransportSettings","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"static private func newServerTransportH2Server ( t : Http2Server , dynamicWindow : Bool ) : Unit {  t . controlBuf = ControlBuffer ( ) NL if ( dynamicWindow ) {   var bdpe : BdpEstimator = BdpEstimator ( t . updateFlowControl ) NL bdpe . bdp = UInt32 ( initialWindowSizeLen ) NL t . bdpEst = bdpe NL } NL  let num : Int64 = t . stats . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = t . stats [ i ] NL sh . tagConn ( ConnTagInfo ( remoteAddr : t . remoteAddr , localAddr : t . localAddr ) ) NL sh . handleConn ( ConnBegin ( ) ) NL } NL t . framer . writer . flush ( ) NL }","func_name":"newServerTransportH2Server","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"static private func newServerTransportHandleKp ( kp : ServerParameters ) : Unit {  if ( kp . maxConnectionIdle == EMPTY_TIME ) {  kp . maxConnectionIdle = defaultMaxConnectionIdle NL } NL if ( kp . maxConnectionAge == EMPTY_TIME ) {  kp . maxConnectionAge = defaultMaxConnectionAge NL } NL if ( kp . maxConnectionAgeGrace == EMPTY_TIME ) {  kp . maxConnectionAgeGrace = defaultMaxConnectionAgeGrace NL } NL if ( kp . time == EMPTY_TIME ) {  kp . time = defaultServerKeepaliveTime NL } NL if ( kp . timeout == EMPTY_TIME ) {  kp . timeout = defaultServerKeepaliveTimeout NL } NL }","func_name":"newServerTransportHandleKp","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func outgoingGoAwayHandler ( g : GoAway ) : ( Bool , GrpcError ) {  synchronized ( this . maxStreamMu ) {  synchronized ( this . mu ) {  if ( this . state == closing ) {  return ( false , ErrConnClosing ) NL } NL if ( ! g . headsUp ) {  this . state = draining NL  var sid : UInt32 = this . maxStreamID NL if ( this . activeStreams . size == 0 ) {  g . closeConn = true NL } NL  let ( arr , err ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeGoAway ( sid , g . code , g . debugData ) NL if ( ! err . isNull ( ) ) {  return ( false , err ) NL } NL if ( g . closeConn ) {  this . framer . writer . flush ( ) NL return ( false , GrpcError ( GrpcUnknown , transport: Connection closing ) ) NL } NL return ( true , NULL_ERR ) NL } NL } NL } NL  let ( arr , err ) : ( Array < UInt8 > , GrpcError ) = this . framer . writeGoAway ( UInt32 . Max , ErrCodeNo , EMPTY_ARRAY_UINT8 ) NL if ( ! err . isNull ( ) ) {  return ( false , err ) NL } NL  let ( arrp , errp ) : ( Array < UInt8 > , GrpcError ) = this . framer . writePing ( false , goAwayPing . data ) NL if ( ! errp . isNull ( ) ) {  return ( false , errp ) NL } NL this . controlBuf . put ( GoAway ( code : g . code , debugData : g . debugData ) ) NL return ( false , NULL_ERR ) NL }","func_name":"outgoingGoAwayHandler","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"func updateFlowControl ( n : UInt32 ) : Unit {  synchronized ( this . mu ) {  for ( ( k , s ) in this . activeStreams ) {  s . fc . newLimit ( n ) NL } NL this . initialWindowSize = Int32 ( n ) NL } NL this . controlBuf . put ( OutgoingWindowUpdate ( streamID : 0 , increment : this . fc . newLimit ( n ) ) ) NL this . controlBuf . put ( OutgoingSettings ( ss : HashMap < UInt16 , UInt32 > ( [ ( UInt16 ( SettingInitialWindowSize ) , n ) ] ) ) ) NL }","func_name":"updateFlowControl","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func handleStreams ( handle : ( Stream ) -> Unit , traceCtx : ( String ) -> Unit ) : Unit {  while ( true ) {   let ( frame , isMHFrame , err ) : ( Frame , Bool , GrpcError ) = this . framer . readFrame ( ) NL this . lastRead = unixNano ( ) NL if ( ! err . isNull ( ) ) {  if ( err is StreamError ) {   let se : StreamError = ( err as StreamError ) . getOrThrow ( ) NL  var stream : Stream NL synchronized ( this . mu ) {  stream = this . activeStreams [ se . streamID ] NL } NL if ( ! stream . isNull ( ) ) {  this . closeStream ( stream , true , se . code , false ) NL } else {   let cleanupStream : CleanupStream = CleanupStream ( streamID : se . streamID , rst : true , rstCode : se . code ) NL this . controlBuf . put ( cleanupStream ) NL } NL continue NL } NL if ( err . msg . equals ( EOF ) || err . msg . equals ( unexpected EOF ) ) {  this . close ( ) NL return NL } NL this . close ( ) NL return NL } NL match ( frame . types ) { case 0x0 => this . handleData ( ( frame as GrpcDataFrame ) . getOrThrow ( ) ) NL case 0x3 => spawn { => this . handleRSTStream ( ( frame as GrpcRSTStreamFrame ) . getOrThrow ( ) ) NL } NL case 0x4 => spawn { => this . handleSettings ( ( frame as GrpcSettingsFrame ) . getOrThrow ( ) ) NL } NL case 0x6 => spawn { => this . handlePing ( ( frame as GrpcPingFrame ) . getOrThrow ( ) ) NL } NL case 0x8 => spawn { => this . handleWindowUpdate ( ( frame as GrpcWindowUpdateFrame ) . getOrThrow ( ) ) NL } NL case 0x7 => ( ) NL case _ => if ( isMHFrame ) {  if ( this . operateHeaders ( ( frame as MetaHeadersFrame ) . getOrThrow ( ) , handle , traceCtx ) ) {  this . close ( ) NL break NL } NL } NL } NL } NL }","func_name":"handleStreams","docstring":"//Receives the incoming stream using the given handler."}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"protected func getStream ( frame : Frame ) : ( Stream , Bool ) {  synchronized ( this . mu ) {  if ( ! this . activeStreams . contains ( frame . streamID ) ) {  return ( Stream ( ) , false ) NL } NL  let stream : Stream = this . activeStreams [ frame . streamID ] NL return ( stream , true ) NL } NL }","func_name":"getStream","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"protected func handleData ( frame : GrpcDataFrame ) : Unit {   let size : UInt32 = frame . length NL  var sendBDPPing : Bool = false NL if ( ! this . bdpEst . isNull ( ) ) {  sendBDPPing = this . bdpEst . add ( size ) NL } NL  let wnum : UInt32 = this . fc . onData ( size ) NL if ( wnum > 0 ) {   let owp : OutgoingWindowUpdate = OutgoingWindowUpdate ( streamID : 0 , increment : wnum ) NL this . controlBuf . put ( owp ) NL } NL if ( sendBDPPing ) {   let w : UInt32 = this . fc . reset ( ) NL if ( w > 0 ) {  this . controlBuf . put ( OutgoingWindowUpdate ( streamID : 0 , increment : w ) ) NL } NL this . controlBuf . put ( bdpPing ) NL } NL  let ( s , ok ) : ( Stream , Bool ) = this . getStream ( frame ) NL if ( ! ok ) {  return NL } NL if ( s . getState ( ) == streamReadDone ) {  this . closeStream ( s , true , ErrCodeStreamClosed , false ) NL return NL } NL if ( size > 0 ) {   let err : GrpcError = s . fc . onData ( size ) NL if ( ! err . isNull ( ) ) {  this . closeStream ( s , true , ErrCodeFlowControl , false ) NL return NL } NL if ( hasPadded ( frame . flags ) ) {   let num : UInt32 = s . fc . onRead ( size - frame . length ) NL if ( num > 0 ) {   let owp : OutgoingWindowUpdate = OutgoingWindowUpdate ( streamID : s . id , increment : num ) NL this . controlBuf . put ( owp ) NL } NL } NL if ( frame . length > 0 ) {   let arr : Array < UInt8 > = frame . payload NL if ( arr . size > 0 ) {  s . write ( arr ) NL } NL } NL } NL if ( streamEnded ( frame . flags ) ) {  s . compareAndSwapState ( streamActive , streamReadDone ) NL  let rm : RecvMsg = RecvMsg ( err : EOF_ERR ) NL s . write ( rm ) NL } NL }","func_name":"handleData","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"protected func handleRSTStream ( frame : GrpcRSTStreamFrame ) : Unit {   let ( s , ok ) : ( Stream , Bool ) = this . getStream ( frame ) NL if ( ok ) {  this . closeStream ( s , false , 0 , false ) NL return NL } NL  let cs : CleanupStream = CleanupStream ( streamID : frame . streamID , rst : false , rstCode : 0 , onWrite : defaultUnitToUnit ) NL this . controlBuf . put ( cs ) NL }","func_name":"handleRSTStream","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"protected func handleSettings ( frame : GrpcSettingsFrame ) : Unit {  if ( isAck ( frame . flags ) ) {  return NL } NL  var ss : HashMap < Int64 , UInt32 > = HashMap < Int64 , UInt32 > ( ) NL  let parameters : Array < UInt32 > = frame . parameters NL  let num : Int64 = parameters . size NL for ( i in 0 .. num ) {   let val : UInt32 = parameters [ i ] NL if ( val != 0 ) {  ss . put ( i , val ) NL } NL } NL  let incomingSettings : IncomingSettings = IncomingSettings ( ss : ss ) NL this . controlBuf . executeAndPut ( defaultAnyToBool , incomingSettings , fIsNull : true ) NL }","func_name":"handleSettings","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"func handlePing ( frame : GrpcPingFrame ) : Unit {  if ( isAck ( frame . flags ) ) {  if ( frame . payload == goAwayPing . data ) {  return NL } NL if ( ! this . bdpEst . isNull ( ) ) {  this . bdpEst . calculate ( frame . payload ) NL } NL return NL } NL  let pingAck : Ping = Ping ( ack : true , data : frame . payload ) NL this . controlBuf . put ( pingAck ) NL  let now : Time = Time . now ( ) NL if ( this . resetPingStrikes == 1 ) {  this . resetPingStrikes = 0 NL this . pingStrikes = 0 NL this . lastPingAt = now NL return NL } NL  var ns : Int64 = 0 NL synchronized ( this . mu ) {  ns = this . activeStreams . size NL } NL if ( ns < 1 && ! this . kep . permitWithoutStream ) {  this . lastPingAt += defaultPingTimeout NL if ( this . lastPingAt > now ) {  this . pingStrikes ++ NL } NL } else {  this . lastPingAt += this . kep . minTime NL if ( this . lastPingAt > now ) {  this . pingStrikes ++ NL } NL } NL if ( Int64 ( this . pingStrikes ) > maxPingStrikes ) {   let ga : GoAway = GoAway ( code : ErrCodeEnhanceYourCalm , debugData : too_many_pings . toUtf8Array ( ) , closeConn : true ) NL this . controlBuf . put ( ga ) NL } NL this . lastPingAt = now NL }","func_name":"handlePing","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"func handleWindowUpdate ( frame : GrpcWindowUpdateFrame ) : Unit {   let inwp : IncomingWindowUpdate = IncomingWindowUpdate ( streamID : frame . streamID , increment : frame . increment ) NL this . controlBuf . put ( inwp ) NL }","func_name":"handleWindowUpdate","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"protected func operateHeaders ( frame : MetaHeadersFrame , handle : ( Stream ) -> Unit , traceCtx : ( String ) -> Unit ) : Bool {  synchronized ( this . maxStreamMu ) {   let streamID : UInt32 = frame . headersFrame . streamID NL traceCtx ( traceCtx ) NL if ( frame . truncated ) {   let cs : CleanupStream = CleanupStream ( streamID : streamID , rst : true , rstCode : ErrCodeFrameSize , onWrite : defaultUnitToUnit ) NL this . controlBuf . put ( cs ) NL return false NL } NL if ( streamID % 2 != 1 || streamID <= this . maxStreamID ) {  return true NL } NL this . maxStreamID = streamID NL  let s : Stream = Stream ( id : streamID , st : this , fc : InFlow ( UInt32 ( this . initialWindowSize ) ) ) NL  var mdata : HashMap < String , Array < String > > = HashMap < String , Array < String > > ( ) NL  let ( isGRPC , httpMethod , headerError , timeoutSet , timeout ) : ( Bool , String , Bool , Bool , Duration ) = this . operateHeadersFor ( s , mdata , frame ) NL  let notReturn : Bool = this . operateHeadersCentre ( httpMethod , headerError , timeoutSet , timeout , isGRPC , streamID , s , mdata , frame ) NL if ( ! notReturn ) {  return notReturn NL } NL this . operateHeadersEnd ( s , mdata , frame ) NL handle ( s ) NL return false NL } NL }","func_name":"operateHeaders","docstring":"//Performs operations on decoded headers."}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"private func operateHeadersFor ( s : Stream , mdata : HashMap < String , Array < String > > , frame : MetaHeadersFrame ) : ( Bool , String , Bool , Bool , Duration ) {   var isGRPC : Bool = false NL  var httpMethod : String =  NL  var headerError : Bool = false NL  var timeoutSet : Bool = false NL  var timeout : Duration = Duration . nanosecond ( ) NL  let fields : Array < HeaderField > = frame . fields NL  let num : Int64 = fields . size NL for ( i in 0 .. num ) {   let hf : HeaderField = fields [ i ] NL if ( hf . name . equals ( content-type ) ) {   let ( contentSubtype , validContentType ) : ( String , Bool ) = handleContentSubtype ( hf . value ) NL if ( ! validContentType ) {  continue NL } NL appendHashMapValue ( mdata , hf . name , hf . value ) NL s . contentSubtype = contentSubtype NL isGRPC = true NL } else if ( hf . name . equals ( grpc-encoding ) || hf . name . equals ( Grpc-Encoding ) ) {  s . recvCompress = hf . value NL } else if ( hf . name . equals ( :method ) ) {  httpMethod = hf . value NL } else if ( hf . name . equals ( :path ) ) {  s . method = hf . value NL } else if ( hf . name . equals ( grpc-timeout ) ) {  timeoutSet = true NL  let ( duration , err ) : ( Duration , GrpcError ) = decodeTimeout ( hf . value ) NL timeout = duration NL if ( ! err . isNull ( ) ) {  headerError = true NL } NL } else if ( hf . name . equals ( connection ) ) {  headerError = true NL } else {  if ( isReservedHeader ( hf . name ) && ! isWhitelistedHeader ( hf . name ) ) {  continue NL } NL  let ( v , err ) : ( String , GrpcError ) = decodeMetadataHeader ( hf . name , hf . value ) NL if ( ! err . isNull ( ) ) {  headerError = true NL continue NL } NL appendHashMapValue ( mdata , hf . name , v ) NL } NL } NL return ( isGRPC , httpMethod , headerError , timeoutSet , timeout ) NL }","func_name":"operateHeadersFor","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"private func operateHeadersCentre ( httpMethod : String , headerError : Bool , timeoutSet : Bool , timeout : Duration , isGRPC : Bool , streamID : UInt32 , s : Stream , mdata : HashMap < String , Array < String > > , frame : MetaHeadersFrame ) : Bool {   var authority : Array < String > = Array < String > ( ) NL  var host : Array < String > = Array < String > ( ) NL  var authorityLen : Int64 = 0 NL  var lenHost : Int64 = 0 NL if ( mdata . contains ( :authority ) ) {  authority = mdata [ :authority ] NL authorityLen = authority . size NL } NL if ( mdata . contains ( host ) ) {  host = mdata [ host ] NL lenHost = host . size NL } NL if ( authorityLen > 1 || lenHost > 1 ) {   let errMsg : String = num values of :authority: ${authorityLen}, num values of host: ${lenHost}, both must only have 1 value as per HTTP/2 spec NL  let es : EarlyAbortStream = EarlyAbortStream ( httpStatus : 400 , streamID : streamID , contentSubtype : s . contentSubtype , status : GrpcError ( insideInternal , errMsg ) , rst : ! streamEnded ( frame . flags ) ) NL this . controlBuf . put ( es ) NL return false NL } NL if ( ! isGRPC || headerError ) {   let cs : CleanupStream = CleanupStream ( streamID : streamID , rst : true , rstCode : ErrCodeProtocol , onWrite : defaultUnitToUnit ) NL this . controlBuf . put ( cs ) NL return false NL } NL if ( authorityLen == 0 && lenHost > 0 ) {  mdata . put ( :authority , host ) NL } else {  mdata . remove ( host ) NL } NL if ( streamEnded ( frame . flags ) ) {  s . state = streamReadDone NL } NL if ( timeoutSet ) {  this . idleTimeout = timeout NL } NL return this . operateHeadersMu ( httpMethod , s , streamID , frame ) NL }","func_name":"operateHeadersCentre","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"private func operateHeadersMu ( httpMethod : String , s : Stream , streamID : UInt32 , frame : MetaHeadersFrame ) : Bool {  synchronized ( this . mu ) {  if ( this . state != reachable ) {  s . cancel NL return false NL } NL if ( UInt32 ( this . activeStreams . size ) > = this . maxStreams ) {   let cleanupStream : CleanupStream = CleanupStream ( streamID : streamID , rst : true , rstCode : ErrCodeRefusedStream , onWrite : defaultUnitToUnit ) NL this . controlBuf . put ( cleanupStream ) NL s . cancel NL return false NL } NL if ( ! httpMethod . equals ( POST ) ) {   let errMsg : String = http2Server.operateHeaders parsed a :method field: ${httpMethod} which should be POST NL  let es : EarlyAbortStream = EarlyAbortStream ( httpStatus : 405 , streamID : streamID , contentSubtype : s . contentSubtype , status : GrpcError ( insideInternal , errMsg ) , rst : ! streamEnded ( frame . flags ) ) NL this . controlBuf . put ( es ) NL s . cancel NL return false NL } NL if ( ! this . inTapHandle . isNull ( ) ) {   let info : String = s . method NL  var err : GrpcError = this . inTapHandle . f ( info ) NL if ( ! err . isNull ( ) ) {   let es : EarlyAbortStream = EarlyAbortStream ( httpStatus : 200 , streamID : s . id , contentSubtype : s . contentSubtype , status : err , rst : ! streamEnded ( frame . flags ) ) NL this . controlBuf . put ( es ) NL return false NL } NL } NL this . activeStreams . put ( streamID , s ) NL if ( this . activeStreams . size == 1 ) {  this . idle = TIME_UTC_ZONE NL } NL return true NL } NL }","func_name":"operateHeadersMu","docstring":"//the result is not return--notReturn."}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"private func operateHeadersEnd ( s : Stream , mdata : HashMap < String , Array < String > > , frame : MetaHeadersFrame ) : Unit {  if ( isOn ( ) ) {  this . czData . streamsStarted ++ NL this . czData . lastStreamCreatedTime = unixNano ( ) NL } NL  let num : Int64 = this . stats . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = this . stats [ i ] NL sh . tagRPC ( RPCTagInfo ( fullMethodName : s . method ) ) NL  let inHeader : InHeader = InHeader ( fullMethod : s . method , remoteAddr : this . remoteAddr , localAddr : this . localAddr , compression : s . recvCompress , wireLength : Int64 ( frame . length ) , header : mdata . clone ( ) ) NL sh . handleRPC ( inHeader ) NL } NL s . wq = WriteQuota ( Int32 ( defaultWriteQuota ) ) NL  let rs : RegisterStream = RegisterStream ( streamID : s . id , wq : s . wq ) NL this . controlBuf . put ( rs ) NL }","func_name":"operateHeadersEnd","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func writeHeader ( s : Stream , md : HashMap < String , Array < String > > ) : GrpcError {  if ( s . updateHeaderSent ( ) ) {  return ErrIllegalHeaderWrite NL } NL if ( s . getState ( ) == streamDone ) {  return NULL_ERR NL } NL s . headerAddMD ( md ) NL  let err : GrpcError = this . writeHeaderLocked ( s ) NL if ( ! err . isNull ( ) ) {  return err NL } NL return NULL_ERR NL }","func_name":"writeHeader","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func write ( s : Stream , hdr : Array < UInt8 > , data : Array < UInt8 > ) : GrpcError {  if ( ! s . isHeaderSent ( ) ) {   let err : GrpcError = this . writeHeader ( s , EMPTY_MD ) NL if ( ! err . isNull ( ) ) {  return err NL } NL } else {  if ( s . getState ( ) == streamDone ) {  return NULL_ERR NL } NL } NL  let df : DataFrameCbItem = DataFrameCbItem ( streamID : s . id , h : hdr , d : data , onEachWrite : this . setResetPingStrikes ) NL  let err : GrpcError = s . wq . get ( Int32 ( hdr . size + data . size ) ) NL if ( ! err . isNull ( ) ) {  return err NL } NL return this . controlBuf . put ( df ) NL }","func_name":"write","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func writeStatus ( s : Stream , st : GrpcError ) : GrpcError {  if ( s . getState ( ) == streamDone ) {  return NULL_ERR NL } NL  var trailingHeader : HeaderFrame = HeaderFrame ( ) NL  let flag : Bool = s . updateHeaderSent ( ) NL  var len : Int64 = HEADER_FIELDS_NUM_START NL if ( ! flag && s . header . size <= 0 ) {  len = HEADER_FIELDS_NUM NL } NL  let compress : String = s . getRecvCompress ( ) NL  let flagCompress : Bool = compress . equals ( gzip ) NL if ( flagCompress ) {  len ++ NL } NL  var headerFields : Array < HeaderField > = Array < HeaderField > ( len , item : EMPTY_HEADER_FIELD ) NL if ( ! flag ) {  if ( s . header . size > 0 ) {   let err : GrpcError = this . writeHeaderLocked ( s ) NL if ( ! err . isNull ( ) ) {  return err NL } NL } else {  headerFields [ 0 ] = HeaderField ( :status , 200 ) NL  let ctValue : String = contentType ( s . contentSubtype ) NL headerFields [ 1 ] = HeaderField ( content-type , ctValue ) NL } NL } NL if ( flagCompress ) {  headerFields [ len - 3 ] = HeaderField ( grpc-encoding , compress ) NL } NL headerFields [ len - 2 ] = HeaderField ( grpc-status , st . code . toString ( ) ) NL headerFields [ len - 1 ] = HeaderField ( grpc-message , st . message ( ) ) NL if ( s . trailer . size > 0 ) {  headerFields = appendHeaderFieldsFromMD ( headerFields , s . trailer ) NL } NL trailingHeader = HeaderFrame ( streamID : s . id , hf : headerFields , endStream : true , onWrite : this . setResetPingStrikes ) NL  let ( success , err ) : ( Bool , GrpcError ) = this . controlBuf . execute ( this . checkForHeaderListSize , trailingHeader ) NL if ( ! success ) {  if ( ! err . isNull ( ) ) {  return err NL } NL this . closeStream ( s , true , ErrCodeInternal , false ) NL return ErrHeaderListSizeLimitViolation NL } NL  let rst : Bool = s . getState ( ) == streamActive NL this . finishStream ( s , rst , ErrCodeNo , trailingHeader , true ) NL  let num : Int64 = this . stats . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = this . stats [ i ] NL sh . handleRPC ( OutTrailer ( trailer : s . trailer . clone ( ) ) ) NL } NL return NULL_ERR NL }","func_name":"writeStatus","docstring":"//There are no other I/O operations that can be performed on this stream."}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"protected func writeHeaderLocked ( s : Stream ) : GrpcError {   let flag : Bool = s . sendCompress . isEmpty ( ) NL  var len : Int64 = HEADER_FIELDS_NUM_START NL if ( ! flag ) {  len ++ NL } NL  var headerFields : Array < HeaderField > = Array < HeaderField > ( len , item : EMPTY_HEADER_FIELD ) NL headerFields [ 0 ] = HeaderField ( :status , 200 ) NL  let ctValue : String = contentType ( s . contentSubtype ) NL headerFields [ 1 ] = HeaderField ( content-type , ctValue ) NL if ( ! flag ) {  headerFields [ 2 ] = HeaderField ( grpc-encoding , s . sendCompress ) NL } NL if ( s . trailer . size > 0 ) {  headerFields = appendHeaderFieldsFromMD ( headerFields , s . header ) NL } NL  let hf : HeaderFrame = HeaderFrame ( streamID : s . id , hf : headerFields , endStream : false , onWrite : this . setResetPingStrikes ) NL  let ( success , err ) : ( Bool , GrpcError ) = this . controlBuf . executeAndPut ( checkForHeaderListSize , hf ) NL if ( ! success ) {  if ( ! err . isNull ( ) ) {  return err NL } NL this . closeStream ( s , true , ErrCodeInternal , false ) NL return ErrHeaderListSizeLimitViolation NL } NL  let num : Int64 = this . stats . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = this . stats [ i ] NL  let outHeader : OutHeader = OutHeader ( header : s . header . clone ( ) , compression : s . sendCompress ) NL sh . handleRPC ( outHeader ) NL } NL return NULL_ERR NL }","func_name":"writeHeaderLocked","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"func closeStream ( s : Stream , rst : Bool , rstCode : UInt32 , eosReceived : Bool ) : Unit {  s . swapState ( streamDone ) NL this . deleteStream ( s , eosReceived ) NL  let cs : CleanupStream = CleanupStream ( streamID : s . id , rst : rst , rstCode : rstCode , onWrite : defaultUnitToUnit ) NL this . controlBuf . put ( cs ) NL }","func_name":"closeStream","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"func setResetPingStrikes ( ) : Unit {  this . resetPingStrikes = 1 NL }","func_name":"setResetPingStrikes","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func checkForHeaderListSize ( it : Any ) : Bool {  if ( this . maxSendHeaderListSize == 0 ) {  return true NL } NL  let isHeaderFrame : Bool = it is HeaderFrame NL if ( isHeaderFrame ) {   let hdrFrame : HeaderFrame = ( it as HeaderFrame ) . getOrThrow ( ) NL  let hf : Array < HeaderField > = hdrFrame . hf NL  var sz : Int64 = 0 NL for ( i in 0 .. hf . size ) {  sz += hf [ i ] . size ( ) NL if ( sz > Int64 ( this . maxSendHeaderListSize ) ) {  return false NL } NL } NL } NL return true NL }","func_name":"checkForHeaderListSize","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func close ( ) : Unit {   var streams : HashMap < UInt32 , Stream > = HashMap < UInt32 , Stream > ( ) NL synchronized ( this . mu ) {  if ( this . state == closing ) {  return NL } NL this . state = closing NL streams = this . activeStreams NL this . activeStreams = HashMap < UInt32 , Stream > ( ) NL } NL this . controlBuf . finish ( ) NL this . conn . close ( ) NL for ( ( k , s ) in streams ) {  s . cancel NL } NL  let num : Int64 = this . stats . size NL for ( i in 0 .. num ) {   let sh : GrpcHandler = this . stats [ i ] NL  let connEnd : ConnEnd = ConnEnd ( ) NL sh . handleConn ( connEnd ) NL } NL }","func_name":"close","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func getRemoteAddr ( ) : SocketAddress {  return this . remoteAddr NL }","func_name":"getRemoteAddr","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func drain ( ) : Unit {  synchronized ( this . mu ) {   let ga : GoAway = GoAway ( code : ErrCodeNo , debugData : EMPTY_ARRAY_UINT8 , closeConn : true ) NL this . controlBuf . put ( ga ) NL } NL }","func_name":"drain","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func incrMsgSent ( ) : Unit {  this . czData . msgSent ++ NL this . czData . lastMsgSentTime = unixNano ( ) NL }","func_name":"incrMsgSent","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"public func incrMsgRecv ( ) : Unit {  this . czData . msgRecv ++ NL this . czData . lastMsgRecvTime = unixNano ( ) NL }","func_name":"incrMsgRecv","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"func deleteStream ( s : Stream , eosReceived : Bool ) : Unit {  synchronized ( mu ) {  match ( this . activeStreams . get ( s . id ) ) { case Some ( v ) => this . activeStreams . remove ( s . id ) NL if ( this . activeStreams . size == 0 ) {  this . idle = Time . now ( ) NL } NL case _ => ( ) NL } NL } NL if ( isOn ( ) ) {  if ( eosReceived ) {  this . czData . streamsSucceeded ++ NL } else {  this . czData . streamsFailed ++ NL } NL } NL }","func_name":"deleteStream","docstring":""}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"func finishStream ( s : Stream , rst : Bool , rstCode : UInt32 , hdr : HeaderFrame , eosReceived : Bool ) : Unit {   let oldState : UInt32 = s . swapState ( streamDone ) NL if ( oldState == streamDone ) {  return NL } NL  func onWriteInsideCS ( ) : Unit {  this . deleteStream ( s , eosReceived ) NL } NL hdr . cleanup = CleanupStream ( streamID : s . id , rst : rst , rstCode : rstCode , onWrite : onWriteInsideCS ) NL this . controlBuf . put ( hdr ) NL }","func_name":"finishStream","docstring":"//Close the flow and put the tail headerFrame in controlbuf."}
{"repo":"grpc","file":"http2_server.cj","path":"grpc/src/transport/http2_server.cj","code_tokens":"func onWriteInsideCS ( ) : Unit {  this . deleteStream ( s , eosReceived ) NL }","func_name":"onWriteInsideCS","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public open func toString ( ) : String {   let sb = StringBuilder ( ) NL  let types : String = match ( this . myType ) { case 0x0 => DATA NL case 0x1 => HEADERS NL case 0x2 => PRIORITY NL case 0x3 => RST_STREAM NL case 0x4 => SETTINGS NL case 0x5 => PUSH_PROMISE NL case 0x6 => PING NL case 0x7 => GOAWAY NL case 0x8 => WINDOW_UPDATE NL case 0x9 => CONTINUATION NL case 0xa => ALTSVC NL case 0xb => BLOCKED NL case 0xc => ORIGIN NL case _ => unknown NL } NL sb . append ( types ) . append ( : length =  ) . append ( this . myLength ) . append ( : flags =  ) . append ( this . myFlags ) . append ( , streamID =  ) . append ( this . myStreamID ) NL return sb . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func streamEnded ( ) : Bool {  return ( myFlags & FLAG_END_STREAM ) == FLAG_END_STREAM NL }","func_name":"streamEnded","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func setPriority ( streamDependency : Int64 , exclusive : Bool , weight : Int64 ) {  this . myStreamDependency = streamDependency NL this . myExclusive = exclusive NL this . myWeight = weight NL }","func_name":"setPriority","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func streamEnded ( ) : Bool {  return ( myFlags & FLAG_END_STREAM ) == FLAG_END_STREAM NL }","func_name":"streamEnded","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func headersEnded ( ) : Bool {  return ( myFlags & FLAG_END_HEADERS ) == FLAG_END_HEADERS NL }","func_name":"headersEnded","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func hasPriority ( ) : Bool {  return ( myFlags & FLAG_PRIORITY ) == FLAG_PRIORITY NL }","func_name":"hasPriority","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func isAck ( ) : Bool {  return ( myFlags & FLAG_ACK ) == FLAG_ACK NL }","func_name":"isAck","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func toString ( ) {   let sb = StringBuilder ( ) NL sb . append ( super . toString ( ) ) . append (  [Settings:  ) NL for ( i in 0 .. 6 ) {  if ( myParameters [ i ] != 0 ) {  sb . append ( name ( i ) ) . append ( = ) . append ( parameters [ i ] ) . append (   ) NL } NL } NL sb . append ( ] ) NL return sb . toString ( ) NL }","func_name":"toString","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"private func name ( num : Int64 ) : String {  return match ( num + 1 ) { case 1 => HEADER_TABLE_SIZE NL case 2 => ENABLE_PUSH NL case 3 => MAX_CONCURRENT_STREAMS NL case 4 => INITIAL_WINDOW_SIZE NL case 5 => MAX_FRAME_SIZE NL case 6 => MAX_HEADER_LIST_SIZE NL case _ => unknown parameter NL } NL }","func_name":"name","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func setParameter ( paramID : Int64 , value : UInt32 ) {  if ( paramID > MAX_PARAM ) {  throw IllegalArgumentException ( illegal parameter set ) NL } NL this . myParameters [ paramID - 1 ] = value NL }","func_name":"setParameter","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func getParameter ( paramID : Int64 ) : UInt32 {  if ( paramID > MAX_PARAM ) {  throw IllegalArgumentException ( illegal parameter get ) NL } NL return this . myParameters [ paramID - 1 ] NL }","func_name":"getParameter","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func headersEnded ( ) : Bool {  return ( myFlags & FLAG_END_HEADERS ) == FLAG_END_HEADERS NL }","func_name":"headersEnded","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func isAck ( ) : Bool {  return ( myFlags & FLAG_ACK ) == FLAG_ACK NL }","func_name":"isAck","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func headersEnded ( ) : Bool {  return ( myFlags & FLAG_END_HEADERS ) == FLAG_END_HEADERS NL }","func_name":"headersEnded","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func isNull ( ) : Bool {  return this . fields . size == 0 && ! this . truncated && this . types == FREAM_ERRORS && this . flags == 0 && this . streamID == 0 NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func checkPseudos ( ) : GrpcError {   var isRequest : Bool = false NL  var isResponse : Bool = false NL  let pf : Array < HeaderField > = pseudoFields ( ) NL  var index : Int64 = 0 NL  let num : Int64 = pf . size NL for ( i in 0 .. num ) {   let hf : HeaderField = pf [ i ] NL  let name : String = hf . name NL if ( name . equals ( :method ) || name . equals ( :path ) || name . equals ( :scheme ) || name . equals ( :authority ) ) {  isRequest = true NL } else if ( name . equals ( :status ) ) {  isResponse = true NL } else {  return GrpcError ( GrpcUnknown , invalid pseudo-header ${name} ) NL } NL for ( j in 0 .. index ) {   let hf2 : HeaderField = pf [ j ] NL if ( name . equals ( hf2 . name ) ) {  return GrpcError ( GrpcUnknown , duplicate pseudo-header ${name} ) NL } NL } NL index ++ NL } NL if ( isRequest && isResponse ) {  return GrpcError ( GrpcUnknown , mix of request and response pseudo headers ) NL } NL return NULL_ERR NL }","func_name":"checkPseudos","docstring":""}
{"repo":"grpc","file":"frame.cj","path":"grpc/src/transport/frame.cj","code_tokens":"public func pseudoFields ( ) : Array < HeaderField > {   let num : Int64 = this . fields . size NL for ( i in 0 .. num ) {  if ( ! isPseudo ( this . fields [ i ] ) ) {  return this . fields [ 0 .. i ] NL } NL } NL return this . fields NL }","func_name":"pseudoFields","docstring":"//Returns the pseudo header field of mh. The caller does not own the returned slice."}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func put ( rMsg : RecvMsg ) : Unit {  synchronized ( this . mu ) {  if ( ! this . err . isNull ( ) ) {  return NL } NL this . err = rMsg . err NL this . backlog . append ( rMsg ) NL } NL }","func_name":"put","docstring":""}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {  return - 1 NL }","func_name":"read","docstring":"/**\n     * The Function is read\n     *\n     * @param data of Array<Byte>\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {   let num : Int64 = this . reader . read ( buffer ) NL this . windowHandler ( num ) NL return num NL }","func_name":"read","docstring":"/**\n     * The Function is read\n     *\n     * @param data of Array<Byte>\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func isNull ( ) : Bool {  return this . isNone NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func read ( data : Array < Byte > ) : Int64 {  return this . dataReader . get ( data ) NL }","func_name":"read","docstring":"/**\n     * The Function is read\n     *\n     * @param data of Array<Byte>\n     *\n     * @return Type of Int64\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func write ( data : Array < Byte > ) : Unit {  this . dataReader . appendAll ( data ) NL }","func_name":"write","docstring":"/**\n     * The Function is write\n     *\n     * @param rMsg of RecvMsg\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func write ( rMsg : RecvMsg ) : Unit {  this . buf . put ( rMsg ) NL }","func_name":"write","docstring":"/**\n     * The Function is write\n     *\n     * @param rMsg of RecvMsg\n     *\n     * @return Type of Unit\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"protected func compareAndSwapState ( oldState : UInt32 , newState : UInt32 ) : Bool {   let flag : Bool = this . state == oldState NL if ( flag ) {  this . state = newState NL } NL return flag NL }","func_name":"compareAndSwapState","docstring":""}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func getTrailer ( ) : HashMap < String , Array < String > > {  return this . trailer . clone ( ) NL }","func_name":"getTrailer","docstring":"/**\n     * Trailer returns cached trailer metadata.\n     * Note that if it is not called after the completion of the entire flow, it may only return an empty MD. client.\n     * It can only read safely if io.EOF is returned from reading or writing after the stream ends.\n     *\n     * @return Type of HashMap<String, Array<String>>\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func getContentSubtype ( ) : String {  return this . contentSubtype NL }","func_name":"getContentSubtype","docstring":"/**\n     * The Function is getContentSubtype\n     *\n     * @return Type of String\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func getMethod ( ) : String {  return this . method NL }","func_name":"getMethod","docstring":"/**\n     * The Function is getMethod\n     *\n     * @return Type of String\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func getStatus ( ) : GrpcError {  return this . status NL }","func_name":"getStatus","docstring":"/**\n     * Status Returns the status received from the server.\n     * The state can be safely read only after the end of the stream, that is, after the completion of shutdown().\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public open func setHeader ( md : HashMap < String , Array < String > > ) : GrpcError {  if ( md . size == 0 ) {  return NULL_ERR NL } NL if ( isHeaderSent ( ) || getState ( ) == streamDone ) {  return ErrIllegalHeaderWrite NL } NL synchronized ( this . hdrMu ) {  join ( this . header , md ) NL } NL return NULL_ERR NL }","func_name":"setHeader","docstring":"/**\n     * Set header metadata. This can be called multiple. Server side only.\n     * This should not be called in parallel with other data writes.\n     *\n     * @param md of HashMap<String,Array<String>>\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public open func sendHeader ( md : HashMap < String , Array < String > > ) : GrpcError {  return this . st . getOrThrow ( ) . writeHeader ( this , md ) NL }","func_name":"sendHeader","docstring":"/**\n     * Send the given header metadata.\n     * The given metadata is combined with any metadata set by calling setheader before,\n     * and then written to the transport stream.\n     *\n     * @param md of HashMap<String,Array<String>>\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public open func setTrailer ( md : HashMap < String , Array < String > > ) : GrpcError {  if ( md . size == 0 ) {  return NULL_ERR NL } NL if ( this . getState ( ) == streamDone ) {  return ErrIllegalHeaderWrite NL } NL synchronized ( this . hdrMu ) {  join ( this . trailer , md ) NL } NL return NULL_ERR NL }","func_name":"setTrailer","docstring":"/**\n     * Sets the tail metadata that the server will send with RPC status.\n     * This can be called multiple times. Server side only.\n     * This should not be called in parallel with other data writes.\n     *\n     * @param md of HashMap<String,Array<String>>\n     *\n     * @return Type of GrpcError\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"protected func isHeaderSent ( ) : Bool {  return this . headerSent == 1 NL }","func_name":"isHeaderSent","docstring":"//Valid only on the server side."}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"protected func getState ( ) : UInt32 {  return this . state NL }","func_name":"getState","docstring":""}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func getRecvCompress ( ) : String {  return this . recvCompress NL }","func_name":"getRecvCompress","docstring":"/**\n     * Returns the compression algorithm applied to inbound messages.\n     * An empty string if compression is not applied.\n     *\n     * @return Type of String\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"protected func updateHeaderSent ( ) : Bool {   let oldNum : UInt32 = this . headerSent NL this . headerSent = 1 NL return oldNum == 1 NL }","func_name":"updateHeaderSent","docstring":"//Update headerSent. If it is set, return true. It is only valid on the server side."}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func swapState ( st : UInt32 ) : UInt32 {   let oldNum : UInt32 = this . state NL this . state = st NL return oldNum NL }","func_name":"swapState","docstring":"/**\n     * The Function is swapState\n     *\n     * @param st of UInt32\n     *\n     * @return Type of UInt32\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"transport_util.cj","path":"grpc/src/transport/transport_util.cj","code_tokens":"public func headerAddMD ( md : HashMap < String , Array < String > > ) : Unit {  synchronized ( this . hdrMu ) {  if ( md . size > 0 ) {  if ( this . header . size > 0 ) {  join ( this . header , md ) NL } else {  this . header = md NL } NL } NL } NL }","func_name":"headerAddMD","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func setDeadline ( time : Duration ) : Unit {  if ( time < Duration . nanosecond ( 1 ) ) {  this . hasTimeOut = false NL } else {  this . hasTimeOut = true NL this . idleConnTimeout = time NL this . idleReadTimeout = time NL this . idleWriteTimeout = time NL } NL }","func_name":"setDeadline","docstring":"/*\n     * Set the read/write deadline associated with the connection.\n     * This is equivalent to calling SetReadDeadline and SetWriteDeadline.\n     */"}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func read ( buffer : Array < Byte > ) : Int64 {  if ( this . hasTimeOut ) {  return this . conn . read ( buffer , idleConnTimeout ) NL } NL return this . conn . read ( buffer ) NL }","func_name":"read","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func write ( buffer : Array < Byte > ) : Unit {  if ( this . hasTimeOut ) {  this . conn . write ( buffer , idleConnTimeout ) NL } else {  this . conn . write ( buffer ) NL } NL }","func_name":"write","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func close ( ) : Unit {  this . conn . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func getLocalAddr ( ) : SocketAddress {  this . conn . getLocalAddr ( ) NL }","func_name":"getLocalAddr","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func getRemoteAddr ( ) : SocketAddress {  this . conn . getRemoteAddr ( ) NL }","func_name":"getRemoteAddr","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"func setTCP ( ) : Unit {  match ( this . ss ) { case GrpcSocketS ( server ) => server . noDelay = true NL server . quickAck = true NL case GrpcTlsS ( server ) => ( ) NL } NL }","func_name":"setTCP","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func hashCode ( ) : Int64 {  return ( 31 << 2 ) + this . ss . toString ( ) . hashCode ( ) NL }","func_name":"hashCode","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public operator func == ( that : GRPCServerSocket ) : Bool {  return refEq ( this , that ) || this . ss . toString ( ) . equals ( that . ss . toString ( ) ) NL }","func_name":"==","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public operator func != ( that : GRPCServerSocket ) : Bool {  return ! refEq ( this , that ) && ! this . ss . toString ( ) . equals ( that . ss . toString ( ) ) NL }","func_name":"!=","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func setDeadline ( time : Duration ) : Unit {  if ( time < Duration . nanosecond ( 1 ) ) {  this . hasTimeOut = false NL } else {  this . hasTimeOut = true NL this . idleConnTimeout = time NL this . idleReadTimeout = time NL this . idleWriteTimeout = time NL } NL }","func_name":"setDeadline","docstring":"/*\n     * Set the read/write deadline associated with the connection.\n     * This is equivalent to calling SetReadDeadline and SetWriteDeadline.\n     */"}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func accept ( ) : GRPCConn {   let conn : GRPCConn = if ( this . hasTimeOut ) {  this . ss . accept ( idleConnTimeout ) NL } else {  this . ss . accept ( ) NL } NL this . acceptSockets . append ( conn ) NL return conn NL }","func_name":"accept","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func getAddr ( ) : SocketAddress {  this . ss . getAddr ( ) NL }","func_name":"getAddr","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func isClosed ( ) : Unit {  this . ss . isClosed ( ) NL }","func_name":"isClosed","docstring":""}
{"repo":"grpc","file":"http2_server_util.cj","path":"grpc/src/transport/http2_server_util.cj","code_tokens":"public func close ( ) : Unit {  for ( socket in this . acceptSockets ) {  socket . close ( ) NL } NL this . acceptSockets . clear ( ) NL this . ss . close ( ) NL }","func_name":"close","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"func isRPCStats ( ) : Unit","func_name":"isRPCStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"func isClient ( ) : Bool","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isRPCStats ( ) : Unit {  }","func_name":"isRPCStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isRPCStats ( ) {  }","func_name":"isRPCStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isRPCStats ( ) : Unit {  }","func_name":"isRPCStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isRPCStats ( ) : Unit {  }","func_name":"isRPCStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"static public func getOutPayload ( client : Bool , msg : Any , data : Array < UInt8 > , payload : Array < UInt8 > , t : Time ) : OutPayload {  return OutPayload ( client : client , payload : msg , data : data , length : data . size , wireLength : payload . size + Int64 ( HEADER_LEN ) , sentTime : t ) NL }","func_name":"getOutPayload","docstring":"/**\n     * The Function is getOutPayload\n     *\n     * @param client of Bool\n     * @param msg of Any\n     * @param data of Array<UInt8>\n     * @param payload of Array<UInt8>\n     * @param t of Time\n     *\n     * @return Type of OutPayload\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isRPCStats ( ) : Unit {  }","func_name":"isRPCStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isRPCStats ( ) : Unit {  }","func_name":"isRPCStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isRPCStats ( ) : Unit {  }","func_name":"isRPCStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isRPCStats ( ) {  }","func_name":"isRPCStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"func isConnStats ( ) : Unit","func_name":"isConnStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"func isClient ( ) : Bool","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isConnStats ( ) : Unit {  }","func_name":"isConnStats","docstring":""}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isClient ( ) : Bool {  return this . client NL }","func_name":"isClient","docstring":"/*\n     * Indicates whether the statistics are from the client.\n     *\n     * @return Type of Bool\n     * @since 0.32.5\n     */"}
{"repo":"grpc","file":"stats.cj","path":"grpc/src/transport/stats.cj","code_tokens":"public func isConnStats ( ) : Unit {  }","func_name":"isConnStats","docstring":""}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func isNull ( ) : Bool {  return this . isNone NL }","func_name":"isNull","docstring":""}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func get ( sz : Int32 ) : GrpcError {  if ( this . quota > 0 ) {  this . quota = this . quota - sz NL } NL return NULL_ERR NL }","func_name":"get","docstring":""}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func realReplenish ( n : Int64 ) : Unit {  this . quota = this . quota + Int32 ( n ) NL }","func_name":"realReplenish","docstring":""}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func newLimit ( n : UInt32 ) : Unit {  synchronized ( this . mu ) {  this . limit = n NL } NL }","func_name":"newLimit","docstring":""}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func maybeAdjust ( num : UInt32 ) : UInt32 {   var n : UInt32 = num NL if ( n > UInt32 ( Int32 . Max ) ) {  n = UInt32 ( Int32 . Max ) NL } NL synchronized ( this . mu ) {   let estSenderQuota : Int32 = Int32 ( this . limit - ( this . pendingData + this . pendingUpdate ) ) NL  let estUntransmittedData : Int32 = Int32 ( n - this . pendingData ) NL if ( estUntransmittedData > estSenderQuota ) {  if ( ( this . limit + n ) > UInt32 ( maxWindowSize ) ) {  this . delta = UInt32 ( maxWindowSize ) - this . limit NL } else {  this . delta = n NL } NL return this . delta NL } NL } NL return 0 NL }","func_name":"maybeAdjust","docstring":""}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func onData ( n : UInt32 ) : GrpcError {  synchronized ( this . mu ) {  this . pendingData += n NL if ( ( this . pendingData + this . pendingUpdate ) > ( this . limit + this . delta ) ) {   let rcvd : UInt32 = this . pendingData + this . pendingUpdate NL return GrpcError ( GrpcUnknown , received ${rcvd}-bytes data exceeding the limit ${this.limit} bytes ) NL } NL } NL return NULL_ERR NL }","func_name":"onData","docstring":"/*\n     * When some data frames are received, onData will be called.\n     * It updates pendingData.\n     */"}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func onRead ( num : UInt32 ) : UInt32 {   var n : UInt32 = num NL synchronized ( this . mu ) {  if ( this . pendingData == 0 ) {  return 0 NL } NL this . pendingData -= n NL if ( n > this . delta ) {  n -= this . delta NL this . delta = 0 NL } else {  this . delta -= n NL n = 0 NL } NL this . pendingUpdate += n NL if ( this . pendingUpdate > = ( this . limit / 4 ) ) {   let wu : UInt32 = this . pendingUpdate NL this . pendingUpdate = 0 NL return wu NL } NL } NL return 0 NL }","func_name":"onRead","docstring":"/*\n     * OnRead is called when the application reads data.\n     * It returns the size of the window to send to the peer.\n     */"}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func newLimit ( n : UInt32 ) : UInt32 {   let d : UInt32 = n - this . limit NL this . limit = n NL this . updateEffectiveWindowSize ( ) NL return d NL }","func_name":"newLimit","docstring":""}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"protected func onData ( n : UInt32 ) : UInt32 {  this . unacked += n NL if ( this . unacked > = ( this . limit / 4 ) ) {   let num : UInt32 = this . unacked NL this . unacked = 0 NL this . updateEffectiveWindowSize ( ) NL return num NL } NL this . updateEffectiveWindowSize ( ) NL return 0 NL }","func_name":"onData","docstring":"/*\n     * When some data frames are received, onData will be called.\n     * It updates pendingData.\n     */"}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func reset ( ) : UInt32 {   let num : UInt32 = this . unacked NL this . unacked = 0 NL this . updateEffectiveWindowSize ( ) NL return num NL }","func_name":"reset","docstring":""}
{"repo":"grpc","file":"flowcontrol.cj","path":"grpc/src/transport/flowcontrol.cj","code_tokens":"public func updateEffectiveWindowSize ( ) : Unit {  this . effectiveWindowSize = this . limit - this . unacked NL }","func_name":"updateEffectiveWindowSize","docstring":""}
{"repo":"grpc","file":"attributes.cj","path":"grpc/src/attributes/attributes.cj","code_tokens":"public func Equal ( o : Attributes < K , V > ) : Bool {  if ( this . m . isEmpty ( ) && o . m . isEmpty ( ) ) {  return true NL } NL if ( this . m . isEmpty ( ) || o . m . isEmpty ( ) ) {  return false NL } NL if ( this . m . size != o . m . size ) {  return false NL } NL for ( ( k , v ) in this . m ) {  if ( ! o . m . contains ( k ) ) {  return false NL } NL  var ov = o . m [ k ] NL if ( v != o . m [ k ] ) {  return false NL } NL } NL return true NL }","func_name":"Equal","docstring":"/*\n     * Equal returns whether a and o are equivalent.  If 'Equal(o interface{})\n     * bool' is implemented for a value in the attributes, it is called to\n     * determine if the value matches the one stored in the other attributes.  If\n     * Equal is not implemented, standard equality is used to determine if the two\n     * values are equal. Note that some types (e.g. maps) aren't comparable by\n     * default, so they must be wrapped in a struct, or in an alias type, with Equal\n     * defined. \n     */"}
{"repo":"grpc","file":"attributes.cj","path":"grpc/src/attributes/attributes.cj","code_tokens":"public func new < K , V > ( key : K , value : V ) : Attributes < K , V > where K <: Hashable & Equatable < K > , V <: Equatable < V > {   var attr = Attributes < K , V > ( ) NL attr . m . put ( key , value ) NL return attr NL }","func_name":"new","docstring":"/**\n * New returns a new Attributes containing the key/value pair.\n */"}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"func updateState ( state : State ) : GrpcError","func_name":"updateState","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"func reportError ( error : GrpcError ) : Unit","func_name":"reportError","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"func newAddress ( addresses : ArrayList < Address > ) : Unit","func_name":"newAddress","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"func newServiceConfig ( serviceConfig : String ) : Unit","func_name":"newServiceConfig","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"func build ( target : resolver . Target ) : ( Resolver , GrpcError )","func_name":"build","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"func scheme ( ) : String","func_name":"scheme","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"func resolveNow ( resolve : ResolveNowOptions ) : Unit","func_name":"resolveNow","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"func close ( ) : Unit","func_name":"close","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"func getTarget ( ) : String","func_name":"getTarget","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"public func resloverGet ( scheme : String ) : Option < Builder > {   var b = reslover_m . get ( scheme ) NL if ( reslover_m . contains ( scheme ) ) {  return reslover_m . get ( scheme ) . getOrThrow ( ) NL } NL return Option < Builder > . None NL }","func_name":"resloverGet","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"public func setDefaultScheme ( scheme : String ) {  defaultScheme = scheme NL }","func_name":"setDefaultScheme","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"public func getDefaultScheme ( ) : String {  return defaultScheme NL }","func_name":"getDefaultScheme","docstring":""}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"public func equal ( o : Address ) : Bool {  return this . addr == o . addr && this . serverName == o . serverName && this . attributes . Equal ( o . attributes ) && this . addrType == o . addrType NL }","func_name":"equal","docstring":"/*\n     * Equal returns whether a and o are identical.  Metadata is compared directly,\n     * not with any recursive introspection.\n     */"}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"public func register ( b : Builder ) : Unit {  reslover_m . put ( b . scheme ( ) , b ) NL }","func_name":"register","docstring":"/**\n * Register registers the resolver builder to the resolver map. b.Scheme will be\n * used as the scheme registered with this builder.\n * NOTE: this function must only be called during initialization time (i.e. in\n * an init() function), and is not thread-safe. If multiple Resolvers are\n * registered with the same name, the one registered last will take effect.\n */"}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"public func unregisterForTesting ( scheme : String ) : Unit {  match ( reslover_m . remove ( scheme ) ) { case Some ( V ) => ( ) NL case None => throw Exception ( the scheme ${scheme} is not registered ) NL } NL }","func_name":"unregisterForTesting","docstring":"/**\n * UnregisterForTesting removes the resolver builder with the given scheme from the\n * resolver map.\n * This function is for testing only.\n */"}
{"repo":"grpc","file":"resolver.cj","path":"grpc/src/resolver/resolver.cj","code_tokens":"public func get ( scheme : String ) : Builder {   var b = reslover_m . get ( scheme ) NL match ( b ) { case Some ( v ) => return v NL case None => throw Exception ( not find resolver Builder ) NL } NL }","func_name":"get","docstring":"/**\n * Get returns the resolver builder registered with the given scheme.\n * If no builder is register with the scheme, a exception will be throwed.\n */"}
{"repo":"grpc","file":"map.cj","path":"grpc/src/resolver/map.cj","code_tokens":"public func get ( addr : Address ) : ( String , Bool ) {   var entryList = this . m [ addr . addr ] NL  var entry = findAddressMapEntryList ( entryList , addr ) NL if ( entry != - 1 ) {  return ( entryList [ entry ] . value , true ) NL } NL throw NoneValueException ( ) NL }","func_name":"get","docstring":"// Get returns the value for the address in the map, if present."}
{"repo":"grpc","file":"map.cj","path":"grpc/src/resolver/map.cj","code_tokens":"public func set ( addr : Address , value : String ) : Unit {  if ( addr . addr . isEmpty ( ) ) {  throw Exception ( Address addr is empty ) NL } NL if ( ! m . contains ( addr . addr ) ) {   var val = addressMapEntryList ( ) NL val . append ( addressMapEntry ( addr , value ) ) NL m . put ( addr . addr , val ) NL return NL } NL  var entryList = this . m [ addr . addr ] NL  var entry = findAddressMapEntryList ( entryList , addr ) NL if ( entry != - 1 ) {  this . m [ addr . addr ] [ entry ] . value = value NL return NL } NL  var val = addressMapEntryList ( ) NL val . append ( addressMapEntry ( addr , value ) ) NL this . m . put ( addr . addr , val ) NL }","func_name":"set","docstring":"// Set updates or adds the value to the address in the map."}
{"repo":"grpc","file":"map.cj","path":"grpc/src/resolver/map.cj","code_tokens":"public func delete ( addr : Address ) : Unit {   var entryList = this . m [ addr . addr ] NL  var entry = findAddressMapEntryList ( entryList , addr ) NL if ( entry == - 1 ) {  throw NoneValueException ( ) NL } NL if ( entryList . size == 1 ) {  entryList = ArrayList < addressMapEntry > ( ) NL } else {  entryList . remove ( entry ) NL } NL this . m [ addr . addr ] = entryList NL }","func_name":"delete","docstring":"// Delete removes addr from the map."}
{"repo":"grpc","file":"map.cj","path":"grpc/src/resolver/map.cj","code_tokens":"public func len ( ) : Int64 {   var ret = 0 NL for ( ( _ , v ) in this . m ) {  ret += v . size NL } NL return ret NL }","func_name":"len","docstring":"// Len returns the number of entries in the map."}
{"repo":"grpc","file":"map.cj","path":"grpc/src/resolver/map.cj","code_tokens":"public func keys ( ) : ArrayList < Address > {   var ret = ArrayList < Address > ( this . len ( ) ) NL for ( ( _ , entryList ) in this . m ) {  for ( entry in entryList ) {  ret . append ( entry . addr ) NL } NL } NL return ret NL }","func_name":"keys","docstring":"// Keys returns a slice of all current map keys."}
{"repo":"grpc","file":"map.cj","path":"grpc/src/resolver/map.cj","code_tokens":"public func newAddressMap ( ) : AddressMap {  return AddressMap ( ) NL }","func_name":"newAddressMap","docstring":"/**\n * NewAddressMap creates a new AddressMap.\n */"}
{"repo":"grpc","file":"map.cj","path":"grpc/src/resolver/map.cj","code_tokens":"func findAddressMapEntryList ( map : addressMapEntryList , addr : Address ) : Int64 {  if ( map . size == 0 ) {  return - 1 NL } NL  var i = 0 NL for ( v in map ) {  ( v as addressMapEntry ) . getOrThrow ( ) . addr . serverName NL if ( v . addr . serverName == addr . serverName && v . addr . attributes . Equal ( addr . attributes ) ) {  return i NL } NL i ++ NL } NL return - 1 NL }","func_name":"findAddressMapEntryList","docstring":"/**\n * find returns the index of addr in the addressMapEntry slice, or -1 if not\n * present.\n */"}
{"repo":"grpc","file":"passthrough.cj","path":"grpc/src/resolver/passthrough/passthrough.cj","code_tokens":"public func build ( target : resolver . Target ) : ( resolver . Resolver , GrpcError ) {   var r = passthroughResolver ( target ) NL r . start ( ) NL return ( r , NULL_ERR ) NL }","func_name":"build","docstring":""}
{"repo":"grpc","file":"passthrough.cj","path":"grpc/src/resolver/passthrough/passthrough.cj","code_tokens":"public func scheme ( ) : String {  return defaultScheme NL }","func_name":"scheme","docstring":""}
{"repo":"grpc","file":"passthrough.cj","path":"grpc/src/resolver/passthrough/passthrough.cj","code_tokens":"func start ( ) {   var arr = ArrayList < resolver . Address > ( ) NL  var addr = Address ( ) NL addr . addr = this . target . endpoint NL arr . append ( addr ) NL }","func_name":"start","docstring":"/*\n     * The Function is start a resolver\n     */"}
{"repo":"grpc","file":"passthrough.cj","path":"grpc/src/resolver/passthrough/passthrough.cj","code_tokens":"public func resolveNow ( o : resolver . ResolveNowOptions ) : Unit {  }","func_name":"resolveNow","docstring":"/*\n     * The Function is implement the interface Resolver\n     */"}
{"repo":"grpc","file":"passthrough.cj","path":"grpc/src/resolver/passthrough/passthrough.cj","code_tokens":"public func close ( ) {  }","func_name":"close","docstring":"/*\n     * The Function is implement the interface Resolver\n     */"}
{"repo":"grpc","file":"passthrough.cj","path":"grpc/src/resolver/passthrough/passthrough.cj","code_tokens":"public func getTarget ( ) : String {  return this . target . endpoint NL }","func_name":"getTarget","docstring":""}
{"repo":"grpc","file":"passthrough.cj","path":"grpc/src/resolver/passthrough/passthrough.cj","code_tokens":"public func initPassThrough ( ) {  resolver . register ( passthroughBuilder ( ) ) NL }","func_name":"initPassThrough","docstring":"/*\n * The Function is register a pass-through Builder into system resolver\n */"}
{"repo":"grpc","file":"manual.cj","path":"grpc/src/resolver/manual/manual.cj","code_tokens":"public func newBuilderWithScheme ( scheme : String ) : ManualResolver {  return ManualResolver ( { target : resolver . Target => } , { rn : resolver . ResolveNowOptions => } , { => } , scheme ) NL }","func_name":"newBuilderWithScheme","docstring":"// NewBuilderWithScheme creates a new test resolver builder with the given scheme."}
{"repo":"grpc","file":"manual.cj","path":"grpc/src/resolver/manual/manual.cj","code_tokens":"public func initialState ( s : resolver . State ) {  this . bootstrapState = s NL }","func_name":"initialState","docstring":""}
{"repo":"grpc","file":"manual.cj","path":"grpc/src/resolver/manual/manual.cj","code_tokens":"public func build ( target : resolver . Target ) : ( resolver . Resolver , GrpcError ) {  this . buildCallback ( target ) NL return ( this , NULL_ERR ) NL }","func_name":"build","docstring":""}
{"repo":"grpc","file":"manual.cj","path":"grpc/src/resolver/manual/manual.cj","code_tokens":"public func scheme ( ) : String {  return this . builderScheme NL }","func_name":"scheme","docstring":""}
{"repo":"grpc","file":"manual.cj","path":"grpc/src/resolver/manual/manual.cj","code_tokens":"public func resolveNow ( o : resolver . ResolveNowOptions ) : Unit {  this . resolveNowCallback ( o ) NL }","func_name":"resolveNow","docstring":""}
{"repo":"grpc","file":"manual.cj","path":"grpc/src/resolver/manual/manual.cj","code_tokens":"public func close ( ) : Unit {  this . closeCallback ( ) NL }","func_name":"close","docstring":"// Close is a noop for Resolver."}
{"repo":"grpc","file":"manual.cj","path":"grpc/src/resolver/manual/manual.cj","code_tokens":"public func updateState ( s : resolver . State ) : GrpcError {  this . cc . getOrThrow ( ) . updateState ( s ) NL }","func_name":"updateState","docstring":"// UpdateState calls cc.UpdateState."}
{"repo":"grpc","file":"manual.cj","path":"grpc/src/resolver/manual/manual.cj","code_tokens":"public func reportError ( err : GrpcError ) : Unit {  this . cc . getOrThrow ( ) . reportError ( err ) NL }","func_name":"reportError","docstring":"// ReportError calls cc.ReportError."}
{"repo":"grpc","file":"manual.cj","path":"grpc/src/resolver/manual/manual.cj","code_tokens":"public func getTarget ( ) : String {  if ( this . bootstrapState . addresses . size < 1 ) {  throw Exception ( empty address list ) NL } NL return this . bootstrapState . addresses [ 0 ] . addr NL }","func_name":"getTarget","docstring":""}
{"repo":"grpc","file":"dns_resolver.cj","path":"grpc/src/resolver/dns/dns_resolver.cj","code_tokens":"public func newDnsBuilder ( ) : resolver . Builder {  return internal . resolver . dns . NewBuilder ( ) NL }","func_name":"newDnsBuilder","docstring":"/**\n * NewBuilder creates a dnsBuilder which is used to factory DNS resolvers.\n *\n * Deprecated: import resolver and use resolver.get(\"dns\") instead.\n */"}
{"repo":"grpc","file":"http2_util.cj","path":"grpc/src/util/http2_util.cj","code_tokens":"public func unixNano ( ) : Int64 {   let oldTime : Time = Time ( 1970 , Month . January , 1 , loc : Location . UTC ) NL return Time . since ( oldTime ) . nanoseconds ( ) NL }","func_name":"unixNano","docstring":"//Nanoseconds elapsed since UTC on January 1, 1970(1970.01.01)"}
{"repo":"grpc","file":"http2_util.cj","path":"grpc/src/util/http2_util.cj","code_tokens":"public func validStreamID ( streamID : UInt32 ) : Bool {  return streamID != 0 && ( streamID & ( 1 << 31 ) ) == 0 NL }","func_name":"validStreamID","docstring":""}
{"repo":"grpc","file":"http2_util.cj","path":"grpc/src/util/http2_util.cj","code_tokens":"public func validWireHeaderFieldName ( v : String ) : Bool {  if ( v . isEmpty ( ) ) {  return false NL } NL for ( r in v ) {  if ( ! isTokenRune ( Int64 ( UInt32 ( r ) ) ) ) {  return false NL } NL if ( A <= r && r <= Z ) {  return false NL } NL } NL return true NL }","func_name":"validWireHeaderFieldName","docstring":""}
{"repo":"grpc","file":"http2_util.cj","path":"grpc/src/util/http2_util.cj","code_tokens":"public func handleContentSubtype ( contentType : String ) : ( String , Bool ) {  if ( contentType . equals ( baseContentType ) ) {  return (  , true ) NL } NL if ( contentType . contains ( baseContentType ) ) {   let res : String = clearHeadAndTailControlCharacters ( contentType ) NL if ( res . equals ( baseContentType ) ) {  return (  , true ) NL } NL } NL if ( ! contentType . startsWith ( baseContentType ) ) {  return (  , false ) NL } NL  let char : Char = contentType [ baseContentType . size ] NL if ( char == + || char == ; ) {  return ( contentType [ ( baseContentType . size + 1 ) .. contentType . size ] , true ) NL } else {  return (  , false ) NL } NL }","func_name":"handleContentSubtype","docstring":""}
{"repo":"grpc","file":"http2_util.cj","path":"grpc/src/util/http2_util.cj","code_tokens":"public func clearHeadAndTailControlCharacters ( contentType : String ) : String {  if ( ! hasNotPrintable ( contentType ) ) {  return contentType NL } NL  let arr : Array < UInt8 > = contentType . toUtf8Array ( ) NL  let ctSize : Int64 = arr . size NL  let res : Array < UInt8 > = Array < UInt8 > ( ctSize , item : 0 ) NL  var index : Int64 = 0 NL for ( i in 0 .. ctSize ) {   let num : UInt8 = arr [ i ] NL if ( num > = 32 && num < 127 ) {  res [ index ] = num NL index ++ NL } NL } NL return String . fromUtf8 ( res [ 0 .. index ] ) NL }","func_name":"clearHeadAndTailControlCharacters","docstring":""}
{"repo":"grpc","file":"http2_util.cj","path":"grpc/src/util/http2_util.cj","code_tokens":"public func hasNotPrintable ( msg : String ) : Bool {  for ( c in msg ) {  if ( c <   || c > ~ ) {  return true NL } NL } NL return false NL }","func_name":"hasNotPrintable","docstring":"//If msg contains any characters not in 0x20-0x7E(32-126)/(' ' - '~'), return true"}
{"repo":"grpc","file":"http2_util.cj","path":"grpc/src/util/http2_util.cj","code_tokens":"public func appendHashMapValue ( map : HashMap < String , Array < String > > , name : String , value : String ) : Unit {  if ( map . contains ( name ) ) {   let arr : Array < String > = map [ name ] NL if ( arr . size == 0 ) {  map . put ( name , Array < String > ( [ value ] ) ) NL } else {   let rst : Array < String > = Array < String > ( arr . size + 1 , item :  ) NL arr . copyTo ( rst , 0 , 0 , arr . size ) NL rst [ arr . size ] = value NL map . put ( name , rst ) NL } NL } else {  map . put ( name , Array < String > ( [ value ] ) ) NL } NL }","func_name":"appendHashMapValue","docstring":""}
{"repo":"grpc","file":"http2_util.cj","path":"grpc/src/util/http2_util.cj","code_tokens":"func isTokenRune ( r : Int64 ) : Bool {  return r < isTokenTables . size && isTokenTables [ r ] NL }","func_name":"isTokenRune","docstring":""}
{"repo":"grpc","file":"grpc_utils.cj","path":"grpc/src/util/grpc_utils.cj","code_tokens":"public func parseUInt8ToHexadecimal ( num : UInt8 ) : String {   let remainder : UInt8 = num % 16 NL  let division : UInt8 = num / 16 NL return % + arrHexadecimal [ Int64 ( division ) ] + arrHexadecimal [ Int64 ( remainder ) ] NL }","func_name":"parseUInt8ToHexadecimal","docstring":""}
{"repo":"grpc","file":"grpc_utils.cj","path":"grpc/src/util/grpc_utils.cj","code_tokens":"public func encodeGrpcMessage ( msg : String ) : String {  if ( msg . isEmpty ( ) ) {  return  NL } NL for ( c in msg ) {  if ( ! ( c > = spaceByte && c <= tildeByte && c != percentByte ) ) {  return encodeGrpcMessageUnchecked ( msg ) NL } NL } NL return msg NL }","func_name":"encodeGrpcMessage","docstring":"/*\n * Used to encode the status code in the header field \"grpc message\".\n * It is percentage encoded and replaces invalid utf-8 characters with Unicode replacement characters.\n * It checks whether each byte in the msg is an allowed byte, and then encodes or passes it as a percentage.\n * When percentage encoding is performed, the bytes are converted to hexadecimal notation, preceded by \"%\".\n */"}
{"repo":"grpc","file":"grpc_utils.cj","path":"grpc/src/util/grpc_utils.cj","code_tokens":"public func encodeGrpcMessageUnchecked ( str : String ) : String {   var msg : String = str NL  var buf : StringBuilder = StringBuilder ( ) NL while ( msg . size > 0 ) {   let ( num , size ) : ( Int32 , Int64 ) = decodeRuneInString ( msg ) NL  let numArr : Array < UInt8 > = Char ( num ) . toString ( ) . toUtf8Array ( ) NL for ( b in numArr ) {  if ( size > 1 ) {  buf . append ( parseUInt8ToHexadecimal ( b ) ) NL continue NL } NL  let bUInt32 : UInt32 = UInt32 ( b ) NL if ( bUInt32 > = UInt32 ( spaceByte ) && bUInt32 <= UInt32 ( tildeByte ) && bUInt32 != UInt32 ( percentByte ) ) {  buf . append ( Char ( b ) ) NL } else {  buf . append ( parseUInt8ToHexadecimal ( b ) ) NL } NL } NL msg = msg [ size .. msg . size ] NL } NL return buf . toString ( ) NL }","func_name":"encodeGrpcMessageUnchecked","docstring":"/*\n * Direct use within the scope of Asco code meter: \"1a\"=>\"1a\"\n * Conversion to% 16 base except ASK code table: \"China\"=>% E4% B8% AD% E5% 9B% BD\n */"}
{"repo":"grpc","file":"grpc_utils.cj","path":"grpc/src/util/grpc_utils.cj","code_tokens":"public func join ( mds : HashMap < String , Array < String > > , md : HashMap < String , Array < String > > ) : Unit {  for ( ( k , vv ) in md ) {  if ( mds . contains ( k ) ) {   var arr : Array < String > = mds . get ( k ) ?? Array < String > ( ) NL  let vals : Array < String > = Array < String > ( arr . size + vv . size , item :  ) NL vv . copyTo ( vals , 0 , 0 , vv . size ) NL arr . copyTo ( vals , 0 , vv . size , arr . size ) NL mds . put ( k , vals ) NL } else {  mds . put ( k , vv ) NL } NL } NL return NL }","func_name":"join","docstring":"/*\n * Join combines any number of MDs into one MD.\n * The value order of each key is determined by the rendering order of the mds containing these values.\n */"}
{"repo":"grpc","file":"grpc_utils.cj","path":"grpc/src/util/grpc_utils.cj","code_tokens":"public func appendHeaderFieldsFromMD ( headerFields : Array < HeaderField > , md : HashMap < String , Array < String > > ) : Array < HeaderField > {   let buf : ArrayList < HeaderField > = ArrayList < HeaderField > ( headerFields ) NL for ( ( k , vv ) in md ) {  if ( isReservedHeader ( k ) ) {  continue NL } NL  let num : Int64 = vv . size NL for ( i in 0 .. num ) {  buf . append ( HeaderField ( k , encodeMetadataHeader ( k , vv [ i ] ) ) ) NL } NL } NL return Array < HeaderField > ( buf ) NL }","func_name":"appendHeaderFieldsFromMD","docstring":""}
{"repo":"grpc","file":"grpc_utils.cj","path":"grpc/src/util/grpc_utils.cj","code_tokens":"public func encodeMetadataHeader ( k : String , v : String ) : String {  if ( k . endsWith ( binHdrSuffix ) ) {  return encodeBinHeader ( v . toUtf8Array ( ) ) NL } NL return v NL }","func_name":"encodeMetadataHeader","docstring":""}
{"repo":"grpc","file":"grpc_utils.cj","path":"grpc/src/util/grpc_utils.cj","code_tokens":"public func encodeBinHeader ( arr : Array < UInt8 > ) : String {  return toBase64String ( arr ) NL }","func_name":"encodeBinHeader","docstring":""}
{"repo":"grpc","file":"codec.cj","path":"grpc/src/util/codec.cj","code_tokens":"public func marshal ( m : Message ) : Array < Byte > {  return Proto . marshal ( m ) NL }","func_name":"marshal","docstring":"/**\n     * The Function is marshal\n     *\n     * @param m of Any\n     *\n     * @return Type of Array<Byte>\n     */"}
{"repo":"grpc","file":"codec.cj","path":"grpc/src/util/codec.cj","code_tokens":"public func unmarshal ( data : ArrayList < Byte > , m : Message ) : Unit {  Proto . unmarshal ( data , m ) NL }","func_name":"unmarshal","docstring":""}
{"repo":"grpc","file":"auth_info.cj","path":"grpc/src/util/auth_info.cj","code_tokens":"func authType ( ) : String","func_name":"authType","docstring":"/*\n     * The Function is authType\n     *\n     * @return Type of String\n     */"}
{"repo":"grpc","file":"auth_info.cj","path":"grpc/src/util/auth_info.cj","code_tokens":"public func getCommonAuthInfo ( ) : CommonAuthInfo {  return this NL }","func_name":"getCommonAuthInfo","docstring":"/*\n     * The Function is getCommonAuthInfo\n     *\n     * @return Type of CommonAuthInfo\n     */"}
{"repo":"grpc","file":"auth_info.cj","path":"grpc/src/util/auth_info.cj","code_tokens":"public func toString ( ) : String {  return match ( this ) { case InvalidSecurityLevel => InvalidSecurityLevel NL case NoSecurity => NoSecurity NL case IntegrityOnly => IntegrityOnly NL case PrivacyAndIntegrity => PrivacyAndIntegrity NL } NL }","func_name":"toString","docstring":"/**\n     * The Function is toString\n     *\n     * @return Type of String\n     */"}
{"repo":"grpc","file":"auth_info.cj","path":"grpc/src/util/auth_info.cj","code_tokens":"public func authType ( ) : String {  return insecure NL }","func_name":"authType","docstring":"/*\n     * The Function is authType\n     *\n     * @return Type of String\n     */"}
{"repo":"grpc","file":"utf8_util.cj","path":"grpc/src/util/utf8_util.cj","code_tokens":"public func decodeRuneInString ( str : String ) : ( Int32 , Int64 ) {   let n : Int64 = str . size NL if ( n < 1 ) {  return ( RuneError , 0 ) NL } NL  let s0 : Int32 = Int32 ( UInt32 ( str [ 0 ] ) ) NL  let x : UInt8 = first [ Int64 ( s0 ) ] NL if ( x > = as1 ) {   let mask : Int32 = ( Int32 ( x ) << 31 ) >> 31 NL  let s0Int32 : Int32 = s0 NL return ( s0Int32 ^ ( s0Int32 & mask ) | RuneError & mask , 1 ) NL } NL  let sz : Int64 = Int64 ( x & 7 ) NL  let accept : AcceptRange = acceptRanges [ Int64 ( x >> 4 ) ] NL if ( n < sz ) {  return ( RuneError , 1 ) NL } NL  let s1 : Int32 = Int32 ( UInt32 ( str [ 1 ] ) ) NL if ( s1 < Int32 ( accept . lo ) || Int32 ( accept . hi ) < s1 ) {  return ( RuneError , 1 ) NL } NL if ( sz <= 2 ) {  return ( ( s0 & Int32 ( mask2 ) ) << 6 | s1 & Int32 ( maskx ) , 2 ) NL } NL  let s2 : Int32 = Int32 ( UInt32 ( str [ 2 ] ) ) NL if ( s2 < Int32 ( locb ) || Int32 ( hicb ) < s2 ) {  return ( RuneError , 1 ) NL } NL if ( sz <= 3 ) {  return ( ( s0 & Int32 ( mask3 ) ) << 12 | ( s1 & Int32 ( maskx ) ) << 6 | s2 & Int32 ( maskx ) , 3 ) NL } NL  let s3 : Int32 = Int32 ( UInt32 ( str [ 3 ] ) ) NL if ( s3 < Int32 ( locb ) || Int32 ( hicb ) < s3 ) {  return ( RuneError , 1 ) NL } NL return ( ( s0 & Int32 ( mask4 ) ) << 18 | ( s1 & Int32 ( maskx ) ) << 12 | ( s2 & Int32 ( maskx ) ) << 6 | s3 & Int32 ( maskx ) , 4 ) NL }","func_name":"decodeRuneInString","docstring":"/*\n * It is similar to DecodeRun, but its input is a string. If s is null, it returns (RuneError, 0).\n * Otherwise, if the encoding is invalid, it returns (RuneError, 1).\n * For the correct non empty UTF-8, both results are impossible.\n * If the encoded UTF-8 is incorrect, the encoded character is out of range,\n * or it is not the shortest UTF-8 encoding of the value, then the encoding is invalid.\n * No additional validation is performed.\n */"}
{"repo":"grpc","file":"funcs.cj","path":"grpc/src/util/funcs.cj","code_tokens":"public func isOn ( ) : Bool {  return curState . compareAndSwap ( 1 , 1 ) NL }","func_name":"isOn","docstring":"//Returns whether channelz data collection is enabled."}
{"repo":"grpc","file":"proto.cj","path":"grpc/src/util/proto.cj","code_tokens":"static public func marshal ( m : Message ) : Array < Byte > {  return m . pack ( ) NL }","func_name":"marshal","docstring":"/**\n     * The Function is marshal\n     *\n     * @param m of Message\n     *\n     * @return Type of Array<Byte>\n     */"}
{"repo":"grpc","file":"proto.cj","path":"grpc/src/util/proto.cj","code_tokens":"static public func unmarshal ( b : ArrayList < Byte > , m : Message ) : Unit {  m . unpack ( b ) NL }","func_name":"unmarshal","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultAnyToUnit ( any : Any ) : Unit {  }","func_name":"defaultAnyToUnit","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultErrorToUnit ( any : Any ) : Unit {  }","func_name":"defaultErrorToUnit","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultUInt32ToUnit ( num : UInt32 ) : Unit {  }","func_name":"defaultUInt32ToUnit","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultUInt64ToUnit ( num : UInt64 ) : Unit {  }","func_name":"defaultUInt64ToUnit","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultInt64ToUnit ( num : Int64 ) : Unit {  }","func_name":"defaultInt64ToUnit","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultAnyToBool ( it : Any ) : Bool {  return false NL }","func_name":"defaultAnyToBool","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultUnitToUnit ( ) : Unit {  }","func_name":"defaultUnitToUnit","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultAnyToGrpcError ( it : Any ) : GrpcError {  return NULL_ERR NL }","func_name":"defaultAnyToGrpcError","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultUInt32ToGrpcError ( it : UInt32 ) : GrpcError {  return NULL_ERR NL }","func_name":"defaultUInt32ToGrpcError","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultByteArrayStreamToUnit ( buf : ByteArrayStream ) : Unit {  }","func_name":"defaultByteArrayStreamToUnit","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultServerInHandle ( info : String ) : GrpcError {  return NULL_ERR NL }","func_name":"defaultServerInHandle","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"protected func m_size ( ) : Int64 {  return 0 NL }","func_name":"m_size","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"protected func m_isEmpty ( ) : Bool {  return false NL }","func_name":"m_isEmpty","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"protected func m_clear ( ) : Unit {  }","func_name":"m_clear","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func unpacki ( src : BytesReader ) : Unit {  }","func_name":"unpacki","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func packi ( out : BytesWriter ) : Unit {  }","func_name":"packi","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func toString ( ) : String {  return  NL }","func_name":"toString","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func defaultAnyToAnyAndGrpcError ( any : Any ) : ( Message , GrpcError ) {  return ( C_DEFAULT_MESSAGELITE , NULL_ERR ) NL }","func_name":"defaultAnyToAnyAndGrpcError","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func contentType ( contentSubtype : String ) : String {  if ( contentSubtype . isEmpty ( ) ) {  return baseContentType NL } NL return baseContentType + + + contentSubtype NL }","func_name":"contentType","docstring":"/*\n * Generates a full content type using the given subtype.\n * ContentSubtype is assumed to be lowercase.\n */"}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func header ( ) : Header {  return Header ( ) NL }","func_name":"header","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func write ( buf : Array < UInt8 > ) : Unit {  }","func_name":"write","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func writeStatusCode ( statusCode : Int64 ) : Unit {  }","func_name":"writeStatusCode","docstring":""}
{"repo":"grpc","file":"defaults.cj","path":"grpc/src/util/defaults.cj","code_tokens":"public func flush ( ) : Unit {  }","func_name":"flush","docstring":""}
{"repo":"grpc","file":"block_byte_queue.cj","path":"grpc/src/buffer/block_byte_queue.cj","code_tokens":"public func appendAll ( buf : Array < UInt8 > ) : Unit {  synchronized ( m ) {   let bufSize : Int64 = buf . size NL if ( bufSize == 0 ) {  return NL } NL this . reserve ( bufSize ) NL buf . copyTo ( this . myData , 0 , this . start + this . length_ , bufSize ) NL m . notify ( notEmpty ) NL this . length_ += bufSize NL } NL }","func_name":"appendAll","docstring":""}
{"repo":"grpc","file":"block_byte_queue.cj","path":"grpc/src/buffer/block_byte_queue.cj","code_tokens":"func reserve ( needCapacity : Int64 ) : Unit {  if ( this . myData . size - this . start - this . length_ > = needCapacity ) {  return NL } NL this . grow ( this . myData . size + needCapacity ) NL }","func_name":"reserve","docstring":""}
{"repo":"grpc","file":"block_byte_queue.cj","path":"grpc/src/buffer/block_byte_queue.cj","code_tokens":"private func grow ( minCapacity : Int64 ) : Unit {   let oldCapacity : Int64 = this . myData . size NL  var newCapacity : Int64 = oldCapacity + ( oldCapacity >> 1 ) NL if ( newCapacity < minCapacity ) {  newCapacity = minCapacity NL } NL  let newData : Array < UInt8 > = Array < UInt8 > ( newCapacity , item : 0 ) NL this . myData . copyTo ( newData , 0 , 0 , this . start + this . length_ ) NL this . myData = newData NL }","func_name":"grow","docstring":""}
{"repo":"grpc","file":"block_byte_queue.cj","path":"grpc/src/buffer/block_byte_queue.cj","code_tokens":"public func get ( buf : Array < UInt8 > ) : Int64 {  synchronized ( m ) {   let size : Int64 = buf . size NL while ( this . length_ < size ) {  m . wait ( notEmpty ) NL } NL this . myData . copyTo ( buf , this . start , 0 , size ) NL if ( this . length_ > size ) {  this . length_ -= size NL this . start += size NL } else {  this . start = 0 NL this . length_ = 0 NL } NL return size NL } NL }","func_name":"get","docstring":""}
{"repo":"grpc","file":"block_byte_queue.cj","path":"grpc/src/buffer/block_byte_queue.cj","code_tokens":"public func getAll ( ) : Array < UInt8 > {   let buf : Array < UInt8 > = Array < UInt8 > ( this . length_ , item : 0 ) NL this . myData . copyTo ( buf , this . start , 0 , this . length_ ) NL this . start = 0 NL this . length_ = 0 NL return buf NL }","func_name":"getAll","docstring":""}
{"repo":"grpc","file":"block_byte_queue.cj","path":"grpc/src/buffer/block_byte_queue.cj","code_tokens":"public func clear ( ) {  synchronized ( m ) {  this . start = 0 NL this . length_ = 0 NL } NL }","func_name":"clear","docstring":""}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func clear ( ) : Unit {  mySize = 0 NL first = None NL last = None NL }","func_name":"clear","docstring":"/**\n     * The Function is clear\n     *\n     *\n     * @return Type of Unit\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func dequeueAll ( ) : ? ItemNode < T > {  this . mySize = 0 NL  let h : ? ItemNode < T > = this . first NL this . first = None NL this . last = None NL return h NL }","func_name":"dequeueAll","docstring":""}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func isEmpty ( ) : Bool {  return this . mySize == 0 NL }","func_name":"isEmpty","docstring":"/**\n     * Judge ItemList whether it is empty\n     *\n     * @return Bool The return type of Bool\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  LinkedListIterator ( this . first ) NL }","func_name":"iterator","docstring":"/**\n     * ItemList iterator\n     *\n     * @return Iterator The return type of Iterator<T>\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func getFirst ( ) : T {  match ( this . first ) { case Some ( vul ) => vul . value NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"getFirst","docstring":"/**\n     * Get ItemList first value.\n     *\n     * @return T The return type of T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func peek ( ) : T {  return this . getFirst ( ) NL }","func_name":"peek","docstring":""}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func getLast ( ) : T {  match ( this . last ) { case Some ( val ) => val . value NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"getLast","docstring":"/**\n     * Get ItemList last value.\n     *\n     * @return T The return type of T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func get ( indexNum : Int64 ) : T {  if ( indexNum < 0 || indexNum > = this . mySize ) {  throw IndexOutOfBoundsException ( ) NL } NL match ( at ( indexNum ) ) { case Some ( val ) => val . value NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"get","docstring":"/**\n     * Gets the value of the specified index\n     *\n     * @param indexNum ItemList index\n     *\n     * @return T Return value\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func set ( index : Int64 , element : T ) : T {  if ( index < 0 || index > = this . mySize ) {  throw IndexOutOfBoundsException ( ) NL } NL match ( at ( index ) ) { case Some ( val ) =>  let oldValue = val . value NL val . value = element NL oldValue NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"set","docstring":"/**\n     * Replace element at specified location\n     *\n     * @param index Specified location index\n     * @param element Specified location value\n     *\n     * @return T The return type of T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func prepend ( element : T ) : Unit {  this . linkFirst ( element ) NL }","func_name":"prepend","docstring":"/**\n     * Append element before\n     *\n     * @param element Append element\n     *\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func append ( element : T ) : Unit {  this . linkLast ( element ) NL }","func_name":"append","docstring":"/**\n     * Append element after\n     *\n     * @param element Append element\n     *\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func enqueue ( element : T ) : Unit {  this . append ( element ) NL }","func_name":"enqueue","docstring":""}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func insert ( index : Int64 , element : T ) : Unit {  if ( index < 0 || index > this . mySize ) {  throw IndexOutOfBoundsException ( ) NL } NL if ( index == 0 ) {  this . linkFirst ( element ) NL } else {  this . linkBefore ( element , at ( index ) ) NL } NL }","func_name":"insert","docstring":"/**\n     * Inserts an element at the specified location\n     *\n     * @param index Specified location index\n     * @param element Insert element\n     *\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func remove ( index : Int64 ) : T {  if ( index < 0 || index > = this . mySize ) {  throw IndexOutOfBoundsException ( ) NL } NL match ( at ( index ) ) { case Some ( val ) => unlink ( val ) NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"remove","docstring":"/**\n     * Removes the element at the specified location\n     *\n     * @param index Specified location index\n     *\n     * @return T The return type of T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func removeFirst ( ) : T {  match ( this . first ) { case Some ( val ) => this . unlinkFirst ( val ) NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"removeFirst","docstring":"/**\n     * Remove first element\n     *\n     * @return The return type of T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func dequeue ( ) : T {  return this . removeFirst ( ) NL }","func_name":"dequeue","docstring":""}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func removeLast ( ) : T {  match ( this . last ) { case Some ( val ) => unlinkLast ( val ) NL case _ => throw IndexOutOfBoundsException ( ) NL } NL }","func_name":"removeLast","docstring":"/**\n     * Remove last element\n     *\n     *\n     * @return The return type of T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"private func at ( index : Int64 ) : ? ItemNode < T > {  if ( index < ( this . mySize >> 1 ) ) {   var x = this . first NL for ( i in 0 .. index ) {  match ( x ) { case Some ( val ) => x = val . next NL case _ => ( ) NL } NL } NL x NL } else {   var x = this . last NL  var i = this . mySize - 1 NL while ( i > index ) {  match ( x ) { case Some ( val ) => x = val . prev NL case _ => ( ) NL } NL i -- NL } NL x NL } NL }","func_name":"at","docstring":"/*\n     * The Function is at\n     *\n     * @param index of Int64\n     *\n     * @return Type of ?ItemNode<T>\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"private func linkFirst ( element : T ) : Unit {   let first = this . first NL  let newNode = ItemNode ( prev : None < ItemNode < T > > , value : element , next : first ) NL this . first = newNode NL match ( this . first ) { case Some ( val ) => val . prev = newNode NL case _ => last = newNode NL } NL this . mySize ++ NL }","func_name":"linkFirst","docstring":"/*\n     * The Function is linkFirst\n     *\n     * @param element of T\n     *\n     * @return Type of Unit\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"private func linkLast ( element : T ) : Unit {   let last = this . last NL  let newNode = ItemNode ( prev : last , value : element , next : None < ItemNode < T > > ) NL this . last = newNode NL match ( last ) { case Some ( val ) => val . next = newNode NL case _ => first = newNode NL } NL this . mySize ++ NL }","func_name":"linkLast","docstring":"/*\n     * The Function is linkLast\n     *\n     * @param element of T\n     *\n     * @return Type of Unit\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"private func linkBefore ( element : T , succ : ? ItemNode < T > ) : Unit {  match ( succ ) { case Some ( val ) =>  let pred = val . prev NL  let newNode = ItemNode ( prev : pred , value : element , next : succ ) NL val . prev = newNode NL match ( pred ) { case Some ( v2 ) => v2 . next = newNode NL case _ => this . first = newNode NL } NL this . mySize ++ NL case _ => ( ) NL } NL }","func_name":"linkBefore","docstring":"/*\n     * The Function is linkBefore\n     *\n     * @param element of T\n     * @param succ of ?ItemNode<T>\n     *\n     * @return Type of Unit\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"private func unlinkFirst ( x : ItemNode < T > ) : T {   let element = x . value NL  let next = x . next NL x . next = None NL this . first = next NL match ( next ) { case Some ( val ) => val . prev = None NL case _ => this . last = None NL } NL this . mySize -- NL element NL }","func_name":"unlinkFirst","docstring":"/*\n     * The Function is unlinkFirst\n     *\n     * @param x of ItemNode<T>\n     *\n     * @return Type of T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"private func unlinkLast ( x : ItemNode < T > ) : T {   let element = x . value NL  let prev = x . prev NL x . prev = None NL this . last = prev NL match ( prev ) { case Some ( val ) => val . next = None NL case _ => this . first = None NL } NL this . mySize -- NL element NL }","func_name":"unlinkLast","docstring":"/*\n     * The Function is unlinkLast\n     *\n     * @param x of ItemNode<T>\n     *\n     * @return Type of T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"private func unlink ( x : ItemNode < T > ) : T {   let element = x . value NL  let next = x . next NL  let prev = x . prev NL match ( prev ) { case Some ( val ) => val . next = next NL x . prev = None NL case _ => this . first = next NL } NL match ( next ) { case Some ( val ) => val . prev = prev NL x . next = None NL case _ => this . last = prev NL } NL this . mySize -- NL element NL }","func_name":"unlink","docstring":"/*\n     * The Function is unlink\n     *\n     * @param x of ItemNode<T>\n     *\n     * @return Type of T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func next ( ) : ? T {  match ( current ) { case Some ( val ) =>  let element = val . value NL current = val . next NL element NL case _ => None NL } NL }","func_name":"next","docstring":"/**\n     * The Function is next\n     *\n     *\n     * @return Type of ?T\n     * @since 0.28.4\n     */"}
{"repo":"grpc","file":"linked_list.cj","path":"grpc/src/buffer/linked_list.cj","code_tokens":"public func iterator ( ) : Iterator < T > {  return this NL }","func_name":"iterator","docstring":"/**\n     * ItemList iterator\n     *\n     * @return Iterator The return type of Iterator<T>\n     * @since 0.28.4\n     */"}
