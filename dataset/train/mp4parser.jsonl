{"repo":"mp4parser","file":"fileutils.cj","path":"mp4parser/src/fileutils.cj","code_tokens":"public func isFilePathValid ( filePath : String ) : ( String , String ) {   let con : Option < Int64 > = filePath . lastIndexOf ( / ) NL  var lastSlash : Int64 = 0 NL match ( con ) { case Some ( v ) => lastSlash = v NL case None => throw Exception ( Invalid filepath ) NL } NL  let directoryName : String = filePath . substring ( 0 , lastSlash ) NL  let fileName : String = filePath . substring ( lastSlash + 1 ) NL  let confield : Option < Int64 > = fileName . lastIndexOf ( . ) NL  var len : Int64 = 0 NL match ( confield ) { case Some ( v ) => len = v NL case None => throw Exception ( Invalid filepath. Need to include filename ) NL } NL  let fields : String = fileName . substring ( len + 1 ) NL logger . info ( isFilePathValid lastSlash INDEX :  + ${lastSlash} +  directoryName :  + ${directoryName} +  fileName :  + ${fileName} ) NL  let isFile : Bool = isReg ( fileName ) NL  let isDir : Bool = isDir ( directoryName ) NL if ( ! isFile ) {  logger . info ( isFilePathValid isFile is   + ${isFile} ) NL throw Exception ( ${fileName} +  not normal file ) NL } NL if ( ! isDir ) {  logger . info ( isFilePathValid isDir is   + ${isDir} ) NL throw Exception ( isFilePathValid invalid directory ) NL } NL logger . info ( isFilePathValid filePath is valid ) NL logger . flush ( ) NL return ( fileName , fields ) NL }","func_name":"isFilePathValid","docstring":"/**\n     * The Function is isFilePathValid\n     *\n     * @param filePath of String\n     *\n     * @return Type of (String,String)\n     * @since 0.32.5\n     */"}
{"repo":"mp4parser","file":"mp4parsers.cj","path":"mp4parser/src/mp4parsers.cj","code_tokens":"public func videoClip ( startTime : String , endTime : String , sourcePath : String , outPath : String ) : Int32 {   let fileClip1 = files . isFilePathValid ( sourcePath ) NL  let fileClip2 = files . isFilePathValid ( outPath ) NL if ( fileClip1 [ 1 ] != mp4 ) {  throw Exception ( ${fileClip1[1]} +  file format is not mp4 ) NL } NL if ( fileClip2 [ 1 ] != mp4 ) {  throw Exception ( ${fileClip2[1]} +  file format is not mp4 ) NL } NL try {  spawn {  var videor = ffmpeg_exec ( ffmpeg -y -i  + fileClip1 [ 0 ] +  -ss  + startTime +  -t  + endTime +   + fileClip2 [ 0 ] +  -y ) NL } NL return 1 NL } catch ( e : Exception ) {  return 0 NL } NL }","func_name":"videoClip","docstring":"/**\n     * The Function is videoClip\n     *\n     * @param startTime of String\n     * @param endTime of String\n     * @param sourcePath of String\n     * @param outPath of String\n     * @since 0.32.5\n     */"}
{"repo":"mp4parser","file":"mp4parsers.cj","path":"mp4parser/src/mp4parsers.cj","code_tokens":"public func videoMultMerge ( sourcePath : String , outPath : String ) : Int32 {   let filename1 = files . isFilePathValid ( sourcePath ) NL  let filename2 = files . isFilePathValid ( outPath ) NL if ( filename1 [ 1 ] != txt ) {  throw Exception ( ${filename1[1]} +  file format is not txt ) NL } NL if ( filename2 [ 1 ] != mp4 ) {  throw Exception ( ${filename2[1]} +  file format is not mp4 ) NL } NL try {  spawn {  var videoret = ffmpeg_exec ( ffmpeg -f concat -i  + filename1 [ 0 ] +  -c copy  + filename2 [ 0 ] +  -y ) NL } NL return 1 NL } catch ( e : Exception ) {  return 0 NL } NL }","func_name":"videoMultMerge","docstring":"/**\n     * The Function is videoMultMerge\n     *\n     * @param sourcePath of String\n     * @param outPath of String\n     * @since 0.32.5\n     */"}
{"repo":"mp4parser","file":"mp4parsers.cj","path":"mp4parser/src/mp4parsers.cj","code_tokens":"public func videoMerge ( sourcePath : String , outPath : String ) : Int32 {   let fileMerge1 = files . isFilePathValid ( sourcePath ) NL  let fileMerge2 = files . isFilePathValid ( outPath ) NL if ( fileMerge1 [ 1 ] != mp4 ) {  throw Exception ( ${fileMerge1[1]} +  file format is not mp4 ) NL } NL if ( fileMerge2 [ 1 ] != mp4 ) {  throw Exception ( ${fileMerge2[1]} +  file format is not mp4 ) NL } NL try {  spawn {  var ret = ffmpeg_exec ( ffmpeg -i  + fileMerge1 [ 0 ] +  -c copy  + fileMerge2 [ 0 ] +  -y ) NL } NL return 1 NL } catch ( e : Exception ) {  return 0 NL } NL }","func_name":"videoMerge","docstring":"/**\n     * The Function is videoMerge\n     *\n     * @param sourcePath of String\n     * @param outPath of String\n     * @since 0.32.5\n     */"}
{"repo":"mp4parser","file":"mp4parsers.cj","path":"mp4parser/src/mp4parsers.cj","code_tokens":"public func audioMultMerge ( sourcePath : String , outPath : String ) : Int32 {   let multMerge1 = files . isFilePathValid ( sourcePath ) NL  let multMerge2 = files . isFilePathValid ( outPath ) NL if ( multMerge1 [ 1 ] != txt ) {  throw Exception ( ${multMerge1[1]} +  file format is not txt ) NL } NL if ( multMerge2 [ 1 ] != mp3 ) {  throw Exception ( ${multMerge2[1]} +  file format is not mp3 ) NL } NL try {  spawn {  var audioret = ffmpeg_exec ( ffmpeg -f concat -i  + multMerge1 [ 0 ] +  -c copy  + multMerge2 [ 0 ] +  -y ) NL } NL return 1 NL } catch ( e : Exception ) {  return 0 NL } NL }","func_name":"audioMultMerge","docstring":"/**\n     * The Function is audioMultMerge\n     *\n     * @param sourcePath of String\n     * @param outPath of String\n     * @since 0.32.5\n     */"}
{"repo":"mp4parser","file":"mp4parsers.cj","path":"mp4parser/src/mp4parsers.cj","code_tokens":"public func audioMerge ( sourcePath : String , outPath : String ) : Int32 {   let audioMerge1 = files . isFilePathValid ( sourcePath ) NL  let audioMerge2 = files . isFilePathValid ( outPath ) NL if ( audioMerge1 [ 1 ] != mp3 ) {  throw Exception ( ${audioMerge1[1]} +  file format is not mp3 ) NL } NL if ( audioMerge2 [ 1 ] != mp3 ) {  throw Exception ( ${audioMerge2[1]} +  file format is not mp3 ) NL } NL try {  spawn {  var audioret = ffmpeg_exec ( ffmpeg -i  + audioMerge1 [ 0 ] +  -c copy  + audioMerge2 [ 0 ] +  -y ) NL } NL return 1 NL } catch ( e : Exception ) {  return 0 NL } NL }","func_name":"audioMerge","docstring":"/**\n     * The Function is audioMerge\n     *\n     * @param sourcePath of String\n     * @param outPath of String\n     * @since 0.32.5\n     */"}
{"repo":"mp4parser","file":"mp4parsers.cj","path":"mp4parser/src/mp4parsers.cj","code_tokens":"public func audioClip ( startTime : String , endTime : String , sourcePath : String , outPath : String ) : Int32 {   let audio1 = files . isFilePathValid ( sourcePath ) NL  let audio2 = files . isFilePathValid ( outPath ) NL if ( audio1 [ 1 ] != mp3 ) {  throw Exception ( ${audio1[1]} +  file format is not mp3 ) NL } NL if ( audio2 [ 1 ] != mp3 ) {  throw Exception ( ${audio2[1]} +  file format is not mp3 ) NL } NL try {  spawn {  var videor = ffmpeg_exec ( ffmpeg -y -i  + audio1 [ 0 ] +  -ss  + startTime +  -t  + endTime +  -c copy  + audio2 [ 0 ] +  -y ) NL } NL return 1 NL } catch ( e : Exception ) {  return 0 NL } NL }","func_name":"audioClip","docstring":"/**\n     * The Function is audioClip\n     *\n     * @param startTime of String\n     * @param endTime of String\n     * @param sourcePath of String\n     * @param outPath of String\n     * @since 0.32.5\n     */"}
{"repo":"mp4parser","file":"mp4parsers.cj","path":"mp4parser/src/mp4parsers.cj","code_tokens":"foreign func c_ffmpeg_exec ( str : CString ) : Int32","func_name":"c_ffmpeg_exec","docstring":"/*\n * The Function is c_ffmpeg_exec\n *\n * @param str of CString\n *\n * @return Type of Int32\n * @since 0.32.5\n */"}
{"repo":"mp4parser","file":"mp4parsers.cj","path":"mp4parser/src/mp4parsers.cj","code_tokens":"func ffmpeg_exec ( str : String ) : Int32 {   var input = CString ( str ) NL  var ret = unsafe {  c_ffmpeg_exec ( input ) NL } NL ret NL }","func_name":"ffmpeg_exec","docstring":"/**\n * The Function is ffmpeg_exec\n *\n * @param str of String\n *\n * @return Type of Int32\n * @since 0.32.5\n */"}
